/*
 * Playcanvas Engine v1.29.0-dev revision ff78b68a
 * Copyright 2011-2020 PlayCanvas Ltd. All rights reserved.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.pc = {}));
}(this, (function (exports) { 'use strict';

    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    if (!Array.prototype.find) {
        Object.defineProperty(Array.prototype, 'find', {
            value: function(predicate) {
                // 1. Let O be ? ToObject(this value).
                if (this == null) {
                    throw TypeError('"this" is null or not defined');
                }

                var o = Object(this);

                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;

                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if (typeof predicate !== 'function') {
                    throw TypeError('predicate must be a function');
                }

                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[1];

                // 5. Let k be 0.
                var k = 0;

                // 6. Repeat, while k < len
                while (k < len) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                    // d. If testResult is true, return kValue.
                    var kValue = o[k];
                    if (predicate.call(thisArg, kValue, k, o)) {
                        return kValue;
                    }
                    // e. Increase k by 1.
                    k++;
                }

                // 7. Return undefined.
                return undefined;
            },
            configurable: true,
            writable: true
        });
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2#Polyfill
    Math.log2 = Math.log2 || function(x) {
        return Math.log(x) * Math.LOG2E;
    };

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
    if (!Math.sign) {
        Math.sign = function(x) {
            // If x is NaN, the result is NaN.
            // If x is -0, the result is -0.
            // If x is +0, the result is +0.
            // If x is negative and not -0, the result is -1.
            // If x is positive and not +0, the result is +1.
            return ((x > 0) - (x < 0)) || +x;
            // A more aesthetic pseudo-representation:
            //
            // ( (x > 0) ? 1 : 0 )  // if x is positive, then positive one
            //          +           // else (because you can't be both - and +)
            // ( (x < 0) ? -1 : 0 ) // if x is negative, then negative one
            //         ||           // if x is 0, -0, or NaN, or not a number,
            //         +x           // then the result will be x, (or) if x is
            //                      // not a number, then x converts to number
        };
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
    if (typeof Object.assign != 'function') {
        // Must be writable: true, enumerable: false, configurable: true
        Object.defineProperty(Object, "assign", {
            value: function assign(target, varArgs) { // .length of function is 2
                if (target == null) { // TypeError if undefined or null
                    throw new TypeError('Cannot convert undefined or null to object');
                }

                var to = Object(target);

                for (var index = 1; index < arguments.length; index++) {
                    var nextSource = arguments[index];

                    if (nextSource != null) { // Skip over if undefined or null
                        for (var nextKey in nextSource) {
                            // Avoid bugs when hasOwnProperty is shadowed
                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
                return to;
            },
            writable: true,
            configurable: true
        });
    }

    // Apply PointerLock shims
    (function () {
        // Old API
        if (typeof navigator === 'undefined' || typeof document === 'undefined') {
            // Not running in a browser
            return;
        }

        navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;

        // Events
        var pointerlockchange = function () {
            var e = document.createEvent('CustomEvent');
            e.initCustomEvent('pointerlockchange', true, false, null);
            document.dispatchEvent(e);
        };

        var pointerlockerror = function () {
            var e = document.createEvent('CustomEvent');
            e.initCustomEvent('pointerlockerror', true, false, null);
            document.dispatchEvent(e);
        };

        document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
        document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
        document.addEventListener('mozpointerlockchange', pointerlockchange, false);
        document.addEventListener('mozpointerlocklost', pointerlockchange, false);

        document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
        document.addEventListener('mozpointerlockerror', pointerlockerror, false);

        // requestPointerLock
        if (Element.prototype.mozRequestPointerLock) {
            // FF requires a new function for some reason
            Element.prototype.requestPointerLock = function () {
                this.mozRequestPointerLock();
            };
        } else {
            Element.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
        }

        if (!Element.prototype.requestPointerLock && navigator.pointer) {
            Element.prototype.requestPointerLock = function () {
                var el = this;
                document.pointerLockElement = el;
                navigator.pointer.lock(el, pointerlockchange, pointerlockerror);
            };
        }

        // exitPointerLock
        document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
        if (!document.exitPointerLock) {
            document.exitPointerLock = function () {
                if (navigator.pointer) {
                    document.pointerLockElement = null;
                    navigator.pointer.unlock();
                }
            };
        }
    })();

    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

    // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

    // MIT license

    (function() {
        if (typeof window === 'undefined') return;

        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                       || window[vendors[x]+'CancelRequestAnimationFrame'];
        }
     
        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                  timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
     
        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
    }());

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill
    if (!String.prototype.endsWith) {
        String.prototype.endsWith = function(search, this_len) {
            if (this_len === undefined || this_len > this.length) {
                this_len = this.length;
            }
            return this.substring(this_len - search.length, this_len) === search;
        };
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill
    if (!String.prototype.includes) {
        String.prototype.includes = function(search, start) {
            if (typeof start !== 'number') {
                start = 0;
            }

            if (start + search.length > this.length) {
                return false;
            } else {
                return this.indexOf(search, start) !== -1;
            }
        };
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function(search, pos) {
            return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        };
    }

    /**
     * @name pc
     * @namespace
     * @description Root namespace for the PlayCanvas Engine.
     */

    /**
     * @private
     * @function
     * @name _typeLookup
     * @description Create look up table for types.
     */
    var _typeLookup = function () {
        var result = { };
        var names = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];

        for (var i = 0; i < names.length; i++)
            result["[object " + names[i] + "]"] = names[i].toLowerCase();

        return result;
    }();

    var version = "1.29.0-dev";
    var revision = "ff78b68a";
    var config = { };
    var common = { };
    var apps = { }; // Storage for the applications using the PlayCanvas Engine
    var data = { }; // Storage for exported entity data

    /**
     * @private
     * @function
     * @name pc.makeArray
     * @description Convert an array-like object into a normal array.
     * For example, this is useful for converting the arguments object into an array.
     * @param {object} arr - The array to convert.
     * @returns {Array} An array.
     */
    function makeArray(arr) {
        var i,
            ret = [],
            length = arr.length;

        for (i = 0; i < length; ++i) {
            ret.push(arr[i]);
        }

        return ret;
    }

    /**
     * @private
     * @function
     * @name pc.type
     * @description Extended typeof() function, returns the type of the object.
     * @param {object} obj - The object to get the type of.
     * @returns {string} The type string: "null", "undefined", "number", "string", "boolean", "array", "object", "function", "date", "regexp" or "float32array".
     */
    function type(obj) {
        if (obj === null) {
            return "null";
        }

        var type = typeof obj;

        if (type === "undefined" || type === "number" || type === "string" || type === "boolean") {
            return type;
        }

        return _typeLookup[Object.prototype.toString.call(obj)];
    }

    /**
     * @private
     * @function
     * @name pc.extend
     * @description Merge the contents of two objects into a single object.
     * @param {object} target - The target object of the merge.
     * @param {object} ex - The object that is merged with target.
     * @returns {object} The target object.
     * @example
     * var A = {
     *     a: function () {
     *         console.log(this.a);
     *     }
     * };
     * var B = {
     *     b: function () {
     *         console.log(this.b);
     *     }
     * };
     *
     * pc.extend(A, B);
     * A.a();
     * // logs "a"
     * A.b();
     * // logs "b"
     */
    function extend(target, ex) {
        var prop,
            copy;

        for (prop in ex) {
            copy = ex[prop];
            if (type(copy) == "object") {
                target[prop] = extend({}, copy);
            } else if (type(copy) == "array") {
                target[prop] = extend([], copy);
            } else {
                target[prop] = copy;
            }
        }

        return target;
    }

    /**
     * @private
     * @function
     * @name pc.isDefined
     * @description Return true if the Object is not undefined.
     * @param {object} o - The Object to test.
     * @returns {boolean} True if the Object is not undefined.
     */
    function isDefined(o) {
        var a;
        return (o !== a);
    }

    /**
     * @name pc.debug
     * @private
     * @namespace
     */
    var debug = (function () {
        var table = null;
        var row = null;
        var title = null;
        var field = null;

        return {
            /**
             * @private
             * @function
             * @name pc.debug.display
             * @description Display an object and its data in a table on the page.
             * @param {object} data - The object to display.
             */
            display: function (data) {
                function init() {
                    table = document.createElement('table');
                    row = document.createElement('tr');
                    title = document.createElement('td');
                    field = document.createElement('td');

                    table.style.cssText = 'position:absolute;font-family:sans-serif;font-size:12px;color:#cccccc';
                    table.style.top = '0px';
                    table.style.left = '0px';
                    table.style.border = 'thin solid #cccccc';

                    document.body.appendChild(table);
                }

                if (!table) {
                    init();
                }

                table.innerHTML = '';
                for (var key in data) {
                    var r = row.cloneNode();
                    var t = title.cloneNode();
                    var f = field.cloneNode();

                    t.textContent = key;
                    f.textContent = data[key];

                    r.appendChild(t);
                    r.appendChild(f);
                    table.appendChild(r);
                }
            }
        };
    }());

    /**
     * @class
     * @name pc.EventHandler
     * @classdesc Abstract base class that implements functionality for event handling.
     * @description Create a new event handler.
     * @example
     * var obj = new EventHandlerSubclass();
     *
     * // subscribe to an event
     * obj.on('hello', function (str) {
     *     console.log('event hello is fired', str);
     * });
     *
     * // fire event
     * obj.fire('hello', 'world');
     */
    function EventHandler() {
        this._callbacks = { };
        this._callbackActive = { };
    }

    Object.assign(EventHandler.prototype, {

        _addCallback: function (name, callback, scope, once) {
            if (!name || typeof name !== 'string' || !callback)
                return;

            if (!this._callbacks[name])
                this._callbacks[name] = [];

            if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name])
                this._callbackActive[name] = this._callbackActive[name].slice();

            this._callbacks[name].push({
                callback: callback,
                scope: scope || this,
                once: once || false
            });
        },

        /**
         * @function
         * @name pc.EventHandler#on
         * @description Attach an event handler to an event.
         * @param {string} name - Name of the event to bind the callback to.
         * @param {pc.callbacks.HandleEvent} callback - Function that is called when event is fired. Note the callback is limited to 8 arguments.
         * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to current this.
         * @returns {pc.EventHandler} Self for chaining.
         * @example
         * obj.on('test', function (a, b) {
         *     console.log(a + b);
         * });
         * obj.fire('test', 1, 2); // prints 3 to the console
         */
        on: function (name, callback, scope) {
            this._addCallback(name, callback, scope, false);

            return this;
        },

        /**
         * @function
         * @name pc.EventHandler#off
         * @description Detach an event handler from an event. If callback is not provided then all callbacks are unbound from the event,
         * if scope is not provided then all events with the callback will be unbound.
         * @param {string} [name] - Name of the event to unbind.
         * @param {pc.callbacks.HandleEvent} [callback] - Function to be unbound.
         * @param {object} [scope] - Scope that was used as the this when the event is fired.
         * @returns {pc.EventHandler} Self for chaining.
         * @example
         * var handler = function () {
         * };
         * obj.on('test', handler);
         *
         * obj.off(); // Removes all events
         * obj.off('test'); // Removes all events called 'test'
         * obj.off('test', handler); // Removes all handler functions, called 'test'
         * obj.off('test', handler, this); // Removes all hander functions, called 'test' with scope this
         */
        off: function (name, callback, scope) {
            if (name) {
                if (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name])
                    this._callbackActive[name] = this._callbackActive[name].slice();
            } else {
                for (var key in this._callbackActive) {
                    if (!this._callbacks[key])
                        continue;

                    if (this._callbacks[key] !== this._callbackActive[key])
                        continue;

                    this._callbackActive[key] = this._callbackActive[key].slice();
                }
            }

            if (!name) {
                this._callbacks = { };
            } else if (!callback) {
                if (this._callbacks[name])
                    this._callbacks[name] = [];
            } else {
                var events = this._callbacks[name];
                if (!events)
                    return this;

                var count = events.length;

                for (var i = 0; i < count; i++) {
                    if (events[i].callback !== callback)
                        continue;

                    if (scope && events[i].scope !== scope)
                        continue;

                    events[i--] = events[--count];
                }
                events.length = count;
            }

            return this;
        },

        // ESLint rule disabled here as documenting arg1, arg2...argN as [...] rest
        // arguments is preferable to documenting each one individually.
        /* eslint-disable valid-jsdoc */
        /**
         * @function
         * @name pc.EventHandler#fire
         * @description Fire an event, all additional arguments are passed on to the event listener.
         * @param {object} name - Name of event to fire.
         * @param {*} [arg1] - First argument that is passed to the event handler.
         * @param {*} [arg2] - Second argument that is passed to the event handler.
         * @param {*} [arg3] - Third argument that is passed to the event handler.
         * @param {*} [arg4] - Fourth argument that is passed to the event handler.
         * @param {*} [arg5] - Fifth argument that is passed to the event handler.
         * @param {*} [arg6] - Sixth argument that is passed to the event handler.
         * @param {*} [arg7] - Seventh argument that is passed to the event handler.
         * @param {*} [arg8] - Eighth argument that is passed to the event handler.
         * @returns {pc.EventHandler} Self for chaining.
         * @example
         * obj.fire('test', 'This is the message');
         */
        /* eslint-enable valid-jsdoc */
        fire: function (name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            if (!name || !this._callbacks[name])
                return this;

            var callbacks;

            if (!this._callbackActive[name]) {
                this._callbackActive[name] = this._callbacks[name];
            } else {
                if (this._callbackActive[name] === this._callbacks[name])
                    this._callbackActive[name] = this._callbackActive[name].slice();

                callbacks = this._callbacks[name].slice();
            }

            // TODO: What does callbacks do here?
            // In particular this condition check looks wrong: (i < (callbacks || this._callbackActive[name]).length)
            // Because callbacks is not an integer
            // eslint-disable-next-line no-unmodified-loop-condition
            for (var i = 0; (callbacks || this._callbackActive[name]) && (i < (callbacks || this._callbackActive[name]).length); i++) {
                var evt = (callbacks || this._callbackActive[name])[i];
                evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

                if (evt.once) {
                    var ind = this._callbacks[name].indexOf(evt);
                    if (ind !== -1) {
                        if (this._callbackActive[name] === this._callbacks[name])
                            this._callbackActive[name] = this._callbackActive[name].slice();

                        this._callbacks[name].splice(ind, 1);
                    }
                }
            }

            if (!callbacks)
                this._callbackActive[name] = null;

            return this;
        },

        /**
         * @function
         * @name pc.EventHandler#once
         * @description Attach an event handler to an event. This handler will be removed after being fired once.
         * @param {string} name - Name of the event to bind the callback to.
         * @param {pc.callbacks.HandleEvent} callback - Function that is called when event is fired. Note the callback is limited to 8 arguments.
         * @param {object} [scope] - Object to use as 'this' when the event is fired, defaults to current this.
         * @returns {pc.EventHandler} Self for chaining.
         * @example
         * obj.once('test', function (a, b) {
         *     console.log(a + b);
         * });
         * obj.fire('test', 1, 2); // prints 3 to the console
         * obj.fire('test', 1, 2); // not going to get handled
         */
        once: function (name, callback, scope) {
            this._addCallback(name, callback, scope, true);
            return this;
        },

        /**
         * @function
         * @name pc.EventHandler#hasEvent
         * @description Test if there are any handlers bound to an event name.
         * @param {string} name - The name of the event to test.
         * @returns {boolean} True if the object has handlers bound to the specified event name.
         * @example
         * obj.on('test', function () { }); // bind an event to 'test'
         * obj.hasEvent('test'); // returns true
         * obj.hasEvent('hello'); // returns false
         */
        hasEvent: function (name) {
            return (this._callbacks[name] && this._callbacks[name].length !== 0) || false;
        }
    });

    var events = {
        /**
         * @private
         * @function
         * @name pc.events.attach
         * @description Attach event methods 'on', 'off', 'fire', 'once' and 'hasEvent' to the
         * target object.
         * @param {object} target - The object to add events to.
         * @returns {object} The target object.
         * @example
         * var obj = { };
         * pc.events.attach(obj);
         */
        attach: function (target) {
            var ev = events;
            target._addCallback = ev._addCallback;
            target.on = ev.on;
            target.off = ev.off;
            target.fire = ev.fire;
            target.once = ev.once;
            target.hasEvent = ev.hasEvent;
            target._callbacks = { };
            target._callbackActive = { };
            return target;
        },

        _addCallback: EventHandler.prototype._addCallback,
        on: EventHandler.prototype.on,
        off: EventHandler.prototype.off,
        fire: EventHandler.prototype.fire,
        once: EventHandler.prototype.once,
        hasEvent: EventHandler.prototype.hasEvent
    };

    /**
     * @name pc.guid
     * @namespace
     * @description Basically a very large random number (128-bit) which means the probability of creating two that clash is vanishingly small.
     * GUIDs are used as the unique identifiers for Entities.
     */
    var guid = {
        /**
         * @function
         * @name pc.guid.create
         * @description Create an RFC4122 version 4 compliant GUID.
         * @returns {string} A new GUID.
         */
        create: function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0,
                    v = (c == 'x') ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
    };

    /**
     * @namespace pc.path
     * @description File path API.
     */
    var path = {
        /**
         * @constant
         * @type {string}
         * @name pc.path.delimiter
         * @description The character that separates path segments.
         */
        delimiter: "/",

        /**
         * @function
         * @name pc.path.join
         * @description Join two or more sections of file path together, inserting a
         * delimiter if needed.
         * @param {...string} section - Section of path to join. 2 or more can be
         * provided as parameters.
         * @returns {string} The joined file path.
         * @example
         * var path = pc.path.join('foo', 'bar');
         * console.log(path); // Prints 'foo/bar'
         * @example
         * var path = pc.path.join('alpha', 'beta', 'gamma');
         * console.log(path); // Prints 'alpha/beta/gamma'
         */
        join: function () {
            var index;
            var num = arguments.length;
            var result = arguments[0];

            for (index = 0; index < num - 1; ++index) {
                var one = arguments[index];
                var two = arguments[index + 1];
                if (!isDefined(one) || !isDefined(two)) {
                    throw new Error("undefined argument to pc.path.join");
                }
                if (two[0] === path.delimiter) {
                    result = two;
                    continue;
                }

                if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
                    result += (path.delimiter + two);
                } else {
                    result += (two);
                }
            }

            return result;
        },

        /**
         * @function
         * @name pc.path.normalize
         * @description Normalize the path by removing '.' and '..' instances.
         * @param {string} pathname - The path to normalize.
         * @returns {string} The normalized path.
         */
        normalize: function (pathname) {
            var lead = pathname.startsWith(path.delimiter);
            var trail = pathname.endsWith(path.delimiter);

            var parts = pathname.split('/');

            var result = '';

            var cleaned = [];

            for (var i = 0; i < parts.length; i++) {
                if (parts[i] === '') continue;
                if (parts[i] === '.') continue;
                if (parts[i] === '..' && cleaned.length > 0) {
                    cleaned = cleaned.slice(0, cleaned.length - 2);
                    continue;
                }

                if (i > 0) cleaned.push(path.delimiter);
                cleaned.push(parts[i]);
            }


            result = cleaned.join('');
            if (!lead && result[0] === path.delimiter) {
                result = result.slice(1);
            }

            if (trail && result[result.length - 1] !== path.delimiter) {
                result += path.delimiter;
            }

            return result;
        },

        /**
         * @function
         * @name pc.path.split
         * @description Split the pathname path into a pair [head, tail] where tail is the final part of the path
         * after the last delimiter and head is everything leading up to that. tail will never contain a slash.
         * @param {string} pathname - The path to split.
         * @returns {string[]} The split path which is an array of two strings, the path and the filename.
         */
        split: function (pathname) {
            var parts = pathname.split(path.delimiter);
            var tail = parts.slice(parts.length - 1)[0];
            var head = parts.slice(0, parts.length - 1).join(path.delimiter);
            return [head, tail];
        },

        /**
         * @function
         * @name pc.path.getBasename
         * @description Return the basename of the path. That is the second element of the pair returned by
         * passing path into {@link pc.path.split}.
         * @param {string} pathname - The path to process.
         * @returns {string} The basename.
         * @example
         * pc.path.getBasename("/path/to/file.txt"); // returns "path.txt"
         * pc.path.getBasename("/path/to/dir"); // returns "dir"
         */
        getBasename: function (pathname) {
            return path.split(pathname)[1];
        },

        /**
         * @function
         * @name pc.path.getDirectory
         * @description Get the directory name from the path. This is everything up to the final instance of pc.path.delimiter.
         * @param {string} pathname - The path to get the directory from.
         * @returns {string} The directory part of the path.
         */
        getDirectory: function (pathname) {
            var parts = pathname.split(path.delimiter);
            return parts.slice(0, parts.length - 1).join(path.delimiter);
        },
        /**
         * @function
         * @name pc.path.getExtension
         * @description Return the extension of the path. Pop the last value of a list after path is split by question mark and comma.
         * @param {string} pathname - The path to process.
         * @returns {string} The extension.
         * @example
         * pc.path.getExtension("/path/to/file.txt"); // returns ".txt"
         * pc.path.getExtension("/path/to/file.jpg"); // returns ".jpg"
         * pc.path.getExtension("/path/to/file.txt?function=getExtension"); // returns ".txt"
         */
        getExtension: function (pathname) {
            var ext = pathname.split('?')[0].split('.').pop();
            if (ext !== pathname) {
                return "." + ext;
            }
            return "";
        },

        /**
         * @function
         * @name pc.path.isRelativePath
         * @description Check if a string s is relative path.
         * @param {string} pathname - The path to process.
         * @returns {boolean} True if s doesn't start with slash and doesn't include colon and double slash.
         * @example
         * pc.path.isRelativePath("file.txt"); // returns true
         * pc.path.isRelativePath("path/to/file.txt"); // returns true
         * pc.path.isRelativePath("./path/to/file.txt"); // returns true
         * pc.path.isRelativePath("../path/to/file.jpg"); // returns true
         * pc.path.isRelativePath("/path/to/file.jpg"); // returns false
         * pc.path.isRelativePath("http://path/to/file.jpg"); // returns false
         */
        isRelativePath: function (pathname) {
            return pathname.charAt(0) !== "/" && pathname.match(/:\/\//) === null;
        },

        /**
         * @function
         * @name pc.path.extractPath
         * @description Return the path without file name. If path is relative path, start with period.
         * @param {string} pathname - The full path to process.
         * @returns {string} The path without a last element from list split by slash.
         * @example
         * pc.path.extractPath("path/to/file.txt");    // returns "./path/to"
         * pc.path.extractPath("./path/to/file.txt");  // returns "./path/to"
         * pc.path.extractPath("../path/to/file.txt"); // returns "../path/to"
         * pc.path.extractPath("/path/to/file.txt");   // returns "/path/to"
         */
        extractPath: function (pathname) {
            var result = "";
            var parts = pathname.split("/");
            var i = 0;

            if (parts.length > 1) {
                if (path.isRelativePath(pathname)) {
                    if (parts[0] === ".") {
                        for (i = 0; i < parts.length - 1; ++i) {
                            result += (i === 0) ? parts[i] : "/" + parts[i];

                        }
                    } else if (parts[0] === "..") {
                        for (i = 0; i < parts.length - 1; ++i) {
                            result += (i === 0) ? parts[i] : "/" + parts[i];
                        }
                    } else {
                        result = ".";
                        for (i = 0; i < parts.length - 1; ++i) {
                            result += "/" + parts[i];
                        }
                    }
                } else {
                    for (i = 0; i < parts.length - 1; ++i) {
                        result += (i === 0) ? parts[i] : "/" + parts[i];
                    }
                }
            }
            return result;
        }
    };

    /**
     * @namespace
     * @name pc.platform
     * @description Global namespace that stores flags regarding platform environment and features support.
     * @example
     * if (pc.platform.touch) {
     *     // touch is supported
     * }
     */
    var platform = {
        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.desktop
         * @description Is it a desktop or laptop device.
         */
        desktop: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.mobile
         * @description Is it a mobile or tablet device.
         */
        mobile: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.ios
         * @description If it is iOS.
         */
        ios: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.android
         * @description If it is Android.
         */
        android: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.windows
         * @description If it is Windows.
         */
        windows: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.xbox
         * @description If it is Xbox.
         */
        xbox: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.gamepads
         * @description If platform supports gamepads.
         */
        gamepads: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.touch
         * @description If platform supports touch input.
         */
        touch: false,

        /**
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.workers
         * @description If the platform supports Web Workers.
         */
        workers: false,

        /**
         * @private
         * @static
         * @readonly
         * @type {boolean}
         * @name pc.platform.passiveEvents
         * @description If the platform supports an options object as the third parameter
         * to `EventTarget.addEventListener()` and the passive property is supported.
         */
        passiveEvents: false
    };

    if (typeof navigator !== 'undefined') {
        var ua = navigator.userAgent;

        if (/(windows|mac os|linux|cros)/i.test(ua))
            platform.desktop = true;

        if (/xbox/i.test(ua))
            platform.xbox = true;

        if (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {
            platform.desktop = false;
            platform.mobile = true;
            platform.windows = true;
        } else if (/android/i.test(ua)) {
            platform.desktop = false;
            platform.mobile = true;
            platform.android = true;
        } else if (/ip([ao]d|hone)/i.test(ua)) {
            platform.desktop = false;
            platform.mobile = true;
            platform.ios = true;
        }

        if (typeof window !== 'undefined') {
            platform.touch = 'ontouchstart' in window || ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
        }

        platform.gamepads = 'getGamepads' in navigator;

        platform.workers = (typeof(Worker) !== 'undefined');

        try {
            var opts = Object.defineProperty({}, 'passive', {
                get: function () {
                    platform.passiveEvents = true;
                    return false;
                }
            });
            window.addEventListener("testpassive", null, opts);
            window.removeEventListener("testpassive", null, opts);
        } catch (e) {}
    }

    /**
     * @namespace
     * @name pc.string
     * @description Extended String API.
     */
    var string = function () {
        var ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
        var ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;

        var HIGH_SURROGATE_BEGIN = 0xD800;
        var HIGH_SURROGATE_END = 0xDBFF;
        var LOW_SURROGATE_BEGIN = 0xDC00;
        var LOW_SURROGATE_END = 0xDFFF;
        var ZERO_WIDTH_JOINER = 0x200D;

        // Flag emoji
        var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
        var REGIONAL_INDICATOR_END = 0x1F1FF;

        // Skin color modifications to emoji
        var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
        var FITZPATRICK_MODIFIER_END = 0x1F3FF;

        // Accent characters
        var DIACRITICAL_MARKS_BEGIN = 0x20D0;
        var DIACRITICAL_MARKS_END = 0x20FF;

        // Special emoji joins
        var VARIATION_MODIFIER_BEGIN = 0xFE00;
        var VARIATION_MODIFIER_END = 0xFE0F;

        function getCodePointData(string, i) {
            var size = string.length;
            i = i || 0;
            // Account for out-of-bounds indices:
            if (i < 0 || i >= size) {
                return null;
            }
            var first = string.charCodeAt(i);
            var second;
            if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
                second = string.charCodeAt(i + 1);
                if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    return { code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000, long: true };
                }
            }
            return { code: first, long: false };
        }

        function isCodeBetween(string, begin, end) {
            if (!string)
                return false;
            var codeData = getCodePointData(string);
            if (codeData) {
                var code = codeData.code;
                return code >= begin && code <= end;
            }
            return false;
        }

        function numCharsToTakeForNextSymbol(string, index) {
            if (index === string.length - 1) {
                // Last character in the string, so we can only take 1
                return 1;
            }
            if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
                var first = string.substring(index, index + 2);
                var second = string.substring(index + 2, index + 4);

                // check if second character is fitzpatrick (color) modifier
                // or if this is a pair of regional indicators (a flag)
                if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) ||
                    (isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) &&
                    isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END))
                ) {
                    return 4;
                }

                // check if next character is a modifier, in which case we should return it
                if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
                    return 3;
                }

                // return surrogate pair
                return 2;
            }

            // check if next character is the emoji modifier, in which case we should include it
            if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
                return 2;
            }

            // just a regular character
            return 1;
        }

        return {
            /**
             * @constant
             * @type {string}
             * @name pc.string.ASCII_LOWERCASE
             * @description All lowercase letters.
             */
            ASCII_LOWERCASE: ASCII_LOWERCASE,
            /**
             * @constant
             * @type {string}
             * @name pc.string.ASCII_UPPERCASE
             * @description All uppercase letters.
             */
            ASCII_UPPERCASE: ASCII_UPPERCASE,
            /**
             * @constant
             * @type {string}
             * @name pc.string.ASCII_LETTERS
             * @description All ASCII letters.
             */
            ASCII_LETTERS: ASCII_LETTERS,

            /**
             * @function
             * @name pc.string.toBool
             * @description Convert a string value to a boolean. In non-strict mode (the default), 'true' is converted to true, all other values
             * are converted to false. In strict mode, 'true' is converted to true, 'false' is converted to false, all other values will throw
             * an Exception.
             * @param {string} s - The string to convert.
             * @param {boolean} [strict] - In strict mode an Exception is thrown if s is not an accepted string value. Defaults to false.
             * @returns {boolean} The converted value.
             */
            toBool: function (s, strict) {
                if (s === 'true') {
                    return true;
                }

                if (strict) {
                    if (s === 'false') {
                        return false;
                    }

                    throw new TypeError('Not a boolean string');
                }

                return false;
            },
            /**
             * @function
             * @name pc.string.getCodePoint
             * @description Get the code point number for a character in a string. Polyfill for
             * [`codePointAt`]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt}.
             * @param {string} string - The string to get the code point from.
             * @param {number} [i] - The index in the string.
             * @returns {number} The code point value for the character in the string.
             */
            getCodePoint: function (string, i) {
                var codePointData = getCodePointData(string, i);
                return codePointData && codePointData.code;
            },
            /**
             * @function
             * @name pc.string.getCodePoints
             * @description Gets an array of all code points in a string.
             * @param {string} string - The string to get code points from.
             * @returns {number[]} The code points in the string.
             */
            getCodePoints: function (string) {
                if (typeof string !== 'string') {
                    throw new TypeError('Not a string');
                }
                var i = 0;
                var arr = [];
                var codePoint;
                while (!!(codePoint = getCodePointData(string, i))) {
                    arr.push(codePoint.code);
                    i += codePoint.long ? 2 : 1;
                }
                return arr;
            },
            /**
             * @function
             * @name pc.string.getSymbols
             * @description Gets an array of all grapheme clusters (visible symbols) in a string. This is needed because
             * some symbols (such as emoji or accented characters) are actually made up of multiple character codes.
             * @param {string} string - The string to break into symbols.
             * @returns {string[]} The symbols in the string.
             * @see {@link https://mathiasbynens.be/notes/javascript-unicode Unicode strings in JavaScript}
             */
            getSymbols: function (string) {
                if (typeof string !== 'string') {
                    throw new TypeError('Not a string');
                }
                var index = 0;
                var length = string.length;
                var output = [];
                var take = 0;
                var ch;
                while (index < length) {
                    take += numCharsToTakeForNextSymbol(string, index + take);
                    ch = string[index + take];
                    // Handle special cases
                    if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
                        ch = string[index + (take++)];
                    }
                    if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
                        ch = string[index + (take++)];
                    }
                    if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
                        ch = string[index + (take++)];
                        // Not a complete char yet
                        continue;
                    }
                    var char = string.substring(index, index + take);
                    output.push(char);
                    index += take;
                    take = 0;
                }
                return output;
            },
            /**
             * @function
             * @name pc.string.fromCodePoint
             * @description Get the string for a given code point or set of code points. Polyfill for
             * [`fromCodePoint`]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint}.
             * @param {...number} args - The code points to convert to a string.
             * @returns {string} The converted string.
             */
            fromCodePoint: function (/* ...args */) {
                var chars = [];
                var current;
                var codePoint;
                var units;
                for (var i = 0; i < arguments.length; ++i) {
                    current = Number(arguments[i]);
                    codePoint = current - 0x10000;
                    units = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, (codePoint % 0x400) + 0xDC00] : [current];
                    chars.push(String.fromCharCode.apply(null, units));
                }
                return chars.join('');
            }
        };
    }();

    /**
     * @name pc.math
     * @namespace
     * @description Math API.
     */
    var math = {
        /**
         * @constant
         * @type {number}
         * @name pc.math.DEG_TO_RAD
         * @description Conversion factor between degrees and radians.
         * @example
         * // Convert 180 degrees to pi radians
         * var rad = 180 * pc.math.DEG_TO_RAD;
         */
        DEG_TO_RAD: Math.PI / 180,

        /**
         * @constant
         * @type {number}
         * @name pc.math.RAD_TO_DEG
         * @description Conversion factor between degrees and radians.
         * @example
         * // Convert pi radians to 180 degrees
         * var deg = Math.PI * pc.math.RAD_TO_DEG;
         */
        RAD_TO_DEG: 180 / Math.PI,

        /**
         * @function
         * @name pc.math.clamp
         * @description Clamp a number between min and max inclusive.
         * @param {number} value - Number to clamp.
         * @param {number} min - Min value.
         * @param {number} max - Max value.
         * @returns {number} The clamped value.
         */
        clamp: function (value, min, max) {
            if (value >= max) return max;
            if (value <= min) return min;
            return value;
        },

        /**
         * @function
         * @name pc.math.intToBytes24
         * @description Convert an 24 bit integer into an array of 3 bytes.
         * @param {number} i - Number holding an integer value.
         * @returns {number[]} An array of 3 bytes.
         * @example
         * // Set bytes to [0x11, 0x22, 0x33]
         * var bytes = pc.math.intToBytes24(0x112233);
         */
        intToBytes24: function (i) {
            var r, g, b;

            r = (i >> 16) & 0xff;
            g = (i >> 8) & 0xff;
            b = (i) & 0xff;

            return [r, g, b];
        },

        /**
         * @function
         * @name pc.math.intToBytes32
         * @description Convert an 32 bit integer into an array of 4 bytes.
         * @returns {number[]} An array of 4 bytes.
         * @param {number} i - Number holding an integer value.
         * @example
         * // Set bytes to [0x11, 0x22, 0x33, 0x44]
         * var bytes = pc.math.intToBytes32(0x11223344);
         */
        intToBytes32: function (i) {
            var r, g, b, a;

            r = (i >> 24) & 0xff;
            g = (i >> 16) & 0xff;
            b = (i >> 8) & 0xff;
            a = (i) & 0xff;

            return [r, g, b, a];
        },

        /**
         * @function
         * @name pc.math.bytesToInt24
         * @description Convert 3 8 bit Numbers into a single unsigned 24 bit Number.
         * @example
         * // Set result1 to 0x112233 from an array of 3 values
         * var result1 = pc.math.bytesToInt24([0x11, 0x22, 0x33]);
         *
         * // Set result2 to 0x112233 from 3 discrete values
         * var result2 = pc.math.bytesToInt24(0x11, 0x22, 0x33);
         * @param {number} r - A single byte (0-255).
         * @param {number} g - A single byte (0-255).
         * @param {number} b - A single byte (0-255).
         * @returns {number} A single unsigned 24 bit Number.
         */
        bytesToInt24: function (r, g, b) {
            if (r.length) {
                b = r[2];
                g = r[1];
                r = r[0];
            }
            return ((r << 16) | (g << 8) | b);
        },

        /**
         * @function
         * @name pc.math.bytesToInt32
         * @description Convert 4 1-byte Numbers into a single unsigned 32bit Number.
         * @returns {number} A single unsigned 32bit Number.
         * @example
         * // Set result1 to 0x11223344 from an array of 4 values
         * var result1 = pc.math.bytesToInt32([0x11, 0x22, 0x33, 0x44]);
         *
         * // Set result2 to 0x11223344 from 4 discrete values
         * var result2 = pc.math.bytesToInt32(0x11, 0x22, 0x33, 0x44);
         * @param {number} r - A single byte (0-255).
         * @param {number} g - A single byte (0-255).
         * @param {number} b - A single byte (0-255).
         * @param {number} a - A single byte (0-255).
         */
        bytesToInt32: function (r, g, b, a) {
            if (r.length) {
                a = r[3];
                b = r[2];
                g = r[1];
                r = r[0];
            }
            // Why ((r << 24)>>>32)?
            // << operator uses signed 32 bit numbers, so 128<<24 is negative.
            // >>> used unsigned so >>>32 converts back to an unsigned.
            // See http://stackoverflow.com/questions/1908492/unsigned-integer-in-javascript
            return ((r << 24) | (g << 16) | (b << 8) | a) >>> 32;
        },

        /**
         * @function
         * @name pc.math.lerp
         * @returns {number} The linear interpolation of two numbers.
         * @description Calculates the linear interpolation of two numbers.
         * @param {number} a - Number to linearly interpolate from.
         * @param {number} b - Number to linearly interpolate to.
         * @param {number} alpha - The value controlling the result of interpolation. When alpha is 0,
         * a is returned. When alpha is 1, b is returned. Between 0 and 1, a linear interpolation between
         * a and b is returned. alpha is clamped between 0 and 1.
         */
        lerp: function (a, b, alpha) {
            return a + (b - a) * math.clamp(alpha, 0, 1);
        },

        /**
         * @function
         * @name pc.math.lerpAngle
         * @description Calculates the linear interpolation of two angles ensuring that interpolation
         * is correctly performed across the 360 to 0 degree boundary. Angles are supplied in degrees.
         * @returns {number} The linear interpolation of two angles.
         * @param {number} a - Angle (in degrees) to linearly interpolate from.
         * @param {number} b - Angle (in degrees) to linearly interpolate to.
         * @param {number} alpha - The value controlling the result of interpolation. When alpha is 0,
         * a is returned. When alpha is 1, b is returned. Between 0 and 1, a linear interpolation between
         * a and b is returned. alpha is clamped between 0 and 1.
         */
        lerpAngle: function (a, b, alpha) {
            if (b - a > 180 ) {
                b -= 360;
            }
            if (b - a < -180 ) {
                b += 360;
            }
            return pc.math.lerp(a, b, math.clamp(alpha, 0, 1));
        },

        /**
         * @function
         * @name pc.math.powerOfTwo
         * @description Returns true if argument is a power-of-two and false otherwise.
         * @param {number} x - Number to check for power-of-two property.
         * @returns {boolean} True if power-of-two and false otherwise.
         */
        powerOfTwo: function (x) {
            return ((x !== 0) && !(x & (x - 1)));
        },

        /**
         * @function
         * @name pc.math.nextPowerOfTwo
         * @description Returns the next power of 2 for the specified value.
         * @param {number} val - The value for which to calculate the next power of 2.
         * @returns {number} The next power of 2.
         */
        nextPowerOfTwo: function (val) {
            val--;
            val |= (val >> 1);
            val |= (val >> 2);
            val |= (val >> 4);
            val |= (val >> 8);
            val |= (val >> 16);
            val++;
            return val;
        },

        /**
         * @function
         * @name pc.math.random
         * @description Return a pseudo-random number between min and max.
         * The number generated is in the range [min, max), that is inclusive of the minimum but exclusive of the maximum.
         * @param {number} min - Lower bound for range.
         * @param {number} max - Upper bound for range.
         * @returns {number} Pseudo-random number between the supplied range.
         */
        random: function (min, max) {
            var diff = max - min;
            return Math.random() * diff + min;
        },

        /**
         * @function
         * @name pc.math.smoothstep
         * @description The function interpolates smoothly between two input values based on
         * a third one that should be between the first two. The returned value is clamped
         * between 0 and 1.
         * <br/>The slope (i.e. derivative) of the smoothstep function starts at 0 and ends at 0.
         * This makes it easy to create a sequence of transitions using smoothstep to interpolate
         * each segment rather than using a more sophisticated or expensive interpolation technique.
         * <br/>See http://en.wikipedia.org/wiki/Smoothstep for more details.
         * @param {number} min - The lower bound of the interpolation range.
         * @param {number} max - The upper bound of the interpolation range.
         * @param {number} x - The value to interpolate.
         * @returns {number} The smoothly interpolated value clamped between zero and one.
         */
        smoothstep: function (min, max, x) {
            if (x <= min) return 0;
            if (x >= max) return 1;

            x = (x - min) / (max - min);

            return x * x * (3 - 2 * x);
        },

        /**
         * @function
         * @name pc.math.smootherstep
         * @description An improved version of the pc.math.smoothstep function which has zero
         * 1st and 2nd order derivatives at t=0 and t=1.
         * <br/>See http://en.wikipedia.org/wiki/Smoothstep for more details.
         * @param {number} min - The lower bound of the interpolation range.
         * @param {number} max - The upper bound of the interpolation range.
         * @param {number} x - The value to interpolate.
         * @returns {number} The smoothly interpolated value clamped between zero and one.
         */
        smootherstep: function (min, max, x) {
            if (x <= min) return 0;
            if (x >= max) return 1;

            x = (x - min) / (max - min);

            return x * x * x * (x * (x * 6 - 15) + 10);
        },

        /**
         * @function
         * @name pc.math.roundUp
         * @description Rounds a number up to nearest multiple.
         * @param {number} numToRound - The number to round up.
         * @param {number} multiple - The multiple to round up to.
         * @returns {number} A number rounded up to nearest multiple.
         */
        roundUp: function (numToRound, multiple) {
            if (multiple === 0)
                return numToRound;
            return Math.ceil(numToRound / multiple) * multiple;
        }
    };

    /**
     * @class
     * @name pc.Color
     * @classdesc Representation of an RGBA color.
     * @description Create a new Color object.
     * @param {number|number[]} [r] - The value of the red component (0-1). If r is an array of length 3 or 4, the array will be used to populate all components.
     * @param {number} [g] - The value of the green component (0-1).
     * @param {number} [b] - The value of the blue component (0-1).
     * @param {number} [a] - The value of the alpha component (0-1).
     * @property {number} r The red component of the color.
     * @property {number} g The green component of the color.
     * @property {number} b The blue component of the color.
     * @property {number} a The alpha component of the color.
     */
    function Color(r, g, b, a) {
        var length = r && r.length;
        if (length === 3 || length === 4) {
            this.r = r[0];
            this.g = r[1];
            this.b = r[2];
            this.a = r[3] !== undefined ? r[3] : 1;
        } else {
            this.r = r || 0;
            this.g = g || 0;
            this.b = b || 0;
            this.a = a !== undefined ? a : 1;
        }
    }

    Object.assign(Color.prototype, {
        /**
         * @function
         * @name pc.Color#clone
         * @description Returns a clone of the specified color.
         * @returns {pc.Color} A duplicate color object.
         */
        clone: function () {
            return new Color(this.r, this.g, this.b, this.a);
        },

        /**
         * @function
         * @name pc.Color#copy
         * @description Copies the contents of a source color to a destination color.
         * @param {pc.Color} rhs - A color to copy to the specified color.
         * @returns {pc.Color} Self for chaining.
         * @example
         * var src = new pc.Color(1, 0, 0, 1);
         * var dst = new pc.Color();
         *
         * dst.copy(src);
         *
         * console.log("The two colors are " + (dst.equals(src) ? "equal" : "different"));
         */
        copy: function (rhs) {
            this.r = rhs.r;
            this.g = rhs.g;
            this.b = rhs.b;
            this.a = rhs.a;

            return this;
        },

        /**
         * @function
         * @name pc.Color#set
         * @description Assign values to the color components, including alpha.
         * @param {number} r - The value for red (0-1).
         * @param {number} g - The value for blue (0-1).
         * @param {number} b - The value for green (0-1).
         * @param {number} [a] - The value for the alpha (0-1), defaults to 1.
         * @returns {pc.Color} Self for chaining.
         */
        set: function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = (a === undefined) ? 1 : a;

            return this;
        },


        /**
         * @function
         * @name pc.Color#lerp
         * @description Returns the result of a linear interpolation between two specified colors.
         * @param {pc.Color} lhs - The color to interpolate from.
         * @param {pc.Color} rhs - The color to interpolate to.
         * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1, the linear interpolant
         * will occur on a straight line between lhs and rhs. Outside of this range, the linear interpolant will occur on
         * a ray extrapolated from this line.
         * @returns {pc.Color} Self for chaining.
         * @example
         * var a = new pc.Color(0, 0, 0);
         * var b = new pc.Color(1, 1, 0.5);
         * var r = new pc.Color();
         *
         * r.lerp(a, b, 0);   // r is equal to a
         * r.lerp(a, b, 0.5); // r is 0.5, 0.5, 0.25
         * r.lerp(a, b, 1);   // r is equal to b
         */
        lerp: function (lhs, rhs, alpha) {
            this.r = lhs.r + alpha * (rhs.r - lhs.r);
            this.g = lhs.g + alpha * (rhs.g - lhs.g);
            this.b = lhs.b + alpha * (rhs.b - lhs.b);
            this.a = lhs.a + alpha * (rhs.a - lhs.a);

            return this;
        },

        /**
         * @function
         * @name pc.Color#fromString
         * @description Set the values of the color from a string representation '#11223344' or '#112233'.
         * @param {string} hex - A string representation in the format '#RRGGBBAA' or '#RRGGBB'. Where RR, GG, BB, AA are red, green, blue and alpha values.
         * This is the same format used in HTML/CSS.
         * @returns {pc.Color} Self for chaining.
         */
        fromString: function (hex) {
            var i = parseInt(hex.replace('#', '0x'), 16);
            var bytes;
            if (hex.length > 7) {
                bytes = math.intToBytes32(i);
            } else {
                bytes = math.intToBytes24(i);
                bytes[3] = 255;
            }

            this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);

            return this;
        },

        /**
         * @function
         * @name pc.Color#toString
         * @description Converts the color to string form. The format is '#RRGGBBAA', where
         * RR, GG, BB, AA are the red, green, blue and alpha values. When the alpha value is not
         * included (the default), this is the same format as used in HTML/CSS.
         * @param {boolean} alpha - If true, the output string will include the alpha value.
         * @returns {string} The color in string form.
         * @example
         * var c = new pc.Color(1, 1, 1);
         * // Should output '#ffffffff'
         * console.log(c.toString());
         */
        toString: function (alpha) {
            var s = "#" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
            if (alpha === true) {
                var a = Math.round(this.a * 255).toString(16);
                if (this.a < 16 / 255) {
                    s += '0' + a;
                } else {
                    s += a;
                }

            }

            return s;
        }
    });

    /**
     * @private
     * @class
     * @name pc.IndexedList
     * @classdesc A ordered list-type data structure that can provide item look up by key, but also return return a list.\.
     */
    function IndexedList() {
        this._list = [];
        this._index = {};
    }

    Object.assign(IndexedList.prototype, {
        /**
         * @private
         * @function
         * @name pc.IndexedList#push
         * @description  Add a new item into the list with a index key.
         * @param {string} key -  Key used to look up item in index.
         * @param {object} item - Item to be stored.
         */
        push: function (key, item) {
            if (this._index[key]) {
                throw Error("Key already in index " + key);
            }
            var location = this._list.push(item) - 1;
            this._index[key] = location;
        },

        /**
         * @private
         * @function
         * @name pc.IndexedList#has
         * @description Test whether a key has been added to the index.
         * @param {string} key - The key to test.
         * @returns {boolean} Returns true if key is in the index, false if not.
         */
        has: function (key) {
            return this._index[key] !== undefined;
        },

        /**
         * @private
         * @function
         * @name pc.IndexedList#get
         * @description Return the item indexed by a key.
         * @param {string} key - The key of the item to retrieve.
         * @returns {object} The item stored at key.
         */
        get: function (key) {
            var location = this._index[key];
            if (location !== undefined) {
                return this._list[location];
            }
            return null;
        },

        /**
         * @private
         * @function
         * @name pc.IndexedList#remove
         * @description Remove the item indexed by key from the list.
         * @param {string} key - The key at which to remove the item.
         * @returns {boolean} Returns true if the key exists and an item was removed, returns false if no item was removed.
         */
        remove: function (key) {
            var location = this._index[key];
            if (location !== undefined) {
                this._list.splice(location, 1);
                delete this._index[key];

                // update index
                for (key in this._index) {
                    var idx = this._index[key];
                    if (idx > location) {
                        this._index[key] = idx - 1;
                    }
                }
                return true;
            }

            return false;
        },

        /**
         * @private
         * @function
         * @name pc.IndexedList#list
         * @description Returns the list of items.
         * @returns {object[]} The list of items.
         */
        list: function () {
            return this._list;
        },

        /**
         * @private
         * @function
         * @name pc.IndexedList#clear
         * @description Remove all items from the list.
         */
        clear: function () {
            this._list.length = 0;

            for (var prop in this._index) {
                delete this._index[prop];
            }
        }
    });

    function TagsCache(key) {
        this._index = { };
        this._key = key || null;
    }

    Object.assign(TagsCache.prototype, {
        addItem: function (item) {
            var tags = item.tags._list;

            for (var i = 0; i < tags.length; i++)
                this.add(tags[i], item);
        },

        removeItem: function (item) {
            var tags = item.tags._list;

            for (var i = 0; i < tags.length; i++)
                this.remove(tags[i], item);
        },

        add: function (tag, item) {
            // already in cache
            if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1)
                return;

            // create index for tag
            if (!this._index[tag]) {
                this._index[tag] = {
                    list: []
                };
                // key indexing is available
                if (this._key)
                    this._index[tag].keys = { };
            }

            // add to index list
            this._index[tag].list.push(item);

            // add to index keys
            if (this._key)
                this._index[tag].keys[item[this._key]] = item;
        },

        remove: function (tag, item) {
            // no index created for that tag
            if (!this._index[tag])
                return;

            // check if item not in cache
            if (this._key) {
                // by key
                if (!this._index[tag].keys[item[this._key]])
                    return;
            }

            // by position in list
            var ind = this._index[tag].indexOf(item);
            if (ind === -1)
                return;

            // remove item from index list
            this._index[tag].list.splice(ind, 1);

            // rmeove item from index keys
            if (this._key)
                delete this._index[tag].keys[item[this._key]];

            // if index empty, remove it
            if (this._index[tag].list.length === 0)
                delete this._index[tag];
        },

        find: function (args) {
            var self = this;
            var index = { };
            var items = [];
            var i, n, t;
            var item, tag, tags, tagsRest, missingIndex;

            var sort = function (a, b) {
                return self._index[a].list.length - self._index[b].list.length;
            };

            for (i = 0; i < args.length; i++) {
                tag = args[i];

                if (tag instanceof Array) {
                    if (tag.length === 0)
                        continue;

                    if (tag.length === 1) {
                        tag = tag[0];
                    } else {
                        // check if all indexes are in present
                        missingIndex = false;
                        for (t = 0; t < tag.length; t++) {
                            if (!this._index[tag[t]]) {
                                missingIndex = true;
                                break;
                            }
                        }
                        if (missingIndex)
                            continue;

                        // sort tags by least number of matches first
                        tags = tag.slice(0).sort(sort);

                        // remainder of tags for `has` checks
                        tagsRest = tags.slice(1);
                        if (tagsRest.length === 1)
                            tagsRest = tagsRest[0];

                        for (n = 0; n < this._index[tags[0]].list.length; n++) {
                            item = this._index[tags[0]].list[n];
                            if ((this._key ? !index[item[this._key]] : (items.indexOf(item) === -1)) && item.tags.has(tagsRest)) {
                                if (this._key)
                                    index[item[this._key]] = true;
                                items.push(item);
                            }
                        }

                        continue;
                    }
                }

                if (tag && typeof tag === 'string' && this._index[tag]) {
                    for (n = 0; n < this._index[tag].list.length; n++) {
                        item = this._index[tag].list[n];

                        if (this._key) {
                            if (!index[item[this._key]]) {
                                index[item[this._key]] = true;
                                items.push(item);
                            }
                        } else if (items.indexOf(item) === -1) {
                            items.push(item);
                        }
                    }
                }
            }

            return items;
        }
    });


    /**
     * @class
     * @name pc.Tags
     * @augments pc.EventHandler
     * @classdesc Set of tag names.
     * @description Create an instance of a Tags.
     * @param {object} [parent] - Parent object who tags belong to.
     * Note: Tags are used as addition of `pc.Entity` and `pc.Asset` as `tags` field.
     */

    /**
     * @event
     * @name pc.Tags#add
     * @param {string} tag - Name of a tag added to a set.
     * @param {object} parent - Parent object who tags belong to.
     */

    /**
     * @event
     * @name pc.Tags#remove
     * @param {string} tag - Name of a tag removed from a set.
     * @param {object} parent - Parent object who tags belong to.
     */

    /**
     * @event
     * @name pc.Tags#change
     * @param {object} [parent] - Parent object who tags belong to.
     * @description Fires when tags been added / removed.
     * It will fire once on bulk changes, while `add`/`remove` will fire on each tag operation.
     */

    function Tags(parent) {
        EventHandler.call(this);

        this._index = { };
        this._list = [];
        this._parent = parent;
    }
    Tags.prototype = Object.create(EventHandler.prototype);
    Tags.prototype.constructor = Tags;

    Object.assign(Tags.prototype, {
        /**
         * @function
         * @name pc.Tags#add
         * @description Add a tag, duplicates are ignored. Can be array or comma separated arguments for multiple tags.
         * @param {string} name - Name of a tag, or array of tags.
         * @returns {boolean} True if any tag were added.
         * @example
         * tags.add('level-1');
         * @example
         * tags.add('ui', 'settings');
         * @example
         * tags.add(['level-2', 'mob']);
         */
        add: function () {
            var changed = false;
            var tags = this._processArguments(arguments, true);

            if (!tags.length)
                return changed;

            for (var i = 0; i < tags.length; i++) {
                if (this._index[tags[i]])
                    continue;

                changed = true;

                this._index[tags[i]] = true;
                this._list.push(tags[i]);

                this.fire('add', tags[i], this._parent);
            }

            if (changed)
                this.fire('change', this._parent);

            return changed;
        },

        /**
         * @function
         * @name pc.Tags#remove
         * @description Remove tag.
         * @param {string} name - Name of a tag or array of tags.
         * @returns {boolean} True if any tag were removed.
         * @example
         * tags.remove('level-1');
         * @example
         * tags.remove('ui', 'settings');
         * @example
         * tags.remove(['level-2', 'mob']);
         */
        remove: function () {
            var changed = false;

            if (!this._list.length)
                return changed;

            var tags = this._processArguments(arguments, true);

            if (!tags.length)
                return changed;

            for (var i = 0; i < tags.length; i++) {
                if (!this._index[tags[i]])
                    continue;

                changed = true;

                delete this._index[tags[i]];
                this._list.splice(this._list.indexOf(tags[i]), 1);

                this.fire('remove', tags[i], this._parent);
            }

            if (changed)
                this.fire('change', this._parent);

            return changed;
        },

        /**
         * @function
         * @name pc.Tags#clear
         * @description Remove all tags.
         * @example
         * tags.clear();
         */
        clear: function () {
            if (!this._list.length)
                return;

            var tags = this._list.slice(0);
            this._list = [];
            this._index = { };

            for (var i = 0; i < tags.length; i++)
                this.fire('remove', tags[i], this._parent);

            this.fire('change', this._parent);
        },

        /**
         * @function
         * @name pc.Tags#has
         * @description Check if tags satisfy filters.
         * Filters can be provided by simple name of tag, as well as by array of tags.
         * When an array is provided it will check if tags contain each tag within the array.
         * If any of comma separated argument is satisfied, then it will return true.
         * Any number of combinations are valid, and order is irrelevant.
         * @param {...*} query - Name of a tag or array of tags.
         * @returns {boolean} True if filters are satisfied.
         * @example
         * tags.has('player'); // player
         * @example
         * tags.has('mob', 'player'); // player OR mob
         * @example
         * tags.has(['level-1', 'mob']); // monster AND level-1
         * @example
         * tags.has(['ui', 'settings'], ['ui', 'levels']); // (ui AND settings) OR (ui AND levels)
         */
        has: function () {
            if (!this._list.length)
                return false;

            return this._has(this._processArguments(arguments));
        },


        _has: function (tags) {
            if (!this._list.length || !tags.length)
                return false;

            for (var i = 0; i < tags.length; i++) {
                if (tags[i].length === 1) {
                    // single occurance
                    if (this._index[tags[i][0]])
                        return true;
                } else {
                    // combined occurance
                    var multiple = true;

                    for (var t = 0; t < tags[i].length; t++) {
                        if (this._index[tags[i][t]])
                            continue;

                        multiple = false;
                        break;
                    }

                    if (multiple)
                        return true;
                }
            }

            return false;
        },

        /**
         * @function
         * @name pc.Tags#list
         * @description Returns immutable array of tags.
         * @returns {string[]} Copy of tags array.
         */
        list: function () {
            return this._list.slice(0);
        },

        _processArguments: function (args, flat) {
            var tags = [];
            var tmp = [];

            if (!args || !args.length)
                return tags;

            for (var i = 0; i < args.length; i++) {
                if (args[i] instanceof Array) {
                    if (!flat)
                        tmp = [];

                    for (var t = 0; t < args[i].length; t++) {
                        if (typeof args[i][t] !== 'string')
                            continue;

                        if (flat) {
                            tags.push(args[i][t]);
                        } else {
                            tmp.push(args[i][t]);
                        }
                    }

                    if (!flat && tmp.length)
                        tags.push(tmp);
                } else if (typeof args[i] === 'string') {
                    if (flat) {
                        tags.push(args[i]);
                    } else {
                        tags.push([args[i]]);
                    }
                }
            }

            return tags;
        }
    });

    /**
     * @field
     * @readonly
     * @name pc.Tags#size
     * @type {number}
     * @description Number of tags in set.
     */
    Object.defineProperty(Tags.prototype, 'size', {
        get: function () {
            return this._list.length;
        }
    });

    /**
     * @private
     * @function
     * @name pc.now
     * @description Get current time in milliseconds. Use it to measure time difference. Reference time may differ on different platforms.
     * @returns {number} The time in milliseconds.
     */
    var now = (typeof window !== 'undefined') && window.performance && window.performance.now && window.performance.timing ? function () {
        return window.performance.now();
    } : Date.now;

    /**
     * @private
     * @class
     * @name pc.Timer
     * @description Create a new Timer instance.
     * @classdesc A Timer counts milliseconds from when start() is called until when stop() is called.
     */
    function Timer() {
        this._isRunning = false;
        this._a = 0;
        this._b = 0;
    }

    Object.assign(Timer.prototype, {
        /**
         * @private
         * @function
         * @name pc.Timer#start
         * @description Start the timer.
         */
        start: function () {
            this._isRunning = true;
            this._a = now();
        },

        /**
         * @private
         * @function
         * @name pc.Timer#stop
         * @description Stop the timer.
         */
        stop: function () {
            this._isRunning = false;
            this._b = now();
        },

        /**
         * @private
         * @function
         * @name pc.Timer#getMilliseconds
         * @description Get the number of milliseconds that passed between start() and stop() being called.
         * @returns {number} The elapsed milliseconds.
         */
        getMilliseconds: function () {
            return this._b - this._a;
        }
    });

    /**
     * @private
     * @function
     * @name pc.createURI
     * @description Create a URI object from constituent parts.
     * @param {object} options - Parts of the URI to build.
     * @param {string} [options.scheme] - The URI scheme (e.g. http).
     * @param {string} [options.authority] - The URI authority (e.g. `www.example.com`).
     * @param {string} [options.host] - Combination of scheme and authority (e.g. `http://www.example.com`).
     * @param {string} [options.path] - The URI path (e.g. /users/example).
     * @param {string} [options.hostpath] - Combination of scheme, authority and path (e.g. `http://www.example.com/users/example`).
     * @param {string} [options.query] - The query section, after the ?(e.g. `http://example.com?**key=value&another=123**`).
     * @param {string} [options.fragment] - The fragment section, after the # (e.g. `http://example.com#**fragment/data**`).
     * @returns {string} A URI string.
     */
    function createURI(options) {
        var s = "";
        if ((options.authority || options.scheme) && (options.host || options.hostpath)) {
            throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
        }
        if (options.host && options.hostpath) {
            throw new Error("Can't have 'host' and 'hostpath' option");
        }
        if (options.path && options.hostpath) {
            throw new Error("Can't have 'path' and 'hostpath' option");
        }

        if (options.scheme) {
            s += options.scheme + ":";
        }

        if (options.authority) {
            s += "//" + options.authority;
        }

        if (options.host) {
            s += options.host;
        }

        if (options.path) {
            s += options.path;
        }

        if (options.hostpath) {
            s += options.hostpath;
        }

        if (options.query) {
            s += "?" + options.query;
        }

        if (options.fragment) {
            s += "#" + options.fragment;
        }

        return s;
    }

    /**
     * @private
     * @class
     * @name pc.URI
     * @description Create a new URI object.
     * @classdesc A URI object.
     * @param {string} uri - URI string.
     */
    function URI(uri) {
        // See http://tools.ietf.org/html/rfc2396#appendix-B for details of RegExp
        var re = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
            result = uri.match(re);

        /**
         * @private
         * @name pc.URI#scheme
         * @type {string}
         * @description The scheme. (e.g. Http).
         */
        this.scheme = result[2];

        /**
         * @private
         * @name pc.URI#authority
         * @type {string}
         * @description The authority. (e.g. Www.example.com).
         */
        this.authority = result[4];

        /**
         * @private
         * @name pc.URI#path
         * @type {string}
         * @description The path. (e.g. /users/example).
         */
        this.path = result[5];

        /**
         * @private
         * @name pc.URI#query
         * @type {string}
         * @description The query, the section after a ?. (e.g. Search=value).
         */
        this.query = result[7];

        /**
         * @private
         * @name pc.URI#fragment
         * @type {string}
         * @description The fragment, the section after a #.
         */
        this.fragment = result[9];

        /**
         * @private
         * @function
         * @name pc.URI#toString
         * @description Convert URI back to string.
         * @returns {string} The URI as a string.
         */
        this.toString = function () {
            var s = "";

            if (this.scheme) {
                s += this.scheme + ":";
            }

            if (this.authority) {
                s += "//" + this.authority;
            }

            s += this.path;

            if (this.query) {
                s += "?" + this.query;
            }

            if (this.fragment) {
                s += "#" + this.fragment;
            }

            return s;
        };

        /**
         * @private
         * @function
         * @name pc.URI#getQuery
         * @description Returns the query parameters as an Object.
         * @returns {object} The URI's query parameters converted to an Object.
         * @example
         * var s = "http://example.com?a=1&b=2&c=3";
         * var uri = new pc.URI(s);
         * var q = uri.getQuery();
         * console.log(q.a); // logs "1"
         * console.log(q.b); // logs "2"
         * console.log(q.c); // logs "3"
         */
        this.getQuery = function () {
            var vars;
            var pair;
            var result = {};

            if (this.query) {
                vars = decodeURIComponent(this.query).split("&");
                vars.forEach(function (item, index, arr) {
                    pair = item.split("=");
                    result[pair[0]] = pair[1];
                }, this);
            }

            return result;
        };

        /**
         * @private
         * @function
         * @name pc.URI#setQuery
         * @description Set the query section of the URI from a Object.
         * @param {object} params - Key-Value pairs to encode into the query string.
         * @example
         * var s = "http://example.com";
         * var uri = new pc.URI(s);
         * uri.setQuery({
         *     "a": 1,
         *     "b": 2
         * });
         * console.log(uri.toString()); // logs "http://example.com?a=1&b=2
         */
        this.setQuery = function (params) {
            var q = "";
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    if (q !== "") {
                        q += "&";
                    }
                    q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
                }
            }

            this.query = q;
        };
    }

    /**
     * @class
     * @name pc.Http
     * @classdesc Used to send and receive HTTP requests.
     * @description Create a new Http instance. By default, a PlayCanvas application creates an instance of this
     * object at `pc.http`.
     */
    function Http() {}

    Http.ContentType = {
        FORM_URLENCODED: "application/x-www-form-urlencoded",
        GIF: "image/gif",
        JPEG: "image/jpeg",
        DDS: "image/dds",
        JSON: "application/json",
        PNG: "image/png",
        TEXT: "text/plain",
        XML: "application/xml",
        WAV: "audio/x-wav",
        OGG: "audio/ogg",
        MP3: "audio/mpeg",
        MP4: "audio/mp4",
        AAC: "audio/aac",
        BIN: "application/octet-stream",
        BASIS: "image/basis",
        GLB: "model/gltf-binary"
    };

    Http.ResponseType = {
        TEXT: 'text',
        ARRAY_BUFFER: 'arraybuffer',
        BLOB: 'blob',
        DOCUMENT: 'document',
        JSON: 'json'
    };

    Http.binaryExtensions = [
        '.model',
        '.wav',
        '.ogg',
        '.mp3',
        '.mp4',
        '.m4a',
        '.aac',
        '.dds',
        '.basis',
        '.glb'
    ];

    Http.retryDelay = 100;

    Object.assign(Http.prototype, {

        ContentType: Http.ContentType,
        ResponseType: Http.ResponseType,
        binaryExtensions: Http.binaryExtensions,

        /**
         * @function
         * @name pc.Http#get
         * @description Perform an HTTP GET request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @example
         * pc.http.get("http://example.com/", function (err, response) {
         *     console.log(response);
         * });
         * @returns {XMLHttpRequest} The request object.
         */
        /**
         * @function
         * @name pc.Http#get
         * @variation 2
         * @description Perform an HTTP GET request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {object} options - Additional options.
         * @param {object} [options.headers] - HTTP headers to add to the request.
         * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
         * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
         * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
         * @param {string} [options.responseType] - Override the response type.
         * @param {Document|object} [options.postdata] - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
         * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
         * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        get: function (url, options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            return this.request("GET", url, options, callback);
        },

        /**
         * @function
         * @name pc.Http#post
         * @description Perform an HTTP POST request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {object} data - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        /**
         * @function
         * @name pc.Http#post
         * @variation 2
         * @description Perform an HTTP POST request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {object} data - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {object} options - Additional options.
         * @param {object} [options.headers] - HTTP headers to add to the request.
         * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
         * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
         * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
         * @param {string} [options.responseType] - Override the response type.
         * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
         * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
         * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        post: function (url, data, options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            options.postdata = data;
            return this.request("POST", url, options, callback);
        },

        /**
         * @function
         * @name pc.Http#put
         * @description Perform an HTTP PUT request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {Document|object} data - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        /**
         * @function
         * @name pc.Http#put
         * @variation 2
         * @description Perform an HTTP PUT request to the given url.
         * @param {string} url - The URL to make the request to.
         * @param {Document|object} data - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {object} options - Additional options.
         * @param {object} [options.headers] - HTTP headers to add to the request.
         * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
         * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
         * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
         * @param {string} [options.responseType] - Override the response type.
         * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
         * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
         * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        put: function (url, data, options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            options.postdata = data;
            return this.request("PUT", url, options, callback);
        },

        /**
         * @function
         * @name pc.Http#del
         * @description Perform an HTTP DELETE request to the given url.
         * @param {object} url - The URL to make the request to.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        /**
         * @function
         * @name pc.Http#del
         * @variation 2
         * @description Perform an HTTP DELETE request to the given url.
         * @param {object} url - The URL to make the request to.
         * @param {object} options - Additional options.
         * @param {object} [options.headers] - HTTP headers to add to the request.
         * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
         * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
         * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
         * @param {string} [options.responseType] - Override the response type.
         * @param {Document|object} [options.postdata] - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
         * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
         * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        del: function (url, options, callback) {
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            return this.request("DELETE", url, options, callback);
        },

        /**
         * @function
         * @name pc.Http#request
         * @description Make a general purpose HTTP request.
         * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
         * @param {string} url - The url to make the request to.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        /**
         * @function
         * @name pc.Http#request
         * @variation 2
         * @description Make a general purpose HTTP request.
         * @param {string} method - The HTTP method "GET", "POST", "PUT", "DELETE".
         * @param {string} url - The url to make the request to.
         * @param {object} options - Additional options.
         * @param {object} [options.headers] - HTTP headers to add to the request.
         * @param {boolean} [options.async] - Make the request asynchronously. Defaults to true.
         * @param {object} [options.cache] - If false, then add a timestamp to the request to prevent caching.
         * @param {boolean} [options.withCredentials] - Send cookies with this request. Defaults to false.
         * @param {boolean} [options.retry] - If true then if the request fails it will be retried with an exponential backoff.
         * @param {number} [options.maxRetries] - If options.retry is true this specifies the maximum number of retries. Defaults to 5.
         * @param {number} [options.maxRetryDelay] - If options.retry is true this specifies the maximum amount of time to wait between retries in milliseconds. Defaults to 5000.
         * @param {string} [options.responseType] - Override the response type.
         * @param {Document|object} [options.postdata] - Data to send in the body of the request.
         * Some content types are handled automatically. If postdata is an XML Document, it is handled. If
         * the Content-Type header is set to 'application/json' then the postdata is JSON stringified.
         * Otherwise, by default, the data is sent as form-urlencoded.
         * @param {pc.callbacks.HttpResponse} callback - The callback used when the response has returned. Passed (err, data)
         * where data is the response (format depends on response type: text, Object, ArrayBuffer, XML) and
         * err is the error code.
         * @returns {XMLHttpRequest} The request object.
         */
        request: function (method, url, options, callback) {
            var uri, query, timestamp, postdata, xhr;
            var errored = false;

            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            // if retryable we are going to store new properties
            // in the options so create a new copy to not affect
            // the original
            if (options.retry) {
                options = Object.assign({
                    retries: 0,
                    maxRetries: 5
                }, options);
            }

            // store callback
            options.callback = callback;

            // setup defaults
            if (options.async == null) {
                options.async = true;
            }
            if (options.headers == null) {
                options.headers = {};
            }

            if (options.postdata != null) {
                if (options.postdata instanceof Document) {
                    // It's an XML document, so we can send it directly.
                    // XMLHttpRequest will set the content type correctly.
                    postdata = options.postdata;
                } else if (options.postdata instanceof FormData) {
                    postdata = options.postdata;
                } else if (options.postdata instanceof Object) {
                    // Now to work out how to encode the post data based on the headers
                    var contentType = options.headers["Content-Type"];

                    // If there is no type then default to form-encoded
                    if (contentType === undefined) {
                        options.headers["Content-Type"] = Http.ContentType.FORM_URLENCODED;
                        contentType = options.headers["Content-Type"];
                    }
                    switch (contentType) {
                        case Http.ContentType.FORM_URLENCODED:
                            // Normal URL encoded form data
                            postdata = "";
                            var bFirstItem = true;

                            // Loop round each entry in the map and encode them into the post data
                            for (var key in options.postdata) {
                                if (options.postdata.hasOwnProperty(key)) {
                                    if (bFirstItem) {
                                        bFirstItem = false;
                                    } else {
                                        postdata += "&";
                                    }
                                    postdata += escape(key) + "=" + escape(options.postdata[key]);
                                }
                            }
                            break;
                        default:
                        case Http.ContentType.JSON:
                            if (contentType == null) {
                                options.headers["Content-Type"] = Http.ContentType.JSON;
                            }
                            postdata = JSON.stringify(options.postdata);
                            break;
                    }
                } else {
                    postdata = options.postdata;
                }
            }

            if (options.cache === false) {
                // Add timestamp to url to prevent browser caching file
                timestamp = now();

                uri = new URI(url);
                if (!uri.query) {
                    uri.query = "ts=" + timestamp;
                } else {
                    uri.query = uri.query + "&ts=" + timestamp;
                }
                url = uri.toString();
            }

            if (options.query) {
                uri = new URI(url);
                query = extend(uri.getQuery(), options.query);
                uri.setQuery(query);
                url = uri.toString();
            }

            xhr = new XMLHttpRequest();
            xhr.open(method, url, options.async);
            xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
            xhr.responseType = options.responseType || this._guessResponseType(url);

            // Set the http headers
            for (var header in options.headers) {
                if (options.headers.hasOwnProperty(header)) {
                    xhr.setRequestHeader(header, options.headers[header]);
                }
            }

            xhr.onreadystatechange = function () {
                this._onReadyStateChange(method, url, options, xhr);
            }.bind(this);

            xhr.onerror = function () {
                this._onError(method, url, options, xhr);
                errored = true;
            }.bind(this);

            try {
                xhr.send(postdata);
            } catch (e) {
                // DWE: Don't callback on exceptions as behaviour is inconsistent, e.g. cross-domain request errors don't throw an exception.
                // Error callback should be called by xhr.onerror() callback instead.
                if (!errored) {
                    options.error(xhr.status, xhr, e);
                }
            }

            // Return the request object as it can be handy for blocking calls
            return xhr;
        },

        _guessResponseType: function (url) {
            var uri = new URI(url);
            var ext = path.getExtension(uri.path);

            if (Http.binaryExtensions.indexOf(ext) >= 0) {
                return Http.ResponseType.ARRAY_BUFFER;
            }

            if (ext === ".xml") {
                return Http.ResponseType.DOCUMENT;
            }

            return Http.ResponseType.TEXT;
        },

        _isBinaryContentType: function (contentType) {
            var binTypes = [
                Http.ContentType.MP4,
                Http.ContentType.WAV,
                Http.ContentType.OGG,
                Http.ContentType.MP3,
                Http.ContentType.BIN,
                Http.ContentType.DDS,
                Http.ContentType.BASIS,
                Http.ContentType.GLB
            ];
            if (binTypes.indexOf(contentType) >= 0) {
                return true;
            }

            return false;
        },

        _onReadyStateChange: function (method, url, options, xhr) {
            if (xhr.readyState === 4) {
                switch (xhr.status) {
                    case 0: {

                        // If this is a local resource then continue (IOS) otherwise the request
                        // didn't complete, possibly an exception or attempt to do cross-domain request
                        if (url[0] != '/') {
                            this._onSuccess(method, url, options, xhr);
                        } else {
                            this._onError(method, url, options, xhr);
                        }

                        break;
                    }
                    case 200:
                    case 201:
                    case 206:
                    case 304: {
                        this._onSuccess(method, url, options, xhr);
                        break;
                    }
                    default: {
                        this._onError(method, url, options, xhr);
                        break;
                    }
                }
            }
        },

        _onSuccess: function (method, url, options, xhr) {
            var response;
            var header;
            var contentType;
            var parts;
            header = xhr.getResponseHeader("Content-Type");
            if (header) {
                // Split up header into content type and parameter
                parts = header.split(";");
                contentType = parts[0].trim();
            }
            try {
                // Check the content type to see if we want to parse it
                if (contentType === this.ContentType.JSON || url.split('?')[0].endsWith(".json")) {
                    // It's a JSON response
                    response = JSON.parse(xhr.responseText);
                } else if (this._isBinaryContentType(contentType)) {
                    response = xhr.response;
                } else {
                    if (contentType) {
                        console.warn("responseType: " + xhr.responseType + " being served with Content-Type: " + contentType);
                    }

                    if (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {
                        response = xhr.response;
                    } else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {
                        response = xhr.response;
                    } else {
                        if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === this.ContentType.XML) {
                            // It's an XML response
                            response = xhr.responseXML;
                        } else {
                            // It's raw data
                            response = xhr.responseText;
                        }
                    }
                }

                options.callback(null, response);
            } catch (err) {
                options.callback(err);
            }
        },

        _onError: function (method, url, options, xhr) {
            if (options.retrying) {
                return;
            }

            // retry if necessary
            if (options.retry && options.retries < options.maxRetries) {
                options.retries++;
                options.retrying = true; // used to stop retrying when both onError and xhr.onerror are called
                var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
                console.log(method + ': ' + url + ' - Error ' + xhr.status + '. Retrying in ' + retryDelay + ' ms');

                setTimeout(function () {
                    options.retrying = false;
                    this.request(method, url, options, options.callback);
                }.bind(this), retryDelay);
            } else {
                // no more retries or not retry so just fail
                options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
            }
        }
    });

    var http = new Http();

    /**
     * @constant
     * @type {number}
     * @name pc.CURVE_LINEAR
     * @description A linear interpolation scheme.
     */
    var CURVE_LINEAR = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.CURVE_SMOOTHSTEP
     * @description A smooth step interpolation scheme.
     */
    var CURVE_SMOOTHSTEP = 1;
    /**
     * @deprecated
     * @constant
     * @type {number}
     * @name pc.CURVE_CATMULL
     * @description A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
     */
    var CURVE_CATMULL = 2;
    /**
     * @deprecated
     * @constant
     * @type {number}
     * @name pc.CURVE_CARDINAL
     * @description A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
     */
    var CURVE_CARDINAL = 3;
    /**
     * @constant
     * @type {number}
     * @name pc.CURVE_SPLINE
     * @description Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.
     */
    var CURVE_SPLINE = 4;
    /**
     * @constant
     * @type {number}
     * @name pc.CURVE_STEP
     * @description A stepped interpolater, free from the shackles of blending.
     */
    var CURVE_STEP = 5;

    function CurveEvaluator(curve, time) {
        this._curve = curve;
        this._left = -Infinity;
        this._right = Infinity;
        this._recip = 0;
        this._p0 = 0;
        this._p1 = 0;
        this._m0 = 0;
        this._m1 = 0;
        this._reset(time || 0);
    }

    Object.assign(CurveEvaluator.prototype, {

        // Evaluate the curve at the given time. Specify forceReset if the
        // underlying curve keys have changed since the last evaluation.
        evaluate: function (time, forceReset) {
            if (forceReset || time < this._left || time >= this._right) {
                this._reset(time);
            }

            var result;

            var type = this._curve.type;
            if (type === CURVE_STEP) {
                // step
                result = this._p0;
            } else {
                // calculate normalized t
                var t = (this._recip === 0) ? 0 : (time - this._left) * this._recip;

                if (type === CURVE_LINEAR) {
                    // linear
                    result = pc.math.lerp(this._p0, this._p1, t);
                } else if (type === CURVE_SMOOTHSTEP) {
                    // smoothstep
                    result = pc.math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
                } else {
                    // curve
                    result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
                }
            }
            return result;
        },

        // Calculate weights for the curve interval at the given time
        _reset: function (time) {
            var keys = this._curve.keys;
            var len = keys.length;

            if (!len) {
                // curve is empty
                this._left = -Infinity;
                this._right = Infinity;
                this._recip = 0;
                this._p0 = this._p1 = this._m0 = this._m1 = 0;
            } else {
                if (time < keys[0][0]) {
                    // iterator falls to the left of the start of the curve
                    this._left = -Infinity;
                    this._right = keys[0][0];
                    this._recip = 0;
                    this._p0 = this._p1 = keys[0][1];
                    this._m0 = this._m1 = 0;
                } else if (time >= keys[len - 1][0]) {
                    // iterator falls to the right of the end of the curve
                    this._left = keys[len - 1][0];
                    this._right = Infinity;
                    this._recip = 0;
                    this._p0 = this._p1 = keys[len - 1][1];
                    this._m0 = this._m1 = 0;
                } else {
                    // iterator falls within the bounds of the curve
                    // perform a linear search for the key just left of the current time.
                    // (TODO: for cases where the curve has more than 'n' keys it will
                    // be more efficient to perform a binary search here instead. Which is
                    // straight forward thanks to the sorted list of knots).
                    var index = 0;
                    while (time >= keys[index + 1][0]) {
                        index++;
                    }
                    this._left = keys[index][0];
                    this._right = keys[index + 1][0];
                    var diff = 1.0 / (this._right - this._left);
                    this._recip = (isFinite(diff) ? diff : 0);
                    this._p0 = keys[index][1];
                    this._p1 = keys[index + 1][1];
                    if (this._isHermite()) {
                        this._calcTangents(keys, index);
                    }
                }
            }
        },

        // returns true if the curve is a hermite and false otherwise
        _isHermite: function () {
            return this._curve.type === CURVE_CATMULL ||
                   this._curve.type === CURVE_CARDINAL ||
                   this._curve.type === CURVE_SPLINE;
        },

        // calculate tangents for the hermite curve
        _calcTangents: function (keys, index) {
            var a;
            var b = keys[index];
            var c = keys[index + 1];
            var d;

            if (index === 0) {
                a = [keys[0][0] + (keys[0][0] - keys[1][0]),
                    keys[0][1] + (keys[0][1] - keys[1][1])];
            } else {
                a = keys[index - 1];
            }

            if (index == keys.length - 2) {
                d = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]),
                    keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];
            } else {
                d = keys[index + 2];
            }

            if (this._curve.type === CURVE_SPLINE) {
                // calculate tangent scale (due to non-uniform knot spacing)
                var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
                var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);

                this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
                this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
            } else {
                // original tangent scale calc
                var s1 = (c[0] - b[0]) / (b[0] - a[0]);
                var s2 = (c[0] - b[0]) / (d[0] - c[0]);

                var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
                var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);

                var tension = (this._curve.type === CURVE_CATMULL) ? 0.5 : this._curve.tension;

                this._m0 = tension * (c[1] - a_);
                this._m1 = tension * (d_ - b[1]);
            }
        },

        _evaluateHermite: function (p0, p1, m0, m1, t) {
            var t2 = t * t;
            var twot = t + t;
            var omt = 1 - t;
            var omt2 = omt * omt;
            return p0 * ((1 + twot) * omt2) +
                   m0 * (t * omt2) +
                   p1 * (t2 * (3 - twot)) +
                   m1 * (t2 * (t - 1));
        }
    });

    /**
     * @class
     * @name pc.Curve
     * @classdesc A curve is a collection of keys (time/value pairs). The shape of the
     * curve is defined by its type that specifies an interpolation scheme for the keys.
     * @description Creates a new curve.
     * @param {number[]} [data] - An array of keys (pairs of numbers with the time first and
     * value second).
     * @property {number} length The number of keys in the curve. [read only].
     * @property {number} type The curve interpolation scheme. Can be:
     *
     * * {@link pc.CURVE_LINEAR}
     * * {@link pc.CURVE_SMOOTHSTEP}
     * * {@link pc.CURVE_SPLINE}
     * * {@link pc.CURVE_STEP}
     *
     * Defaults to {@link pc.CURVE_SMOOTHSTEP}.
     */
    function Curve(data) {
        this.keys = [];
        this.type = CURVE_SMOOTHSTEP;
        this.tension = 0.5; // used for CURVE_CARDINAL
        this._eval = new CurveEvaluator(this);

        if (data) {
            for (var i = 0; i < data.length - 1; i += 2) {
                this.keys.push([data[i], data[i + 1]]);
            }
        }

        this.sort();
    }

    Object.assign(Curve.prototype, {
        /**
         * @function
         * @name pc.Curve#add
         * @description Add a new key to the curve.
         * @param {number} time - Time to add new key.
         * @param {number} value - Value of new key.
         * @returns {number[]} [time, value] pair.
         */
        add: function (time, value) {
            var keys = this.keys;
            var len = keys.length;
            var i = 0;

            for (; i < len; i++) {
                if (keys[i][0] > time) {
                    break;
                }
            }

            var key = [time, value];
            this.keys.splice(i, 0, key);
            return key;
        },

        /**
         * @function
         * @name pc.Curve#get
         * @description Return a specific key.
         * @param {number} index - The index of the key to return.
         * @returns {number[]} The key at the specified index.
         */
        get: function (index) {
            return this.keys[index];
        },

        /**
         * @function
         * @name pc.Curve#sort
         * @description Sort keys by time.
         */
        sort: function () {
            this.keys.sort(function (a, b) {
                return a[0] - b[0];
            });
        },

        /**
         * @function
         * @name pc.Curve#value
         * @description Returns the interpolated value of the curve at specified time.
         * @param {number} time - The time at which to calculate the value.
         * @returns {number} The interpolated value.
         */
        value: function (time) {
            // we for the evaluation because keys may have changed since the last evaluate
            // (we can't know)
            return this._eval.evaluate(time, true);
        },

        closest: function (time) {
            var keys = this.keys;
            var length = keys.length;
            var min = 2;
            var result = null;

            for (var i = 0; i < length; i++) {
                var diff = Math.abs(time - keys[i][0]);
                if (min >= diff) {
                    min = diff;
                    result = keys[i];
                } else {
                    break;
                }
            }

            return result;
        },

        /**
         * @function
         * @name pc.Curve#clone
         * @description Returns a clone of the specified curve object.
         * @returns {pc.Curve} A clone of the specified curve.
         */
        clone: function () {
            var result = new Curve();
            result.keys = pc.extend(result.keys, this.keys);
            result.type = this.type;
            result.tension = this.tension;
            return result;
        },

        /**
         * @private
         * @function
         * @name pc.Curve#quantize
         * @description Sample the curve at regular intervals over the range [0..1].
         * @param {number} precision - The number of samples to return.
         * @returns {Float32Array} The set of quantized values.
         */
        quantize: function (precision) {
            precision = Math.max(precision, 2);

            var values = new Float32Array(precision);
            var step = 1.0 / (precision - 1);

            // quantize graph to table of interpolated values
            values[0] = this._eval.evaluate(0, true);
            for (var i = 1; i < precision; i++) {
                values[i] = this._eval.evaluate(step * i);
            }

            return values;
        },

        /**
         * @private
         * @function
         * @name pc.Curve#quantizeClamped
         * @description Sample the curve at regular intervals over the range [0..1]
         * and clamp the resulting samples to [min..max].
         * @param {number} precision - The number of samples to return.
         * @param {number} min - The minimum output value.
         * @param {number} max - The maximum output value.
         * @returns {Float32Array} The set of quantized values.
         */
        quantizeClamped: function (precision, min, max) {
            var result = this.quantize(precision);
            for (var i = 0; i < result.length; ++i) {
                result[i] = Math.min(max, Math.max(min, result[i]));
            }
            return result;
        }
    });

    Object.defineProperty(Curve.prototype, 'length', {
        get: function () {
            return this.keys.length;
        }
    });

    /**
     * @class
     * @name pc.CurveSet
     * @classdesc A curve set is a collection of curves.
     * @description Creates a new curve set.
     * @param {Array<number[]>} [curveKeys] - An array of arrays of keys (pairs of numbers with
     * the time first and value second).
     */
    function CurveSet() {
        var i;

        this.curves = [];
        this._type = CURVE_SMOOTHSTEP;

        if (arguments.length > 1) {
            for (i = 0; i < arguments.length; i++) {
                this.curves.push(new Curve(arguments[i]));
            }
        } else {
            if (arguments.length === 0) {
                this.curves.push(new Curve());
            } else {
                var arg = arguments[0];
                if (pc.type(arg) === 'number') {
                    for (i = 0; i < arg; i++) {
                        this.curves.push(new Curve());
                    }
                } else {
                    for (i = 0; i < arg.length; i++) {
                        this.curves.push(new Curve(arg[i]));
                    }
                }
            }
        }
    }

    Object.assign(CurveSet.prototype, {
        /**
         * @function
         * @name pc.CurveSet#get
         * @description Return a specific curve in the curve set.
         * @param {number} index - The index of the curve to return.
         * @returns {pc.Curve} The curve at the specified index.
         */
        get: function (index) {
            return this.curves[index];
        },

        /**
         * @function
         * @name pc.CurveSet#value
         * @description Returns the interpolated value of all curves in the curve
         * set at the specified time.
         * @param {number} time - The time at which to calculate the value.
         * @param {number[]} [result] - The interpolated curve values at the specified time.
         * If this parameter is not supplied, the function allocates a new array internally
         * to return the result.
         * @returns {number[]} The interpolated curve values at the specified time.
         */
        value: function (time, result) {
            var length = this.curves.length;
            result = result || [];
            result.length = length;

            for (var i = 0; i < length; i++) {
                result[i] = this.curves[i].value(time);
            }

            return result;
        },

        /**
         * @function
         * @name pc.CurveSet#clone
         * @description Returns a clone of the specified curve set object.
         * @returns {pc.CurveSet} A clone of the specified curve set.
         */
        clone: function () {
            var result = new CurveSet();

            result.curves = [];
            for (var i = 0; i < this.curves.length; i++) {
                result.curves.push(this.curves[i].clone());
            }

            result._type = this._type;

            return result;
        },

        quantize: function (precision) {
            precision = Math.max(precision, 2);

            var numCurves = this.curves.length;
            var values = new Float32Array(precision * numCurves);
            var step = 1.0 / (precision - 1);

            for (var c = 0; c < numCurves; c++) {
                var ev = new CurveEvaluator(this.curves[c]);
                for (var i = 0; i < precision; i++) { // quantize graph to table of interpolated values
                    values[i * numCurves + c] = ev.evaluate(step * i);
                }
            }

            return values;
        },

        /**
         * @private
         * @function
         * @name pc.CurveSet#quantizeClamped
         * @description This function will sample the curveset at regular intervals
         * over the range [0..1] and clamp the result to min and max.
         * @param {number} precision - The number of samples to return.
         * @param {number} min - The minimum output value.
         * @param {number} max - The maximum output value.
         * @returns {number[]} The set of quantized values.
         */
        quantizeClamped: function (precision, min, max) {
            var result = this.quantize(precision);
            for (var i = 0; i < result.length; ++i) {
                result[i] = Math.min(max, Math.max(min, result[i]));
            }
            return result;
        }
    });

    /**
     * @readonly
     * @name pc.CurveSet#length
     * @type {number}
     * @description The number of curves in the curve set.
     */
    Object.defineProperty(CurveSet.prototype, 'length', {
        get: function () {
            return this.curves.length;
        }
    });

    /**
     * @name pc.CurveSet#type
     * @type {number}
     * @description The interpolation scheme applied to all curves in the curve set. Can be:
     *
     * * {@link pc.CURVE_LINEAR}
     * * {@link pc.CURVE_SMOOTHSTEP}
     * * {@link pc.CURVE_SPLINE}
     * * {@link pc.CURVE_STEP}
     *
     * Defaults to {@link pc.CURVE_SMOOTHSTEP}.
     */
    Object.defineProperty(CurveSet.prototype, 'type', {
        get: function () {
            return this._type;
        },

        set: function (value) {
            this._type = value;
            for (var i = 0; i < this.curves.length; i++) {
                this.curves[i].type = value;
            }
        }
    });

    /**
     * @class
     * @name pc.Mat3
     * @classdesc A 3x3 matrix.
     * @description Creates a new identity Mat3 object.
     * @property {Float32Array} data Matrix elements in the form of a flat array.
     */
    function Mat3() {
        var data;
        // Create an identity matrix. Note that a new Float32Array has all elements set
        // to zero by default, so we only need to set the relevant elements to one.
        data = new Float32Array(9);
        data[0] = data[4] = data[8] = 1;
        this.data = data;
    }

    Object.assign(Mat3.prototype, {
        /**
         * @function
         * @name pc.Mat3#clone
         * @description Creates a duplicate of the specified matrix.
         * @returns {pc.Mat3} A duplicate matrix.
         * @example
         * var src = new pc.Mat3().translate(10, 20, 30);
         * var dst = src.clone();
         * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
         */
        clone: function () {
            return new Mat3().copy(this);
        },

        /**
         * @function
         * @name pc.Mat3#copy
         * @description Copies the contents of a source 3x3 matrix to a destination 3x3 matrix.
         * @param {pc.Mat3} rhs - A 3x3 matrix to be copied.
         * @returns {pc.Mat3} Self for chaining.
         * @example
         * var src = new pc.Mat3().translate(10, 20, 30);
         * var dst = new pc.Mat3();
         * dst.copy(src);
         * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
         */
        copy: function (rhs) {
            var src = rhs.data;
            var dst = this.data;

            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3];
            dst[4] = src[4];
            dst[5] = src[5];
            dst[6] = src[6];
            dst[7] = src[7];
            dst[8] = src[8];

            return this;
        },

        /**
         * @function
         * @name pc.Mat3#set
         * @description Copies the contents of a source array[9] to a destination 3x3 matrix.
         * @param {number[]} src - An array[9] to be copied.
         * @returns {pc.Mat3} Self for chaining.
         * @example
         * var dst = new pc.Mat3();
         * dst.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);
         */
        set: function (src) {
            var dst = this.data;

            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3];
            dst[4] = src[4];
            dst[5] = src[5];
            dst[6] = src[6];
            dst[7] = src[7];
            dst[8] = src[8];

            return this;
        },

        /**
         * @function
         * @name pc.Mat3#equals
         * @param {pc.Mat3} rhs - The other matrix.
         * @description Reports whether two matrices are equal.
         * @returns {boolean} True if the matrices are equal and false otherwise.
         * @example
         * var a = new pc.Mat3().translate(10, 20, 30);
         * var b = new pc.Mat3();
         * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            var l = this.data;
            var r = rhs.data;

            return ((l[0] === r[0]) &&
                    (l[1] === r[1]) &&
                    (l[2] === r[2]) &&
                    (l[3] === r[3]) &&
                    (l[4] === r[4]) &&
                    (l[5] === r[5]) &&
                    (l[6] === r[6]) &&
                    (l[7] === r[7]) &&
                    (l[8] === r[8]));
        },

        /**
         * @function
         * @name pc.Mat3#isIdentity
         * @description Reports whether the specified matrix is the identity matrix.
         * @returns {boolean} True if the matrix is identity and false otherwise.
         * @example
         * var m = new pc.Mat3();
         * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
         */
        isIdentity: function () {
            var m = this.data;
            return ((m[0] === 1) &&
                    (m[1] === 0) &&
                    (m[2] === 0) &&
                    (m[3] === 0) &&
                    (m[4] === 1) &&
                    (m[5] === 0) &&
                    (m[6] === 0) &&
                    (m[7] === 0) &&
                    (m[8] === 1));
        },

        /**
         * @function
         * @name pc.Mat3#setIdentity
         * @description Sets the matrix to the identity matrix.
         * @returns {pc.Mat3} Self for chaining.
         * @example
         * m.setIdentity();
         * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
         */
        setIdentity: function () {
            var m = this.data;
            m[0] = 1;
            m[1] = 0;
            m[2] = 0;

            m[3] = 0;
            m[4] = 1;
            m[5] = 0;

            m[6] = 0;
            m[7] = 0;
            m[8] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat3#toString
         * @description Converts the matrix to string form.
         * @returns {string} The matrix in string form.
         * @example
         * var m = new pc.Mat3();
         * // Should output '[1, 0, 0, 0, 1, 0, 0, 0, 1]'
         * console.log(m.toString());
         */
        toString: function () {
            var t = '[';
            for (var i = 0; i < 9; i++) {
                t += this.data[i];
                t += (i !== 8) ? ', ' : '';
            }
            t += ']';
            return t;
        },

        /**
         * @function
         * @name pc.Mat3#transpose
         * @description Generates the transpose of the specified 3x3 matrix.
         * @returns {pc.Mat3} Self for chaining.
         * @example
         * var m = new pc.Mat3();
         *
         * // Transpose in place
         * m.transpose();
         */
        transpose: function () {
            var m = this.data;

            var tmp;
            tmp = m[1]; m[1] = m[3]; m[3] = tmp;
            tmp = m[2]; m[2] = m[6]; m[6] = tmp;
            tmp = m[5]; m[5] = m[7]; m[7] = tmp;

            return this;
        }
    });

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Mat3.IDENTITY
     * @type {pc.Mat3}
     * @description A constant matrix set to the identity.
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Mat3.ZERO
     * @type {pc.Mat3}
     * @description A constant matrix with all elements set to 0.
     */

    Object.defineProperties(Mat3, {
        ZERO: { value: new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]) },
        IDENTITY: { value: new Mat3() }
    });

    /**
     * @class
     * @name pc.Vec3
     * @classdesc A 3-dimensional vector.
     * @description Creates a new Vec3 object.
     * @param {number|number[]} [x] - The x value. If x is an array of length 3, the array will be used to populate all components.
     * @param {number} [y] - The y value.
     * @param {number} [z] - The z value.
     * @example
     * var v = new pc.Vec3(1, 2, 3);
     */
    function Vec3(x, y, z) {
        if (x && x.length === 3) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2];
        } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }
    }

    Object.assign(Vec3.prototype, {
        /**
         * @function
         * @name pc.Vec3#add
         * @description Adds a 3-dimensional vector to another in place.
         * @param {pc.Vec3} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(10, 10, 10);
         * var b = new pc.Vec3(20, 20, 20);
         *
         * a.add(b);
         *
         * // Should output [30, 30, 30]
         * console.log("The result of the addition is: " + a.toString());
         */
        add: function (rhs) {
            this.x += rhs.x;
            this.y += rhs.y;
            this.z += rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#add2
         * @description Adds two 3-dimensional vectors together and returns the result.
         * @param {pc.Vec3} lhs - The first vector operand for the addition.
         * @param {pc.Vec3} rhs - The second vector operand for the addition.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(10, 10, 10);
         * var b = new pc.Vec3(20, 20, 20);
         * var r = new pc.Vec3();
         *
         * r.add2(a, b);
         * // Should output [30, 30, 30]
         *
         * console.log("The result of the addition is: " + r.toString());
         */
        add2: function (lhs, rhs) {
            this.x = lhs.x + rhs.x;
            this.y = lhs.y + rhs.y;
            this.z = lhs.z + rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#clone
         * @description Returns an identical copy of the specified 3-dimensional vector.
         * @returns {pc.Vec3} A 3-dimensional vector containing the result of the cloning.
         * @example
         * var v = new pc.Vec3(10, 20, 30);
         * var vclone = v.clone();
         * console.log("The result of the cloning is: " + vclone.toString());
         */
        clone: function () {
            return new Vec3().copy(this);
        },

        /**
         * @function
         * @name pc.Vec3#copy
         * @description Copied the contents of a source 3-dimensional vector to a destination 3-dimensional vector.
         * @param {pc.Vec3} rhs - A vector to copy to the specified vector.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var src = new pc.Vec3(10, 20, 30);
         * var dst = new pc.Vec3();
         *
         * dst.copy(src);
         *
         * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
         */
        copy: function (rhs) {
            this.x = rhs.x;
            this.y = rhs.y;
            this.z = rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#cross
         * @description Returns the result of a cross product operation performed on the two specified 3-dimensional vectors.
         * @param {pc.Vec3} lhs - The first 3-dimensional vector operand of the cross product.
         * @param {pc.Vec3} rhs - The second 3-dimensional vector operand of the cross product.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var back = new pc.Vec3().cross(pc.Vec3.RIGHT, pc.Vec3.UP);
         *
         * // Should print the Z axis (i.e. [0, 0, 1])
         * console.log("The result of the cross product is: " + back.toString());
         */
        cross: function (lhs, rhs) {
            // Create temporary variables in case lhs or rhs are 'this'
            var lx = lhs.x;
            var ly = lhs.y;
            var lz = lhs.z;
            var rx = rhs.x;
            var ry = rhs.y;
            var rz = rhs.z;

            this.x = ly * rz - ry * lz;
            this.y = lz * rx - rz * lx;
            this.z = lx * ry - rx * ly;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#distance
         * @description Returns the distance between the two specified 3-dimensional vectors.
         * @param {pc.Vec3} rhs - The second 3-dimensional vector to test.
         * @returns {number} The distance between the two vectors.
         * @example
         * var v1 = new pc.Vec3(5, 10, 20);
         * var v2 = new pc.Vec3(10, 20, 40);
         * var d = v1.distance(v2);
         * console.log("The between v1 and v2 is: " + d);
         */
        distance: function (rhs) {
            var x = this.x - rhs.x;
            var y = this.y - rhs.y;
            var z = this.z - rhs.z;
            return Math.sqrt(x * x + y * y + z * z);
        },

        /**
         * @function
         * @name pc.Vec3#dot
         * @description Returns the result of a dot product operation performed on the two specified 3-dimensional vectors.
         * @param {pc.Vec3} rhs - The second 3-dimensional vector operand of the dot product.
         * @returns {number} The result of the dot product operation.
         * @example
         * var v1 = new pc.Vec3(5, 10, 20);
         * var v2 = new pc.Vec3(10, 20, 40);
         * var v1dotv2 = v1.dot(v2);
         * console.log("The result of the dot product is: " + v1dotv2);
         */
        dot: function (rhs) {
            return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
        },

        /**
         * @function
         * @name pc.Vec3#equals
         * @description Reports whether two vectors are equal.
         * @param {pc.Vec3} rhs - The vector to compare to the specified vector.
         * @returns {boolean} True if the vectors are equal and false otherwise.
         * @example
         * var a = new pc.Vec3(1, 2, 3);
         * var b = new pc.Vec3(4, 5, 6);
         * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
        },

        /**
         * @function
         * @name pc.Vec3#length
         * @description Returns the magnitude of the specified 3-dimensional vector.
         * @returns {number} The magnitude of the specified 3-dimensional vector.
         * @example
         * var vec = new pc.Vec3(3, 4, 0);
         * var len = vec.length();
         * // Should output 5
         * console.log("The length of the vector is: " + len);
         */
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },

        /**
         * @function
         * @name pc.Vec3#lengthSq
         * @description Returns the magnitude squared of the specified 3-dimensional vector.
         * @returns {number} The magnitude of the specified 3-dimensional vector.
         * @example
         * var vec = new pc.Vec3(3, 4, 0);
         * var len = vec.lengthSq();
         * // Should output 25
         * console.log("The length squared of the vector is: " + len);
         */
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },

        /**
         * @function
         * @name pc.Vec3#lerp
         * @description Returns the result of a linear interpolation between two specified 3-dimensional vectors.
         * @param {pc.Vec3} lhs - The 3-dimensional to interpolate from.
         * @param {pc.Vec3} rhs - The 3-dimensional to interpolate to.
         * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1, the linear interpolant
         * will occur on a straight line between lhs and rhs. Outside of this range, the linear interpolant will occur on
         * a ray extrapolated from this line.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(0, 0, 0);
         * var b = new pc.Vec3(10, 10, 10);
         * var r = new pc.Vec3();
         *
         * r.lerp(a, b, 0);   // r is equal to a
         * r.lerp(a, b, 0.5); // r is 5, 5, 5
         * r.lerp(a, b, 1);   // r is equal to b
         */
        lerp: function (lhs, rhs, alpha) {
            this.x = lhs.x + alpha * (rhs.x - lhs.x);
            this.y = lhs.y + alpha * (rhs.y - lhs.y);
            this.z = lhs.z + alpha * (rhs.z - lhs.z);

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#mul
         * @description Multiplies a 3-dimensional vector to another in place.
         * @param {pc.Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(2, 3, 4);
         * var b = new pc.Vec3(4, 5, 6);
         *
         * a.mul(b);
         *
         * // Should output 8, 15, 24
         * console.log("The result of the multiplication is: " + a.toString());
         */
        mul: function (rhs) {
            this.x *= rhs.x;
            this.y *= rhs.y;
            this.z *= rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#mul2
         * @description Returns the result of multiplying the specified 3-dimensional vectors together.
         * @param {pc.Vec3} lhs - The 3-dimensional vector used as the first multiplicand of the operation.
         * @param {pc.Vec3} rhs - The 3-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(2, 3, 4);
         * var b = new pc.Vec3(4, 5, 6);
         * var r = new pc.Vec3();
         *
         * r.mul2(a, b);
         *
         * // Should output 8, 15, 24
         * console.log("The result of the multiplication is: " + r.toString());
         */
        mul2: function (lhs, rhs) {
            this.x = lhs.x * rhs.x;
            this.y = lhs.y * rhs.y;
            this.z = lhs.z * rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#normalize
         * @description Returns this 3-dimensional vector converted to a unit vector in place.
         * If the vector has a length of zero, the vector's elements will be set to zero.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var v = new pc.Vec3(25, 0, 0);
         *
         * v.normalize();
         *
         * // Should output 1, 0, 0
         * console.log("The result of the vector normalization is: " + v.toString());
         */
        normalize: function () {
            var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;
            if (lengthSq > 0) {
                var invLength = 1 / Math.sqrt(lengthSq);
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
            }

            return this;
        },

        /**
         * @function
         * @name  pc.Vec3#project
         * @description Projects this 3-dimensional vector onto the specified vector.
         * @param {pc.Vec3} rhs - The vector onto which the original vector will be projected on.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var v = new pc.Vec3(5, 5, 5);
         * var normal = new pc.Vec3(1, 0, 0);
         *
         * v.project(normal);
         *
         * // Should output 5, 0, 0
         * console.log("The result of the vector projection is: " + v.toString());
         */
        project: function (rhs) {
            var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
            var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
            var s = a_dot_b / b_dot_b;
            this.x = rhs.x * s;
            this.y = rhs.y * s;
            this.z = rhs.z * s;
            return this;
        },

        /**
         * @function
         * @name pc.Vec3#scale
         * @description Scales each dimension of the specified 3-dimensional vector by the supplied
         * scalar value.
         * @param {number} scalar - The value by which each vector component is multiplied.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var v = new pc.Vec3(2, 4, 8);
         *
         * // Multiply by 2
         * v.scale(2);
         *
         * // Negate
         * v.scale(-1);
         *
         * // Divide by 2
         * v.scale(0.5);
         */
        scale: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#set
         * @description Sets the specified 3-dimensional vector to the supplied numerical values.
         * @param {number} x - The value to set on the first component of the vector.
         * @param {number} y - The value to set on the second component of the vector.
         * @param {number} z - The value to set on the third component of the vector.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var v = new pc.Vec3();
         * v.set(5, 10, 20);
         *
         * // Should output 5, 10, 20
         * console.log("The result of the vector set is: " + v.toString());
         */
        set: function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#sub
         * @description Subtracts a 3-dimensional vector from another in place.
         * @param {pc.Vec3} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(10, 10, 10);
         * var b = new pc.Vec3(20, 20, 20);
         *
         * a.sub(b);
         *
         * // Should output [-10, -10, -10]
         * console.log("The result of the addition is: " + a.toString());
         */
        sub: function (rhs) {
            this.x -= rhs.x;
            this.y -= rhs.y;
            this.z -= rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#sub2
         * @description Subtracts two 3-dimensional vectors from one another and returns the result.
         * @param {pc.Vec3} lhs - The first vector operand for the addition.
         * @param {pc.Vec3} rhs - The second vector operand for the addition.
         * @returns {pc.Vec3} Self for chaining.
         * @example
         * var a = new pc.Vec3(10, 10, 10);
         * var b = new pc.Vec3(20, 20, 20);
         * var r = new pc.Vec3();
         *
         * r.sub2(a, b);
         *
         * // Should output [-10, -10, -10]
         * console.log("The result of the addition is: " + r.toString());
         */
        sub2: function (lhs, rhs) {
            this.x = lhs.x - rhs.x;
            this.y = lhs.y - rhs.y;
            this.z = lhs.z - rhs.z;

            return this;
        },

        /**
         * @function
         * @name pc.Vec3#toString
         * @description Converts the vector to string form.
         * @returns {string} The vector in string form.
         * @example
         * var v = new pc.Vec3(20, 10, 5);
         * // Should output '[20, 10, 5]'
         * console.log(v.toString());
         */
        toString: function () {
            return '[' + this.x + ', ' + this.y + ', ' + this.z + ']';
        }
    });

    /**
     * @name pc.Vec3#x
     * @type {number}
     * @description The first component of the vector.
     * @example
     * var vec = new pc.Vec3(10, 20, 30);
     *
     * // Get x
     * var x = vec.x;
     *
     * // Set x
     * vec.x = 0;
     */
    /**
     * @name pc.Vec3#y
     * @type {number}
     * @description The second component of the vector.
     * @example
     * var vec = new pc.Vec3(10, 20, 30);
     *
     * // Get y
     * var y = vec.y;
     *
     * // Set y
     * vec.y = 0;
     */
    /**
     * @name pc.Vec3#z
     * @type {number}
     * @description The third component of the vector.
     * @example
     * var vec = new pc.Vec3(10, 20, 30);
     *
     * // Get z
     * var z = vec.z;
     *
     * // Set z
     * vec.z = 0;
     */

    /**
     * @static
     * @readonly
     * @name pc.Vec3.BACK
     * @type {pc.Vec3}
     * @description A constant vector set to [0, 0, 1].
     */

    /**
     * @static
     * @readonly
     * @name pc.Vec3.DOWN
     * @type {pc.Vec3}
     * @description A constant vector set to [0, -1, 0].
     */

    /**
     * @static
     * @readonly
     * @name pc.Vec3.FORWARD
     * @type {pc.Vec3}
     * @description A constant vector set to [0, 0, -1].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec3.LEFT
     * @type {pc.Vec3}
     * @description A constant vector set to [-1, 0, 0].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec3.ONE
     * @type {pc.Vec3}
     * @description A constant vector set to [1, 1, 1].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec3.RIGHT
     * @type {pc.Vec3}
     * @description A constant vector set to [1, 0, 0].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec3.UP
     * @type {pc.Vec3}
     * @description A constant vector set to [0, 1, 0].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec3.ZERO
     * @type {pc.Vec3}
     * @description A constant vector set to [0, 0, 0].
     */

    Object.defineProperties(Vec3, {
        ZERO: { value: new Vec3(0, 0, 0) },
        ONE: { value: new Vec3(1, 1, 1) },
        UP: { value: new Vec3(0, 1, 0) },
        DOWN: { value: new Vec3(0, -1, 0) },
        RIGHT: { value: new Vec3(1, 0, 0) },
        LEFT: { value: new Vec3(-1, 0, 0) },
        FORWARD: { value: new Vec3(0, 0, -1) },
        BACK: { value: new Vec3(0, 0, 1) }
    });

    /**
     * @class
     * @name pc.Vec4
     * @classdesc A 4-dimensional vector.
     * @description Creates a new Vec4 object.
     * @param {number|number[]} [x] - The x value. If x is an array of length 4, the array will be used to populate all components.
     * @param {number} [y] - The y value.
     * @param {number} [z] - The z value.
     * @param {number} [w] - The w value.
     * @example
     * var v = new pc.Vec4(1, 2, 3, 4);
     */
    function Vec4(x, y, z, w) {
        if (x && x.length === 4) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2];
            this.w = x[3];
        } else {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = w || 0;
        }
    }

    Object.assign(Vec4.prototype, {
        /**
         * @function
         * @name pc.Vec4#add
         * @description Adds a 4-dimensional vector to another in place.
         * @param {pc.Vec4} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(10, 10, 10, 10);
         * var b = new pc.Vec4(20, 20, 20, 20);
         *
         * a.add(b);
         *
         * // Should output [30, 30, 30]
         * console.log("The result of the addition is: " + a.toString());
         */
        add: function (rhs) {
            this.x += rhs.x;
            this.y += rhs.y;
            this.z += rhs.z;
            this.w += rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#add2
         * @description Adds two 4-dimensional vectors together and returns the result.
         * @param {pc.Vec4} lhs - The first vector operand for the addition.
         * @param {pc.Vec4} rhs - The second vector operand for the addition.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(10, 10, 10, 10);
         * var b = new pc.Vec4(20, 20, 20, 20);
         * var r = new pc.Vec4();
         *
         * r.add2(a, b);
         * // Should output [30, 30, 30]
         *
         * console.log("The result of the addition is: " + r.toString());
         */
        add2: function (lhs, rhs) {
            this.x = lhs.x + rhs.x;
            this.y = lhs.y + rhs.y;
            this.z = lhs.z + rhs.z;
            this.w = lhs.w + rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#clone
         * @description Returns an identical copy of the specified 4-dimensional vector.
         * @returns {pc.Vec4} A 4-dimensional vector containing the result of the cloning.
         * @example
         * var v = new pc.Vec4(10, 20, 30, 40);
         * var vclone = v.clone();
         * console.log("The result of the cloning is: " + vclone.toString());
         */
        clone: function () {
            return new Vec4().copy(this);
        },

        /**
         * @function
         * @name pc.Vec4#copy
         * @description Copied the contents of a source 4-dimensional vector to a destination 4-dimensional vector.
         * @param {pc.Vec4} rhs - A vector to copy to the specified vector.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var src = new pc.Vec4(10, 20, 30, 40);
         * var dst = new pc.Vec4();
         *
         * dst.copy(src);
         *
         * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
         */
        copy: function (rhs) {
            this.x = rhs.x;
            this.y = rhs.y;
            this.z = rhs.z;
            this.w = rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#dot
         * @description Returns the result of a dot product operation performed on the two specified 4-dimensional vectors.
         * @param {pc.Vec4} rhs - The second 4-dimensional vector operand of the dot product.
         * @returns {number} The result of the dot product operation.
         * @example
         * var v1 = new pc.Vec4(5, 10, 20, 40);
         * var v2 = new pc.Vec4(10, 20, 40, 80);
         * var v1dotv2 = v1.dot(v2);
         * console.log("The result of the dot product is: " + v1dotv2);
         */
        dot: function (rhs) {
            return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
        },

        /**
         * @function
         * @name pc.Vec4#equals
         * @description Reports whether two vectors are equal.
         * @param {pc.Vec4} rhs - The vector to compare to the specified vector.
         * @returns {boolean} True if the vectors are equal and false otherwise.
         * @example
         * var a = new pc.Vec4(1, 2, 3, 4);
         * var b = new pc.Vec4(5, 6, 7, 8);
         * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
        },

        /**
         * @function
         * @name pc.Vec4#length
         * @description Returns the magnitude of the specified 4-dimensional vector.
         * @returns {number} The magnitude of the specified 4-dimensional vector.
         * @example
         * var vec = new pc.Vec4(3, 4, 0, 0);
         * var len = vec.length();
         * // Should output 5
         * console.log("The length of the vector is: " + len);
         */
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },

        /**
         * @function
         * @name pc.Vec4#lengthSq
         * @description Returns the magnitude squared of the specified 4-dimensional vector.
         * @returns {number} The magnitude of the specified 4-dimensional vector.
         * @example
         * var vec = new pc.Vec4(3, 4, 0);
         * var len = vec.lengthSq();
         * // Should output 25
         * console.log("The length squared of the vector is: " + len);
         */
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },

        /**
         * @function
         * @name pc.Vec4#lerp
         * @description Returns the result of a linear interpolation between two specified 4-dimensional vectors.
         * @param {pc.Vec4} lhs - The 4-dimensional to interpolate from.
         * @param {pc.Vec4} rhs - The 4-dimensional to interpolate to.
         * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1, the linear interpolant
         * will occur on a straight line between lhs and rhs. Outside of this range, the linear interpolant will occur on
         * a ray extrapolated from this line.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(0, 0, 0, 0);
         * var b = new pc.Vec4(10, 10, 10, 10);
         * var r = new pc.Vec4();
         *
         * r.lerp(a, b, 0);   // r is equal to a
         * r.lerp(a, b, 0.5); // r is 5, 5, 5, 5
         * r.lerp(a, b, 1);   // r is equal to b
         */
        lerp: function (lhs, rhs, alpha) {
            this.x = lhs.x + alpha * (rhs.x - lhs.x);
            this.y = lhs.y + alpha * (rhs.y - lhs.y);
            this.z = lhs.z + alpha * (rhs.z - lhs.z);
            this.w = lhs.w + alpha * (rhs.w - lhs.w);

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#mul
         * @description Multiplies a 4-dimensional vector to another in place.
         * @param {pc.Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(2, 3, 4, 5);
         * var b = new pc.Vec4(4, 5, 6, 7);
         *
         * a.mul(b);
         *
         * // Should output 8, 15, 24, 35
         * console.log("The result of the multiplication is: " + a.toString());
         */
        mul: function (rhs) {
            this.x *= rhs.x;
            this.y *= rhs.y;
            this.z *= rhs.z;
            this.w *= rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#mul2
         * @description Returns the result of multiplying the specified 4-dimensional vectors together.
         * @param {pc.Vec4} lhs - The 4-dimensional vector used as the first multiplicand of the operation.
         * @param {pc.Vec4} rhs - The 4-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(2, 3, 4, 5);
         * var b = new pc.Vec4(4, 5, 6, 7);
         * var r = new pc.Vec4();
         *
         * r.mul2(a, b);
         *
         * // Should output 8, 15, 24, 35
         * console.log("The result of the multiplication is: " + r.toString());
         */
        mul2: function (lhs, rhs) {
            this.x = lhs.x * rhs.x;
            this.y = lhs.y * rhs.y;
            this.z = lhs.z * rhs.z;
            this.w = lhs.w * rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#normalize
         * @description Returns this 4-dimensional vector converted to a unit vector in place.
         * If the vector has a length of zero, the vector's elements will be set to zero.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var v = new pc.Vec4(25, 0, 0, 0);
         *
         * v.normalize();
         *
         * // Should output 1, 0, 0, 0
         * console.log("The result of the vector normalization is: " + v.toString());
         */
        normalize: function () {
            var lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (lengthSq > 0) {
                var invLength = 1 / Math.sqrt(lengthSq);
                this.x *= invLength;
                this.y *= invLength;
                this.z *= invLength;
                this.w *= invLength;
            }

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#scale
         * @description Scales each dimension of the specified 4-dimensional vector by the supplied
         * scalar value.
         * @param {number} scalar - The value by which each vector component is multiplied.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var v = new pc.Vec4(2, 4, 8, 16);
         *
         * // Multiply by 2
         * v.scale(2);
         *
         * // Negate
         * v.scale(-1);
         *
         * // Divide by 2
         * v.scale(0.5);
         */
        scale: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#set
         * @description Sets the specified 4-dimensional vector to the supplied numerical values.
         * @param {number} x - The value to set on the first component of the vector.
         * @param {number} y - The value to set on the second component of the vector.
         * @param {number} z - The value to set on the third component of the vector.
         * @param {number} w - The value to set on the fourth component of the vector.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var v = new pc.Vec4();
         * v.set(5, 10, 20, 40);
         *
         * // Should output 5, 10, 20, 40
         * console.log("The result of the vector set is: " + v.toString());
         */
        set: function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#sub
         * @description Subtracts a 4-dimensional vector from another in place.
         * @param {pc.Vec4} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(10, 10, 10, 10);
         * var b = new pc.Vec4(20, 20, 20, 20);
         *
         * a.sub(b);
         *
         * // Should output [-10, -10, -10, -10]
         * console.log("The result of the subtraction is: " + a.toString());
         */
        sub: function (rhs) {
            this.x -= rhs.x;
            this.y -= rhs.y;
            this.z -= rhs.z;
            this.w -= rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#sub2
         * @description Subtracts two 4-dimensional vectors from one another and returns the result.
         * @param {pc.Vec4} lhs - The first vector operand for the subtraction.
         * @param {pc.Vec4} rhs - The second vector operand for the subtraction.
         * @returns {pc.Vec4} Self for chaining.
         * @example
         * var a = new pc.Vec4(10, 10, 10, 10);
         * var b = new pc.Vec4(20, 20, 20, 20);
         * var r = new pc.Vec4();
         *
         * r.sub2(a, b);
         *
         * // Should output [-10, -10, -10, -10]
         * console.log("The result of the subtraction is: " + r.toString());
         */
        sub2: function (lhs, rhs) {
            this.x = lhs.x - rhs.x;
            this.y = lhs.y - rhs.y;
            this.z = lhs.z - rhs.z;
            this.w = lhs.w - rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Vec4#toString
         * @description Converts the vector to string form.
         * @returns {string} The vector in string form.
         * @example
         * var v = new pc.Vec4(20, 10, 5, 0);
         * // Should output '[20, 10, 5, 0]'
         * console.log(v.toString());
         */
        toString: function () {
            return '[' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ']';
        }
    });

    /**
     * @field
     * @name pc.Vec4#x
     * @type {number}
     * @description The first component of the vector.
     * @example
     * var vec = new pc.Vec4(10, 20, 30, 40);
     *
     * // Get x
     * var x = vec.x;
     *
     * // Set x
     * vec.x = 0;
     */
    /**
     * @field
     * @name pc.Vec4#y
     * @type {number}
     * @description The second component of the vector.
     * @example
     * var vec = new pc.Vec4(10, 20, 30, 40);
     *
     * // Get y
     * var y = vec.y;
     *
     * // Set y
     * vec.y = 0;
     */
    /**
     * @field
     * @name pc.Vec4#z
     * @type {number}
     * @description The third component of the vector.
     * @example
     * var vec = new pc.Vec4(10, 20, 30, 40);
     *
     * // Get z
     * var z = vec.z;
     *
     * // Set z
     * vec.z = 0;
     */
    /**
     * @field
     * @name pc.Vec4#w
     * @type {number}
     * @description The fourth component of the vector.
     * @example
     * var vec = new pc.Vec4(10, 20, 30, 40);
     *
     * // Get w
     * var w = vec.w;
     *
     * // Set w
     * vec.w = 0;
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec4.ONE
     * @type {pc.Vec4}
     * @description A constant vector set to [1, 1, 1, 1].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec4.ZERO
     * @type {pc.Vec4}
     * @description A constant vector set to [0, 0, 0, 0].
     */

    Object.defineProperties(Vec4, {
        ZERO: { value: new Vec4(0, 0, 0, 0) },
        ONE: { value: new Vec4(1, 1, 1, 1) }
    });

    /**
     * @class
     * @name pc.Mat4
     * @classdesc A 4x4 matrix.
     * @description Creates a new identity Mat4 object.
     * @property {Float32Array} data Matrix elements in the form of a flat array.
     */
    function Mat4() {
        var data = new Float32Array(16);
        // Create an identity matrix. Note that a new Float32Array has all elements set
        // to zero by default, so we only need to set the relevant elements to one.
        data[0] = data[5] = data[10] = data[15] = 1;
        this.data = data;
    }

    Object.assign(Mat4.prototype, {
        /**
         * @function
         * @name pc.Mat4#add2
         * @description Adds the specified 4x4 matrices together and stores the result in
         * the current instance.
         * @param {pc.Mat4} lhs - The 4x4 matrix used as the first operand of the addition.
         * @param {pc.Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var m = new pc.Mat4();
         *
         * m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);
         *
         * console.log("The result of the addition is: " + m.toString());
         */
        add2: function (lhs, rhs) {
            var a = lhs.data,
                b = rhs.data,
                r = this.data;

            r[0] = a[0] + b[0];
            r[1] = a[1] + b[1];
            r[2] = a[2] + b[2];
            r[3] = a[3] + b[3];
            r[4] = a[4] + b[4];
            r[5] = a[5] + b[5];
            r[6] = a[6] + b[6];
            r[7] = a[7] + b[7];
            r[8] = a[8] + b[8];
            r[9] = a[9] + b[9];
            r[10] = a[10] + b[10];
            r[11] = a[11] + b[11];
            r[12] = a[12] + b[12];
            r[13] = a[13] + b[13];
            r[14] = a[14] + b[14];
            r[15] = a[15] + b[15];

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#add
         * @description Adds the specified 4x4 matrix to the current instance.
         * @param {pc.Mat4} rhs - The 4x4 matrix used as the second operand of the addition.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var m = new pc.Mat4();
         *
         * m.add(pc.Mat4.ONE);
         *
         * console.log("The result of the addition is: " + m.toString());
         */
        add: function (rhs) {
            return this.add2(this, rhs);
        },

        /**
         * @function
         * @name pc.Mat4#clone
         * @description Creates a duplicate of the specified matrix.
         * @returns {pc.Mat4} A duplicate matrix.
         * @example
         * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         * var dst = src.clone();
         * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
         */
        clone: function () {
            return new Mat4().copy(this);
        },

        /**
         * @function
         * @name pc.Mat4#copy
         * @description Copies the contents of a source 4x4 matrix to a destination 4x4 matrix.
         * @param {pc.Mat4} rhs - A 4x4 matrix to be copied.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var src = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         * var dst = new pc.Mat4();
         * dst.copy(src);
         * console.log("The two matrices are " + (src.equals(dst) ? "equal" : "different"));
         */
        copy: function (rhs) {
            var src = rhs.data,
                dst = this.data;

            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3];
            dst[4] = src[4];
            dst[5] = src[5];
            dst[6] = src[6];
            dst[7] = src[7];
            dst[8] = src[8];
            dst[9] = src[9];
            dst[10] = src[10];
            dst[11] = src[11];
            dst[12] = src[12];
            dst[13] = src[13];
            dst[14] = src[14];
            dst[15] = src[15];

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#equals
         * @description Reports whether two matrices are equal.
         * @param {pc.Mat4} rhs - The other matrix.
         * @returns {boolean} True if the matrices are equal and false otherwise.
         * @example
         * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         * var b = new pc.Mat4();
         * console.log("The two matrices are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            var l = this.data,
                r = rhs.data;

            return ((l[0] === r[0]) &&
                    (l[1] === r[1]) &&
                    (l[2] === r[2]) &&
                    (l[3] === r[3]) &&
                    (l[4] === r[4]) &&
                    (l[5] === r[5]) &&
                    (l[6] === r[6]) &&
                    (l[7] === r[7]) &&
                    (l[8] === r[8]) &&
                    (l[9] === r[9]) &&
                    (l[10] === r[10]) &&
                    (l[11] === r[11]) &&
                    (l[12] === r[12]) &&
                    (l[13] === r[13]) &&
                    (l[14] === r[14]) &&
                    (l[15] === r[15]));
        },

        /**
         * @function
         * @name pc.Mat4#isIdentity
         * @description Reports whether the specified matrix is the identity matrix.
         * @returns {boolean} True if the matrix is identity and false otherwise.
         * @example
         * var m = new pc.Mat4();
         * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
         */
        isIdentity: function () {
            var m = this.data;

            return ((m[0] === 1) &&
                    (m[1] === 0) &&
                    (m[2] === 0) &&
                    (m[3] === 0) &&
                    (m[4] === 0) &&
                    (m[5] === 1) &&
                    (m[6] === 0) &&
                    (m[7] === 0) &&
                    (m[8] === 0) &&
                    (m[9] === 0) &&
                    (m[10] === 1) &&
                    (m[11] === 0) &&
                    (m[12] === 0) &&
                    (m[13] === 0) &&
                    (m[14] === 0) &&
                    (m[15] === 1));
        },

        /**
         * @function
         * @name pc.Mat4#mul2
         * @description Multiplies the specified 4x4 matrices together and stores the result in
         * the current instance.
         * @param {pc.Mat4} lhs - The 4x4 matrix used as the first multiplicand of the operation.
         * @param {pc.Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
         * var r = new pc.Mat4();
         *
         * // r = a * b
         * r.mul2(a, b);
         *
         * console.log("The result of the multiplication is: " + r.toString());
         */
        mul2: function (lhs, rhs) {
            var a00, a01, a02, a03,
                a10, a11, a12, a13,
                a20, a21, a22, a23,
                a30, a31, a32, a33,
                b0, b1, b2, b3,
                a = lhs.data,
                b = rhs.data,
                r = this.data;

            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            a30 = a[12];
            a31 = a[13];
            a32 = a[14];
            a33 = a[15];

            b0 = b[0];
            b1 = b[1];
            b2 = b[2];
            b3 = b[3];
            r[0]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            r[1]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            r[2]  = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            r[3]  = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

            b0 = b[4];
            b1 = b[5];
            b2 = b[6];
            b3 = b[7];
            r[4]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            r[5]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            r[6]  = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            r[7]  = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

            b0 = b[8];
            b1 = b[9];
            b2 = b[10];
            b3 = b[11];
            r[8]  = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            r[9]  = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

            b0 = b[12];
            b1 = b[13];
            b2 = b[14];
            b3 = b[15];
            r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#mul
         * @description Multiplies the current instance by the specified 4x4 matrix.
         * @param {pc.Mat4} rhs - The 4x4 matrix used as the second multiplicand of the operation.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         * var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
         *
         * // a = a * b
         * a.mul(b);
         *
         * console.log("The result of the multiplication is: " + a.toString());
         */
        mul: function (rhs) {
            return this.mul2(this, rhs);
        },

        /**
         * @function
         * @name pc.Mat4#transformPoint
         * @description Transforms a 3-dimensional point by a 4x4 matrix.
         * @param {pc.Vec3} vec - The 3-dimensional point to be transformed.
         * @param {pc.Vec3} [res] - An optional 3-dimensional point to receive the result of the transformation.
         * @returns {pc.Vec3} The input point v transformed by the current instance.
         * @example
         * // Create a 3-dimensional point
         * var v = new pc.Vec3(1, 2, 3);
         *
         * // Create a 4x4 rotation matrix
         * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         *
         * var tv = m.transformPoint(v);
         */
        transformPoint: function (vec, res) {
            var x, y, z, m;

            m = this.data;

            x = vec.x;
            y = vec.y;
            z = vec.z;

            res = (res === undefined) ? new Vec3() : res;

            res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
            res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
            res.z = x * m[2] + y * m[6] + z * m[10] + m[14];

            return res;
        },

        /**
         * @function
         * @name pc.Mat4#transformVector
         * @description Transforms a 3-dimensional vector by a 4x4 matrix.
         * @param {pc.Vec3} vec - The 3-dimensional vector to be transformed.
         * @param {pc.Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.
         * @returns {pc.Vec3} The input vector v transformed by the current instance.
         * @example
         * // Create a 3-dimensional vector
         * var v = new pc.Vec3(1, 2, 3);
         *
         * // Create a 4x4 rotation matrix
         * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         *
         * var tv = m.transformVector(v);
         */
        transformVector: function (vec, res) {
            var x, y, z, m;

            m = this.data;

            x = vec.x;
            y = vec.y;
            z = vec.z;

            res = (res === undefined) ? new Vec3() : res;

            res.x = x * m[0] + y * m[4] + z * m[8];
            res.y = x * m[1] + y * m[5] + z * m[9];
            res.z = x * m[2] + y * m[6] + z * m[10];

            return res;
        },

        /**
         * @function
         * @name pc.Mat4#transformVec4
         * @description Transforms a 4-dimensional vector by a 4x4 matrix.
         * @param {pc.Vec4} vec - The 4-dimensional vector to be transformed.
         * @param {pc.Vec4} [res] - An optional 4-dimensional vector to receive the result of the transformation.
         * @returns {pc.Vec4} The input vector v transformed by the current instance.
         * @example
         * // Create an input 4-dimensional vector
         * var v = new pc.Vec4(1, 2, 3, 4);
         *
         * // Create an output 4-dimensional vector
         * var result = new pc.Vec4();
         *
         * // Create a 4x4 rotation matrix
         * var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
         *
         * m.transformVec4(v, result);
         */
        transformVec4: function (vec, res) {
            var x, y, z, w, m;

            m = this.data;

            x = vec.x;
            y = vec.y;
            z = vec.z;
            w = vec.w;

            res = (res === undefined) ? new Vec4() : res;

            res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
            res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
            res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
            res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];

            return res;
        },

        /**
         * @function
         * @name pc.Mat4#setLookAt
         * @description Sets the specified matrix to a viewing matrix derived from an eye point, a target point
         * and an up vector. The matrix maps the target point to the negative z-axis and the eye point to the
         * origin, so that when you use a typical projection matrix, the center of the scene maps to the center
         * of the viewport. Similarly, the direction described by the up vector projected onto the viewing plane
         * is mapped to the positive y-axis so that it points upward in the viewport. The up vector must not be
         * parallel to the line of sight from the eye to the reference point.
         * @param {pc.Vec3} position - 3-d vector holding view position.
         * @param {pc.Vec3} target - 3-d vector holding reference point.
         * @param {pc.Vec3} up - 3-d vector holding the up direction.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var position = new pc.Vec3(10, 10, 10);
         * var target = new pc.Vec3(0, 0, 0);
         * var up = new pc.Vec3(0, 1, 0);
         * var m = new pc.Mat4().setLookAt(position, target, up);
         */
        setLookAt: (function () {
            var x, y, z;

            x = new Vec3();
            y = new Vec3();
            z = new Vec3();

            return function (position, target, up) {
                z.sub2(position, target).normalize();
                y.copy(up).normalize();
                x.cross(y, z).normalize();
                y.cross(z, x);

                var r = this.data;

                r[0]  = x.x;
                r[1]  = x.y;
                r[2]  = x.z;
                r[3]  = 0;
                r[4]  = y.x;
                r[5]  = y.y;
                r[6]  = y.z;
                r[7]  = 0;
                r[8]  = z.x;
                r[9]  = z.y;
                r[10] = z.z;
                r[11] = 0;
                r[12] = position.x;
                r[13] = position.y;
                r[14] = position.z;
                r[15] = 1;

                return this;
            };
        }()),

        /**
         * @private
         * @function
         * @name pc.Mat4#setFrustum
         * @description Sets the specified matrix to a perspective projection matrix. The function's parameters define
         * the shape of a frustum.
         * @param {number} left - The x-coordinate for the left edge of the camera's projection plane in eye space.
         * @param {number} right - The x-coordinate for the right edge of the camera's projection plane in eye space.
         * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection plane in eye space.
         * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in eye space.
         * @param {number} znear - The near clip plane in eye coordinates.
         * @param {number} zfar - The far clip plane in eye coordinates.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 perspective projection matrix
         * var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);
         */
        setFrustum: function (left, right, bottom, top, znear, zfar) {
            var temp1, temp2, temp3, temp4, r;

            temp1 = 2 * znear;
            temp2 = right - left;
            temp3 = top - bottom;
            temp4 = zfar - znear;

            r = this.data;
            r[0] = temp1 / temp2;
            r[1] = 0;
            r[2] = 0;
            r[3] = 0;
            r[4] = 0;
            r[5] = temp1 / temp3;
            r[6] = 0;
            r[7] = 0;
            r[8] = (right + left) / temp2;
            r[9] = (top + bottom) / temp3;
            r[10] = (-zfar - znear) / temp4;
            r[11] = -1;
            r[12] = 0;
            r[13] = 0;
            r[14] = (-temp1 * zfar) / temp4;
            r[15] = 0;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#setPerspective
         * @description Sets the specified matrix to a perspective projection matrix. The function's
         * parameters define the shape of a frustum.
         * @param {number} fov - The frustum's field of view in degrees. The fovIsHorizontal parameter
         * controls whether this is a vertical or horizontal field of view. By default, it's a vertical
         * field of view.
         * @param {number} aspect - The aspect ratio of the frustum's projection plane (width / height).
         * @param {number} znear - The near clip plane in eye coordinates.
         * @param {number} zfar - The far clip plane in eye coordinates.
         * @param {boolean} [fovIsHorizontal=false] - Set to true to treat the fov as horizontal (x-axis)
         * and false for vertical (y-axis). Defaults to false.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 perspective projection matrix
         * var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);
         */
        setPerspective: function (fov, aspect, znear, zfar, fovIsHorizontal) {
            var xmax, ymax;

            if (!fovIsHorizontal) {
                ymax = znear * Math.tan(fov * Math.PI / 360);
                xmax = ymax * aspect;
            } else {
                xmax = znear * Math.tan(fov * Math.PI / 360);
                ymax = xmax / aspect;
            }

            return this.setFrustum(-xmax, xmax, -ymax, ymax, znear, zfar);
        },

        /**
         * @function
         * @name pc.Mat4#setOrtho
         * @description Sets the specified matrix to an orthographic projection matrix. The function's parameters
         * define the shape of a cuboid-shaped frustum.
         * @param {number} left - The x-coordinate for the left edge of the camera's projection plane in eye space.
         * @param {number} right - The x-coordinate for the right edge of the camera's projection plane in eye space.
         * @param {number} bottom - The y-coordinate for the bottom edge of the camera's projection plane in eye space.
         * @param {number} top - The y-coordinate for the top edge of the camera's projection plane in eye space.
         * @param {number} near - The near clip plane in eye coordinates.
         * @param {number} far - The far clip plane in eye coordinates.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 orthographic projection matrix
         * var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);
         */
        setOrtho: function (left, right, bottom, top, near, far) {
            var r = this.data;

            r[0] = 2 / (right - left);
            r[1] = 0;
            r[2] = 0;
            r[3] = 0;
            r[4] = 0;
            r[5] = 2 / (top - bottom);
            r[6] = 0;
            r[7] = 0;
            r[8] = 0;
            r[9] = 0;
            r[10] = -2 / (far - near);
            r[11] = 0;
            r[12] = -(right + left) / (right - left);
            r[13] = -(top + bottom) / (top - bottom);
            r[14] = -(far + near) / (far - near);
            r[15] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#setFromAxisAngle
         * @description Sets the specified matrix to a rotation matrix equivalent to a rotation around
         * an axis. The axis must be normalized (unit length) and the angle must be specified in degrees.
         * @param {pc.Vec3} axis - The normalized axis vector around which to rotate.
         * @param {number} angle - The angle of rotation in degrees.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 rotation matrix
         * var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);
         */
        setFromAxisAngle: function (axis, angle) {
            var x, y, z, c, s, t, tx, ty, m;

            angle *= pc.math.DEG_TO_RAD;

            x = axis.x;
            y = axis.y;
            z = axis.z;
            c = Math.cos(angle);
            s = Math.sin(angle);
            t = 1 - c;
            tx = t * x;
            ty = t * y;
            m = this.data;

            m[0] = tx * x + c;
            m[1] = tx * y + s * z;
            m[2] = tx * z - s * y;
            m[3] = 0;
            m[4] = tx * y - s * z;
            m[5] = ty * y + c;
            m[6] = ty * z + s * x;
            m[7] = 0;
            m[8] = tx * z + s * y;
            m[9] = ty * z - x * s;
            m[10] = t * z * z + c;
            m[11] = 0;
            m[12] = 0;
            m[13] = 0;
            m[14] = 0;
            m[15] = 1;

            return this;
        },

        /**
         * @private
         * @function
         * @name pc.Mat4#setTranslate
         * @description Sets the specified matrix to a translation matrix.
         * @param {number} x - The x-component of the translation.
         * @param {number} y - The y-component of the translation.
         * @param {number} z - The z-component of the translation.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 translation matrix
         * var tm = new pc.Mat4().setTranslate(10, 10, 10);
         */
        setTranslate: function (x, y, z) {
            var m = this.data;

            m[0] = 1;
            m[1] = 0;
            m[2] = 0;
            m[3] = 0;
            m[4] = 0;
            m[5] = 1;
            m[6] = 0;
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = 1;
            m[11] = 0;
            m[12] = x;
            m[13] = y;
            m[14] = z;
            m[15] = 1;

            return this;
        },

        /**
         * @private
         * @function
         * @name pc.Mat4#setScale
         * @description Sets the specified matrix to a scale matrix.
         * @param {number} x - The x-component of the scale.
         * @param {number} y - The y-component of the scale.
         * @param {number} z - The z-component of the scale.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 scale matrix
         * var sm = new pc.Mat4().setScale(10, 10, 10);
         */
        setScale: function (x, y, z) {
            var m = this.data;

            m[0] = x;
            m[1] = 0;
            m[2] = 0;
            m[3] = 0;
            m[4] = 0;
            m[5] = y;
            m[6] = 0;
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = z;
            m[11] = 0;
            m[12] = 0;
            m[13] = 0;
            m[14] = 0;
            m[15] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#invert
         * @description Sets the specified matrix to its inverse.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
         * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
         *
         * // Invert in place
         * rot.invert();
         */
        invert: function () {
            var a00, a01, a02, a03,
                a10, a11, a12, a13,
                a20, a21, a22, a23,
                a30, a31, a32, a33,
                b00, b01, b02, b03,
                b04, b05, b06, b07,
                b08, b09, b10, b11,
                det, invDet, m;

            m = this.data;
            a00 = m[0];
            a01 = m[1];
            a02 = m[2];
            a03 = m[3];
            a10 = m[4];
            a11 = m[5];
            a12 = m[6];
            a13 = m[7];
            a20 = m[8];
            a21 = m[9];
            a22 = m[10];
            a23 = m[11];
            a30 = m[12];
            a31 = m[13];
            a32 = m[14];
            a33 = m[15];

            b00 = a00 * a11 - a01 * a10;
            b01 = a00 * a12 - a02 * a10;
            b02 = a00 * a13 - a03 * a10;
            b03 = a01 * a12 - a02 * a11;
            b04 = a01 * a13 - a03 * a11;
            b05 = a02 * a13 - a03 * a12;
            b06 = a20 * a31 - a21 * a30;
            b07 = a20 * a32 - a22 * a30;
            b08 = a20 * a33 - a23 * a30;
            b09 = a21 * a32 - a22 * a31;
            b10 = a21 * a33 - a23 * a31;
            b11 = a22 * a33 - a23 * a32;

            det = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
            if (det === 0) {
                this.setIdentity();
            } else {
                invDet = 1 / det;

                m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
                m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
                m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
                m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
                m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
                m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
                m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
                m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
                m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
                m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
                m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
                m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
                m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
                m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
                m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
                m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
            }


            return this;
        },

        /**
         * @function
         * @name pc.Mat4#set
         * @description Sets matrix data from an array.
         * @param {number[]} src - Source array. Must have 16 values.
         * @returns {pc.Mat4} Self for chaining.
         */
        set: function (src) {
            var dst = this.data;
            dst[0] = src[0];
            dst[1] = src[1];
            dst[2] = src[2];
            dst[3] = src[3];
            dst[4] = src[4];
            dst[5] = src[5];
            dst[6] = src[6];
            dst[7] = src[7];
            dst[8] = src[8];
            dst[9] = src[9];
            dst[10] = src[10];
            dst[11] = src[11];
            dst[12] = src[12];
            dst[13] = src[13];
            dst[14] = src[14];
            dst[15] = src[15];

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#setIdentity
         * @description Sets the specified matrix to the identity matrix.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * m.setIdentity();
         * console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
         */
        setIdentity: function () {
            var m = this.data;
            m[0] = 1;
            m[1] = 0;
            m[2] = 0;
            m[3] = 0;
            m[4] = 0;
            m[5] = 1;
            m[6] = 0;
            m[7] = 0;
            m[8] = 0;
            m[9] = 0;
            m[10] = 1;
            m[11] = 0;
            m[12] = 0;
            m[13] = 0;
            m[14] = 0;
            m[15] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#setTRS
         * @description Sets the specified matrix to the concatenation of a translation, a
         * quaternion rotation and a scale.
         * @param {pc.Vec3} t - A 3-d vector translation.
         * @param {pc.Quat} r - A quaternion rotation.
         * @param {pc.Vec3} s - A 3-d vector scale.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var t = new pc.Vec3(10, 20, 30);
         * var r = new pc.Quat();
         * var s = new pc.Vec3(2, 2, 2);
         *
         * var m = new pc.Mat4();
         * m.setTRS(t, r, s);
         */
        setTRS: function (t, r, s) {
            var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz,
                x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;

            tx = t.x;
            ty = t.y;
            tz = t.z;

            qx = r.x;
            qy = r.y;
            qz = r.z;
            qw = r.w;

            sx = s.x;
            sy = s.y;
            sz = s.z;

            x2 = qx + qx;
            y2 = qy + qy;
            z2 = qz + qz;
            xx = qx * x2;
            xy = qx * y2;
            xz = qx * z2;
            yy = qy * y2;
            yz = qy * z2;
            zz = qz * z2;
            wx = qw * x2;
            wy = qw * y2;
            wz = qw * z2;

            m = this.data;

            m[0] = (1 - (yy + zz)) * sx;
            m[1] = (xy + wz) * sx;
            m[2] = (xz - wy) * sx;
            m[3] = 0;

            m[4] = (xy - wz) * sy;
            m[5] = (1 - (xx + zz)) * sy;
            m[6] = (yz + wx) * sy;
            m[7] = 0;

            m[8] = (xz + wy) * sz;
            m[9] = (yz - wx) * sz;
            m[10] = (1 - (xx + yy)) * sz;
            m[11] = 0;

            m[12] = tx;
            m[13] = ty;
            m[14] = tz;
            m[15] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#transpose
         * @description Sets the specified matrix to its transpose.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var m = new pc.Mat4();
         *
         * // Transpose in place
         * m.transpose();
         */
        transpose: function () {
            var tmp, m = this.data;

            tmp = m[1];
            m[1] = m[4];
            m[4] = tmp;

            tmp = m[2];
            m[2] = m[8];
            m[8] = tmp;

            tmp = m[3];
            m[3] = m[12];
            m[12] = tmp;

            tmp = m[6];
            m[6] = m[9];
            m[9] = tmp;

            tmp = m[7];
            m[7] = m[13];
            m[13] = tmp;

            tmp = m[11];
            m[11] = m[14];
            m[14] = tmp;

            return this;
        },

        invertTo3x3: function (res) {
            var a11, a21, a31, a12, a22, a32, a13, a23, a33,
                m, r, det, idet;

            m = this.data;
            r = res.data;

            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];

            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];

            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];

            a11 =  m10 * m5 - m6 * m9;
            a21 = -m10 * m1 + m2 * m9;
            a31 =  m6  * m1 - m2 * m5;
            a12 = -m10 * m4 + m6 * m8;
            a22 =  m10 * m0 - m2 * m8;
            a32 = -m6  * m0 + m2 * m4;
            a13 =  m9  * m4 - m5 * m8;
            a23 = -m9  * m0 + m1 * m8;
            a33 =  m5  * m0 - m1 * m4;

            det =  m0 * a11 + m1 * a12 + m2 * a13;
            if (det === 0) { // no inverse
                return this;
            }

            idet = 1 / det;

            r[0] = idet * a11;
            r[1] = idet * a21;
            r[2] = idet * a31;
            r[3] = idet * a12;
            r[4] = idet * a22;
            r[5] = idet * a32;
            r[6] = idet * a13;
            r[7] = idet * a23;
            r[8] = idet * a33;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#getTranslation
         * @description Extracts the translational component from the specified 4x4 matrix.
         * @param {pc.Vec3} [t] - The vector to receive the translation of the matrix.
         * @returns {pc.Vec3} The translation of the specified 4x4 matrix.
         * @example
         * // Create a 4x4 matrix
         * var m = new pc.Mat4();
         *
         * // Query the z-axis component
         * var t = new pc.Vec3();
         * m.getTranslation(t);
         */
        getTranslation: function (t) {
            t = (t === undefined) ? new Vec3() : t;

            return t.set(this.data[12], this.data[13], this.data[14]);
        },

        /**
         * @function
         * @name pc.Mat4#getX
         * @description Extracts the x-axis from the specified 4x4 matrix.
         * @param {pc.Vec3} [x] - The vector to receive the x axis of the matrix.
         * @returns {pc.Vec3} The x-axis of the specified 4x4 matrix.
         * @example
         * // Create a 4x4 matrix
         * var m = new pc.Mat4();
         *
         * // Query the z-axis component
         * var x = new pc.Vec3();
         * m.getX(x);
         */
        getX: function (x) {
            x = (x === undefined) ? new Vec3() : x;

            return x.set(this.data[0], this.data[1], this.data[2]);
        },

        /**
         * @function
         * @name pc.Mat4#getY
         * @description Extracts the y-axis from the specified 4x4 matrix.
         * @param {pc.Vec3} [y] - The vector to receive the y axis of the matrix.
         * @returns {pc.Vec3} The y-axis of the specified 4x4 matrix.
         * @example
         * // Create a 4x4 matrix
         * var m = new pc.Mat4();
         *
         * // Query the z-axis component
         * var y = new pc.Vec3();
         * m.getY(y);
         */
        getY: function (y) {
            y = (y === undefined) ? new Vec3() : y;

            return y.set(this.data[4], this.data[5], this.data[6]);
        },

        /**
         * @function
         * @name pc.Mat4#getZ
         * @description Extracts the z-axis from the specified 4x4 matrix.
         * @param {pc.Vec3} [z] - The vector to receive the z axis of the matrix.
         * @returns {pc.Vec3} The z-axis of the specified 4x4 matrix.
         * @example
         * // Create a 4x4 matrix
         * var m = new pc.Mat4();
         *
         * // Query the z-axis component
         * var z = new pc.Vec3();
         * m.getZ(z);
         */
        getZ: function (z) {
            z = (z === undefined) ? new Vec3() : z;

            return z.set(this.data[8], this.data[9], this.data[10]);
        },

        /**
         * @function
         * @name pc.Mat4#getScale
         * @description Extracts the scale component from the specified 4x4 matrix.
         * @param {pc.Vec3} [scale] - Vector to receive the scale.
         * @returns {pc.Vec3} The scale in X, Y and Z of the specified 4x4 matrix.
         * @example
         * // Create a 4x4 scale matrix
         * var m = new pc.Mat4().scale(2, 3, 4);
         *
         * // Query the scale component
         * var scale = m.getScale();
         */
        getScale: (function () {
            var x, y, z;

            x = new Vec3();
            y = new Vec3();
            z = new Vec3();

            return function (scale) {
                scale = (scale === undefined) ? new Vec3() : scale;

                this.getX(x);
                this.getY(y);
                this.getZ(z);
                scale.set(x.length(), y.length(), z.length());

                return scale;
            };
        }()),

        /**
         * @function
         * @name pc.Mat4#setFromEulerAngles
         * @description Sets the specified matrix to a rotation matrix defined by
         * Euler angles. The Euler angles are specified in XYZ order and in degrees.
         * @param {number} ex - Angle to rotate around X axis in degrees.
         * @param {number} ey - Angle to rotate around Y axis in degrees.
         * @param {number} ez - Angle to rotate around Z axis in degrees.
         * @returns {pc.Mat4} Self for chaining.
         * @example
         * var m = new pc.Mat4();
         * m.setFromEulerAngles(45, 90, 180);
         */
        // http://en.wikipedia.org/wiki/Rotation_matrix#Conversion_from_and_to_axis-angle
        // The 3D space is right-handed, so the rotation around each axis will be counterclockwise
        // for an observer placed so that the axis goes in his or her direction (Right-hand rule).
        setFromEulerAngles: function (ex, ey, ez) {
            var s1, c1, s2, c2, s3, c3, m;

            ex *= pc.math.DEG_TO_RAD;
            ey *= pc.math.DEG_TO_RAD;
            ez *= pc.math.DEG_TO_RAD;

            // Solution taken from http://en.wikipedia.org/wiki/Euler_angles#Matrix_orientation
            s1 = Math.sin(-ex);
            c1 = Math.cos(-ex);
            s2 = Math.sin(-ey);
            c2 = Math.cos(-ey);
            s3 = Math.sin(-ez);
            c3 = Math.cos(-ez);

            m = this.data;

            // Set rotation elements
            m[0] = c2 * c3;
            m[1] = -c2 * s3;
            m[2] = s2;
            m[3] = 0;

            m[4] = c1 * s3 + c3 * s1 * s2;
            m[5] = c1 * c3 - s1 * s2 * s3;
            m[6] = -c2 * s1;
            m[7] = 0;

            m[8] = s1 * s3 - c1 * c3 * s2;
            m[9] = c3 * s1 + c1 * s2 * s3;
            m[10] = c1 * c2;
            m[11] = 0;

            m[12] = 0;
            m[13] = 0;
            m[14] = 0;
            m[15] = 1;

            return this;
        },

        /**
         * @function
         * @name pc.Mat4#getEulerAngles
         * @description Extracts the Euler angles equivalent to the rotational portion
         * of the specified matrix. The returned Euler angles are in XYZ order an in degrees.
         * @param {pc.Vec3} [eulers] - A 3-d vector to receive the Euler angles.
         * @returns {pc.Vec3} A 3-d vector containing the Euler angles.
         * @example
         * // Create a 4x4 rotation matrix of 45 degrees around the y-axis
         * var m = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 45);
         *
         * var eulers = m.getEulerAngles();
         */
        getEulerAngles: (function () {
            var scale = new Vec3();

            return function (eulers) {
                var x, y, z, sx, sy, sz, m, halfPi;

                eulers = (eulers === undefined) ? new Vec3() : eulers;

                this.getScale(scale);
                sx = scale.x;
                sy = scale.y;
                sz = scale.z;

                m = this.data;

                y = Math.asin(-m[2] / sx);
                halfPi = Math.PI * 0.5;

                if (y < halfPi) {
                    if (y > -halfPi) {
                        x = Math.atan2(m[6] / sy, m[10] / sz);
                        z = Math.atan2(m[1] / sx, m[0] / sx);
                    } else {
                        // Not a unique solution
                        z = 0;
                        x = -Math.atan2(m[4] / sy, m[5] / sy);
                    }
                } else {
                    // Not a unique solution
                    z = 0;
                    x = Math.atan2(m[4] / sy, m[5] / sy);
                }

                return eulers.set(x, y, z).scale(pc.math.RAD_TO_DEG);
            };
        }()),

        /**
         * @function
         * @name pc.Mat4#toString
         * @description Converts the specified matrix to string form.
         * @returns {string} The matrix in string form.
         * @example
         * var m = new pc.Mat4();
         * // Should output '[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]'
         * console.log(m.toString());
         */
        toString: function () {
            var i, t;

            t = '[';
            for (i = 0; i < 16; i += 1) {
                t += this.data[i];
                t += (i !== 15) ? ', ' : '';
            }
            t += ']';
            return t;
        }
    });

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Mat4.IDENTITY
     * @type {pc.Mat4}
     * @description A constant matrix set to the identity.
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Mat4.ZERO
     * @type {pc.Mat4}
     * @description A constant matrix with all elements set to 0.
     */

    Object.defineProperties(Mat4, {
        ZERO: { value: new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) },
        IDENTITY: { value: new Mat4() }
    });

    /**
     * @class
     * @name pc.Quat
     * @classdesc A quaternion.
     * @description Create a new Quat object.
     * @param {number|number[]} [x] - The quaternion's x component. Default value 0. If x is an array of length 4, the array will be used to populate all components.
     * @param {number} [y] - The quaternion's y component. Default value 0.
     * @param {number} [z] - The quaternion's z component. Default value 0.
     * @param {number} [w] - The quaternion's w component. Default value 1.
     */
    function Quat(x, y, z, w) {
        if (x && x.length === 4) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2];
            this.w = x[3];
        } else {
            this.x = (x === undefined) ? 0 : x;
            this.y = (y === undefined) ? 0 : y;
            this.z = (z === undefined) ? 0 : z;
            this.w = (w === undefined) ? 1 : w;
        }
    }

    /**
     * @field
     * @name pc.Quat#x
     * @type {number}
     * @description The x component of the quaternion.
     * @example
     * var quat = new pc.Quat();
     *
     * // Get x
     * var x = quat.x;
     *
     * // Set x
     * quat.x = 0;
     */
    /**
     * @field
     * @name pc.Quat#y
     * @type {number}
     * @description The y component of the quaternion.
     * @example
     * var quat = new pc.Quat();
     *
     * // Get y
     * var y = quat.y;
     *
     * // Set y
     * quat.y = 0;
     */
    /**
     * @field
     * @name pc.Quat#z
     * @type {number}
     * @description The z component of the quaternion.
     * @example
     * var quat = new pc.Quat();
     *
     * // Get z
     * var z = quat.z;
     *
     * // Set z
     * quat.z = 0;
     */
    /**
     * @field
     * @name pc.Quat#w
     * @type {number}
     * @description The w component of the quaternion.
     * @example
     * var quat = new pc.Quat();
     *
     * // Get w
     * var w = quat.w;
     *
     * // Set w
     * quat.w = 0;
     */

    Object.assign(Quat.prototype, {
        /**
         * @function
         * @name pc.Quat#clone
         * @description Returns an identical copy of the specified quaternion.
         * @returns {pc.Quat} A quaternion containing the result of the cloning.
         * @example
         * var q = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
         * var qclone = q.clone();
         *
         * console.log("The result of the cloning is: " + q.toString());
         */
        clone: function () {
            return new Quat(this.x, this.y, this.z, this.w);
        },

        conjugate: function () {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#copy
         * @description Copies the contents of a source quaternion to a destination quaternion.
         * @param {pc.Quat} rhs - The quaternion to be copied.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var src = new pc.Quat();
         * var dst = new pc.Quat();
         * dst.copy(src, src);
         * console.log("The two quaternions are " + (src.equals(dst) ? "equal" : "different"));
         */
        copy: function (rhs) {
            this.x = rhs.x;
            this.y = rhs.y;
            this.z = rhs.z;
            this.w = rhs.w;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#equals
         * @description Reports whether two quaternions are equal.
         * @param {pc.Quat} rhs - The quaternion to be compared against.
         * @returns {boolean} True if the quaternions are equal and false otherwise.
         * @example
         * var a = new pc.Quat();
         * var b = new pc.Quat();
         * console.log("The two quaternions are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            return ((this.x === rhs.x) && (this.y === rhs.y) && (this.z === rhs.z) && (this.w === rhs.w));
        },

        /**
         * @function
         * @name pc.Quat#getAxisAngle
         * @description Gets the rotation axis and angle for a given
         *  quaternion. If a quaternion is created with
         *  setFromAxisAngle, this method will return the same
         *  values as provided in the original parameter list
         *  OR functionally equivalent values.
         * @param {pc.Vec3} axis - The 3-dimensional vector to receive the axis of rotation.
         * @returns {number} Angle, in degrees, of the rotation.
         * @example
         * var q = new pc.Quat();
         * q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);
         * var v = new pc.Vec3();
         * var angle = q.getAxisAngle(v);
         * // Should output 90
         * console.log(angle);
         * // Should output [0, 1, 0]
         * console.log(v.toString());
         */
        getAxisAngle: function (axis) {
            var rad = Math.acos(this.w) * 2;
            var s = Math.sin(rad / 2);
            if (s !== 0) {
                axis.x = this.x / s;
                axis.y = this.y / s;
                axis.z = this.z / s;
                if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
                    // Flip the sign
                    axis.x *= -1;
                    axis.y *= -1;
                    axis.z *= -1;
                    rad *= -1;
                }
            } else {
                // If s is zero, return any axis (no rotation - axis does not matter)
                axis.x = 1;
                axis.y = 0;
                axis.z = 0;
            }
            return rad * math.RAD_TO_DEG;
        },

        /**
         * @function
         * @name pc.Quat#getEulerAngles
         * @description Converts the supplied quaternion to Euler angles.
         * @param {pc.Vec3} [eulers] - The 3-dimensional vector to receive the Euler angles.
         * @returns {pc.Vec3} The 3-dimensional vector holding the Euler angles that
         * correspond to the supplied quaternion.
         */
        getEulerAngles: function (eulers) {
            var x, y, z, qx, qy, qz, qw, a2;

            eulers = (eulers === undefined) ? new Vec3() : eulers;

            qx = this.x;
            qy = this.y;
            qz = this.z;
            qw = this.w;

            a2 = 2 * (qw * qy - qx * qz);
            if (a2 <= -0.99999) {
                x = 2 * Math.atan2(qx, qw);
                y = -Math.PI / 2;
                z = 0;
            } else if (a2 >= 0.99999) {
                x = 2 * Math.atan2(qx, qw);
                y = Math.PI / 2;
                z = 0;
            } else {
                x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
                y = Math.asin(a2);
                z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
            }

            return eulers.set(x, y, z).scale(math.RAD_TO_DEG);
        },

        /**
         * @function
         * @name pc.Quat#invert
         * @description Generates the inverse of the specified quaternion.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * // Create a quaternion rotated 180 degrees around the y-axis
         * var rot = new pc.Quat().setFromEulerAngles(0, 180, 0);
         *
         * // Invert in place
         * rot.invert();
         */
        invert: function () {
            return this.conjugate().normalize();
        },

        /**
         * @function
         * @name pc.Quat#length
         * @description Returns the magnitude of the specified quaternion.
         * @returns {number} The magnitude of the specified quaternion.
         * @example
         * var q = new pc.Quat(0, 0, 0, 5);
         * var len = q.length();
         * // Should output 5
         * console.log("The length of the quaternion is: " + len);
         */
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },

        /**
         * @function
         * @name pc.Quat#lengthSq
         * @description Returns the magnitude squared of the specified quaternion.
         * @returns {number} The magnitude of the specified quaternion.
         * @example
         * var q = new pc.Quat(3, 4, 0);
         * var lenSq = q.lengthSq();
         * // Should output 25
         * console.log("The length squared of the quaternion is: " + lenSq);
         */
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },

        /**
         * @function
         * @name pc.Quat#mul
         * @description Returns the result of multiplying the specified quaternions together.
         * @param {pc.Quat} rhs - The quaternion used as the second multiplicand of the operation.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
         * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
         *
         * // a becomes a 90 degree rotation around the Y axis
         * // In other words, a = a * b
         * a.mul(b);
         *
         * console.log("The result of the multiplication is: " + a.toString());
         */
        mul: function (rhs) {
            var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;

            q1x = this.x;
            q1y = this.y;
            q1z = this.z;
            q1w = this.w;

            q2x = rhs.x;
            q2y = rhs.y;
            q2z = rhs.z;
            q2w = rhs.w;

            this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
            this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
            this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
            this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#mul2
         * @description Returns the result of multiplying the specified quaternions together.
         * @param {pc.Quat} lhs - The quaternion used as the first multiplicand of the operation.
         * @param {pc.Quat} rhs - The quaternion used as the second multiplicand of the operation.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var a = new pc.Quat().setFromEulerAngles(0, 30, 0);
         * var b = new pc.Quat().setFromEulerAngles(0, 60, 0);
         * var r = new pc.Quat();
         *
         * // r is set to a 90 degree rotation around the Y axis
         * // In other words, r = a * b
         * r.mul2(a, b);
         *
         * console.log("The result of the multiplication is: " + r.toString());
         */
        mul2: function (lhs, rhs) {
            var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w;

            q1x = lhs.x;
            q1y = lhs.y;
            q1z = lhs.z;
            q1w = lhs.w;

            q2x = rhs.x;
            q2y = rhs.y;
            q2z = rhs.z;
            q2w = rhs.w;

            this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
            this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
            this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
            this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#normalize
         * @description Returns the specified quaternion converted in place to a unit quaternion.
         * @returns {pc.Quat} The result of the normalization.
         * @example
         * var v = new pc.Quat(0, 0, 0, 5);
         *
         * v.normalize();
         *
         * // Should output 0, 0, 0, 1
         * console.log("The result of the vector normalization is: " + v.toString());
         */
        normalize: function () {
            var len = this.length();
            if (len === 0) {
                this.x = this.y = this.z = 0;
                this.w = 1;
            } else {
                len = 1 / len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
                this.w *= len;
            }

            return this;
        },

        /**
         * @function
         * @name pc.Quat#set
         * @description Sets the specified quaternion to the supplied numerical values.
         * @param {number} x - The x component of the quaternion.
         * @param {number} y - The y component of the quaternion.
         * @param {number} z - The z component of the quaternion.
         * @param {number} w - The w component of the quaternion.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var q = new pc.Quat();
         * q.set(1, 0, 0, 0);
         *
         * // Should output 1, 0, 0, 0
         * console.log("The result of the vector set is: " + q.toString());
         */
        set: function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#setFromAxisAngle
         * @description Sets a quaternion from an angular rotation around an axis.
         * @param {pc.Vec3} axis - World space axis around which to rotate.
         * @param {number} angle - Angle to rotate around the given axis in degrees.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var q = new pc.Quat();
         * q.setFromAxisAngle(pc.Vec3.UP, 90);
         */
        setFromAxisAngle: function (axis, angle) {
            var sa, ca;

            angle *= 0.5 * math.DEG_TO_RAD;

            sa = Math.sin(angle);
            ca = Math.cos(angle);

            this.x = sa * axis.x;
            this.y = sa * axis.y;
            this.z = sa * axis.z;
            this.w = ca;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#setFromEulerAngles
         * @description Sets a quaternion from Euler angles specified in XYZ order.
         * @param {number} ex - Angle to rotate around X axis in degrees.
         * @param {number} ey - Angle to rotate around Y axis in degrees.
         * @param {number} ez - Angle to rotate around Z axis in degrees.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var q = new pc.Quat();
         * q.setFromEulerAngles(45, 90, 180);
         */
        setFromEulerAngles: function (ex, ey, ez) {
            var sx, cx, sy, cy, sz, cz, halfToRad;

            halfToRad = 0.5 * math.DEG_TO_RAD;
            ex *= halfToRad;
            ey *= halfToRad;
            ez *= halfToRad;

            sx = Math.sin(ex);
            cx = Math.cos(ex);
            sy = Math.sin(ey);
            cy = Math.cos(ey);
            sz = Math.sin(ez);
            cz = Math.cos(ez);

            this.x = sx * cy * cz - cx * sy * sz;
            this.y = cx * sy * cz + sx * cy * sz;
            this.z = cx * cy * sz - sx * sy * cz;
            this.w = cx * cy * cz + sx * sy * sz;

            return this;
        },

        /**
         * @function
         * @name pc.Quat#setFromMat4
         * @description Converts the specified 4x4 matrix to a quaternion. Note that since
         * a quaternion is purely a representation for orientation, only the translational part
         * of the matrix is lost.
         * @param {pc.Mat4} m - The 4x4 matrix to convert.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * // Create a 4x4 rotation matrix of 180 degrees around the y-axis
         * var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
         *
         * // Convert to a quaternion
         * var q = new pc.Quat().setFromMat4(rot);
         */
        setFromMat4: function (m) {
            var m00, m01, m02, m10, m11, m12, m20, m21, m22,
                tr, s, rs, lx, ly, lz;

            m = m.data;

            // Cache matrix values for super-speed
            m00 = m[0];
            m01 = m[1];
            m02 = m[2];
            m10 = m[4];
            m11 = m[5];
            m12 = m[6];
            m20 = m[8];
            m21 = m[9];
            m22 = m[10];

            // Remove the scale from the matrix
            lx = m00 * m00 + m01 * m01 + m02 * m02;
            if (lx === 0)
                return this;
            lx = 1 / Math.sqrt(lx);
            ly = m10 * m10 + m11 * m11 + m12 * m12;
            if (ly === 0)
                return this;
            ly = 1 / Math.sqrt(ly);
            lz = m20 * m20 + m21 * m21 + m22 * m22;
            if (lz === 0)
                return this;
            lz = 1 / Math.sqrt(lz);

            m00 *= lx;
            m01 *= lx;
            m02 *= lx;
            m10 *= ly;
            m11 *= ly;
            m12 *= ly;
            m20 *= lz;
            m21 *= lz;
            m22 *= lz;

            // http://www.cs.ucr.edu/~vbz/resources/quatut.pdf

            tr = m00 + m11 + m22;
            if (tr >= 0) {
                s = Math.sqrt(tr + 1);
                this.w = s * 0.5;
                s = 0.5 / s;
                this.x = (m12 - m21) * s;
                this.y = (m20 - m02) * s;
                this.z = (m01 - m10) * s;
            } else {
                if (m00 > m11) {
                    if (m00 > m22) {
                        // XDiagDomMatrix
                        rs = (m00 - (m11 + m22)) + 1;
                        rs = Math.sqrt(rs);

                        this.x = rs * 0.5;
                        rs = 0.5 / rs;
                        this.w = (m12 - m21) * rs;
                        this.y = (m01 + m10) * rs;
                        this.z = (m02 + m20) * rs;
                    } else {
                        // ZDiagDomMatrix
                        rs = (m22 - (m00 + m11)) + 1;
                        rs = Math.sqrt(rs);

                        this.z = rs * 0.5;
                        rs = 0.5 / rs;
                        this.w = (m01 - m10) * rs;
                        this.x = (m20 + m02) * rs;
                        this.y = (m21 + m12) * rs;
                    }
                } else if (m11 > m22) {
                    // YDiagDomMatrix
                    rs = (m11 - (m22 + m00)) + 1;
                    rs = Math.sqrt(rs);

                    this.y = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m20 - m02) * rs;
                    this.z = (m12 + m21) * rs;
                    this.x = (m10 + m01) * rs;
                } else {
                    // ZDiagDomMatrix
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);

                    this.z = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m01 - m10) * rs;
                    this.x = (m20 + m02) * rs;
                    this.y = (m21 + m12) * rs;
                }
            }

            return this;
        },

        /**
         * @function
         * @name pc.Quat#slerp
         * @description Performs a spherical interpolation between two quaternions. The result of
         * the interpolation is written to the quaternion calling the function.
         * @param {pc.Quat} lhs - The quaternion to interpolate from.
         * @param {pc.Quat} rhs - The quaternion to interpolate to.
         * @param {number} alpha - The value controlling the interpolation in relation to the two input
         * quaternions. The value is in the range 0 to 1, 0 generating q1, 1 generating q2 and anything
         * in between generating a spherical interpolation between the two.
         * @returns {pc.Quat} Self for chaining.
         * @example
         * var q1 = new pc.Quat(-0.11, -0.15, -0.46, 0.87);
         * var q2 = new pc.Quat(-0.21, -0.21, -0.67, 0.68);
         *
         * var result;
         * result = new pc.Quat().slerp(q1, q2, 0);   // Return q1
         * result = new pc.Quat().slerp(q1, q2, 0.5); // Return the midpoint interpolant
         * result = new pc.Quat().slerp(q1, q2, 1);   // Return q2
         */
        slerp: function (lhs, rhs, alpha) {
            // Algorithm sourced from:
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var lx, ly, lz, lw, rx, ry, rz, rw;
            lx = lhs.x;
            ly = lhs.y;
            lz = lhs.z;
            lw = lhs.w;
            rx = rhs.x;
            ry = rhs.y;
            rz = rhs.z;
            rw = rhs.w;

            // Calculate angle between them.
            var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;

            if (cosHalfTheta < 0) {
                rw = -rw;
                rx = -rx;
                ry = -ry;
                rz = -rz;
                cosHalfTheta = -cosHalfTheta;
            }

            // If lhs == rhs or lhs == -rhs then theta == 0 and we can return lhs
            if (Math.abs(cosHalfTheta) >= 1) {
                this.w = lw;
                this.x = lx;
                this.y = ly;
                this.z = lz;
                return this;
            }

            // Calculate temporary values.
            var halfTheta = Math.acos(cosHalfTheta);
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);

            // If theta = 180 degrees then result is not fully defined
            // we could rotate around any axis normal to qa or qb
            if (Math.abs(sinHalfTheta) < 0.001) {
                this.w = (lw * 0.5 + rw * 0.5);
                this.x = (lx * 0.5 + rx * 0.5);
                this.y = (ly * 0.5 + ry * 0.5);
                this.z = (lz * 0.5 + rz * 0.5);
                return this;
            }

            var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
            var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;

            // Calculate Quaternion.
            this.w = (lw * ratioA + rw * ratioB);
            this.x = (lx * ratioA + rx * ratioB);
            this.y = (ly * ratioA + ry * ratioB);
            this.z = (lz * ratioA + rz * ratioB);
            return this;
        },

        /**
         * @function
         * @name pc.Quat#transformVector
         * @description Transforms a 3-dimensional vector by the specified quaternion.
         * @param {pc.Vec3} vec - The 3-dimensional vector to be transformed.
         * @param {pc.Vec3} [res] - An optional 3-dimensional vector to receive the result of the transformation.
         * @returns {pc.Vec3} The input vector v transformed by the current instance.
         * @example
         * // Create a 3-dimensional vector
         * var v = new pc.Vec3(1, 2, 3);
         *
         * // Create a 4x4 rotation matrix
         * var q = new pc.Quat().setFromEulerAngles(10, 20, 30);
         *
         * var tv = q.transformVector(v);
         */
        transformVector: function (vec, res) {
            if (res === undefined) {
                res = new Vec3();
            }

            var x = vec.x, y = vec.y, z = vec.z;
            var qx = this.x, qy = this.y, qz = this.z, qw = this.w;

            // calculate quat * vec
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return res;
        },

        /**
         * @function
         * @name pc.Quat#toString
         * @description Converts the quaternion to string form.
         * @returns {string} The quaternion in string form.
         * @example
         * var v = new pc.Quat(0, 0, 0, 1);
         * // Should output '[0, 0, 0, 1]'
         * console.log(v.toString());
         */
        toString: function () {
            return '[' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ']';
        }
    });

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Quat.IDENTITY
     * @type {pc.Quat}
     * @description A constant quaternion set to [0, 0, 0, 1] (the identity).
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Quat.ZERO
     * @type {pc.Quat}
     * @description A constant quaternion set to [0, 0, 0, 0].
     */

    Object.defineProperties(Quat, {
        ZERO: { value: new Quat(0, 0, 0, 0) },
        IDENTITY: { value: new Quat(0, 0, 0, 1) }
    });

    /**
     * @class
     * @name pc.Vec2
     * @classdesc A 2-dimensional vector.
     * @description Creates a new Vec2 object.
     * @param {number|number[]} [x] - The x value. If x is an array of length 2, the array will be used to populate all components.
     * @param {number} [y] - The y value.
     * @example
     * var v = new pc.Vec2(1, 2);
     */
    function Vec2(x, y) {
        if (x && x.length === 2) {
            this.x = x[0];
            this.y = x[1];
        } else {
            this.x = x || 0;
            this.y = y || 0;
        }
    }

    Object.assign(Vec2.prototype, {
        /**
         * @function
         * @name pc.Vec2#add
         * @description Adds a 2-dimensional vector to another in place.
         * @param {pc.Vec2} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(10, 10);
         * var b = new pc.Vec2(20, 20);
         *
         * a.add(b);
         *
         * // Should output [30, 30]
         * console.log("The result of the addition is: " + a.toString());
         */
        add: function (rhs) {
            this.x += rhs.x;
            this.y += rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#add2
         * @description Adds two 2-dimensional vectors together and returns the result.
         * @param {pc.Vec2} lhs - The first vector operand for the addition.
         * @param {pc.Vec2} rhs - The second vector operand for the addition.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(10, 10);
         * var b = new pc.Vec2(20, 20);
         * var r = new pc.Vec2();
         *
         * r.add2(a, b);
         * // Should output [30, 30]
         *
         * console.log("The result of the addition is: " + r.toString());
         */
        add2: function (lhs, rhs) {
            this.x = lhs.x + rhs.x;
            this.y = lhs.y + rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#clone
         * @description Returns an identical copy of the specified 2-dimensional vector.
         * @returns {pc.Vec2} A 2-dimensional vector containing the result of the cloning.
         * @example
         * var v = new pc.Vec2(10, 20);
         * var vclone = v.clone();
         * console.log("The result of the cloning is: " + vclone.toString());
         */
        clone: function () {
            return new Vec2().copy(this);
        },

        /**
         * @function
         * @name pc.Vec2#copy
         * @description Copied the contents of a source 2-dimensional vector to a destination 2-dimensional vector.
         * @param {pc.Vec2} rhs - A vector to copy to the specified vector.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var src = new pc.Vec2(10, 20);
         * var dst = new pc.Vec2();
         *
         * dst.copy(src);
         *
         * console.log("The two vectors are " + (dst.equals(src) ? "equal" : "different"));
         */
        copy: function (rhs) {
            this.x = rhs.x;
            this.y = rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#distance
         * @description Returns the distance between the two specified 2-dimensional vectors.
         * @param {pc.Vec2} rhs - The second 2-dimensional vector to test.
         * @returns {number} The distance between the two vectors.
         * @example
         * var v1 = new pc.Vec2(5, 10);
         * var v2 = new pc.Vec2(10, 20);
         * var d = v1.distance(v2);
         * console.log("The between v1 and v2 is: " + d);
         */
        distance: function (rhs) {
            var x = this.x - rhs.x;
            var y = this.y - rhs.y;
            return Math.sqrt(x * x + y * y);
        },

        /**
         * @function
         * @name pc.Vec2#dot
         * @description Returns the result of a dot product operation performed on the two specified 2-dimensional vectors.
         * @param {pc.Vec2} rhs - The second 2-dimensional vector operand of the dot product.
         * @returns {number} The result of the dot product operation.
         * @example
         * var v1 = new pc.Vec2(5, 10);
         * var v2 = new pc.Vec2(10, 20);
         * var v1dotv2 = v1.dot(v2);
         * console.log("The result of the dot product is: " + v1dotv2);
         */
        dot: function (rhs) {
            return this.x * rhs.x + this.y * rhs.y;
        },

        /**
         * @function
         * @name pc.Vec2#equals
         * @description Reports whether two vectors are equal.
         * @param {pc.Vec2} rhs - The vector to compare to the specified vector.
         * @returns {boolean} True if the vectors are equal and false otherwise.
         * @example
         * var a = new pc.Vec2(1, 2);
         * var b = new pc.Vec2(4, 5);
         * console.log("The two vectors are " + (a.equals(b) ? "equal" : "different"));
         */
        equals: function (rhs) {
            return this.x === rhs.x && this.y === rhs.y;
        },

        /**
         * @function
         * @name pc.Vec2#length
         * @description Returns the magnitude of the specified 2-dimensional vector.
         * @returns {number} The magnitude of the specified 2-dimensional vector.
         * @example
         * var vec = new pc.Vec2(3, 4);
         * var len = vec.length();
         * // Should output 5
         * console.log("The length of the vector is: " + len);
         */
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        /**
         * @function
         * @name pc.Vec2#lengthSq
         * @description Returns the magnitude squared of the specified 2-dimensional vector.
         * @returns {number} The magnitude of the specified 2-dimensional vector.
         * @example
         * var vec = new pc.Vec2(3, 4);
         * var len = vec.lengthSq();
         * // Should output 25
         * console.log("The length squared of the vector is: " + len);
         */
        lengthSq: function () {
            return this.x * this.x + this.y * this.y;
        },

        /**
         * @function
         * @name pc.Vec2#lerp
         * @description Returns the result of a linear interpolation between two specified 2-dimensional vectors.
         * @param {pc.Vec2} lhs - The 2-dimensional to interpolate from.
         * @param {pc.Vec2} rhs - The 2-dimensional to interpolate to.
         * @param {number} alpha - The value controlling the point of interpolation. Between 0 and 1, the linear interpolant
         * will occur on a straight line between lhs and rhs. Outside of this range, the linear interpolant will occur on
         * a ray extrapolated from this line.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(0, 0);
         * var b = new pc.Vec2(10, 10);
         * var r = new pc.Vec2();
         *
         * r.lerp(a, b, 0);   // r is equal to a
         * r.lerp(a, b, 0.5); // r is 5, 5
         * r.lerp(a, b, 1);   // r is equal to b
         */
        lerp: function (lhs, rhs, alpha) {
            this.x = lhs.x + alpha * (rhs.x - lhs.x);
            this.y = lhs.y + alpha * (rhs.y - lhs.y);

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#mul
         * @description Multiplies a 2-dimensional vector to another in place.
         * @param {pc.Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(2, 3);
         * var b = new pc.Vec2(4, 5);
         *
         * a.mul(b);
         *
         * // Should output 8, 15
         * console.log("The result of the multiplication is: " + a.toString());
         */
        mul: function (rhs) {
            this.x *= rhs.x;
            this.y *= rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#mul2
         * @description Returns the result of multiplying the specified 2-dimensional vectors together.
         * @param {pc.Vec2} lhs - The 2-dimensional vector used as the first multiplicand of the operation.
         * @param {pc.Vec2} rhs - The 2-dimensional vector used as the second multiplicand of the operation.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(2, 3);
         * var b = new pc.Vec2(4, 5);
         * var r = new pc.Vec2();
         *
         * r.mul2(a, b);
         *
         * // Should output 8, 15
         * console.log("The result of the multiplication is: " + r.toString());
         */
        mul2: function (lhs, rhs) {
            this.x = lhs.x * rhs.x;
            this.y = lhs.y * rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#normalize
         * @description Returns this 2-dimensional vector converted to a unit vector in place.
         * If the vector has a length of zero, the vector's elements will be set to zero.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var v = new pc.Vec2(25, 0);
         *
         * v.normalize();
         *
         * // Should output 1, 0
         * console.log("The result of the vector normalization is: " + v.toString());
         */
        normalize: function () {
            var lengthSq = this.x * this.x + this.y * this.y;
            if (lengthSq > 0) {
                var invLength = 1 / Math.sqrt(lengthSq);
                this.x *= invLength;
                this.y *= invLength;
            }

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#scale
         * @description Scales each component of the specified 2-dimensional vector by the supplied
         * scalar value.
         * @param {number} scalar - The value by which each vector component is multiplied.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var v = new pc.Vec2(2, 4);
         *
         * // Multiply by 2
         * v.scale(2);
         *
         * // Negate
         * v.scale(-1);
         *
         * // Divide by 2
         * v.scale(0.5);
         */
        scale: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#set
         * @description Sets the specified 2-dimensional vector to the supplied numerical values.
         * @param {number} x - The value to set on the first component of the vector.
         * @param {number} y - The value to set on the second component of the vector.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var v = new pc.Vec2();
         * v.set(5, 10);
         *
         * // Should output 5, 10
         * console.log("The result of the vector set is: " + v.toString());
         */
        set: function (x, y) {
            this.x = x;
            this.y = y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#sub
         * @description Subtracts a 2-dimensional vector from another in place.
         * @param {pc.Vec2} rhs - The vector to add to the specified vector.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(10, 10);
         * var b = new pc.Vec2(20, 20);
         *
         * a.sub(b);
         *
         * // Should output [-10, -10]
         * console.log("The result of the addition is: " + a.toString());
         */
        sub: function (rhs) {
            this.x -= rhs.x;
            this.y -= rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#sub2
         * @description Subtracts two 2-dimensional vectors from one another and returns the result.
         * @param {pc.Vec2} lhs - The first vector operand for the addition.
         * @param {pc.Vec2} rhs - The second vector operand for the addition.
         * @returns {pc.Vec2} Self for chaining.
         * @example
         * var a = new pc.Vec2(10, 10);
         * var b = new pc.Vec2(20, 20);
         * var r = new pc.Vec2();
         *
         * r.sub2(a, b);
         *
         * // Should output [-10, -10]
         * console.log("The result of the addition is: " + r.toString());
         */
        sub2: function (lhs, rhs) {
            this.x = lhs.x - rhs.x;
            this.y = lhs.y - rhs.y;

            return this;
        },

        /**
         * @function
         * @name pc.Vec2#toString
         * @description Converts the vector to string form.
         * @returns {string} The vector in string form.
         * @example
         * var v = new pc.Vec2(20, 10);
         * // Should output '[20, 10]'
         * console.log(v.toString());
         */
        toString: function () {
            return '[' + this.x + ', ' + this.y + ']';
        }
    });

    /**
     * @field
     * @name pc.Vec2#x
     * @type {number}
     * @description The first element of the vector.
     * @example
     * var vec = new pc.Vec2(10, 20);
     *
     * // Get x
     * var x = vec.x;
     *
     * // Set x
     * vec.x = 0;
     */
    /**
     * @field
     * @name pc.Vec2#y
     * @type {number}
     * @description The second element of the vector.
     * @example
     * var vec = new pc.Vec2(10, 20);
     *
     * // Get y
     * var y = vec.y;
     *
     * // Set y
     * vec.y = 0;
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec2.ONE
     * @type {pc.Vec2}
     * @description A constant vector set to [1, 1].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec2.RIGHT
     * @type {pc.Vec2}
     * @description A constant vector set to [1, 0].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec2.LEFT
     * @type {pc.Vec2}
     * @description A constant vector set to [-1, 0].
     */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec2.UP
     * @type {pc.Vec2}
     * @description A constant vector set to [0, 1].
     */

     /**
      * @field
      * @static
      * @readonly
      * @name pc.Vec2.DOWN
      * @type {pc.Vec2}
      * @description A constant vector set to [0, -1].
      */

    /**
     * @field
     * @static
     * @readonly
     * @name pc.Vec2.ZERO
     * @type {pc.Vec2}
     * @description A constant vector set to [0, 0].
     */

    Object.defineProperties(Vec2, {
        ZERO: { value: new Vec2(0, 0) },
        ONE: { value: new Vec2(1, 1) },
        UP: { value: new Vec2(0, 1) },
        DOWN: { value: new Vec2(0, -1) },
        RIGHT: { value: new Vec2(1, 0) },
        LEFT: { value: new Vec2(-1, 0) }
    });

    var tmpVecA = new Vec3();
    var tmpVecB = new Vec3();
    var tmpVecC = new Vec3();
    var tmpVecD = new Vec3();
    var tmpVecE = new Vec3();

    /**
     * @class
     * @name pc.BoundingBox
     * @description Create a new axis-aligned bounding box.
     * @classdesc Axis-Aligned Bounding Box.
     * @param {pc.Vec3} [center] - Center of box. The constructor takes a reference of this parameter.
     * @param {pc.Vec3} [halfExtents] - Half the distance across the box in each axis. The constructor takes a reference of this parameter.
     * @property {pc.Vec3} center Center of box.
     * @property {pc.Vec3} halfExtents Half the distance across the box in each axis.
     */
    function BoundingBox(center, halfExtents) {
        this.center = center || new Vec3(0, 0, 0);
        this.halfExtents = halfExtents || new Vec3(0.5, 0.5, 0.5);
        this._min = new Vec3();
        this._max = new Vec3();
    }

    Object.assign(BoundingBox.prototype, {

        /**
         * @function
         * @name pc.BoundingBox#add
         * @description Combines two bounding boxes into one, enclosing both.
         * @param {pc.BoundingBox} other - Bounding box to add.
         */
        add: function (other) {
            var tc = this.center;
            var tcx = tc.x;
            var tcy = tc.y;
            var tcz = tc.z;
            var th = this.halfExtents;
            var thx = th.x;
            var thy = th.y;
            var thz = th.z;
            var tminx = tcx - thx;
            var tmaxx = tcx + thx;
            var tminy = tcy - thy;
            var tmaxy = tcy + thy;
            var tminz = tcz - thz;
            var tmaxz = tcz + thz;

            var oc = other.center;
            var ocx = oc.x;
            var ocy = oc.y;
            var ocz = oc.z;
            var oh = other.halfExtents;
            var ohx = oh.x;
            var ohy = oh.y;
            var ohz = oh.z;
            var ominx = ocx - ohx;
            var omaxx = ocx + ohx;
            var ominy = ocy - ohy;
            var omaxy = ocy + ohy;
            var ominz = ocz - ohz;
            var omaxz = ocz + ohz;

            if (ominx < tminx) tminx = ominx;
            if (omaxx > tmaxx) tmaxx = omaxx;
            if (ominy < tminy) tminy = ominy;
            if (omaxy > tmaxy) tmaxy = omaxy;
            if (ominz < tminz) tminz = ominz;
            if (omaxz > tmaxz) tmaxz = omaxz;

            tc.x = (tminx + tmaxx) * 0.5;
            tc.y = (tminy + tmaxy) * 0.5;
            tc.z = (tminz + tmaxz) * 0.5;
            th.x = (tmaxx - tminx) * 0.5;
            th.y = (tmaxy - tminy) * 0.5;
            th.z = (tmaxz - tminz) * 0.5;
        },

        /**
         * @function
         * @name pc.BoundingBox#copy
         * @description Copies the contents of a source AABB.
         * @param {pc.BoundingBox} src - The AABB to copy from.
         */
        copy: function (src) {
            this.center.copy(src.center);
            this.halfExtents.copy(src.halfExtents);
            this.type = src.type;
        },

        /**
         * @function
         * @name pc.BoundingBox#clone
         * @description Returns a clone of the AABB
         * @returns {pc.BoundingBox} A duplicate AABB.
         */
        clone: function () {
            return new BoundingBox(this.center.clone(), this.halfExtents.clone());
        },

        /**
         * @function
         * @name pc.BoundingBox#intersects
         * @description Test whether two axis-aligned bounding boxes intersect.
         * @param {pc.BoundingBox} other - Bounding box to test against.
         * @returns {boolean} True if there is an intersection.
         */
        intersects: function (other) {
            var aMax = this.getMax();
            var aMin = this.getMin();
            var bMax = other.getMax();
            var bMin = other.getMin();

            return (aMin.x <= bMax.x) && (aMax.x >= bMin.x) &&
                   (aMin.y <= bMax.y) && (aMax.y >= bMin.y) &&
                   (aMin.z <= bMax.z) && (aMax.z >= bMin.z);
        },

        _intersectsRay: function (ray, point) {
            var tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);
            var tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);
            var dir = ray.direction;

            // Ensure that we are not dividing it by zero
            if (dir.x === 0) {
                tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
                tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            } else {
                tMin.x /= dir.x;
                tMax.x /= dir.x;
            }
            if (dir.y === 0) {
                tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
                tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            } else {
                tMin.y /= dir.y;
                tMax.y /= dir.y;
            }
            if (dir.z === 0) {
                tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
                tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            } else {
                tMin.z /= dir.z;
                tMax.z /= dir.z;
            }

            var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
            var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));

            var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
            var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);

            var intersects = minMax >= maxMin && maxMin >= 0;

            if (intersects)
                point.copy(ray.direction).scale(maxMin).add(ray.origin);

            return intersects;
        },

        _fastIntersectsRay: function (ray) {
            var diff = tmpVecA;
            var cross = tmpVecB;
            var prod = tmpVecC;
            var absDiff = tmpVecD;
            var absDir = tmpVecE;
            var rayDir = ray.direction;

            diff.sub2(ray.origin, this.center);
            absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));

            prod.mul2(diff, rayDir);

            if (absDiff.x > this.halfExtents.x && prod.x >= 0)
                return false;

            if (absDiff.y > this.halfExtents.y && prod.y >= 0)
                return false;

            if (absDiff.z > this.halfExtents.z && prod.z >= 0)
                return false;

            absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
            cross.cross(rayDir, diff);
            cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));

            if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y)
                return false;

            if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x)
                return false;

            if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x)
                return false;

            return true;
        },

        /**
         * @function
         * @name pc.BoundingBox#intersectsRay
         * @description Test if a ray intersects with the AABB.
         * @param {pc.Ray} ray - Ray to test against (direction must be normalized).
         * @param {pc.Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
         * @returns {boolean} True if there is an intersection.
         */
        intersectsRay: function (ray, point) {
            if (point) {
                return this._intersectsRay(ray, point);
            }

            return this._fastIntersectsRay(ray);
        },

        /**
         * @function
         * @name pc.BoundingBox#setMinMax
         * @description Sets the minimum and maximum corner of the AABB.
         * Using this function is faster than assigning min and max separately.
         * @param {pc.Vec3} min - The minimum corner of the AABB.
         * @param {pc.Vec3} max - The maximum corner of the AABB.
         */
        setMinMax: function (min, max) {
            this.center.add2(max, min).scale(0.5);
            this.halfExtents.sub2(max, min).scale(0.5);
        },

        /**
         * @function
         * @name pc.BoundingBox#getMin
         * @description Return the minimum corner of the AABB.
         * @returns {pc.Vec3} Minimum corner.
         */
        getMin: function () {
            return this._min.copy(this.center).sub(this.halfExtents);
        },

        /**
         * @function
         * @name pc.BoundingBox#getMax
         * @description Return the maximum corner of the AABB.
         * @returns {pc.Vec3} Maximum corner.
         */
        getMax: function () {
            return this._max.copy(this.center).add(this.halfExtents);
        },

        /**
         * @function
         * @name pc.BoundingBox#containsPoint
         * @description Test if a point is inside a AABB.
         * @param {pc.Vec3} point - Point to test.
         * @returns {boolean} True if the point is inside the AABB and false otherwise.
         */
        containsPoint: function (point) {
            var min = this.getMin();
            var max = this.getMax();

            if (point.x < min.x || point.x > max.x ||
                point.y < min.y || point.y > max.y ||
                point.z < min.z || point.z > max.z) {
                return false;
            }

            return true;
        },

        /**
         * @function
         * @name pc.BoundingBox#setFromTransformedAabb
         * @description Set an AABB to enclose the specified AABB if it were to be
         * transformed by the specified 4x4 matrix.
         * @param {pc.BoundingBox} aabb - Box to transform and enclose.
         * @param {pc.Mat4} m - Transformation matrix to apply to source AABB.
         */
        setFromTransformedAabb: function (aabb, m) {
            var bc = this.center;
            var br = this.halfExtents;
            var ac = aabb.center;
            var ar = aabb.halfExtents;

            m = m.data;
            var mx0 = m[0];
            var mx1 = m[4];
            var mx2 = m[8];
            var my0 = m[1];
            var my1 = m[5];
            var my2 = m[9];
            var mz0 = m[2];
            var mz1 = m[6];
            var mz2 = m[10];

            var mx0a = Math.abs(mx0);
            var mx1a = Math.abs(mx1);
            var mx2a = Math.abs(mx2);
            var my0a = Math.abs(my0);
            var my1a = Math.abs(my1);
            var my2a = Math.abs(my2);
            var mz0a = Math.abs(mz0);
            var mz1a = Math.abs(mz1);
            var mz2a = Math.abs(mz2);

            bc.set(
                m[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z,
                m[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z,
                m[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z
            );

            br.set(
                mx0a * ar.x + mx1a * ar.y + mx2a * ar.z,
                my0a * ar.x + my1a * ar.y + my2a * ar.z,
                mz0a * ar.x + mz1a * ar.y + mz2a * ar.z
            );
        },

        /**
         * @function
         * @name pc.BoundingBox#compute
         * @description Compute the size of the AABB to encapsulate all specified vertices.
         * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the AABB.
         * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array. All vertices are used if not specified.
         */
        compute: function (vertices, numVerts) {
            numVerts = numVerts === undefined ? vertices.length / 3 : numVerts;
            if (numVerts > 0) {
                var min = tmpVecA.set(vertices[0], vertices[1], vertices[2]);
                var max = tmpVecB.set(vertices[0], vertices[1], vertices[2]);

                for (var i = 1; i < numVerts; i++) {
                    var x = vertices[i * 3 + 0];
                    var y = vertices[i * 3 + 1];
                    var z = vertices[i * 3 + 2];
                    if (x < min.x) min.x = x;
                    if (y < min.y) min.y = y;
                    if (z < min.z) min.z = z;
                    if (x > max.x) max.x = x;
                    if (y > max.y) max.y = y;
                    if (z > max.z) max.z = z;
                }

                this.setMinMax(min, max);
            }
        },

        /**
         * @function
         * @name pc.BoundingBox#intersectsBoundingSphere
         * @description Test if a Bounding Sphere is overlapping, enveloping, or inside this AABB.
         * @param {pc.BoundingSphere} sphere - Bounding Sphere to test.
         * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside the AABB and false otherwise.
         */
        intersectsBoundingSphere: function (sphere) {
            var sq = this._distanceToBoundingSphereSq(sphere);
            if (sq <= sphere.radius * sphere.radius) {
                return true;
            }

            return false;
        },

        _distanceToBoundingSphereSq: function (sphere) {
            var boxMin = this.getMin();
            var boxMax = this.getMax();

            var sq = 0;
            var axis = ['x', 'y', 'z'];

            for (var i = 0; i < 3; ++i) {
                var out = 0;
                var pn = sphere.center[axis[i]];
                var bMin = boxMin[axis[i]];
                var bMax = boxMax[axis[i]];
                var val = 0;

                if (pn < bMin) {
                    val = (bMin - pn);
                    out += val * val;
                }

                if (pn > bMax) {
                    val = (pn - bMax);
                    out += val * val;
                }

                sq += out;
            }

            return sq;
        },

        _expand: function (expandMin, expandMax) {
            tmpVecA.add2(this.getMin(), expandMin);
            tmpVecB.add2(this.getMax(), expandMax);
            this.setMinMax(tmpVecA, tmpVecB);
        }
    });

    var tmpVecA$1 = new Vec3();
    var tmpVecB$1 = new Vec3();
    var tmpVecC$1 = new Vec3();
    var tmpVecD$1 = new Vec3();

    /**
     * @class
     * @name pc.BoundingSphere
     * @classdesc A bounding sphere is a volume for facilitating fast intersection testing.
     * @description Creates a new bounding sphere.
     * @example
     * // Create a new bounding sphere centered on the origin with a radius of 0.5
     * var sphere = new pc.BoundingSphere();
     * @param {pc.Vec3} [center] - The world space coordinate marking the center of the sphere. The constructor takes a reference of this parameter.
     * @param {number} [radius] - The radius of the bounding sphere. Defaults to 0.5.
     */
    function BoundingSphere(center, radius) {
        this.center = center || new Vec3(0, 0, 0);
        this.radius = radius === undefined ? 0.5 : radius;
    }

    Object.assign(BoundingSphere.prototype, {
        containsPoint: function (point) {
            var lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();
            var r = this.radius;
            return lenSq < r * r;
        },

        compute: function (vertices) {
            var i;
            var numVerts = vertices.length / 3;

            var vertex = tmpVecA$1;
            var avgVertex = tmpVecB$1;
            var sum = tmpVecC$1;

            // FIRST PASS:
            // Find the "average vertex", which is the sphere's center...

            for (i = 0; i < numVerts; i++) {
                vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
                sum.addSelf(vertex);

                // apply a part-result to avoid float-overflows
                if (i % 100 === 0) {
                    sum.scale(1 / numVerts);
                    avgVertex.add(sum);
                    sum.set(0, 0, 0);
                }
            }

            sum.scale(1 / numVerts);
            avgVertex.add(sum);

            this.center.copy(avgVertex);

            // SECOND PASS:
            // Find the maximum (squared) distance of all vertices to the center...
            var maxDistSq = 0;
            var centerToVert = tmpVecD$1;

            for (i = 0; i < numVerts; i++) {
                vertex.set(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);

                centerToVert.sub2(vertex, this.center);
                maxDistSq = Math.max(centerToVert.lengthSq(), maxDistSq);
            }

            this.radius = Math.sqrt(maxDistSq);
        },

        /**
         * @function
         * @name pc.BoundingSphere#intersectsRay
         * @description Test if a ray intersects with the sphere.
         * @param {pc.Ray} ray - Ray to test against (direction must be normalized).
         * @param {pc.Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
         * @returns {boolean} True if there is an intersection.
         */
        intersectsRay: function (ray, point) {
            var m = tmpVecA$1.copy(ray.origin).sub(this.center);
            var b = m.dot(tmpVecB$1.copy(ray.direction).normalize());
            var c = m.dot(m) - this.radius * this.radius;

            // exit if ray's origin outside of sphere (c > 0) and ray pointing away from s (b > 0)
            if (c > 0 && b > 0)
                return null;

            var discr = b * b - c;
            // a negative discriminant corresponds to ray missing sphere
            if (discr < 0)
                return false;

            // ray intersects sphere, compute smallest t value of intersection
            var t = Math.abs(-b - Math.sqrt(discr));

            // if t is negative, ray started inside sphere so clamp t to zero
            if (point)
                point.copy(ray.direction).scale(t).add(ray.origin);

            return true;
        },

        /**
         * @function
         * @name pc.BoundingSphere#intersectsBoundingSphere
         * @description Test if a Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere.
         * @param {pc.BoundingSphere} sphere - Bounding Sphere to test.
         * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere and false otherwise.
         */
        intersectsBoundingSphere: function (sphere) {
            tmpVecA$1.sub2(sphere.center, this.center);
            var totalRadius = sphere.radius + this.radius;
            if (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {
                return true;
            }

            return false;
        }
    });

    var viewProj = new Mat4();

    /**
     * @class
     * @name pc.Frustum
     * @classdesc A frustum is a shape that defines the viewing space of a camera.
     * @description Creates a new frustum shape.
     * @example
     * // Create a new frustum equivalent to one held by a camera component
     * var projectionMatrix = entity.camera.projectionMatrix;
     * var viewMatrix = entity.camera.viewMatrix;
     * var frustum = new pc.Frustum(projectionMatrix, viewMatrix);
     * @param {pc.Mat4} projectionMatrix - The projection matrix describing the shape of the frustum.
     * @param {pc.Mat4} viewMatrix - The inverse of the world transformation matrix for the frustum.
     */
    function Frustum(projectionMatrix, viewMatrix) {
        projectionMatrix = projectionMatrix || new Mat4().setPerspective(90, 16 / 9, 0.1, 1000);
        viewMatrix = viewMatrix || new Mat4();

        this.planes = [];
        for (var i = 0; i < 6; i++)
            this.planes[i] = [];

        this.update(projectionMatrix, viewMatrix);
    }

    Object.assign(Frustum.prototype, {
        /**
         * @function
         * @name pc.Frustum#update
         * @description Updates the frustum shape based on a view matrix and a projection matrix.
         * @param {pc.Mat4} projectionMatrix - The projection matrix describing the shape of the frustum.
         * @param {pc.Mat4} viewMatrix - The inverse of the world transformation matrix for the frustum.
         */
        update: function (projectionMatrix, viewMatrix) {
            viewProj.mul2(projectionMatrix, viewMatrix);
            var vpm = viewProj.data;

            // Extract the numbers for the RIGHT plane
            this.planes[0][0] = vpm[3] - vpm[0];
            this.planes[0][1] = vpm[7] - vpm[4];
            this.planes[0][2] = vpm[11] - vpm[8];
            this.planes[0][3] = vpm[15] - vpm[12];
            // Normalize the result
            var t = Math.sqrt(this.planes[0][0] * this.planes[0][0] + this.planes[0][1] * this.planes[0][1] + this.planes[0][2] * this.planes[0][2]);
            this.planes[0][0] /= t;
            this.planes[0][1] /= t;
            this.planes[0][2] /= t;
            this.planes[0][3] /= t;

            // Extract the numbers for the LEFT plane
            this.planes[1][0] = vpm[3] + vpm[0];
            this.planes[1][1] = vpm[7] + vpm[4];
            this.planes[1][2] = vpm[11] + vpm[8];
            this.planes[1][3] = vpm[15] + vpm[12];
            // Normalize the result
            t = Math.sqrt(this.planes[1][0] * this.planes[1][0] + this.planes[1][1] * this.planes[1][1] + this.planes[1][2] * this.planes[1][2]);
            this.planes[1][0] /= t;
            this.planes[1][1] /= t;
            this.planes[1][2] /= t;
            this.planes[1][3] /= t;

            // Extract the BOTTOM plane
            this.planes[2][0] = vpm[3] + vpm[1];
            this.planes[2][1] = vpm[7] + vpm[5];
            this.planes[2][2] = vpm[11] + vpm[9];
            this.planes[2][3] = vpm[15] + vpm[13];
            // Normalize the result
            t = Math.sqrt(this.planes[2][0] * this.planes[2][0] + this.planes[2][1] * this.planes[2][1] + this.planes[2][2] * this.planes[2][2] );
            this.planes[2][0] /= t;
            this.planes[2][1] /= t;
            this.planes[2][2] /= t;
            this.planes[2][3] /= t;

            // Extract the TOP plane
            this.planes[3][0] = vpm[3] - vpm[1];
            this.planes[3][1] = vpm[7] - vpm[5];
            this.planes[3][2] = vpm[11] - vpm[9];
            this.planes[3][3] = vpm[15] - vpm[13];
            // Normalize the result
            t = Math.sqrt(this.planes[3][0] * this.planes[3][0] + this.planes[3][1] * this.planes[3][1] + this.planes[3][2] * this.planes[3][2]);
            this.planes[3][0] /= t;
            this.planes[3][1] /= t;
            this.planes[3][2] /= t;
            this.planes[3][3] /= t;

            // Extract the FAR plane
            this.planes[4][0] = vpm[3] - vpm[2];
            this.planes[4][1] = vpm[7] - vpm[6];
            this.planes[4][2] = vpm[11] - vpm[10];
            this.planes[4][3] = vpm[15] - vpm[14];
            // Normalize the result
            t = Math.sqrt(this.planes[4][0] * this.planes[4][0] + this.planes[4][1] * this.planes[4][1] + this.planes[4][2] * this.planes[4][2]);
            this.planes[4][0] /= t;
            this.planes[4][1] /= t;
            this.planes[4][2] /= t;
            this.planes[4][3] /= t;

            // Extract the NEAR plane
            this.planes[5][0] = vpm[3] + vpm[2];
            this.planes[5][1] = vpm[7] + vpm[6];
            this.planes[5][2] = vpm[11] + vpm[10];
            this.planes[5][3] = vpm[15] + vpm[14];
            // Normalize the result
            t = Math.sqrt(this.planes[5][0] * this.planes[5][0] + this.planes[5][1] * this.planes[5][1] + this.planes[5][2] * this.planes[5][2]);
            this.planes[5][0] /= t;
            this.planes[5][1] /= t;
            this.planes[5][2] /= t;
            this.planes[5][3] /= t;
        },

        /**
         * @function
         * @name pc.Frustum#containsPoint
         * @description Tests whether a point is inside the frustum. Note that points lying in a frustum plane are
         * considered to be outside the frustum.
         * @param {pc.Vec3} point - The point to test.
         * @returns {boolean} True if the point is inside the frustum, false otherwise.
         */
        containsPoint: function (point) {
            for (var p = 0; p < 6; p++)
                if (this.planes[p][0] * point.x +
                    this.planes[p][1] * point.y +
                    this.planes[p][2] * point.z +
                    this.planes[p][3] <= 0)
                    return false;
            return true;
        },

        /**
         * @function
         * @name pc.Frustum#containsSphere
         * @description Tests whether a bounding sphere intersects the frustum. If the sphere is outside the frustum,
         * zero is returned. If the sphere intersects the frustum, 1 is returned. If the sphere is completely inside
         * the frustum, 2 is returned. Note that a sphere touching a frustum plane from the outside is considered to
         * be outside the frustum.
         * @param {pc.BoundingSphere} sphere - The sphere to test.
         * @returns {number} 0 if the bounding sphere is outside the frustum, 1 if it intersects the frustum and 2 if
         * it is contained by the frustum.
         */
        containsSphere: function (sphere) {
            var c = 0;
            var d;
            var p;

            var sr = sphere.radius;
            var sc = sphere.center;
            var scx = sc.x;
            var scy = sc.y;
            var scz = sc.z;
            var planes = this.planes;
            var plane;

            for (p = 0; p < 6; p++) {
                plane = planes[p];
                d = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];
                if (d <= -sr)
                    return 0;
                if (d > sr)
                    c++;
            }

            return (c === 6) ? 2 : 1;
        }
    });

    /**
     * @class
     * @name pc.Ray
     * @classdesc An infinite ray.
     * @description Creates a new infinite ray starting at a given origin and pointing in a given direction.
     * @example
     * // Create a new ray starting at the position of this entity and pointing down
     * // the entity's negative Z axis
     * var ray = new pc.Ray(this.entity.getPosition(), this.entity.forward);
     * @param {pc.Vec3} [origin] - The starting point of the ray. The constructor takes a reference of this parameter.
     * Defaults to the origin (0, 0, 0).
     * @param {pc.Vec3} [direction] - The direction of the ray. The constructor takes a reference of this parameter.
     * Defaults to a direction down the world negative Z axis (0, 0, -1).
     * @property {pc.Vec3} origin The starting point of the ray.
     * @property {pc.Vec3} direction The direction of the ray.
     */
    function Ray(origin, direction) {
        this.origin = origin || new Vec3(0, 0, 0);
        this.direction = direction || new Vec3(0, 0, -1);
    }

    /**
     * @function
     * @name pc.Ray#set
     * @description Sets origin and direction to the supplied vector values.
     * @param {pc.Vec3} origin - The starting point of the ray.
     * @param {pc.Vec3} direction - The direction of the ray.
     * @returns {pc.Ray} Self for chaining.
     */
    Ray.prototype.set = function (origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    };

    var tmpRay = new Ray();
    var tmpVec3 = new Vec3();
    var tmpSphere = new BoundingSphere();
    var tmpMat4 = new Mat4();

    /**
     * @class
     * @name pc.OrientedBox
     * @description Create a new oriented box.
     * @classdesc Oriented Box.
     * @property {pc.Mat4} [worldTransform] The world transform of the OBB.
     * @param {pc.Mat4} [worldTransform] - Transform that has the orientation and position of the box. Scale is assumed to be one.
     * @param {pc.Vec3} [halfExtents] - Half the distance across the box in each local axis. The constructor takes a reference of this parameter.
     */
    function OrientedBox(worldTransform, halfExtents) {
        this.halfExtents = halfExtents || new Vec3(0.5, 0.5, 0.5);

        worldTransform = worldTransform || tmpMat4.setIdentity();
        this._modelTransform = worldTransform.clone().invert();

        this._worldTransform = worldTransform.clone(); // temp - currently only used in the worldTransform accessor, see future PR for more use
        this._aabb = new BoundingBox(new Vec3(), this.halfExtents);
    }

    Object.assign(OrientedBox.prototype, {
        /**
         * @function
         * @name pc.OrientedBox#intersectsRay
         * @description Test if a ray intersects with the OBB.
         * @param {pc.Ray} ray - Ray to test against (direction must be normalized).
         * @param {pc.Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
         * @returns {boolean} True if there is an intersection.
         */
        intersectsRay: function (ray, point) {
            this._modelTransform.transformPoint(ray.origin, tmpRay.origin);
            this._modelTransform.transformVector(ray.direction, tmpRay.direction);

            if (point) {
                var result = this._aabb._intersectsRay(tmpRay, point);
                tmpMat4.copy(this._modelTransform).invert().transformPoint(point, point);
                return result;
            }

            return this._aabb._fastIntersectsRay(tmpRay);
        },

        /**
         * @function
         * @name pc.OrientedBox#containsPoint
         * @description Test if a point is inside a OBB.
         * @param {pc.Vec3} point - Point to test.
         * @returns {boolean} True if the point is inside the OBB and false otherwise.
         */
        containsPoint: function (point) {
            this._modelTransform.transformPoint(point, tmpVec3);
            return this._aabb.containsPoint(tmpVec3);
        },

        /**
         * @function
         * @name pc.OrientedBox#intersectsBoundingSphere
         * @description Test if a Bounding Sphere is overlapping, enveloping, or inside this OBB.
         * @param {pc.BoundingSphere} sphere - Bounding Sphere to test.
         * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping or inside this OBB and false otherwise.
         */
        intersectsBoundingSphere: function (sphere) {
            this._modelTransform.transformPoint(sphere.center, tmpSphere.center);
            tmpSphere.radius = sphere.radius;

            if (this._aabb.intersectsBoundingSphere(tmpSphere)) {
                return true;
            }

            return false;
        }
    });

    Object.defineProperty(OrientedBox.prototype, 'worldTransform', {
        get: function () {
            return this._worldTransform;
        },
        set: function (value) {
            this._worldTransform.copy(value);
            this._modelTransform.copy(value).invert();
        }
    });

    var tmpVecA$2 = new Vec3();

    /**
     * @private
     * @class
     * @name pc.Plane
     * @classdesc An infinite plane.
     * @description Create an infinite plane.
     * @param {pc.Vec3} [point] - Point position on the plane. The constructor takes a reference of this parameter.
     * @param {pc.Vec3} [normal] - Normal of the plane. The constructor takes a reference of this parameter.
     */
    function Plane(point, normal) {
        this.normal = normal || new Vec3(0, 0, 1);
        this.point = point || new Vec3(0, 0, 0);
    }

    Object.assign(Plane.prototype, {
        /**
         * @private
         * @function
         * @name pc.Plane#intersectsLine
         * @description Test if the plane intersects between two points.
         * @param {pc.Vec3} start - Start position of line.
         * @param {pc.Vec3} end - End position of line.
         * @param {pc.Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
         * @returns {boolean} True if there is an intersection.
         */
        intersectsLine: function (start, end, point) {
            var d = -this.normal.dot(this.point);
            var d0 = this.normal.dot(start) + d;
            var d1 = this.normal.dot(end) + d;

            var t = d0 / (d0 - d1);
            var intersects = t >= 0 && t <= 1;
            if (intersects && point)
                point.lerp(start, end, t);

            return intersects;
        },

        /**
         * @private
         * @function
         * @name pc.Plane#intersectsRay
         * @description Test if a ray intersects with the infinite plane.
         * @param {pc.Ray} ray - Ray to test against (direction must be normalized).
         * @param {pc.Vec3} [point] - If there is an intersection, the intersection point will be copied into here.
         * @returns {boolean} True if there is an intersection.
         */
        intersectsRay: function (ray, point) {
            var pointToOrigin = tmpVecA$2.sub2(this.point, ray.origin);
            var t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);
            var intersects = t >= 0;

            if (intersects && point)
                point.copy(ray.direction).scale(t).add(ray.origin);

            return intersects;
        }
    });

    /**
     * @constant
     * @name pc.ADDRESS_REPEAT
     * @type {number}
     * @description Ignores the integer part of texture coordinates; using only the fractional part.
     */
    var ADDRESS_REPEAT = 0;
    /**
     * @constant
     * @name pc.ADDRESS_CLAMP_TO_EDGE
     * @type {number}
     * @description Clamps texture coordinate to the range 0 to 1.
     */
    var ADDRESS_CLAMP_TO_EDGE = 1;
    /**
     * @constant
     * @name pc.ADDRESS_MIRRORED_REPEAT
     * @type {number}
     * @description Texture coordinate to be set to the fractional part if the integer part is even; if the integer part is odd;
     * then the texture coordinate is set to 1 minus the fractional part.
     */
    var ADDRESS_MIRRORED_REPEAT = 2;

    /**
     * @constant
     * @name pc.BLENDMODE_ZERO
     * @type {number}
     * @description Multiply all fragment components by zero.
     */
    var BLENDMODE_ZERO = 0;
    /**
     * @constant
     * @name pc.BLENDMODE_ONE
     * @type {number}
     * @description Multiply all fragment components by one.
     */
    var BLENDMODE_ONE = 1;
    /**
     * @constant
     * @name pc.BLENDMODE_SRC_COLOR
     * @type {number}
     * @description Multiply all fragment components by the components of the source fragment.
     */
    var BLENDMODE_SRC_COLOR = 2;
    /**
     * @constant
     * @name pc.BLENDMODE_ONE_MINUS_SRC_COLOR
     * @type {number}
     * @description Multiply all fragment components by one minus the components of the source fragment.
     */
    var BLENDMODE_ONE_MINUS_SRC_COLOR = 3;
    /**
     * @constant
     * @name pc.BLENDMODE_DST_COLOR
     * @type {number}
     * @description Multiply all fragment components by the components of the destination fragment.
     */
    var BLENDMODE_DST_COLOR = 4;
    /**
     * @constant
     * @name pc.BLENDMODE_ONE_MINUS_DST_COLOR
     * @type {number}
     * @description Multiply all fragment components by one minus the components of the destination fragment.
     */
    var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
    /**
     * @constant
     * @name pc.BLENDMODE_SRC_ALPHA
     * @type {number}
     * @description Multiply all fragment components by the alpha value of the source fragment.
     */
    var BLENDMODE_SRC_ALPHA = 6;
    /**
     * @constant
     * @name pc.BLENDMODE_SRC_ALPHA_SATURATE
     * @type {number}
     * @description Multiply all fragment components by the alpha value of the source fragment.
     */
    var BLENDMODE_SRC_ALPHA_SATURATE = 7;
    /**
     * @constant
     * @name pc.BLENDMODE_ONE_MINUS_SRC_ALPHA
     * @type {number}
     * @description Multiply all fragment components by one minus the alpha value of the source fragment.
     */
    var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
    /**
     * @constant
     * @name pc.BLENDMODE_DST_ALPHA
     * @type {number}
     * @description Multiply all fragment components by the alpha value of the destination fragment.
     */
    var BLENDMODE_DST_ALPHA = 9;
    /**
     * @constant
     * @name pc.BLENDMODE_ONE_MINUS_DST_ALPHA
     * @type {number}
     * @description Multiply all fragment components by one minus the alpha value of the destination fragment.
     */
    var BLENDMODE_ONE_MINUS_DST_ALPHA = 10;

    /**
     * @constant
     * @name pc.BLENDEQUATION_ADD
     * @type {number}
     * @description Add the results of the source and destination fragment multiplies.
     */
    var BLENDEQUATION_ADD = 0;
    /**
     * @constant
     * @name pc.BLENDEQUATION_SUBTRACT
     * @type {number}
     * @description Subtract the results of the source and destination fragment multiplies.
     */
    var BLENDEQUATION_SUBTRACT = 1;
    /**
     * @constant
     * @name pc.BLENDEQUATION_REVERSE_SUBTRACT
     * @type {number}
     * @description Reverse and subtract the results of the source and destination fragment multiplies.
     */
    var BLENDEQUATION_REVERSE_SUBTRACT = 2;

    /**
     * @constant
     * @name pc.BLENDEQUATION_MIN
     * @type {number}
     * @description Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.
     */
    var BLENDEQUATION_MIN = 3;
    /**
     * @constant
     * @name pc.BLENDEQUATION_MAX
     * @type {number}
     * @description Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.
     */
    var BLENDEQUATION_MAX = 4;

    /**
     * @constant
     * @name pc.BUFFER_STATIC
     * @type {number}
     * @description The data store contents will be modified once and used many times.
     */
    var BUFFER_STATIC = 0;
    /**
     * @constant
     * @name pc.BUFFER_DYNAMIC
     * @type {number}
     * @description The data store contents will be modified repeatedly and used many times.
     */
    var BUFFER_DYNAMIC = 1;
    /**
     * @constant
     * @name pc.BUFFER_STREAM
     * @type {number}
     * @description The data store contents will be modified once and used at most a few times.
     */
    var BUFFER_STREAM = 2;
    /**
     * @constant
     * @name pc.BUFFER_GPUDYNAMIC
     * @type {number}
     * @description The data store contents will be modified repeatedly on the GPU and used many times. Optimal for transform feedback usage (WebGL2 only).
     */
    var BUFFER_GPUDYNAMIC = 3;

    /**
     * @constant
     * @name pc.CLEARFLAG_COLOR
     * @type {number}
     * @description Clear the color buffer.
     */
    var CLEARFLAG_COLOR = 1;
    /**
     * @constant
     * @name pc.CLEARFLAG_DEPTH
     * @type {number}
     * @description Clear the depth buffer.
     */
    var CLEARFLAG_DEPTH = 2;
    /**
     * @constant
     * @name pc.CLEARFLAG_STENCIL
     * @type {number}
     * @description Clear the stencil buffer.
     */
    var CLEARFLAG_STENCIL = 4;

    /**
     * @constant
     * @name pc.CUBEFACE_POSX
     * @type {number}
     * @description The positive X face of a cubemap.
     */
    var CUBEFACE_POSX = 0;
    /**
     * @constant
     * @name pc.CUBEFACE_NEGX
     * @type {number}
     * @description The negative X face of a cubemap.
     */
    var CUBEFACE_NEGX = 1;
    /**
     * @constant
     * @name pc.CUBEFACE_POSY
     * @type {number}
     * @description The positive Y face of a cubemap.
     */
    var CUBEFACE_POSY = 2;
    /**
     * @constant
     * @name pc.CUBEFACE_NEGY
     * @type {number}
     * @description The negative Y face of a cubemap.
     */
    var CUBEFACE_NEGY = 3;
    /**
     * @constant
     * @name pc.CUBEFACE_POSZ
     * @type {number}
     * @description The positive Z face of a cubemap.
     */
    var CUBEFACE_POSZ = 4;
    /**
     * @constant
     * @name pc.CUBEFACE_NEGZ
     * @type {number}
     * @description The negative Z face of a cubemap.
     */
    var CUBEFACE_NEGZ = 5;

    /**
     * @constant
     * @name pc.CULLFACE_NONE
     * @type {number}
     * @description No triangles are culled.
     */
    var CULLFACE_NONE = 0;
    /**
     * @constant
     * @name pc.CULLFACE_BACK
     * @type {number}
     * @description Triangles facing away from the view direction are culled.
     */
    var CULLFACE_BACK = 1;
    /**
     * @constant
     * @name pc.CULLFACE_FRONT
     * @type {number}
     * @description Triangles facing the view direction are culled.
     */
    var CULLFACE_FRONT = 2;
    /**
     * @constant
     * @name pc.CULLFACE_FRONTANDBACK
     * @type {number}
     * @description Triangles are culled regardless of their orientation with respect to the view
     * direction. Note that point or line primitives are unaffected by this render state.
     */
    var CULLFACE_FRONTANDBACK = 3;

    /**
     * @constant
     * @name pc.FILTER_NEAREST
     * @type {number}
     * @description Point sample filtering.
     */
    var FILTER_NEAREST = 0;
    /**
     * @constant
     * @name pc.FILTER_LINEAR
     * @type {number}
     * @description Bilinear filtering.
     */
    var FILTER_LINEAR = 1;
    /**
     * @constant
     * @name pc.FILTER_NEAREST_MIPMAP_NEAREST
     * @type {number}
     * @description Use the nearest neighbor in the nearest mipmap level.
     */
    var FILTER_NEAREST_MIPMAP_NEAREST = 2;
    /**
     * @constant
     * @name pc.FILTER_NEAREST_MIPMAP_LINEAR
     * @type {number}
     * @description Linearly interpolate in the nearest mipmap level.
     */
    var FILTER_NEAREST_MIPMAP_LINEAR = 3;
    /**
     * @constant
     * @name pc.FILTER_LINEAR_MIPMAP_NEAREST
     * @type {number}
     * @description Use the nearest neighbor after linearly interpolating between mipmap levels.
     */
    var FILTER_LINEAR_MIPMAP_NEAREST = 4;
    /**
     * @constant
     * @name pc.FILTER_LINEAR_MIPMAP_LINEAR
     * @type {number}
     * @description Linearly interpolate both the mipmap levels and between texels.
     */
    var FILTER_LINEAR_MIPMAP_LINEAR = 5;

    /**
     * @constant
     * @name pc.FUNC_NEVER
     * @type {number}
     * @description Never pass.
     */
    var FUNC_NEVER = 0;
    /**
     * @constant
     * @name pc.FUNC_LESS
     * @type {number}
     * @description Pass if (ref & mask) < (stencil & mask).
     */
    var FUNC_LESS = 1;
    /**
     * @constant
     * @name pc.FUNC_EQUAL
     * @type {number}
     * @description Pass if (ref & mask) == (stencil & mask).
     */
    var FUNC_EQUAL = 2;
    /**
     * @constant
     * @name pc.FUNC_LESSEQUAL
     * @type {number}
     * @description Pass if (ref & mask) <= (stencil & mask).
     */
    var FUNC_LESSEQUAL = 3;
    /**
     * @constant
     * @name pc.FUNC_GREATER
     * @type {number}
     * @description Pass if (ref & mask) > (stencil & mask).
     */
    var FUNC_GREATER = 4;
    /**
     * @constant
     * @name pc.FUNC_NOTEQUAL
     * @type {number}
     * @description Pass if (ref & mask) != (stencil & mask).
     */
    var FUNC_NOTEQUAL = 5;
    /**
     * @constant
     * @name pc.FUNC_GREATEREQUAL
     * @type {number}
     * @description Pass if (ref & mask) >= (stencil & mask).
     */
    var FUNC_GREATEREQUAL = 6;
    /**
     * @constant
     * @name pc.FUNC_ALWAYS
     * @type {number}
     * @description Always pass.
     */
    var FUNC_ALWAYS = 7;

    /**
     * @constant
     * @name pc.INDEXFORMAT_UINT8
     * @type {number}
     * @description 8-bit unsigned vertex indices.
     */
    var INDEXFORMAT_UINT8 = 0;
    /**
     * @constant
     * @name pc.INDEXFORMAT_UINT16
     * @type {number}
     * @description 16-bit unsigned vertex indices.
     */
    var INDEXFORMAT_UINT16 = 1;
    /**
     * @constant
     * @name pc.INDEXFORMAT_UINT32
     * @type {number}
     * @description 32-bit unsigned vertex indices.
     */
    var INDEXFORMAT_UINT32 = 2;

    /**
     * @constant
     * @name pc.PIXELFORMAT_A8
     * @type {number}
     * @description 8-bit alpha.
     */
    var PIXELFORMAT_A8 = 0;
    /**
     * @constant
     * @name pc.PIXELFORMAT_L8
     * @type {number}
     * @description 8-bit luminance.
     */
    var PIXELFORMAT_L8 = 1;
    /**
     * @constant
     * @name pc.PIXELFORMAT_L8_A8
     * @type {number}
     * @description 8-bit luminance with 8-bit alpha.
     */
    var PIXELFORMAT_L8_A8 = 2;
    /**
     * @constant
     * @name pc.PIXELFORMAT_R5_G6_B5
     * @type {number}
     * @description 16-bit RGB (5-bits for red channel; 6 for green and 5 for blue).
     */
    var PIXELFORMAT_R5_G6_B5 = 3;
    /**
     * @constant
     * @name pc.PIXELFORMAT_R5_G5_B5_A1
     * @type {number}
     * @description 16-bit RGBA (5-bits for red channel; 5 for green; 5 for blue with 1-bit alpha).
     */
    var PIXELFORMAT_R5_G5_B5_A1 = 4;
    /**
     * @constant
     * @name pc.PIXELFORMAT_R4_G4_B4_A4
     * @type {number}
     * @description 16-bit RGBA (4-bits for red channel; 4 for green; 4 for blue with 4-bit alpha).
     */
    var PIXELFORMAT_R4_G4_B4_A4 = 5;
    /**
     * @constant
     * @name pc.PIXELFORMAT_R8_G8_B8
     * @type {number}
     * @description 24-bit RGB (8-bits for red channel; 8 for green and 8 for blue).
     */
    var PIXELFORMAT_R8_G8_B8 = 6;
    /**
     * @constant
     * @name pc.PIXELFORMAT_R8_G8_B8_A8
     * @type {number}
     * @description 32-bit RGBA (8-bits for red channel; 8 for green; 8 for blue with 8-bit alpha).
     */
    var PIXELFORMAT_R8_G8_B8_A8 = 7;
    /**
     * @constant
     * @name pc.PIXELFORMAT_DXT1
     * @type {number}
     * @description Block compressed format; storing 16 input pixels in 64 bits of output; consisting of two 16-bit RGB 5:6:5 color values and a 4x4 two bit lookup table.
     */
    var PIXELFORMAT_DXT1 = 8;
    /**
     * @constant
     * @name pc.PIXELFORMAT_DXT3
     * @type {number}
     * @description Block compressed format; storing 16 input pixels (corresponding to a 4x4 pixel block) into 128 bits of output; consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by 64 bits of color data; encoded the same way as DXT1.
     */
    var PIXELFORMAT_DXT3 = 9;
    /**
     * @constant
     * @name pc.PIXELFORMAT_DXT5
     * @type {number}
     * @description Block compressed format; storing 16 input pixels into 128 bits of output; consisting of 64 bits of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits of color data (encoded the same way as DXT1).
     */
    var PIXELFORMAT_DXT5 = 10;
    /**
     * @constant
     * @name pc.PIXELFORMAT_RGB16F
     * @type {number}
     * @description 16-bit floating point RGB (16-bit float for each red; green and blue channels).
     */
    var PIXELFORMAT_RGB16F = 11;
    /**
     * @constant
     * @name pc.PIXELFORMAT_RGBA16F
     * @type {number}
     * @description 16-bit floating point RGBA (16-bit float for each red; green; blue and alpha channels).
     */
    var PIXELFORMAT_RGBA16F = 12;
    /**
     * @constant
     * @name pc.PIXELFORMAT_RGB32F
     * @type {number}
     * @description 32-bit floating point RGB (32-bit float for each red; green and blue channels).
     */
    var PIXELFORMAT_RGB32F = 13;
    /**
     * @constant
     * @name pc.PIXELFORMAT_RGBA32F
     * @type {number}
     * @description 32-bit floating point RGBA (32-bit float for each red; green; blue and alpha channels).
     */
    var PIXELFORMAT_RGBA32F = 14;

    /**
     * @constant
     * @name pc.PIXELFORMAT_R32F
     * @type {number}
     * @description 32-bit floating point single channel format (WebGL2 only).
     */
    var PIXELFORMAT_R32F = 15;

    /**
     * @constant
     * @name pc.PIXELFORMAT_DEPTH
     * @type {number}
     * @description A readable depth buffer format.
     */
    var PIXELFORMAT_DEPTH = 16;

    /**
     * @constant
     * @name pc.PIXELFORMAT_DEPTHSTENCIL
     * @type {number}
     * @description A readable depth/stencil buffer format (WebGL2 only).
     */
    var PIXELFORMAT_DEPTHSTENCIL = 17;

    /**
     * @constant
     * @name pc.PIXELFORMAT_111110F
     * @type {number}
     * @description A floating-point color-only format with 11 bits for red and green channels; and 10 bits for the blue channel (WebGL2 only).
     */
    var PIXELFORMAT_111110F = 18;

    /**
     * @constant
     * @name pc.PIXELFORMAT_SRGB
     * @type {number}
     * @description Color-only sRGB format (WebGL2 only).
     */
    var PIXELFORMAT_SRGB = 19;

    /**
     * @constant
     * @name pc.PIXELFORMAT_SRGBA
     * @type {number}
     * @description Color sRGB format with additional alpha channel (WebGL2 only).
     */
    var PIXELFORMAT_SRGBA = 20;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ETC1
     * @type {number}
     * @description ETC1 compressed format.
     */
    var PIXELFORMAT_ETC1 = 21;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ETC2_RGB
     * @type {number}
     * @description ETC2 (RGB) compressed format.
     */
    var PIXELFORMAT_ETC2_RGB = 22;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ETC2_RGBA
     * @type {number}
     * @description ETC2 (RGBA) compressed format.
     */
    var PIXELFORMAT_ETC2_RGBA = 23;

    /**
     * @constant
     * @name pc.PIXELFORMAT_PVRTC_2BPP_RGB_1
     * @type {number}
     * @description PVRTC (2BPP RGB) compressed format.
     */
    var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;

    /**
     * @constant
     * @name pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1
     * @type {number}
     * @description PVRTC (2BPP RGBA) compressed format.
     */
    var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;

    /**
     * @constant
     * @name pc.PIXELFORMAT_PVRTC_4BPP_RGB_1
     * @type {number}
     * @description PVRTC (4BPP RGB) compressed format.
     */
    var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;

    /**
     * @constant
     * @name pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1
     * @type {number}
     * @description PVRTC (4BPP RGBA) compressed format.
     */
    var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ASTC_4x4
     * @type {number}
     * @description ATC compressed format with alpha channel in blocks of 4x4.
     */
    var PIXELFORMAT_ASTC_4x4 = 28;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ATC_RGB
     * @type {number}
     * @description ATC compressed format with no alpha channel.
     */
    var PIXELFORMAT_ATC_RGB = 29;

    /**
     * @constant
     * @name pc.PIXELFORMAT_ATC_RGBA
     * @type {number}
     * @description ATC compressed format with alpha channel.
     */
    var PIXELFORMAT_ATC_RGBA = 30;

    // only add compressed formats next

    /**
     * @constant
     * @name pc.PRIMITIVE_POINTS
     * @type {number}
     * @description List of distinct points.
     */
    var PRIMITIVE_POINTS = 0;
    /**
     * @constant
     * @name pc.PRIMITIVE_LINES
     * @type {number}
     * @description Discrete list of line segments.
     */
    var PRIMITIVE_LINES = 1;
    /**
     * @constant
     * @name pc.PRIMITIVE_LINELOOP
     * @type {number}
     * @description List of points that are linked sequentially by line segments; with a closing line segment between the last and first points.
     */
    var PRIMITIVE_LINELOOP = 2;
    /**
     * @constant
     * @name pc.PRIMITIVE_LINESTRIP
     * @type {number}
     * @description List of points that are linked sequentially by line segments.
     */
    var PRIMITIVE_LINESTRIP = 3;
    /**
     * @constant
     * @name pc.PRIMITIVE_TRIANGLES
     * @type {number}
     * @description Discrete list of triangles.
     */
    var PRIMITIVE_TRIANGLES = 4;
    /**
     * @constant
     * @name pc.PRIMITIVE_TRISTRIP
     * @type {number}
     * @description Connected strip of triangles where a specified vertex forms a triangle using the previous two.
     */
    var PRIMITIVE_TRISTRIP = 5;
    /**
     * @constant
     * @name pc.PRIMITIVE_TRIFAN
     * @type {number}
     * @description Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
     */
    var PRIMITIVE_TRIFAN = 6;

    /**
     * @constant
     * @name pc.SEMANTIC_POSITION
     * @type {string}
     * @description Vertex attribute to be treated as a position.
     */
    var SEMANTIC_POSITION = "POSITION";
    /**
     * @constant
     * @name pc.SEMANTIC_NORMAL
     * @type {string}
     * @description Vertex attribute to be treated as a normal.
     */
    var SEMANTIC_NORMAL = "NORMAL";
    /**
     * @constant
     * @name pc.SEMANTIC_TANGENT
     * @type {string}
     * @description Vertex attribute to be treated as a tangent.
     */
    var SEMANTIC_TANGENT = "TANGENT";
    /**
     * @constant
     * @name pc.SEMANTIC_BLENDWEIGHT
     * @type {string}
     * @description Vertex attribute to be treated as skin blend weights.
     */
    var SEMANTIC_BLENDWEIGHT = "BLENDWEIGHT";
    /**
     * @constant
     * @name pc.SEMANTIC_BLENDINDICES
     * @type {string}
     * @description Vertex attribute to be treated as skin blend indices.
     */
    var SEMANTIC_BLENDINDICES = "BLENDINDICES";
    /**
     * @constant
     * @name pc.SEMANTIC_COLOR
     * @type {string}
     * @description Vertex attribute to be treated as a color.
     */
    var SEMANTIC_COLOR = "COLOR";

    // private semantic used for programatic construction of individual texcoord semantics
    var SEMANTIC_TEXCOORD = "TEXCOORD";

    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD0
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 0).
     */
    var SEMANTIC_TEXCOORD0 = "TEXCOORD0";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD1
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 1).
     */
    var SEMANTIC_TEXCOORD1 = "TEXCOORD1";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD2
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 2).
     */
    var SEMANTIC_TEXCOORD2 = "TEXCOORD2";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD3
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 3).
     */
    var SEMANTIC_TEXCOORD3 = "TEXCOORD3";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD4
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 4).
     */
    var SEMANTIC_TEXCOORD4 = "TEXCOORD4";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD5
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 5).
     */
    var SEMANTIC_TEXCOORD5 = "TEXCOORD5";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD6
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 6).
     */
    var SEMANTIC_TEXCOORD6 = "TEXCOORD6";
    /**
     * @constant
     * @name pc.SEMANTIC_TEXCOORD7
     * @type {string}
     * @description Vertex attribute to be treated as a texture coordinate (set 7).
     */
    var SEMANTIC_TEXCOORD7 = "TEXCOORD7";

    // private semantic used for programatic construction of individual attr semantics
    var SEMANTIC_ATTR = "ATTR";

    /**
     * @constant
     * @name pc.SEMANTIC_ATTR0
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR0 = "ATTR0";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR1
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR1 = "ATTR1";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR2
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR2 = "ATTR2";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR3
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR3 = "ATTR3";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR4
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR4 = "ATTR4";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR5
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR5 = "ATTR5";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR6
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR6 = "ATTR6";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR7
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR7 = "ATTR7";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR8
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR8 = "ATTR8";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR9
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR9 = "ATTR9";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR10
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR10 = "ATTR10";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR11
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR11 = "ATTR11";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR12
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR12 = "ATTR12";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR13
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR13 = "ATTR13";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR14
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR14 = "ATTR14";
    /**
     * @constant
     * @name pc.SEMANTIC_ATTR15
     * @type {string}
     * @description Vertex attribute with a user defined semantic.
     */
    var SEMANTIC_ATTR15 = "ATTR15";

    var SHADERTAG_MATERIAL = 1;

    /**
     * @constant
     * @name pc.STENCILOP_KEEP
     * @type {number}
     * @description Don't change the stencil buffer value.
     */
    var STENCILOP_KEEP = 0;
    /**
     * @constant
     * @name pc.STENCILOP_ZERO
     * @type {number}
     * @description Set value to zero.
     */
    var STENCILOP_ZERO = 1;
    /**
     * @constant
     * @name pc.STENCILOP_REPLACE
     * @type {number}
     * @description Replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc}).
     */
    var STENCILOP_REPLACE = 2;
    /**
     * @constant
     * @name pc.STENCILOP_INCREMENT
     * @type {number}
     * @description Increment the value.
     */
    var STENCILOP_INCREMENT = 3;
    /**
     * @constant
     * @name pc.STENCILOP_INCREMENTWRAP
     * @type {number}
     * @description Increment the value; but wrap it to zero when it's larger than a maximum representable value.
     */
    var STENCILOP_INCREMENTWRAP = 4;
    /**
     * @constant
     * @name pc.STENCILOP_DECREMENT
     * @type {number}
     * @description Decrement the value.
     */
    var STENCILOP_DECREMENT = 5;
    /**
     * @constant
     * @name pc.STENCILOP_DECREMENTWRAP
     * @type {number}
     * @description Decrement the value; but wrap it to a maximum representable value; if the current value is 0.
     */
    var STENCILOP_DECREMENTWRAP = 6;
    /**
     * @constant
     * @name pc.STENCILOP_INVERT
     * @type {number}
     * @description Invert the value bitwise.
     */
    var STENCILOP_INVERT = 7;

    /**
     * @constant
     * @name pc.TEXTURELOCK_READ
     * @type {number}
     * @description Read only. Any changes to the locked mip level's pixels will not update the texture.
     */
    var TEXTURELOCK_READ = 1;
    /**
     * @constant
     * @name pc.TEXTURELOCK_WRITE
     * @type {number}
     * @description Write only. The contents of the specified mip level will be entirely replaced.
     */
    var TEXTURELOCK_WRITE = 2;

    /**
     * @constant
     * @name pc.TEXTURETYPE_DEFAULT
     * @type {number}
     * @description Texture is a default type.
     */
    var TEXTURETYPE_DEFAULT = 'default';

    /**
     * @constant
     * @name pc.TEXTURETYPE_RGBM
     * @type {number}
     * @description Texture stores high dynamic range data in RGBM format
     */
    var TEXTURETYPE_RGBM = 'rgbm';

    /**
     * @constant
     * @name pc.TEXTURETYPE_RGBE
     * @type {number}
     * @description Texture stores high dynamic range data in RGBE format
     */
    var TEXTURETYPE_RGBE = 'rgbe';

    /**
     * @constant
     * @name pc.TEXTURETYPE_SWIZZLEGGGR
     * @type {number}
     * @description Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
     * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in higher quality
     * when the texture data is compressed.
     */
    var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';

    var TEXHINT_NONE = 0;
    var TEXHINT_SHADOWMAP = 1;
    var TEXHINT_ASSET = 2;
    var TEXHINT_LIGHTMAP = 3;

    /**
     * @constant
     * @name pc.TYPE_INT8
     * @type {number}
     * @description Signed byte vertex element type.
     */
    var TYPE_INT8 = 0;
    /**
     * @constant
     * @name pc.TYPE_UINT8
     * @type {number}
     * @description Unsigned byte vertex element type.
     */
    var TYPE_UINT8 = 1;
    /**
     * @constant
     * @name pc.TYPE_INT16
     * @type {number}
     * @description Signed short vertex element type.
     */
    var TYPE_INT16 = 2;
    /**
     * @constant
     * @name pc.TYPE_UINT16
     * @type {number}
     * @description Unsigned short vertex element type.
     */
    var TYPE_UINT16 = 3;
    /**
     * @constant
     * @name pc.TYPE_INT32
     * @type {number}
     * @description Signed integer vertex element type.
     */
    var TYPE_INT32 = 4;
    /**
     * @constant
     * @name pc.TYPE_UINT32
     * @type {number}
     * @description Unsigned integer vertex element type.
     */
    var TYPE_UINT32 = 5;
    /**
     * @constant
     * @name pc.TYPE_FLOAT32
     * @type {number}
     * @description Floating point vertex element type.
     */
    var TYPE_FLOAT32 = 6;

    var UNIFORMTYPE_BOOL = 0;
    var UNIFORMTYPE_INT = 1;
    var UNIFORMTYPE_FLOAT = 2;
    var UNIFORMTYPE_VEC2 = 3;
    var UNIFORMTYPE_VEC3 = 4;
    var UNIFORMTYPE_VEC4 = 5;
    var UNIFORMTYPE_IVEC2 = 6;
    var UNIFORMTYPE_IVEC3 = 7;
    var UNIFORMTYPE_IVEC4 = 8;
    var UNIFORMTYPE_BVEC2 = 9;
    var UNIFORMTYPE_BVEC3 = 10;
    var UNIFORMTYPE_BVEC4 = 11;
    var UNIFORMTYPE_MAT2 = 12;
    var UNIFORMTYPE_MAT3 = 13;
    var UNIFORMTYPE_MAT4 = 14;
    var UNIFORMTYPE_TEXTURE2D = 15;
    var UNIFORMTYPE_TEXTURECUBE = 16;
    var UNIFORMTYPE_FLOATARRAY = 17;
    var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
    var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
    var UNIFORMTYPE_TEXTURE3D = 20;

    // map of engine pc.TYPE_*** enums to their corresponding typed array constructors and byte sizes
    var typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];
    var typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];

    // map of typed array to engine pc.TYPE_***
    var typedArrayToType = {
        "Int8Array": TYPE_INT8,
        "Uint8Array": TYPE_UINT8,
        "Int16Array": TYPE_INT16,
        "Uint16Array": TYPE_UINT16,
        "Int32Array": TYPE_INT32,
        "Uint32Array": TYPE_UINT32,
        "Float32Array": TYPE_FLOAT32
    };

    // map of engine pc.INDEXFORMAT_*** to their corresponding typed array constructors and byte sizes
    var typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];
    var typedArrayIndexFormatsByteSize = [1, 2, 4];

    /**
     * @class
     * @name pc.VertexBuffer
     * @classdesc A vertex buffer is the mechanism via which the application specifies vertex
     * data to the graphics hardware.
     * @description Creates a new vertex buffer object.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex buffer.
     * @param {pc.VertexFormat} format - The vertex format of this vertex buffer.
     * @param {number} numVertices - The number of vertices that this vertex buffer will hold.
     * @param {number} [usage] - The usage type of the vertex buffer (see pc.BUFFER_*).
     * @param {ArrayBuffer} [initialData] - Initial data.
     */
    function VertexBuffer(graphicsDevice, format, numVertices, usage, initialData) {
        // By default, vertex buffers are static (better for performance since buffer data can be cached in VRAM)
        this.usage = usage || BUFFER_STATIC;
        this.format = format;
        this.numVertices = numVertices;

        // Calculate the size. If format contains verticesByteSize (non-interleaved format), use it
        this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
        graphicsDevice._vram.vb += this.numBytes;

        // Create the WebGL vertex buffer object
        this.device = graphicsDevice;

        // Allocate the storage
        if (initialData) {
            this.setData(initialData);
        } else {
            this.storage = new ArrayBuffer(this.numBytes);
        }

        this.device.buffers.push(this);
    }

    Object.assign(VertexBuffer.prototype, {
        /**
         * @function
         * @name pc.VertexBuffer#destroy
         * @description Frees resources associated with this vertex buffer.
         */
        destroy: function () {
            var device = this.device;
            var idx = device.buffers.indexOf(this);
            if (idx !== -1) {
                device.buffers.splice(idx, 1);
            }

            if (this.bufferId) {
                var gl = device.gl;
                gl.deleteBuffer(this.bufferId);
                device._vram.vb -= this.storage.byteLength;
                this.bufferId = null;

                // If this buffer was bound, must clean up attribute-buffer bindings to prevent GL errors
                device.boundBuffer = null;
                device.vertexBuffers.length = 0;
                device.vbOffsets.length = 0;
                device.attributesInvalidated = true;
                for (var loc in device.enabledAttributes) {
                    gl.disableVertexAttribArray(Number(loc));
                }
                device.enabledAttributes = {};
            }
        },

        /**
         * @function
         * @name pc.VertexBuffer#getFormat
         * @description Returns the data format of the specified vertex buffer.
         * @returns {pc.VertexFormat} The data format of the specified vertex buffer.
         */
        getFormat: function () {
            return this.format;
        },

        /**
         * @function
         * @name pc.VertexBuffer#getUsage
         * @description Returns the usage type of the specified vertex buffer. This indicates
         * whether the buffer can be modified once and used many times (pc.BUFFER_STATIC),
         * modified repeatedly and used many times (pc.BUFFER_DYNAMIC) or modified once
         * and used at most a few times (pc.BUFFER_STREAM).
         * @returns {number} The usage type of the vertex buffer (see pc.BUFFER_*).
         */
        getUsage: function () {
            return this.usage;
        },

        /**
         * @function
         * @name pc.VertexBuffer#getNumVertices
         * @description Returns the number of vertices stored in the specified vertex buffer.
         * @returns {number} The number of vertices stored in the vertex buffer.
         */
        getNumVertices: function () {
            return this.numVertices;
        },

        /**
         * @function
         * @name pc.VertexBuffer#lock
         * @description Returns a mapped memory block representing the content of the vertex buffer.
         * @returns {ArrayBuffer} An array containing the byte data stored in the vertex buffer.
         */
        lock: function () {
            return this.storage;
        },

        /**
         * @function
         * @name pc.VertexBuffer#unlock
         * @description Notifies the graphics engine that the client side copy of the vertex buffer's
         * memory can be returned to the control of the graphics driver.
         */
        unlock: function () {
            // Upload the new vertex data
            var gl = this.device.gl;

            if (!this.bufferId) {
                this.bufferId = gl.createBuffer();
            }

            var glUsage;
            switch (this.usage) {
                case BUFFER_STATIC:
                    glUsage = gl.STATIC_DRAW;
                    break;
                case BUFFER_DYNAMIC:
                    glUsage = gl.DYNAMIC_DRAW;
                    break;
                case BUFFER_STREAM:
                    glUsage = gl.STREAM_DRAW;
                    break;
                case BUFFER_GPUDYNAMIC:
                    if (this.device.webgl2) {
                        glUsage = gl.DYNAMIC_COPY;
                    } else {
                        glUsage = gl.STATIC_DRAW;
                    }
                    break;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);
            gl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);
        },

        /**
         * @function
         * @name pc.VertexBuffer#setData
         * @description Copies data into vertex buffer's memory.
         * @param {ArrayBuffer} [data] - Source data to copy.
         * @returns {boolean} True if function finished successfuly, false otherwise.
         */
        setData: function (data) {
            if (data.byteLength !== this.numBytes) {
                console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
                return false;
            }
            this.storage = data;
            this.unlock();
            return true;
        }
    });

    /**
     * @private
     * @function
     * @name pc.hashCode
     * @description Calculates simple hash value of a string. Designed for performance, not perfect.
     * @param {string} str - String.
     * @returns {number} Hash value.
     */
    function hashCode(str) {
        var hash = 0;
        for (var i = 0, len = str.length; i < len; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            // Convert to 32bit integer
            hash |= 0;
        }
        return hash;
    }

    /**
     * @class
     * @name pc.VertexFormat
     * @classdesc A vertex format is a descriptor that defines the layout of vertex data inside
     * a {@link pc.VertexBuffer}.
     * @description Returns a new pc.VertexFormat object.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this vertex format.
     * @param {object[]} description - An array of vertex attribute descriptions.
     * @param {string} description[].semantic - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * * {@link pc.SEMANTIC_POSITION}
     * * {@link pc.SEMANTIC_NORMAL}
     * * {@link pc.SEMANTIC_TANGENT}
     * * {@link pc.SEMANTIC_BLENDWEIGHT}
     * * {@link pc.SEMANTIC_BLENDINDICES}
     * * {@link pc.SEMANTIC_COLOR}
     * * {@link pc.SEMANTIC_TEXCOORD0}
     * * {@link pc.SEMANTIC_TEXCOORD1}
     * * {@link pc.SEMANTIC_TEXCOORD2}
     * * {@link pc.SEMANTIC_TEXCOORD3}
     * * {@link pc.SEMANTIC_TEXCOORD4}
     * * {@link pc.SEMANTIC_TEXCOORD5}
     * * {@link pc.SEMANTIC_TEXCOORD6}
     * * {@link pc.SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: pc.SEMANTIC_ATTR0 to pc.SEMANTIC_ATTR15.
     * @param {number} description[].components - The number of components of the vertex attribute.
     * Can be 1, 2, 3 or 4.
     * @param {number} description[].type - The data type of the attribute. Can be:
     *
     * * {@link pc.TYPE_INT8}
     * * {@link pc.TYPE_UINT8}
     * * {@link pc.TYPE_INT16}
     * * {@link pc.TYPE_UINT16}
     * * {@link pc.TYPE_INT32}
     * * {@link pc.TYPE_UINT32}
     * * {@link pc.TYPE_FLOAT32}
     *
     * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped from a
     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
     * unchanged. If this property is unspecified, false is assumed.
     * @param {number} [vertexCount] - When specified, vertex format will be set up for non-interleaved format with a specified
     * number of vertices. (example: PPPPNNNNCCCC), where arrays of individual attributes will be stored one right after the other (subject to alignment requirements).
     * Note that in this case, the format depends on the number of vertices, and needs to change when the number of vertices changes.
     * When not specified, vertex format will be interleaved. (example: PNCPNCPNCPNC)
     * @property {object[]} elements The vertex attribute elements.
     * @property {string} elements[].name The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * * {@link pc.SEMANTIC_POSITION}
     * * {@link pc.SEMANTIC_NORMAL}
     * * {@link pc.SEMANTIC_TANGENT}
     * * {@link pc.SEMANTIC_BLENDWEIGHT}
     * * {@link pc.SEMANTIC_BLENDINDICES}
     * * {@link pc.SEMANTIC_COLOR}
     * * {@link pc.SEMANTIC_TEXCOORD0}
     * * {@link pc.SEMANTIC_TEXCOORD1}
     * * {@link pc.SEMANTIC_TEXCOORD2}
     * * {@link pc.SEMANTIC_TEXCOORD3}
     * * {@link pc.SEMANTIC_TEXCOORD4}
     * * {@link pc.SEMANTIC_TEXCOORD5}
     * * {@link pc.SEMANTIC_TEXCOORD6}
     * * {@link pc.SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: pc.SEMANTIC_ATTR0 to pc.SEMANTIC_ATTR15.
     * @property {number} elements[].numComponents The number of components of the vertex attribute.
     * Can be 1, 2, 3 or 4.
     * @property {number} elements[].dataType The data type of the attribute. Can be:
     *
     * * {@link pc.TYPE_INT8}
     * * {@link pc.TYPE_UINT8}
     * * {@link pc.TYPE_INT16}
     * * {@link pc.TYPE_UINT16}
     * * {@link pc.TYPE_INT32}
     * * {@link pc.TYPE_UINT32}
     * * {@link pc.TYPE_FLOAT32}
     * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a
     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
     * unchanged. If this property is unspecified, false is assumed.
     * @property {number} elements[].offset The number of initial bytes at the start of a vertex that are not relevant to this attribute.
     * @property {number} elements[].stride The number of total bytes that are between the start of one vertex, and the start of the next.
     * @property {pc.ScopeId} elements[].scopeId The shader input variable corresponding to the attribute.
     * @property {number} elements[].size The size of the attribute in bytes.
     * @example
     * // Specify 3-component positions (x, y, z)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
     * ]);
     * @example
     * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
     * var vertexFormat = new pc.VertexFormat(graphicsDevice, [
     *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
     *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
     * ]);
     */
    function VertexFormat(graphicsDevice, description, vertexCount) {
        var i, len, element;

        this.elements = [];
        this.hasUv0 = false;
        this.hasUv1 = false;
        this.hasColor = false;
        this.hasTangents = false;
        this._defaultInstancingFormat = null;
        this.verticesByteSize = 0;
        this.vertexCount = vertexCount;
        this.interleaved = !vertexCount;

        // calculate total size of the vertex
        this.size = description.reduce(function (total, desc) {
            return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
        }, 0);

        var offset = 0, elementSize;
        for (i = 0, len = description.length; i < len; i++) {
            var elementDesc = description[i];

            // align up the offset to elementSize (when vertexCount is specified only - case of non-interleaved format)
            elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
            if (vertexCount) {
                offset = pc.math.roundUp(offset, elementSize);

            }

            element = {
                name: elementDesc.semantic,
                offset: (vertexCount ? offset : (elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset)),
                stride: (vertexCount ? elementSize : (elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size)),
                stream: -1,
                scopeId: graphicsDevice.scope.resolve(elementDesc.semantic),
                dataType: elementDesc.type,
                numComponents: elementDesc.components,
                normalize: (elementDesc.normalize === undefined) ? false : elementDesc.normalize,
                size: elementSize
            };
            this.elements.push(element);

            if (vertexCount) {
                offset += elementSize * vertexCount;
            } else {
                offset += Math.ceil(elementSize / 4) * 4;
            }

            if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
                this.hasUv0 = true;
            } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
                this.hasUv1 = true;
            } else if (elementDesc.semantic === SEMANTIC_COLOR) {
                this.hasColor = true;
            } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
                this.hasTangents = true;
            }
        }

        if (vertexCount) {
            this.verticesByteSize = offset;
        }

        this.batchingHash = this._evaluateBatchingHash();
    }

    VertexFormat.init = function (graphicsDevice) {
        var formatDesc = [
            { semantic: SEMANTIC_TEXCOORD2, components: 4, type: TYPE_FLOAT32 },
            { semantic: SEMANTIC_TEXCOORD3, components: 4, type: TYPE_FLOAT32 },
            { semantic: SEMANTIC_TEXCOORD4, components: 4, type: TYPE_FLOAT32 },
            { semantic: SEMANTIC_TEXCOORD5, components: 4, type: TYPE_FLOAT32 }
        ];

        this._defaultInstancingFormat = new VertexFormat(graphicsDevice, formatDesc);
    };

    /**
     * @field
     * @static
     * @readonly
     * @name pc.VertexFormat.defaultInstancingFormat
     * @type {pc.VertexFormat}
     * @description Returns {@link pc.VertexFormat} used to store matrices of type {@link pc.Mat4} for hardware instancing.
     */
    Object.defineProperty(VertexFormat, 'defaultInstancingFormat', {
        get: (function () {
            return function () {
                return this._defaultInstancingFormat;
            };
        }())
    });

    Object.assign(VertexFormat.prototype, {

        // evaluates hash value for the format allowing fast compare of batching compatibility
        _evaluateBatchingHash: function () {

            // create string description of each element that is relevant for batching
            var stringElement, stringElements = [];
            var i, len = this.elements.length, element;
            for (i = 0; i < len; i++) {
                element = this.elements[i];

                stringElement = element.name;
                stringElement += element.dataType;
                stringElement += element.numComponents;
                stringElement += element.normalize;

                stringElements.push(stringElement);
            }

            // sort them alphabetically to make hash order independent
            stringElements.sort();

            return hashCode(stringElements.join());
        }
    });

    /**
     * @class
     * @name pc.VertexIteratorAccessor
     * @classdesc Helps with accessing a specific vertex attribute.
     * @description Returns a new pc.VertexIteratorAccessor object.
     * @param {ArrayBuffer} buffer - The vertex buffer containing the attribute to be accessed.
     * @param {object} vertexElement - The vertex attribute to be accessed.
     * @param {string} vertexElement.name - The meaning of the vertex element. This is used to link
     * the vertex data to a shader input. Can be:
     *
     * * {@link pc.SEMANTIC_POSITION}
     * * {@link pc.SEMANTIC_NORMAL}
     * * {@link pc.SEMANTIC_TANGENT}
     * * {@link pc.SEMANTIC_BLENDWEIGHT}
     * * {@link pc.SEMANTIC_BLENDINDICES}
     * * {@link pc.SEMANTIC_COLOR}
     * * {@link pc.SEMANTIC_TEXCOORD0}
     * * {@link pc.SEMANTIC_TEXCOORD1}
     * * {@link pc.SEMANTIC_TEXCOORD2}
     * * {@link pc.SEMANTIC_TEXCOORD3}
     * * {@link pc.SEMANTIC_TEXCOORD4}
     * * {@link pc.SEMANTIC_TEXCOORD5}
     * * {@link pc.SEMANTIC_TEXCOORD6}
     * * {@link pc.SEMANTIC_TEXCOORD7}
     *
     * If vertex data has a meaning other that one of those listed above, use the user-defined
     * semantics: pc.SEMANTIC_ATTR0 to pc.SEMANTIC_ATTR15.
     * @param {number} vertexElement.numComponents - The number of components of the vertex attribute.
     * Can be 1, 2, 3 or 4.
     * @param {number} vertexElement.dataType - The data type of the attribute. Can be:
     *
     * * {@link pc.TYPE_INT8}
     * * {@link pc.TYPE_UINT8}
     * * {@link pc.TYPE_INT16}
     * * {@link pc.TYPE_UINT16}
     * * {@link pc.TYPE_INT32}
     * * {@link pc.TYPE_UINT32}
     * * {@link pc.TYPE_FLOAT32}
     * @param {boolean} vertexElement.normalize - If true, vertex attribute data will be mapped from a
     * 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
     * unchanged. If this property is unspecified, false is assumed.
     * @param {number} vertexElement.offset - The number of initial bytes at the start of a vertex that are not relevant to this attribute.
     * @param {number} vertexElement.stride - The number of total bytes that are between the start of one vertex, and the start of the next.
     * @param {pc.ScopeId} vertexElement.scopeId - The shader input variable corresponding to the attribute.
     * @param {number} vertexElement.size - The size of the attribute in bytes.
     * @param {pc.VertexFormat} vertexFormat - A vertex format that defines the layout of vertex data inside the buffer.
     */
    function VertexIteratorAccessor(buffer, vertexElement, vertexFormat) {
        this.index = 0;
        this.numComponents = vertexElement.numComponents;

        // create the typed array based on the element data type
        if (vertexFormat.interleaved) {
            this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
        } else {
            this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
        }

        // BYTES_PER_ELEMENT is on the instance and constructor for Chrome, Safari and Firefox, but just the constructor for Opera
        this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;

        // Methods
        switch (vertexElement.numComponents) {
            case 1:
                this.set = VertexIteratorAccessor_set1;
                this.getToArray = VertexIteratorAccessor_arrayGet1;
                this.setFromArray = VertexIteratorAccessor_arraySet1;
                break;

            case 2:
                this.set = VertexIteratorAccessor_set2;
                this.getToArray = VertexIteratorAccessor_arrayGet2;
                this.setFromArray = VertexIteratorAccessor_arraySet2;
                break;

            case 3:
                this.set = VertexIteratorAccessor_set3;
                this.getToArray = VertexIteratorAccessor_arrayGet3;
                this.setFromArray = VertexIteratorAccessor_arraySet3;
                break;

            case 4:
                this.set = VertexIteratorAccessor_set4;
                this.getToArray = VertexIteratorAccessor_arrayGet4;
                this.setFromArray = VertexIteratorAccessor_arraySet4;
                break;
        }
    }

    /**
     * @function
     * @name pc.VertexIteratorAccessor#get
     * @description Get a attribute component at the iterator's current index.
     * @param {number} offset - The component offset. Should be either 0, 1, 2, or 3.
     * @returns {number} The value of a attribute component.
     */
    VertexIteratorAccessor.prototype.get = function (offset) {
        return this.array[this.index + offset];
    };

    /**
     * @function
     * @name pc.VertexIteratorAccessor#set
     * @description Set all the attribute components at the iterator's current index.
     * @param {number} a - The first component value.
     * @param {number} [b] - The second component value (if applicable).
     * @param {number} [c] - The third component value (if applicable).
     * @param {number} [d] - The fourth component value (if applicable).
     */
    VertexIteratorAccessor.prototype.set = function (a, b, c, d) {
        // Will be replaced with specialized implementation based on number of components
    };

    function VertexIteratorAccessor_set1(a) {
        this.array[this.index] = a;
    }

    function VertexIteratorAccessor_set2(a, b) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
    }

    function VertexIteratorAccessor_set3(a, b, c) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c;
    }

    function VertexIteratorAccessor_set4(a, b, c, d) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = c;
        this.array[this.index + 3] = d;
    }

    /**
     * @function
     * @name pc.VertexIteratorAccessor#setFromArray
     * @description Write attribute components from an input array.
     * @param {number} index - The starting index at which to write data into the buffer. Will be used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} inputArray - The input array to read data from.
     * @param {number} inputIndex - The input index at which to read from the input array.
     */
    VertexIteratorAccessor.prototype.setFromArray = function (index, inputArray, inputIndex) {
        // Will be replaced with specialized implementation based on number of components
    };

    function VertexIteratorAccessor_arraySet1(index, inputArray, inputIndex) {
        this.array[index] = inputArray[inputIndex];
    }

    function VertexIteratorAccessor_arraySet2(index, inputArray, inputIndex) {
        this.array[index] = inputArray[inputIndex];
        this.array[index + 1] = inputArray[inputIndex + 1];
    }

    function VertexIteratorAccessor_arraySet3(index, inputArray, inputIndex) {
        this.array[index] = inputArray[inputIndex];
        this.array[index + 1] = inputArray[inputIndex + 1];
        this.array[index + 2] = inputArray[inputIndex + 2];
    }

    function VertexIteratorAccessor_arraySet4(index, inputArray, inputIndex) {
        this.array[index] = inputArray[inputIndex];
        this.array[index + 1] = inputArray[inputIndex + 1];
        this.array[index + 2] = inputArray[inputIndex + 2];
        this.array[index + 3] = inputArray[inputIndex + 3];
    }

    /**
     * @function
     * @name pc.VertexIteratorAccessor#getToArray
     * @description Read attribute components to an output array.
     * @param {number} offset - The component offset at which to read data from the buffer. Will be used instead of the iterator's current index.
     * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} outputArray - The output array to write data into.
     * @param {number} outputIndex - The output index at which to write into the output array.
     */
    VertexIteratorAccessor.prototype.getToArray = function (offset, outputArray, outputIndex) {
        // Will be replaced with specialized implementation based on number of components
    };

    function VertexIteratorAccessor_arrayGet1(offset, outputArray, outputIndex) {
        outputArray[outputIndex] = this.array[offset];
    }

    function VertexIteratorAccessor_arrayGet2(offset, outputArray, outputIndex) {
        outputArray[outputIndex] = this.array[offset];
        outputArray[outputIndex + 1] = this.array[offset + 1];
    }

    function VertexIteratorAccessor_arrayGet3(offset, outputArray, outputIndex) {
        outputArray[outputIndex] = this.array[offset];
        outputArray[outputIndex + 1] = this.array[offset + 1];
        outputArray[outputIndex + 2] = this.array[offset + 2];
    }

    function VertexIteratorAccessor_arrayGet4(offset, outputArray, outputIndex) {
        outputArray[outputIndex] = this.array[offset];
        outputArray[outputIndex + 1] = this.array[offset + 1];
        outputArray[outputIndex + 2] = this.array[offset + 2];
        outputArray[outputIndex + 3] = this.array[offset + 3];
    }

    /**
     * @class
     * @name pc.VertexIterator
     * @classdesc A vertex iterator simplifies the process of writing vertex data to a vertex buffer.
     * @description Returns a new pc.VertexIterator object.
     * @param {pc.VertexBuffer} vertexBuffer - The vertex buffer to be iterated.
     * @property {object<string, pc.VertexIteratorAccessor>} element The vertex buffer elements.
     */
    function VertexIterator(vertexBuffer) {
        // Store the vertex buffer
        this.vertexBuffer = vertexBuffer;
        this.vertexFormatSize = vertexBuffer.getFormat().size;

        // Lock the vertex buffer
        this.buffer = this.vertexBuffer.lock();

        // Create an empty list
        this.accessors = [];
        this.element = {};

        // Add a new 'setter' function for each element
        var vertexFormat = this.vertexBuffer.getFormat();
        for (var i = 0; i < vertexFormat.elements.length; i++) {
            var vertexElement = vertexFormat.elements[i];
            this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
            this.element[vertexElement.name] = this.accessors[i];
        }
    }

    Object.assign(VertexIterator.prototype, {
        /**
         * @function
         * @name pc.VertexIterator#next
         * @description Moves the vertex iterator on to the next vertex.
         * @param {number} [count] - Optional number of steps to move on when calling next, defaults to 1.
         * @example
         * var iterator = new pc.VertexIterator(vertexBuffer);
         * iterator.element[pc.SEMANTIC_POSTIION].set(-0.9, -0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
         * iterator.next();
         * iterator.element[pc.SEMANTIC_POSTIION].set(0.9, -0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
         * iterator.next();
         * iterator.element[pc.SEMANTIC_POSTIION].set(0.0, 0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
         * iterator.end();
         */
        next: function (count) {
            if (count === undefined) count = 1;

            var i = 0;
            var accessors = this.accessors;
            var numAccessors = this.accessors.length;
            while (i < numAccessors) {
                var accessor = accessors[i++];
                accessor.index += count * accessor.stride;
            }
        },

        /**
         * @function
         * @name pc.VertexIterator#end
         * @description Notifies the vertex buffer being iterated that writes are complete. Internally
         * the vertex buffer is unlocked and vertex data is uploaded to video memory.
         * @example
         * var iterator = new pc.VertexIterator(vertexBuffer);
         * iterator.element[pc.SEMANTIC_POSTIION].set(-0.9, -0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(255, 0, 0, 255);
         * iterator.next();
         * iterator.element[pc.SEMANTIC_POSTIION].set(0.9, -0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(0, 255, 0, 255);
         * iterator.next();
         * iterator.element[pc.SEMANTIC_POSTIION].set(0.0, 0.9, 0.0);
         * iterator.element[pc.SEMANTIC_COLOR].set(0, 0, 255, 255);
         * iterator.end();
         */
        end: function () {
            // Unlock the vertex buffer
            this.vertexBuffer.unlock();
        },

        // Copies data for specified semantic into vertex buffer.
        // Works with both interleaved (slower) and non-interleaved (fast) vertex buffer
        writeData: function (semantic, data, numVertices) {
            var element = this.element[semantic];
            if (element) {

                if (numVertices > this.vertexBuffer.numVertices) {

                    // avoid overwrite
                    numVertices = this.vertexBuffer.numVertices;
                }

                var i, numComponents = element.numComponents;

                // copy data to interleaved buffer by looping over vertices and copying them manually
                if (this.vertexBuffer.getFormat().interleaved) {
                    var index = 0;
                    for (i = 0; i < numVertices; i++) {
                        element.setFromArray(index, data, i * numComponents);
                        index += element.stride;
                    }
                } else {    // non-interleaved copy

                    // if data contains more  data than needed, copy from its subarray
                    if (data.length > numVertices * numComponents) {
                        var copyCount = numVertices * numComponents;

                        // if data is typed array
                        if (ArrayBuffer.isView(data)) {
                            data = data.subarray(0, copyCount);
                            element.array.set(data);
                        } else {
                            // data is array, copy right amount manually
                            for (i = 0; i < copyCount; i++)
                                element.array[i] = data[i];
                        }
                    } else {
                        // copy whole data
                        element.array.set(data);
                    }
                }
            }
        },

        // Function to extract elements of a specified semantic from vertex buffer into flat array (data).
        // Works with both interleaved (slower) and non-interleaved (fast) vertex buffer
        // returns number of verticies
        // Note: when data is typed array and is smaller than needed, only part of data gets copied out (typed arrays ignore read/write out of range)
        readData: function (semantic, data) {
            var element = this.element[semantic];
            var count = 0;
            if (element) {
                count = this.vertexBuffer.numVertices;
                var i, numComponents = element.numComponents;

                if (this.vertexBuffer.getFormat().interleaved) {

                    // extract data from interleaved buffer by looping over vertices and copying them manually
                    if  (Array.isArray(data))
                        data.length = 0;

                    element.index = 0;
                    var offset = 0;
                    for (i = 0; i < count; i++) {
                        element.getToArray(offset, data, i * numComponents);
                        offset += element.stride;
                    }
                } else {
                    if (ArrayBuffer.isView(data)) {
                        // destination data is typed array
                        data.set(element.array);
                    } else {
                        // destination data is array
                        data.length = 0;
                        var copyCount = count * numComponents;
                        for (i = 0; i < copyCount; i++)
                            data[i] = element.array[i];
                    }
                }
            }

            return count;
        }
    });

    // Draws shaded full-screen quad in a single call
    var _postEffectQuadVB = null;
    var _postEffectQuadDraw = {
        type: PRIMITIVE_TRISTRIP,
        base: 0,
        count: 4,
        indexed: false
    };

    /**
     * @function
     * @name pc.drawQuadWithShader
     * @description Draws a screen-space quad using a specific shader. Mostly used by post-effects.
     * @param {pc.GraphicsDevice} device - The graphics device used to draw the quad.
     * @param {pc.RenderTarget|undefined} target - The destination render target. If undefined, target is the frame buffer.
     * @param {pc.Shader} shader - The shader used for rendering the quad. Vertex shader should contain `attribute vec2 vertex_position`.
     * @param {pc.Vec4} [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
     * @param {pc.Vec4} [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
     * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
     */
    function drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend) {
        if (_postEffectQuadVB === null) {
            var vertexFormat = new VertexFormat(device, [{
                semantic: SEMANTIC_POSITION,
                components: 2,
                type: TYPE_FLOAT32
            }]);
            _postEffectQuadVB = new VertexBuffer(device, vertexFormat, 4);

            var iterator = new VertexIterator(_postEffectQuadVB);
            iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
            iterator.next();
            iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
            iterator.next();
            iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
            iterator.next();
            iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
            iterator.end();
        }

        var oldRt = device.renderTarget;
        device.setRenderTarget(target);
        device.updateBegin();

        var x, y, w, h;
        var sx, sy, sw, sh;
        if (!rect) {
            w = target ? target.width : device.width;
            h = target ? target.height : device.height;
            x = 0;
            y = 0;
        } else {
            x = rect.x;
            y = rect.y;
            w = rect.z;
            h = rect.w;
        }

        if (!scissorRect) {
            sx = x;
            sy = y;
            sw = w;
            sh = h;
        } else {
            sx = scissorRect.x;
            sy = scissorRect.y;
            sw = scissorRect.z;
            sh = scissorRect.w;
        }

        var oldVx = device.vx;
        var oldVy = device.vy;
        var oldVw = device.vw;
        var oldVh = device.vh;
        device.setViewport(x, y, w, h);
        var oldSx = device.sx;
        var oldSy = device.sy;
        var oldSw = device.sw;
        var oldSh = device.sh;
        device.setScissor(sx, sy, sw, sh);

        var oldDepthTest = device.getDepthTest();
        var oldDepthWrite = device.getDepthWrite();
        var oldCullMode = device.getCullMode();
        var oldWR = device.writeRed;
        var oldWG = device.writeGreen;
        var oldWB = device.writeBlue;
        var oldWA = device.writeAlpha;
        device.setDepthTest(false);
        device.setDepthWrite(false);
        device.setCullMode(CULLFACE_NONE);
        device.setColorWrite(true, true, true, true);
        if (!useBlend) device.setBlending(false);

        device.setVertexBuffer(_postEffectQuadVB, 0);
        device.setShader(shader);

        device.draw(_postEffectQuadDraw);

        device.setDepthTest(oldDepthTest);
        device.setDepthWrite(oldDepthWrite);
        device.setCullMode(oldCullMode);
        device.setColorWrite(oldWR, oldWG, oldWB, oldWA);

        device.updateEnd();

        device.setRenderTarget(oldRt);
        device.updateBegin();

        device.setViewport(oldVx, oldVy, oldVw, oldVh);
        device.setScissor(oldSx, oldSy, oldSw, oldSh);
    }

    function destroyPostEffectQuad() {
        if (_postEffectQuadVB) {
            _postEffectQuadVB.destroy();
            _postEffectQuadVB = null;
        }
    }

    /**
     * @function
     * @name pc.drawTexture
     * @description Draws a texture in screen-space. Mostly used by post-effects.
     * @param {pc.GraphicsDevice} device - The graphics device used to draw the texture.
     * @param {pc.Texture} texture - The source texture to be drawn. Accessible as `uniform sampler2D source` in shader.
     * @param {pc.RenderTarget} [target] - The destination render target. Defaults to the frame buffer.
     * @param {pc.Shader} [shader] - The shader used for rendering the texture. Defaults to `pc.GraphicsDevice#getCopyShader()`.
     * @param {pc.Vec4} [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
     * @param {pc.Vec4} [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
     * @param {boolean} [useBlend] - True to enable blending. Defaults to false, disabling blending.
     */
    function drawTexture(device, texture, target, shader, rect, scissorRect, useBlend) {
        shader = shader || device.getCopyShader();
        device.constantTexSource.setValue(texture);
        drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);
    }

    /**
     * @constant
     * @name pc.BLEND_SUBTRACTIVE
     * @type {number}
     * @description Subtract the color of the source fragment from the destination fragment
     * and write the result to the frame buffer.
     */
    var BLEND_SUBTRACTIVE = 0;
    /**
     * @constant
     * @name pc.BLEND_ADDITIVE
     * @type {number}
     * @description Add the color of the source fragment to the destination fragment
     * and write the result to the frame buffer.
     */
    var BLEND_ADDITIVE = 1;
    /**
     * @constant
     * @name pc.BLEND_NORMAL
     * @type {number}
     * @description Enable simple translucency for materials such as glass. This is
     * equivalent to enabling a source blend mode of pc.BLENDMODE_SRC_ALPHA and a destination
     * blend mode of pc.BLENDMODE_ONE_MINUS_SRC_ALPHA.
     */
    var BLEND_NORMAL = 2;
    /**
     * @constant
     * @name pc.BLEND_NONE
     * @type {number}
     * @description Disable blending.
     */
    var BLEND_NONE = 3;
    /**
     * @constant
     * @name pc.BLEND_PREMULTIPLIED
     * @type {number}
     * @description Similar to pc.BLEND_NORMAL expect the source fragment is assumed to have
     * already been multiplied by the source alpha value.
     */
    var BLEND_PREMULTIPLIED = 4;
    /**
     * @constant
     * @name pc.BLEND_MULTIPLICATIVE
     * @type {number}
     * @description Multiply the color of the source fragment by the color of the destination
     * fragment and write the result to the frame buffer.
     */
    var BLEND_MULTIPLICATIVE = 5;
    /**
     * @constant
     * @name pc.BLEND_ADDITIVEALPHA
     * @type {number}
     * @description Same as pc.BLEND_ADDITIVE except the source RGB is multiplied by the source alpha.
     */
    var BLEND_ADDITIVEALPHA = 6;

    /**
     * @constant
     * @name pc.BLEND_MULTIPLICATIVE2X
     * @type {number}
     * @description Multiplies colors and doubles the result.
     */
    var BLEND_MULTIPLICATIVE2X = 7;

    /**
     * @constant
     * @name pc.BLEND_SCREEN
     * @type {number}
     * @description Softer version of additive.
     */
    var BLEND_SCREEN = 8;

    /**
     * @constant
     * @name pc.BLEND_MIN
     * @type {number}
     * @description Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
     */
    var BLEND_MIN = 9;

    /**
     * @constant
     * @name pc.BLEND_MAX
     * @type {number}
     * @description Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
     */
    var BLEND_MAX = 10;

    /**
     * @constant
     * @name pc.FOG_NONE
     * @type {string}
     * @description No fog is applied to the scene.
     */
    var FOG_NONE = 'none';
    /**
     * @constant
     * @name pc.FOG_LINEAR
     * @type {string}
     * @description Fog rises linearly from zero to 1 between a start and end depth.
     */
    var FOG_LINEAR = 'linear';
    /**
     * @constant
     * @name pc.FOG_EXP
     * @type {string}
     * @description Fog rises according to an exponential curve controlled by a density value.
     */
    var FOG_EXP = 'exp';
    /**
     * @constant
     * @name pc.FOG_EXP2
     * @type {string}
     * @description Fog rises according to an exponential curve controlled by a density value.
     */
    var FOG_EXP2 = 'exp2';

    /**
     * @constant
     * @name pc.FRESNEL_NONE
     * @type {number}
     * @description No Fresnel.
     */
    var FRESNEL_NONE = 0;
    /**
     * @constant
     * @name pc.FRESNEL_SCHLICK
     * @type {number}
     * @description Schlick's approximation of Fresnel.
     */
    var FRESNEL_SCHLICK = 2;

    // Legacy
    var LAYER_HUD = 0;
    var LAYER_GIZMO = 1;
    var LAYER_FX = 2;
    // 3 - 14 are custom user layers
    var LAYER_WORLD = 15;

    // New layers
    /**
     * @constant
     * @name pc.LAYERID_WORLD
     * @type {number}
     * @description The world layer.
     */
    var LAYERID_WORLD = 0;
    /**
     * @constant
     * @name pc.LAYERID_DEPTH
     * @type {number}
     * @description The depth layer.
     */
    var LAYERID_DEPTH = 1;
    /**
     * @constant
     * @name pc.LAYERID_SKYBOX
     * @type {number}
     * @description The skybox layer.
     */
    var LAYERID_SKYBOX = 2;
    /**
     * @constant
     * @name pc.LAYERID_IMMEDIATE
     * @type {number}
     * @description The immediate layer.
     */
    var LAYERID_IMMEDIATE = 3;
    /**
     * @constant
     * @name pc.LAYERID_UI
     * @type {number}
     * @description The UI layer.
     */
    var LAYERID_UI = 4;

    /**
     * @constant
     * @name pc.LIGHTTYPE_DIRECTIONAL
     * @type {number}
     * @description Directional (global) light source.
     */
    var LIGHTTYPE_DIRECTIONAL = 0;
    /**
     * @constant
     * @name pc.LIGHTTYPE_POINT
     * @type {number}
     * @description Point (local) light source.
     */
    var LIGHTTYPE_POINT = 1;
    /**
     * @constant
     * @name pc.LIGHTTYPE_SPOT
     * @type {number}
     * @description Spot (local) light source.
     */
    var LIGHTTYPE_SPOT = 2;

    /**
     * @constant
     * @name pc.LIGHTFALLOFF_LINEAR
     * @type {number}
     * @description Linear distance falloff model for light attenuation.
     */
    var LIGHTFALLOFF_LINEAR = 0;
    /**
     * @constant
     * @name pc.LIGHTFALLOFF_INVERSESQUARED
     * @type {number}
     * @description Inverse squared distance falloff model for light attenuation.
     */
    var LIGHTFALLOFF_INVERSESQUARED = 1;

    /**
     * @constant
     * @name pc.SHADOW_PCF3
     * @type {number}
     * @description Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
     */
    var SHADOW_PCF3 = 0;
    var SHADOW_DEPTH = 0; // alias for SHADOW_PCF3 for backwards compatibility
    /**
     * @constant
     * @name pc.SHADOW_VSM8
     * @type {number}
     * @description Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.
     */
    var SHADOW_VSM8 = 1;
    /**
     * @constant
     * @name pc.SHADOW_VSM16
     * @type {number}
     * @description Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.
     */
    var SHADOW_VSM16 = 2;
    /**
     * @constant
     * @name pc.SHADOW_VSM32
     * @type {number}
     * @description Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.
     */
    var SHADOW_VSM32 = 3;
    /**
     * @constant
     * @name pc.SHADOW_PCF5
     * @type {number}
     * @description Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires WebGL2. Falls back to pc.SHADOW_PCF3 on WebGL 1.0.
     */
    var SHADOW_PCF5 = 4;

    /**
     * @constant
     * @name pc.BLUR_BOX
     * @type {number}
     * @description Box filter.
     */
    var BLUR_BOX = 0;
    /**
     * @constant
     * @name pc.BLUR_GAUSSIAN
     * @type {number}
     * @description Gaussian filter. May look smoother than box, but requires more samples.
     */
    var BLUR_GAUSSIAN = 1;

    /**
     * @constant
     * @name pc.PARTICLESORT_NONE
     * @type {number}
     * @description No sorting, particles are drawn in arbitary order. Can be simulated on GPU.
     */
    var PARTICLESORT_NONE = 0;
    /**
     * @constant
     * @name pc.PARTICLESORT_DISTANCE
     * @type {number}
     * @description Sorting based on distance to the camera. CPU only.
     */
    var PARTICLESORT_DISTANCE = 1;
    /**
     * @constant
     * @name pc.PARTICLESORT_NEWER_FIRST
     * @type {number}
     * @description Newer particles are drawn first. CPU only.
     */
    var PARTICLESORT_NEWER_FIRST = 2;
    /**
     * @constant
     * @name pc.PARTICLESORT_OLDER_FIRST
     * @type {number}
     * @description Older particles are drawn first. CPU only.
     */
    var PARTICLESORT_OLDER_FIRST = 3;

    var PARTICLEMODE_GPU = 0;
    var PARTICLEMODE_CPU = 1;

    /**
     * @constant
     * @name pc.EMITTERSHAPE_BOX
     * @type {number}
     * @description Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
     */
    var EMITTERSHAPE_BOX = 0;
    /**
     * @constant
     * @name pc.EMITTERSHAPE_SPHERE
     * @type {number}
     * @description Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the center.
     */
    var EMITTERSHAPE_SPHERE = 1;

    /**
     * @constant
     * @name pc.PARTICLEORIENTATION_SCREEN
     * @type {number}
     * @description Particles are facing camera.
     */
    var PARTICLEORIENTATION_SCREEN = 0;
    /**
     * @constant
     * @name pc.PARTICLEORIENTATION_WORLD
     * @type {number}
     * @description User defines world space normal (particleNormal) to set planes orientation.
     */
    var PARTICLEORIENTATION_WORLD = 1;
    /**
     * @constant
     * @name pc.PARTICLEORIENTATION_EMITTER
     * @type {number}
     * @description Similar to previous, but the normal is affected by emitter(entity) transformation.
     */
    var PARTICLEORIENTATION_EMITTER = 2;

    /**
     * @constant
     * @name pc.PROJECTION_PERSPECTIVE
     * @type {number}
     * @description A perspective camera projection where the frustum shape is essentially pyramidal.
     */
    var PROJECTION_PERSPECTIVE = 0;
    /**
     * @constant
     * @name pc.PROJECTION_ORTHOGRAPHIC
     * @type {number}
     * @description An orthographic camera projection where the frustum shape is essentially a cuboid.
     */
    var PROJECTION_ORTHOGRAPHIC = 1;

    /**
     * @constant
     * @name pc.RENDERSTYLE_SOLID
     * @type {number}
     * @description Render mesh instance as solid geometry.
     */
    var RENDERSTYLE_SOLID = 0;
    /**
     * @constant
     * @name pc.RENDERSTYLE_WIREFRAME
     * @type {number}
     * @description Render mesh instance as wireframe.
     */
    var RENDERSTYLE_WIREFRAME = 1;
    /**
     * @constant
     * @name pc.RENDERSTYLE_POINTS
     * @type {number}
     * @description Render mesh instance as points.
     */
    var RENDERSTYLE_POINTS = 2;

    /**
     * @constant
     * @name pc.CUBEPROJ_NONE
     * @type {number}
     * @description The cube map is treated as if it is infinitely far away.
     */
    var CUBEPROJ_NONE = 0;
    /**
     * @constant
     * @name pc.CUBEPROJ_BOX
     * @type {number}
     * @description The cube map is box-projected based on a world space axis-aligned bounding box.
     */
    var CUBEPROJ_BOX = 1;

    /**
     * @constant
     * @name pc.SPECULAR_PHONG
     * @type {number}
     * @description Phong without energy conservation. You should only use it as a backwards compatibility with older projects.
     */
    var SPECULAR_PHONG = 0;
    /**
     * @constant
     * @name pc.SPECULAR_BLINN
     * @type {number}
     * @description Energy-conserving Blinn-Phong.
     */
    var SPECULAR_BLINN = 1;

    /**
     * @constant
     * @name pc.DETAILMODE_MUL
     * @type {string}
     * @description Multiply together the primary and secondary colors.
     */
    var DETAILMODE_MUL = 'mul';
    /**
     * @constant
     * @name pc.DETAILMODE_ADD
     * @type {string}
     * @description Add together the primary and secondary colors.
     */
    var DETAILMODE_ADD = 'add';
    /**
     * @constant
     * @name pc.DETAILMODE_SCREEN
     * @type {string}
     * @description Softer version of {@link pc.DETAILMODE_ADD}.
     */
    var DETAILMODE_SCREEN = 'screen';
    /**
     * @constant
     * @name pc.DETAILMODE_OVERLAY
     * @type {string}
     * @description Multiplies or screens the colors, depending on the primary color.
     */
    var DETAILMODE_OVERLAY = 'overlay';
    /**
     * @constant
     * @name pc.DETAILMODE_MIN
     * @type {string}
     * @description Select whichever of the primary and secondary colors is darker, component-wise.
     */
    var DETAILMODE_MIN = 'min';
    /**
     * @constant
     * @name pc.DETAILMODE_MAX
     * @type {string}
     * @description Select whichever of the primary and secondary colors is lighter, component-wise.
     */
    var DETAILMODE_MAX = 'max';

    /**
     * @constant
     * @name pc.GAMMA_NONE
     * @type {number}
     * @description No gamma correction.
     */
    var GAMMA_NONE = 0;
    /**
     * @constant
     * @name pc.GAMMA_SRGB
     * @type {number}
     * @description Apply sRGB gamma correction.
     */
    var GAMMA_SRGB = 1;
    /**
     * @deprecated
     * @constant
     * @name pc.GAMMA_SRGBFAST
     * @type {number}
     * @description Apply sRGB (fast) gamma correction.
     */
    var GAMMA_SRGBFAST = 2; // deprecated
    /**
     * @constant
     * @name pc.GAMMA_SRGBHDR
     * @type {number}
     * @description Apply sRGB (HDR) gamma correction.
     */
    var GAMMA_SRGBHDR = 3;

    /**
     * @constant
     * @name pc.TONEMAP_LINEAR
     * @type {number}
     * @description Linear tonemapping.
     */
    var TONEMAP_LINEAR = 0;
    /**
     * @constant
     * @name pc.TONEMAP_FILMIC
     * @type {number}
     * @description Filmic tonemapping curve.
     */
    var TONEMAP_FILMIC = 1;
    /**
     * @constant
     * @name pc.TONEMAP_HEJL
     * @type {number}
     * @description Hejl filmic tonemapping curve.
     */
    var TONEMAP_HEJL = 2;
    /**
     * @constant
     * @name pc.TONEMAP_ACES
     * @type {number}
     * @description ACES filmic tonemapping curve.
     */
    var TONEMAP_ACES = 3;
    /**
     * @constant
     * @name pc.TONEMAP_ACES2
     * @type {number}
     * @description ACES v2 filmic tonemapping curve.
     */
    var TONEMAP_ACES2 = 4;

    /**
     * @constant
     * @name pc.SPECOCC_NONE
     * @type {number}
     * @description No specular occlusion.
     */
    var SPECOCC_NONE = 0;
    /**
     * @constant
     * @name pc.SPECOCC_AO
     * @type {number}
     * @description Use AO directly to occlude specular.
     */
    var SPECOCC_AO = 1;
    /**
     * @constant
     * @name pc.SPECOCC_GLOSSDEPENDENT
     * @type {number}
     * @description Modify AO based on material glossiness/view angle to occlude specular.
     */
    var SPECOCC_GLOSSDEPENDENT = 2;

    // 16 bits for shader defs
    var SHADERDEF_NOSHADOW = 1;
    var SHADERDEF_SKIN = 2;
    var SHADERDEF_UV0 = 4;
    var SHADERDEF_UV1 = 8;
    var SHADERDEF_VCOLOR = 16;
    var SHADERDEF_INSTANCING = 32;
    var SHADERDEF_LM = 64;
    var SHADERDEF_DIRLM = 128;
    var SHADERDEF_SCREENSPACE = 256;
    var SHADERDEF_TANGENTS = 512;
    var SHADERDEF_MORPH_POSITION = 1024;
    var SHADERDEF_MORPH_NORMAL = 2048;

    var LINEBATCH_WORLD = 0;
    var LINEBATCH_OVERLAY = 1;
    var LINEBATCH_GIZMO = 2;

    /**
     * @constant
     * @name pc.SHADOWUPDATE_NONE
     * @type {number}
     * @description The shadow map is not to be updated.
     */
    var SHADOWUPDATE_NONE = 0;
    /**
     * @constant
     * @name pc.SHADOWUPDATE_THISFRAME
     * @type {number}
     * @description The shadow map is regenerated this frame and not on subsequent frames.
     */
    var SHADOWUPDATE_THISFRAME = 1;
    /**
     * @constant
     * @name pc.SHADOWUPDATE_REALTIME
     * @type {number}
     * @description The shadow map is regenerated every frame.
     */
    var SHADOWUPDATE_REALTIME = 2;

    var SORTKEY_FORWARD = 0;
    var SORTKEY_DEPTH = 1;

    var MASK_DYNAMIC = 1;
    var MASK_BAKED = 2;
    var MASK_LIGHTMAP = 4;

    /**
     * @constant
     * @name pc.SHADER_FORWARD
     * @type {number}
     * @description Render shaded materials with gamma correction and tonemapping.
     */
    var SHADER_FORWARD = 0;

    /**
     * @constant
     * @name pc.SHADER_FORWARDHDR
     * @type {number}
     * @description Render shaded materials without gamma correction and tonemapping.
     */
    var SHADER_FORWARDHDR = 1;

    /**
     * @constant
     * @name pc.SHADER_DEPTH
     * @type {number}
     * @description Render RGBA-encoded depth value.
     */
    var SHADER_DEPTH = 2;

    // next are undocumented
    var SHADER_SHADOW = 3; // PCF3
    // 4 = VSM8,
    // 5 = VSM16,
    // 6 = VSM32,
    // 7 = PCF5,
    // 8 = PCF3 POINT
    // 9 = VSM8 POINT,
    // 10 = VSM16 POINT,
    // 11 = VSM32 POINT,
    // 12 = PCF5 POINT
    // 13 = PCF3 SPOT
    // 14 = VSM8 SPOT,
    // 15 = VSM16 SPOT,
    // 16 = VSM32 SPOT,
    // 17 = PCF5 SPOT
    var SHADER_PICK = 18;

    /**
     * @constant
     * @type {number}
     * @name pc.SPRITE_RENDERMODE_SIMPLE
     * @description This mode renders a sprite as a simple quad.
     */
    var SPRITE_RENDERMODE_SIMPLE = 0;

    /**
     * @constant
     * @type {number}
     * @name pc.SPRITE_RENDERMODE_SLICED
     * @description This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the
     * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
     * both horizontally and vertically.
     */
    var SPRITE_RENDERMODE_SLICED = 1;

    /**
     * @constant
     * @type {number}
     * @name pc.SPRITE_RENDERMODE_TILED
     * @description This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the
     * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
     * both horizontally and vertically.
     */
    var SPRITE_RENDERMODE_TILED = 2;

    /**
     * @constant
     * @name pc.BAKE_COLOR
     * @type {number}
     * @description Single color lightmap.
     */
    var BAKE_COLOR = 0;
    /**
     * @constant
     * @name pc.BAKE_COLORDIR
     * @type {number}
     * @description Single color lightmap + dominant light direction (used for bump/specular).
     */
    var BAKE_COLORDIR = 1;

    /**
     * @constant
     * @name pc.VIEW_CENTER
     * @type {number}
     * @description Center of view.
     */
    var VIEW_CENTER = 0;
    /**
     * @constant
     * @name pc.VIEW_LEFT
     * @type {number}
     * @description Left of view. Only used in stereo rendering.
     */
    var VIEW_LEFT = 1;
    /**
     * @constant
     * @name pc.VIEW_RIGHT
     * @type {number}
     * @description Right of view. Only used in stereo rendering.
     */
    var VIEW_RIGHT = 2;

    /**
     * @constant
     * @name pc.SORTMODE_NONE
     * @type {number}
     * @description No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
     */
    var SORTMODE_NONE = 0;

    /**
     * @constant
     * @name pc.SORTMODE_MANUAL
     * @type {number}
     * @description Mesh instances are sorted based on {@link pc.MeshInstance#drawOrder}.
     */
    var SORTMODE_MANUAL = 1;

    /**
     * @constant
     * @name pc.SORTMODE_MATERIALMESH
     * @type {number}
     * @description Mesh instances are sorted to minimize switching between materials and meshes to improve rendering performance.
     */
    var SORTMODE_MATERIALMESH = 2;

    /**
     * @constant
     * @name pc.SORTMODE_BACK2FRONT
     * @type {number}
     * @description Mesh instances are sorted back to front. This is the way to properly render many semi-transparent objects on different depth, one is blended on top of another.
     */
    var SORTMODE_BACK2FRONT = 3;

    /**
     * @constant
     * @name pc.SORTMODE_FRONT2BACK
     * @type {number}
     * @description Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give better performance than pc.SORTMODE_MATERIALMESH due to reduced overdraw.
     */
    var SORTMODE_FRONT2BACK = 4;

    /**
     * @private
     * @constant
     * @name  pc.SORTMODE_CUSTOM
     * @type {number}
     * @description Provide custom functions for sorting drawcalls and calculating distance.
     */
    var SORTMODE_CUSTOM = 5;

    var COMPUPDATED_INSTANCES = 1;
    var COMPUPDATED_LIGHTS = 2;
    var COMPUPDATED_CAMERAS = 4;
    var COMPUPDATED_BLEND = 8;

    /**
     * @constant
     * @name pc.ASPECT_AUTO
     * @type {number}
     * @description Automatically set aspect ratio to current render target's width divided by height.
     */
    var ASPECT_AUTO = 0;
    /**
     * @constant
     * @name pc.ASPECT_MANUAL
     * @type {number}
     * @description Use the manual aspect ratio value.
     */
    var ASPECT_MANUAL = 1;

    /**
     * @constant
     * @name pc.ORIENTATION_HORIZONTAL
     * @type {number}
     * @description Horizontal orientation.
     */
    var ORIENTATION_HORIZONTAL = 0;
    /**
     * @constant
     * @name pc.ORIENTATION_VERTICAL
     * @type {number}
     * @description Vertical orientation.
     */
    var ORIENTATION_VERTICAL = 1;

    var basic = {
        generateKey: function (options) {
            var key = 'basic';
            if (options.fog)          key += '_fog';
            if (options.alphaTest)    key += '_atst';
            if (options.vertexColors) key += '_vcol';
            if (options.diffuseMap)   key += '_diff';
            key += '_' + options.pass;
            return key;
        },

        createShaderDefinition: function (device, options) {
            // GENERATE ATTRIBUTES
            var attributes = {
                vertex_position: SEMANTIC_POSITION
            };
            if (options.skin) {
                attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
                attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
            }
            if (options.vertexColors) {
                attributes.vertex_color = SEMANTIC_COLOR;
            }
            if (options.diffuseMap) {
                attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
            }

            var chunks = shaderChunks;

            // GENERATE VERTEX SHADER
            var code = '';

            // VERTEX SHADER DECLARATIONS
            code += chunks.transformDeclVS;

            if (options.skin) {
                code += programlib.skinCode(device);
                code += chunks.transformSkinnedVS;
            } else {
                code += chunks.transformVS;
            }

            if (options.vertexColors) {
                code += 'attribute vec4 vertex_color;\n';
                code += 'varying vec4 vColor;\n';
            }
            if (options.diffuseMap) {
                code += 'attribute vec2 vertex_texCoord0;\n';
                code += 'varying vec2 vUv0;\n';
            }

            if (options.pass === SHADER_DEPTH) {
                code += 'varying float vDepth;\n';
                code += '#ifndef VIEWMATRIX\n';
                code += '#define VIEWMATRIX\n';
                code += 'uniform mat4 matrix_view;\n';
                code += '#endif\n';
                code += '#ifndef CAMERAPLANES\n';
                code += '#define CAMERAPLANES\n';
                code += 'uniform vec4 camera_params;\n\n';
                code += '#endif\n';
            }

            // VERTEX SHADER BODY
            code += programlib.begin();

            code += "   gl_Position = getPosition();\n";

            if (options.pass === SHADER_DEPTH) {
                code += "    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n";
            }

            if (options.vertexColors) {
                code += '    vColor = vertex_color;\n';
            }
            if (options.diffuseMap) {
                code += '    vUv0 = vertex_texCoord0;\n';
            }

            code += programlib.end();

            var vshader = code;

            // GENERATE FRAGMENT SHADER
            code = programlib.precisionCode(device);

            // FRAGMENT SHADER DECLARATIONS
            if (options.vertexColors) {
                code += 'varying vec4 vColor;\n';
            } else {
                code += 'uniform vec4 uColor;\n';
            }
            if (options.diffuseMap) {
                code += 'varying vec2 vUv0;\n';
                code += 'uniform sampler2D texture_diffuseMap;\n';
            }
            if (options.fog) {
                code += programlib.fogCode(options.fog);
            }
            if (options.alphatest) {
                code += chunks.alphaTestPS;
            }

            if (options.pass === SHADER_DEPTH) {
                // ##### SCREEN DEPTH PASS #####
                code += 'varying float vDepth;\n';
                code += chunks.packDepthPS;
            }

            // FRAGMENT SHADER BODY
            code += programlib.begin();

            // Read the map texels that the shader needs
            if (options.vertexColors) {
                code += '    gl_FragColor = vColor;\n';
            } else {
                code += '    gl_FragColor = uColor;\n';
            }
            if (options.diffuseMap) {
                code += '    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n';
            }

            if (options.alphatest) {
                code += "   alphaTest(gl_FragColor.a);\n";
            }

            if (options.pass === SHADER_PICK) ; else if (options.pass === SHADER_DEPTH) {
                // ##### SCREEN DEPTH PASS #####
                code += "    gl_FragColor = packFloat(vDepth);\n";
            } else {
                // ##### FORWARD PASS #####
                if (options.fog) {
                    code += "   glFragColor.rgb = addFog(gl_FragColor.rgb);\n";
                }
            }

            code += programlib.end();

            var fshader = code;

            return {
                attributes: attributes,
                vshader: vshader,
                fshader: fshader
            };
        }
    };

    var particle = {
        generateKey: function (options) {
            var key = "particle";
            for (var prop in options) {
                if (options.hasOwnProperty(prop)) {
                    key += options[prop];
                }
            }
            return key;
        },

        _animTex: function (options, chunk) {
            var vshader = "";
            vshader += options.animTexLoop ? chunk.particleAnimFrameLoopVS : chunk.particleAnimFrameClampVS;
            vshader += chunk.particleAnimTexVS;
            return vshader;
        },

        createShaderDefinition: function (device, options) {

            var chunk = shaderChunks;

            var vshader = "";
            var fshader = programlib.precisionCode(device) + "\n";

            if (device.webgl2) {
                vshader += "#define GL2\n";
                fshader += "#define GL2\n";
            }
            vshader += "#define VERTEXSHADER\n";
            if (options.mesh) vshader += "#define USE_MESH\n";
            if (options.localSpace) vshader += "#define LOCAL_SPACE\n";

            if (options.animTex) vshader += "\nuniform vec2 animTexTilesParams;\n";
            if (options.animTex) vshader += "\nuniform vec4 animTexParams;\n";
            if (options.animTex) vshader += "\nuniform vec2 animTexIndexParams;\n";
            if (options.normal == 2) vshader += "\nvarying mat3 ParticleMat;\n";
            if (options.normal == 1) vshader += "\nvarying vec3 Normal;\n";
            if (options.soft) vshader += "\nvarying float vDepth;\n";

            var faceVS = options.customFace ? chunk.particle_customFaceVS : chunk.particle_billboardVS;

            if (!options.useCpu) {
                vshader += chunk.particle_initVS;
                vshader += (options.pack8 ? chunk.particleInputRgba8PS : chunk.particleInputFloatPS);
                if (options.soft > 0) vshader += chunk.screenDepthPS;
                vshader += chunk.particleVS;
                if (options.localSpace) vshader += chunk.particle_localShiftVS;
                if (options.animTex) vshader += this._animTex(options, chunk);
                if (options.wrap) vshader += chunk.particle_wrapVS;
                if (options.alignToMotion) vshader += chunk.particle_pointAlongVS;
                vshader += options.mesh ? chunk.particle_meshVS : faceVS;
                if (options.normal == 1) vshader += chunk.particle_normalVS;
                if (options.normal == 2) vshader += chunk.particle_TBNVS;
                if (options.stretch > 0.0) vshader += chunk.particle_stretchVS;
                vshader += chunk.particle_endVS;
                if (options.soft > 0) vshader += chunk.particle_softVS;
            } else {
                if (options.soft > 0) vshader += chunk.screenDepthPS;
                vshader += chunk.particle_cpuVS;
                if (options.localSpace) vshader += chunk.particle_localShiftVS;
                if (options.animTex) vshader += this._animTex(options, chunk);
                // if (options.wrap) vshader += chunk.particle_wrapVS;
                if (options.alignToMotion) vshader += chunk.particle_pointAlongVS;
                vshader += options.mesh ? chunk.particle_meshVS : faceVS;
                if (options.normal == 1) vshader += chunk.particle_normalVS;
                if (options.normal == 2) vshader += chunk.particle_TBNVS;
                if (options.stretch > 0.0) vshader += chunk.particle_stretchVS;
                vshader += chunk.particle_cpu_endVS;
                if (options.soft > 0) vshader += chunk.particle_softVS;
            }
            vshader += "}\n";

            if (options.normal > 0) {
                if (options.normal == 1) {
                    fshader += "\nvarying vec3 Normal;\n";
                } else if (options.normal == 2) {
                    fshader += "\nvarying mat3 ParticleMat;\n";
                }
                fshader += "\nuniform vec3 lightCube[6];\n";
            }
            if (options.soft) fshader += "\nvarying float vDepth;\n";

            if ((options.normal === 0) && (options.fog === "none")) options.srgb = false; // don't have to perform all gamma conversions when no lighting and fogging is used
            fshader += programlib.gammaCode(options.gamma);
            fshader += programlib.tonemapCode(options.toneMap);

            if (options.fog === 'linear') {
                fshader += chunk.fogLinearPS;
            } else if (options.fog === 'exp') {
                fshader += chunk.fogExpPS;
            } else if (options.fog === 'exp2') {
                fshader += chunk.fogExp2PS;
            } else {
                fshader += chunk.fogNonePS;
            }

            if (options.normal == 2) fshader += "\nuniform sampler2D normalMap;\n";
            if (options.soft > 0) fshader += chunk.screenDepthPS;
            fshader += chunk.particlePS;
            if (options.soft > 0) fshader += chunk.particle_softPS;
            if (options.normal == 1) fshader += "\nvec3 normal = Normal;\n";
            if (options.normal == 2) fshader += chunk.particle_normalMapPS;
            if (options.normal > 0) fshader += options.halflambert ? chunk.particle_halflambertPS : chunk.particle_lambertPS;
            if (options.normal > 0) fshader += chunk.particle_lightingPS;
            if (options.blend == BLEND_NORMAL) {
                fshader += chunk.particle_blendNormalPS;
            } else if (options.blend == BLEND_ADDITIVE) {
                fshader += chunk.particle_blendAddPS;
            } else if (options.blend == BLEND_MULTIPLICATIVE) {
                fshader += chunk.particle_blendMultiplyPS;
            }
            fshader += chunk.particle_endPS;

            var attributes = shaderChunks.collectAttribs(vshader);

            return {
                attributes: attributes,
                vshader: vshader,
                fshader: fshader
            };
        }
    };

    var skybox = {
        generateKey: function (options) {
            var key = "skybox" + options.rgbm + " " + options.hdr + " " + options.fixSeams + "" +
                      options.toneMapping + "" + options.gamma + "" + options.useIntensity + "" + options.mip;
            return key;
        },

        createShaderDefinition: function (device, options) {
            var chunks = shaderChunks;
            var mip2size = [128, 64, 16, 8, 4, 2];

            return {
                attributes: {
                    aPosition: SEMANTIC_POSITION
                },
                vshader: chunks.skyboxVS,
                fshader: programlib.precisionCode(device) +
                    (options.mip ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) +
                    (options.useIntensity ? chunks.envMultiplyPS : chunks.envConstPS) +
                    programlib.gammaCode(options.gamma) + programlib.tonemapCode(options.toneMapping) + chunks.rgbmPS +
                    chunks.skyboxHDRPS.replace(/\$textureCubeSAMPLE/g, options.rgbm ? "textureCubeRGBM" : (options.hdr ? "textureCube" : "textureCubeSRGB"))
                        .replace(/\$FIXCONST/g, (1.0 - 1.0 / mip2size[options.mip]) + "")
            };
        }
    };

    var _oldChunkFloat = function (s, o, p) {
        return "\n#ifdef MAPFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkColor = function (s, o, p) {
        return "\n#ifdef MAPCOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTex = function (s, o, p) {
        return "\n#ifdef MAPTEXTURE\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTexColor = function (s, o, p) {
        return "#undef MAPTEXTURECOLOR\n#ifdef MAPTEXTURE\n#ifdef MAPCOLOR\n#define MAPTEXTURECOLOR\n#endif\n#endif\n" +
                "#ifdef MAPTEXTURECOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTexFloat = function (s, o, p) {
        return "#undef MAPTEXTUREFLOAT\n#ifdef MAPTEXTURE\n#ifdef MAPFLOAT\n#define MAPTEXTUREFLOAT\n#endif\n#endif\n" +
                "#ifdef MAPTEXTUREFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkVert = function (s, o, p) {
        return "\n#ifdef MAPVERTEX\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkVertColor = function (s, o, p) {
        return "#undef MAPVERTEXCOLOR\n#ifdef MAPVERTEX\n#ifdef MAPCOLOR\n#define MAPVERTEXCOLOR\n#endif\n#endif\n" +
                "#ifdef MAPVERTEXCOLOR\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkVertFloat = function (s, o, p) {
        return "#undef MAPVERTEXFLOAT\n#ifdef MAPVERTEX\n#ifdef MAPFLOAT\n#define MAPVERTEXFLOAT\n#endif\n#endif\n" +
                "#ifdef MAPVERTEXFLOAT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformSkin = function (s, o, p) {
        return "\n#ifdef SKIN\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformDynbatch = function (s, o, p) {
        return "\n#ifdef DYNAMICBATCH\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformInstanced = function (s, o, p) {
        return "\n#ifdef INSTANCING\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformPixelSnap = function (s, o, p) {
        return "\n#ifdef PIXELSNAP\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformScreenSpace = function (s, o, p) {
        return "\n#ifdef SCREENSPACE\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformScreenSpaceBatch = function (s, o, p) {
        return "#undef SCREENSPACEBATCH\n#ifdef SCREENSPACE\n#ifdef BATCH\n#define SCREENSPACEBATCH\n#endif\n#endif\n" +
                "#ifdef SCREENSPACEBATCH\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _oldChunkTransformUv1 = function (s, o, p) {
        return "\n#ifdef UV1LAYOUT\n" + s + "\n#else\n" + shaderChunks[o] + "\n#endif\n";
    };

    var _matTex2D = [];

    var standard = {

        _oldChunkToNew: {
            aoTexPS: { n: "aoPS", f: _oldChunkTex },
            aoVertPS: { n: "aoPS", f: _oldChunkVert },

            diffuseConstPS: { n: "diffusePS", f: _oldChunkColor },
            diffuseTexPS: { n: "diffusePS", f: _oldChunkTex },
            diffuseTexConstPS: { n: "diffusePS", f: _oldChunkTexColor },
            diffuseVertPS: { n: "diffusePS", f: _oldChunkVert },
            diffuseVertConstPS: { n: "diffusePS", f: _oldChunkVertColor },

            emissiveConstPS: { n: "emissivePS", f: _oldChunkColor },
            emissiveTexPS: { n: "emissivePS", f: _oldChunkTex },
            emissiveTexConstPS: { n: "emissivePS", f: _oldChunkTexColor },
            emissiveTexConstFloatPS: { n: "emissivePS", f: _oldChunkTexFloat },
            emissiveVertPS: { n: "emissivePS", f: _oldChunkVert },
            emissiveVertConstPS: { n: "emissivePS", f: _oldChunkVertColor },
            emissiveVertConstFloatPS: { n: "emissivePS", f: _oldChunkVertFloat },

            glossConstPS: { n: "glossPS", f: _oldChunkFloat },
            glossTexPS: { n: "glossPS", f: _oldChunkTex },
            glossTexConstPS: { n: "glossPS", f: _oldChunkTexFloat },
            glossVertPS: { n: "glossPS", f: _oldChunkVert },
            glossVertConstPS: { n: "glossPS", f: _oldChunkVertFloat },

            metalnessConstPS: { n: "metalnessPS", f: _oldChunkFloat },
            metalnessTexPS: { n: "metalnessPS", f: _oldChunkTex },
            metalnessTexConstPS: { n: "metalnessPS", f: _oldChunkTexFloat },
            metalnessVertPS: { n: "metalnessPS", f: _oldChunkVert },
            metalnessVertConstPS: { n: "metalnessPS", f: _oldChunkVertFloat },

            opacityConstPS: { n: "opacityPS", f: _oldChunkFloat },
            opacityTexPS: { n: "opacityPS", f: _oldChunkTex },
            opacityTexConstPS: { n: "opacityPS", f: _oldChunkTexFloat },
            opacityVertPS: { n: "opacityPS", f: _oldChunkVert },
            opacityVertConstPS: { n: "opacityPS", f: _oldChunkVertFloat },

            specularConstPS: { n: "specularPS", f: _oldChunkColor },
            specularTexPS: { n: "specularPS", f: _oldChunkTex },
            specularTexConstPS: { n: "specularPS", f: _oldChunkTexColor },
            specularVertPS: { n: "specularPS", f: _oldChunkVert },
            specularVertConstPS: { n: "specularPS", f: _oldChunkVertColor },

            transformBatchSkinnedVS: { n: "transformVS", f: _oldChunkTransformDynbatch },
            transformInstancedVS: { n: "transformVS", f: _oldChunkTransformInstanced },
            transformPixelSnapVS: { n: "transformVS", f: _oldChunkTransformPixelSnap },
            transformScreenSpaceVS: { n: "transformVS", f: _oldChunkTransformScreenSpace },
            transformScreenSpaceBatchSkinned: { n: "transformVS", f: _oldChunkTransformScreenSpaceBatch },
            transformSkinned: { n: "transformVS", f: _oldChunkTransformSkin },
            transformUv1: { n: "transformVS", f: _oldChunkTransformUv1 }
        },

        // Shared Sandard Material option structures
        optionsContext: {},
        optionsContextMin: {},

        generateKey: function (options) {
            var buildPropertiesList = function (options) {
                var props = [];
                for (var prop in options) {
                    if (options.hasOwnProperty(prop) && prop !== "chunks" && prop !== "lights")
                        props.push(prop);
                }
                return props.sort();
            };
            var props;
            if (options === this.optionsContextMin) {
                if (!this.propsMin) this.propsMin = buildPropertiesList(options);
                props = this.propsMin;
            } else if (options === this.optionsContext) {
                if (!this.props) this.props = buildPropertiesList(options);
                props = this.props;
            } else {
                props = buildPropertiesList(options);
            }

            var key = "standard";

            var i;
            for (i = 0; i < props.length; i++) {
                if (options[props[i]])
                    key += props[i] + options[props[i]];
            }

            if (options.chunks) {
                var chunks = [];
                for (var p in options.chunks) {
                    if (options.chunks.hasOwnProperty(p)) {
                        chunks.push(p + options.chunks[p]);
                    }
                }
                chunks.sort();
                key += chunks;
            }

            if (options.lights) {
                for (i = 0; i < options.lights.length; i++) {
                    key += options.lights[i].key;
                }
            }

            return hashCode(key);
        },

        _correctChannel: function (p, chan) {
            if (_matTex2D[p] > 0) {
                if (_matTex2D[p] < chan.length) {
                    return chan.substring(0, _matTex2D[p]);
                } else if (_matTex2D[p] > chan.length) {
                    var str = chan;
                    var chr = str.charAt(str.length - 1);
                    var addLen = _matTex2D[p] - str.length;
                    for (var i = 0; i < addLen; i++) str += chr;
                    return str;
                }
                return chan;
            }
        },

        _setMapTransform: function (codes, name, id, uv) {
            codes[0] += "uniform vec4 texture_" + name + "MapTransform;\n";

            var checkId = id + uv * 100;
            if (!codes[3][checkId]) {
                codes[1] += "varying vec2 vUV" + uv + "_" + id + ";\n";
                codes[2] += "   vUV" + uv + "_" + id + " = uv" + uv + " * texture_" + name + "MapTransform.xy + texture_" + name + "MapTransform.zw;\n";
                codes[3][checkId] = true;
            }
            return codes;
        },

        // get the value to replace $UV with in Map Shader functions

        /**
         * @private
         * @function
         * @name _getUvSourceExpression
         * @description Get the code with which to to replace '$UV' in the map shader functions.
         * @param  {string} transformPropName - Name of the transform id in the options block. Usually "basenameTransform".
         * @param  {string} uVPropName - Name of the UV channel in the options block. Usually "basenameUv".
         * @param  {object} options - The options passed into createShaderDefinition.
         * @returns {string} The code used to replace "$UV" in the shader code.
         */
        _getUvSourceExpression: function (transformPropName, uVPropName, options) {
            var transformId = options[transformPropName];
            var uvChannel = options[uVPropName];

            var expression;
            var isMainPass = (options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR);

            if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
                expression = "nineSlicedUv";
            } else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
                expression = "nineSlicedUv, -1000.0";
            } else {
                if (transformId === 0) {
                    expression = "vUv" + uvChannel;
                } else {
                    // note: different capitalization!
                    expression = "vUV" + uvChannel + "_" + transformId;
                }

                // if heightmap is enabled all maps except the heightmap are offset
                if (options.heightMap && transformPropName !== "heightMapTransform") {
                    expression += " + dUvOffset";
                }
            }

            return expression;
        },

        _addMapDef: function (name, enabled) {
            var s = "\n#undef " + name + "\n";
            if (enabled) s += " #define " + name + "\n";
            return s;
        },

        _addMapDefs: function (float, color, vertex, map) {
            var s = "";
            s += this._addMapDef("MAPFLOAT", float);
            s += this._addMapDef("MAPCOLOR", color);
            s += this._addMapDef("MAPVERTEX", vertex);
            s += this._addMapDef("MAPTEXTURE", map);
            return s;
        },

        /**
         * @private
         * @function
         * @name _addMap
         * @description Add chunk for Map Types (used for all maps except Normal).
         * @param {string} propName - The base name of the map: diffuse | emissive | opacity | light | height | metalness | specular | gloss | ao.
         * @param {string} chunkName - The name of the chunk to use. Usually "basenamePS".
         * @param {object} options - The options passed into to createShaderDefinition.
         * @param {object} chunks - The set of shader chunks to choose from.
         * @param {string} samplerFormat - Format of texture sampler to use - 0: "texture2DSRGB", 1: "texture2DRGBM", 2: "texture2D".
         * @returns {string} The shader code to support this map.
         */
        _addMap: function (propName, chunkName, options, chunks, samplerFormat) {
            var mapPropName = propName + "Map";

            var uVPropName = mapPropName + "Uv";
            var transformPropName = mapPropName + "Transform";
            var channelPropName = mapPropName + "Channel";
            var vertexColorChannelPropName = propName + "VertexColorChannel";
            var tintPropName = propName + "Tint";
            var vertexColorPropName = propName + "VertexColor";
            var detailModePropName = propName + "Mode";

            var tintOption = options[tintPropName];
            var vertexColorOption = options[vertexColorPropName];
            var textureOption = options[mapPropName];
            var detailModeOption = options[detailModePropName];

            var subCode = chunks[chunkName];

            if (textureOption) {
                var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);

                subCode = subCode.replace(/\$UV/g, uv).replace(/\$CH/g, options[channelPropName]);

                if (samplerFormat !== undefined) {
                    var fmt = samplerFormat === 0 ? "texture2DSRGB" : (samplerFormat === 1 ? "texture2DRGBM" : "texture2D");
                    subCode = subCode.replace(/\$texture2DSAMPLE/g, fmt);
                }
            }

            if (vertexColorOption) {
                subCode = subCode.replace(/\$VC/g, options[vertexColorChannelPropName]);
            }

            if (detailModeOption) {
                subCode = subCode.replace(/\$DETAILMODE/g, detailModeOption);
            }

            var isFloatTint = (tintOption === 1);
            var isVecTint = (tintOption === 3);

            subCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;
            return subCode.replace(/\$/g, "");
        },

        _nonPointShadowMapProjection: function (device, light, shadowCoordArgs) {
            if (!light._normalOffsetBias || light._isVsm) {
                if (light._type === LIGHTTYPE_SPOT) {
                    if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
                        return "       getShadowCoordPerspZbuffer" + shadowCoordArgs;
                    }
                    return "       getShadowCoordPersp" + shadowCoordArgs;
                }
                return "       getShadowCoordOrtho" + shadowCoordArgs;
            }
            if (light._type === LIGHTTYPE_SPOT) {
                if (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {
                    return "       getShadowCoordPerspZbufferNormalOffset" + shadowCoordArgs;
                }
                return "       getShadowCoordPerspNormalOffset" + shadowCoordArgs;
            }
            return "       getShadowCoordOrthoNormalOffset" + shadowCoordArgs;
        },

        _addVaryingIfNeeded: function (code, type, name) {
            return code.indexOf(name) >= 0 ? ("varying " + type + " " + name + ";\n") : "";
        },

        _vsAddTransformCode: function (code, device, chunks, options) {
            code += chunks.transformVS;

            return code;
        },

        _vsAddBaseCode: function (code, device, chunks, options) {
            code += chunks.baseVS;
            if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED ||
                options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
                code += chunks.baseNineSlicedVS;
            }

            return code;
        },

        /**
         * @private
         * @function
         * @name _fsAddBaseCode
         * @description Add "Base" Code section to fragment shader.
         * @param  {string} code - Current fragment shader code.
         * @param  {pc.GraphicsDevice} device - The graphics device.
         * @param  {object} chunks - All available shader chunks.
         * @param  {object} options - The Shader Definition options.
         * @returns {string} The new fragment shader code (old+new).
         */
        _fsAddBaseCode: function (code, device, chunks, options) {
            code += chunks.basePS;
            if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
                code += chunks.baseNineSlicedPS;
            } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
                code += chunks.baseNineSlicedTiledPS;
            }

            return code;
        },

        /**
         * @private
         * @function
         * @name  _fsAddStartCode
         * @description Add "Start" Code section to fragment shader.
         * @param  {string} code -  Current fragment shader code.
         * @param  {pc.GraphicsDevice} device - The graphics device.
         * @param  {object} chunks - All available shader chunks.
         * @param  {object} options - The Shader Definition options.
         * @returns {string} The new fragment shader code (old+new).
         */
        _fsAddStartCode: function (code, device, chunks, options) {
            code += chunks.startPS;

            if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
                code += chunks.startNineSlicedPS;
            } else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
                code += chunks.startNineSlicedTiledPS;
            }

            return code;
        },

        createShaderDefinition: function (device, options) {
            var i, p;
            var lighting = options.lights.length > 0;

            if (options.dirLightMap) {
                lighting = true;
                options.useSpecular = true;
            }

            if (options.shadingModel === SPECULAR_PHONG) {
                options.fresnelModel = 0;
                options.specularAntialias = false;
                options.prefilteredCubemap = false;
                options.dpAtlas = false;
                options.ambientSH = false;
            } else {
                options.fresnelModel = (options.fresnelModel === 0) ? FRESNEL_SCHLICK : options.fresnelModel;
            }

            var cubemapReflection = (options.cubeMap || (options.prefilteredCubemap && options.useSpecular)) && !options.sphereMap && !options.dpAtlas;
            var reflections = options.sphereMap || cubemapReflection || options.dpAtlas;
            var useTexCubeLod = options.useTexCubeLod;
            if (options.cubeMap) options.sphereMap = null; // cubeMaps have higher priority
            if (options.dpAtlas) options.prefilteredCubemap = null; // dp has even higher priority
            if (!options.useSpecular) options.specularMap = options.glossMap = null;
            var needsNormal = lighting || reflections || options.ambientSH || options.prefilteredCubemap || options.heightMap || options.enableGGXSpecular;
            var shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;

            this.options = options;

            // GENERATE VERTEX SHADER
            var code = '';
            var codeBody = '';

            var varyings = ""; // additional varyings for map transforms

            var chunks = shaderChunks;

            var lightType;
            var shadowCoordArgs;
            var chunk;

            var attributes = {
                vertex_position: SEMANTIC_POSITION
            };

            if (options.chunks) {
                var customChunks = {};
                var newP;
                for (p in chunks) {
                    if (chunks.hasOwnProperty(p)) {
                        if (!options.chunks[p]) {
                            customChunks[p] = chunks[p];
                        } else {
                            chunk = options.chunks[p];
                            // scan for attributes in custom code
                            if (chunk.indexOf("vertex_normal") >= 0) {
                                attributes.vertex_normal = SEMANTIC_NORMAL;
                            }
                            if (chunk.indexOf("vertex_tangent") >= 0) {
                                attributes.vertex_tangent = SEMANTIC_TANGENT;
                            }
                            if (chunk.indexOf("vertex_texCoord0") >= 0) {
                                attributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;
                            }
                            if (chunk.indexOf("vertex_texCoord1") >= 0) {
                                attributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;
                            }
                            if (chunk.indexOf("vertex_color") >= 0) {
                                attributes.vertex_color = SEMANTIC_COLOR;
                            }
                            if (chunk.indexOf("vertex_boneWeights") >= 0) {
                                attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
                            }
                            if (chunk.indexOf("vertex_boneIndices") >= 0) {
                                attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
                            }
                            customChunks[p] = chunk;
                        }
                    }
                }

                for (p in options.chunks) {
                    newP = this._oldChunkToNew[p];
                    if (newP) {
                        customChunks[newP.n] = newP.f(options.chunks[p], newP.n, p);
                    }
                }

                chunks = customChunks;
            }


            // code += chunks.baseVS;
            code = this._vsAddBaseCode(code, device, chunks, options);

            // Allow first shadow coords to be computed in VS
            var mainShadowLight = -1;
            if (!options.noShadow && !options.twoSidedLighting) {
                for (i = 0; i < options.lights.length; i++) {
                    lightType = options.lights[i]._type;
                    if (options.lights[i].castShadows) {
                        if (lightType === LIGHTTYPE_DIRECTIONAL) {
                            code += "uniform mat4 light" + i + "_shadowMatrixVS;\n";
                            code += "uniform vec3 light" + i + "_shadowParamsVS;\n";
                            code += "uniform vec3 light" + i + (lightType === LIGHTTYPE_DIRECTIONAL ? "_directionVS" : "_positionVS") + ";\n";
                            mainShadowLight = i;
                            break;
                        }
                    }
                }
                if (mainShadowLight >= 0) {
                    code += chunks.shadowCoordVS;
                }
            }

            codeBody += "   vPositionW    = getWorldPosition();\n";

            if (options.pass === SHADER_DEPTH) {
                code += 'varying float vDepth;\n';
                code += '#ifndef VIEWMATRIX\n';
                code += '#define VIEWMATRIX\n';
                code += 'uniform mat4 matrix_view;\n';
                code += '#endif\n';
                code += '#ifndef CAMERAPLANES\n';
                code += '#define CAMERAPLANES\n';
                code += 'uniform vec4 camera_params;\n\n';
                code += '#endif\n';
                codeBody += "    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";
            }

            if (options.useInstancing) {
                attributes.instance_line1 = SEMANTIC_TEXCOORD2;
                attributes.instance_line2 = SEMANTIC_TEXCOORD3;
                attributes.instance_line3 = SEMANTIC_TEXCOORD4;
                attributes.instance_line4 = SEMANTIC_TEXCOORD5;
                code += chunks.instancingVS;
            }

            if (needsNormal) {
                attributes.vertex_normal = SEMANTIC_NORMAL;
                codeBody += "   vNormalW    = dNormalW = getNormal();\n";

                if ((options.sphereMap) && (device.fragmentUniformsCount <= 16)) {
                    code += chunks.viewNormalVS;
                    codeBody += "   vNormalV    = getViewNormal();\n";
                }

                if ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {
                    attributes.vertex_tangent = SEMANTIC_TANGENT;
                    code += chunks.tangentBinormalVS;
                    codeBody += "   vTangentW   = getTangent();\n";
                    codeBody += "   vBinormalW  = getBinormal();\n";
                } else if (options.enableGGXSpecular) {
                    code += chunks.tangentBinormalVS;
                    codeBody += "   vObjectSpaceUpW  = getObjectSpaceUp();\n";
                }

                if (mainShadowLight >= 0) {
                    lightType = options.lights[mainShadowLight]._type;
                    if (lightType === LIGHTTYPE_DIRECTIONAL) {
                        codeBody += "   dLightDirNormW = light" + mainShadowLight + "_directionVS;\n";
                    } else {
                        codeBody += "   getLightDirPoint(light" + mainShadowLight + "_positionVS);\n";
                    }
                    shadowCoordArgs = "(light" + mainShadowLight + "_shadowMatrixVS, light" + mainShadowLight + "_shadowParamsVS);\n";
                    codeBody += this._nonPointShadowMapProjection(device, options.lights[mainShadowLight], shadowCoordArgs);
                }
            }

            var useUv = [];
            var useUnmodifiedUv = [];
            var maxUvSets = 2;
            var cname, mname, tname, uname;

            for (p in _matTex2D) {
                mname = p + "Map";
                if (options[p + "VertexColor"]) {
                    cname = p + "VertexColorChannel";
                    options[cname] = this._correctChannel(p, options[cname]);
                }
                if (options[mname]) {
                    cname = mname + "Channel";
                    tname = mname + "Transform";
                    uname = mname + "Uv";
                    options[uname] = Math.min(options[uname], maxUvSets - 1);
                    options[cname] = this._correctChannel(p, options[cname]);
                    var uvSet = options[uname];
                    useUv[uvSet] = true;
                    useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || (options[mname] && !options[tname]);
                }
            }

            if (options.forceUv1) useUv[1] = true;

            for (i = 0; i < maxUvSets; i++) {
                if (useUv[i]) {
                    attributes["vertex_texCoord" + i] = pc["SEMANTIC_TEXCOORD" + i];
                    code += chunks["uv" + i + "VS"];
                    codeBody += "   vec2 uv" + i + " = getUv" + i + "();\n";
                }
                if (useUnmodifiedUv[i]) {
                    codeBody += "   vUv" + i + " = uv" + i + ";\n";
                }
            }

            var codes = [code, varyings, codeBody, []];

            for (p in _matTex2D) {
                mname = p + "Map";
                if (options[mname]) {
                    tname = mname + "Transform";
                    if (options[tname]) {
                        uname = mname + "Uv";
                        this._setMapTransform(codes, p, options[tname], options[uname]);
                    }
                }
            }

            code = codes[0];
            varyings = codes[1];
            codeBody = codes[2];

            if (options.vertexColors) {
                attributes.vertex_color = SEMANTIC_COLOR;
                codeBody += "   vVertexColor = vertex_color;\n";
            }

            // set up 8 slots for morphing. these are supported combinations: PPPPPPPP, NNNNNNNN, PPPPNNNN
            if (options.useMorphPosition || options.useMorphNormal) {

                code += "#define MORPHING\n";

                // first 4 slots are either position or normal
                if (options.useMorphPosition) {
                    attributes.morph_pos0 = SEMANTIC_ATTR0;
                    attributes.morph_pos1 = SEMANTIC_ATTR1;
                    attributes.morph_pos2 = SEMANTIC_ATTR2;
                    attributes.morph_pos3 = SEMANTIC_ATTR3;

                    code += "#define MORPHING_POS03\n";
                    code += "attribute vec3 morph_pos0;\n";
                    code += "attribute vec3 morph_pos1;\n";
                    code += "attribute vec3 morph_pos2;\n";
                    code += "attribute vec3 morph_pos3;\n";

                } else if (options.useMorphNormal) {
                    attributes.morph_nrm0 = SEMANTIC_ATTR0;
                    attributes.morph_nrm1 = SEMANTIC_ATTR1;
                    attributes.morph_nrm2 = SEMANTIC_ATTR2;
                    attributes.morph_nrm3 = SEMANTIC_ATTR3;

                    code += "#define MORPHING_NRM03\n";
                    code += "attribute vec3 morph_nrm0;\n";
                    code += "attribute vec3 morph_nrm1;\n";
                    code += "attribute vec3 morph_nrm2;\n";
                    code += "attribute vec3 morph_nrm3;\n";
                }

                // next 4 slots are either position or normal
                if (!options.useMorphNormal) {
                    attributes.morph_pos4 = SEMANTIC_ATTR4;
                    attributes.morph_pos5 = SEMANTIC_ATTR5;
                    attributes.morph_pos6 = SEMANTIC_ATTR6;
                    attributes.morph_pos7 = SEMANTIC_ATTR7;

                    code += "#define MORPHING_POS47\n";
                    code += "attribute vec3 morph_pos4;\n";
                    code += "attribute vec3 morph_pos5;\n";
                    code += "attribute vec3 morph_pos6;\n";
                    code += "attribute vec3 morph_pos7;\n";
                } else {
                    attributes.morph_nrm4 = SEMANTIC_ATTR4;
                    attributes.morph_nrm5 = SEMANTIC_ATTR5;
                    attributes.morph_nrm6 = SEMANTIC_ATTR6;
                    attributes.morph_nrm7 = SEMANTIC_ATTR7;

                    code += "#define MORPHING_NRM47\n";
                    code += "attribute vec3 morph_nrm4;\n";
                    code += "attribute vec3 morph_nrm5;\n";
                    code += "attribute vec3 morph_nrm6;\n";
                    code += "attribute vec3 morph_nrm7;\n";
                }
            }

            if (options.skin) {
                attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
                attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
                code += programlib.skinCode(device, chunks);
                code += "#define SKIN\n";
            } else if (options.useInstancing) {
                code += "#define INSTANCING\n";
            }
            if (options.screenSpace) {
                code += "#define SCREENSPACE\n";
            }
            if (options.pixelSnap) {
                code += "#define PIXELSNAP\n";
            }

            code = this._vsAddTransformCode(code, device, chunks, options);

            if (needsNormal) code += chunks.normalVS;

            code += "\n";

            code += chunks.startVS;
            code += codeBody;
            code += "}";

            var vshader = code;

            var oldVars = varyings;
            varyings = "";
            varyings += this._addVaryingIfNeeded(code, "vec4", "vMainShadowUv");
            varyings += this._addVaryingIfNeeded(code, "vec4", "vVertexColor");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vPositionW");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalV");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vNormalW");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vTangentW");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vBinormalW");
            varyings += this._addVaryingIfNeeded(code, "vec3", "vObjectSpaceUpW");
            varyings += this._addVaryingIfNeeded(code, "vec2", "vUv0");
            varyings += this._addVaryingIfNeeded(code, "vec2", "vUv1");
            varyings += oldVars;
            vshader = varyings + vshader;

            var startCode = "";
            if (device.webgl2) {
                startCode = programlib.versionCode(device);
                if (chunks.extensionVS) {
                    startCode += chunks.extensionVS + "\n";
                }
                vshader = startCode + chunks.gles3VS + vshader;
            } else {
                if (chunks.extensionVS) {
                    startCode = chunks.extensionVS + "\n";
                }
                vshader = startCode + vshader;
            }

            // GENERATE FRAGMENT SHADER
            if (options.forceFragmentPrecision && options.forceFragmentPrecision != "highp" &&
                options.forceFragmentPrecision !== "mediump" && options.forceFragmentPrecision !== "lowp")
                options.forceFragmentPrecision = null;

            if (options.forceFragmentPrecision) {
                if (options.forceFragmentPrecision === "highp" && device.maxPrecision !== "highp") options.forceFragmentPrecision = "mediump";
                if (options.forceFragmentPrecision === "mediump" && device.maxPrecision === "lowp") options.forceFragmentPrecision = "lowp";
            }

            var fshader;
            code = '';

            if (device.webgl2) {
                code += programlib.versionCode(device);
            }

            if (device.extStandardDerivatives && !device.webgl2) {
                code += "#extension GL_OES_standard_derivatives : enable\n\n";
            }
            if (chunks.extensionPS) {
                code += chunks.extensionPS + "\n";
            }

            if (device.webgl2) {
                code += chunks.gles3PS;
            }

            code += options.forceFragmentPrecision ? "precision " + options.forceFragmentPrecision + " float;\n\n" : programlib.precisionCode(device);

            if (options.pass === SHADER_PICK) {
                // ##### PICK PASS #####
                code += "uniform vec4 uColor;\n";
                code += varyings;
                if (options.alphaTest) {
                    code += "float dAlpha;\n";
                    code += this._addMap("opacity", "opacityPS", options, chunks);
                    code += chunks.alphaTestPS;
                }
                code += programlib.begin();
                if (options.alphaTest) {
                    code += "   getOpacity();\n";
                    code += "   alphaTest(dAlpha);\n";
                }
                code += "    gl_FragColor = uColor;\n";
                code += programlib.end();
                return {
                    attributes: attributes,
                    vshader: vshader,
                    fshader: code
                };

            } else if (options.pass === SHADER_DEPTH) {
                // ##### SCREEN DEPTH PASS #####
                code += 'varying float vDepth;\n';
                code += varyings;
                code += chunks.packDepthPS;
                if (options.alphaTest) {
                    code += "float dAlpha;\n";
                    code += this._addMap("opacity", "opacityPS", options, chunks);
                    code += chunks.alphaTestPS;
                }
                code += programlib.begin();
                if (options.alphaTest) {
                    code += "   getOpacity();\n";
                    code += "   alphaTest(dAlpha);\n";
                }
                code += "    gl_FragColor = packFloat(vDepth);\n";
                code += programlib.end();
                return {
                    attributes: attributes,
                    vshader: vshader,
                    fshader: code
                };

            } else if (shadowPass) {
                // ##### SHADOW PASS #####
                var smode = options.pass - SHADER_SHADOW;
                var numShadowModes = 5;
                lightType = Math.floor(smode / numShadowModes);
                var shadowType = smode - lightType * numShadowModes;

                if (device.extStandardDerivatives && !device.webgl2) {
                    code += 'uniform vec2 polygonOffset;\n';
                }

                if (shadowType === SHADOW_VSM32) {
                    if (device.textureFloatHighPrecision) {
                        code += '#define VSM_EXPONENT 15.0\n\n';
                    } else {
                        code += '#define VSM_EXPONENT 5.54\n\n';
                    }
                } else if (shadowType === SHADOW_VSM16) {
                    code += '#define VSM_EXPONENT 5.54\n\n';
                }

                if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                    code += 'uniform vec3 view_position;\n';
                    code += 'uniform float light_radius;\n';
                }

                code += varyings;
                if (options.alphaTest) {
                    code += "float dAlpha;\n";
                    code += this._addMap("opacity", "opacityPS", options, chunks);
                    code += chunks.alphaTestPS;
                }

                if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_POINT)) {
                    code += chunks.packDepthPS;
                } else if (shadowType === SHADOW_VSM8) {
                    code += "vec2 encodeFloatRG( float v ) {\n";
                    code += "    vec2 enc = vec2(1.0, 255.0) * v;\n";
                    code += "    enc = fract(enc);\n";
                    code += "    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";
                    code += "    return enc;\n";
                    code += "}\n\n";
                }

                code += programlib.begin();

                if (options.alphaTest) {
                    code += "   getOpacity();\n";
                    code += "   alphaTest(dAlpha);\n";
                }

                var isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;

                if (lightType === LIGHTTYPE_POINT || (isVsm && lightType !== LIGHTTYPE_DIRECTIONAL)) {
                    code += "   float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";
                } else {
                    code += "   float depth = gl_FragCoord.z;\n";
                }

                if (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_POINT)) {
                    if (device.extStandardDerivatives && !device.webgl2) {
                        code += "   float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";
                        code += "   depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";
                        code += "   gl_FragColor = packFloat(depth);\n";
                    } else {
                        code += "   gl_FragColor = packFloat(depth);\n";
                    }
                } else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {
                    code += "   gl_FragColor = vec4(1.0);\n"; // just the simpliest code, color is not written anyway
                } else if (shadowType === SHADOW_VSM8) {
                    code += "   gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";
                } else {
                    code += chunks.storeEVSMPS;
                }

                code += programlib.end();

                return {
                    attributes: attributes,
                    vshader: vshader,
                    fshader: code
                };
            }

            if (options.customFragmentShader) {
                // ##### CUSTOM PS #####
                fshader = code + options.customFragmentShader;
                return {
                    attributes: attributes,
                    vshader: vshader,
                    fshader: fshader,
                    tag: SHADERTAG_MATERIAL
                };
            }

            // ##### FORWARD/FORWARDHDR PASS #####
            code += varyings;

            // code += chunks.basePS;
            code = this._fsAddBaseCode(code, device, chunks, options);

            if (options.detailModes) {
                code += chunks.detailModesPS;
            }

            var codeBegin = code;
            code = "";

            if (options.clearCoat > 0) {
                code += '#define CLEARCOAT\n';
            }

            // FRAGMENT SHADER INPUTS: UNIFORMS
            var numShadowLights = 0;
            var shadowTypeUsed = [];
            var useVsm = false;
            var usePerspZbufferShadow = false;
            var light;
            for (i = 0; i < options.lights.length; i++) {
                light = options.lights[i];
                lightType = light._type;
                code += "uniform vec3 light" + i + "_color;\n";
                if (lightType === LIGHTTYPE_DIRECTIONAL) {
                    code += "uniform vec3 light" + i + "_direction;\n";
                } else {
                    code += "uniform vec3 light" + i + "_position;\n";
                    code += "uniform float light" + i + "_radius;\n";
                    if (lightType === LIGHTTYPE_SPOT) {
                        code += "uniform vec3 light" + i + "_direction;\n";
                        code += "uniform float light" + i + "_innerConeAngle;\n";
                        code += "uniform float light" + i + "_outerConeAngle;\n";
                    }
                }
                if (light.castShadows && !options.noShadow) {
                    code += "uniform mat4 light" + i + "_shadowMatrix;\n";
                    if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                        code += "uniform vec4 light" + i + "_shadowParams;\n"; // Width, height, bias, radius
                    } else {
                        code += "uniform vec3 light" + i + "_shadowParams;\n"; // Width, height, bias
                    }
                    if (lightType === LIGHTTYPE_POINT) {
                        code += "uniform samplerCube light" + i + "_shadowMap;\n";
                    } else {
                        if (light._isPcf && device.webgl2) {
                            code += "uniform sampler2DShadow light" + i + "_shadowMap;\n";
                        } else {
                            code += "uniform sampler2D light" + i + "_shadowMap;\n";
                        }
                    }
                    numShadowLights++;
                    shadowTypeUsed[light._shadowType] = true;
                    if (light._isVsm) useVsm = true;
                    if (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;
                }
                if (light._cookie) {
                    if (light._cookie._cubemap) {
                        if (lightType === LIGHTTYPE_POINT) {
                            code += "uniform samplerCube light" + i + "_cookie;\n";
                            code += "uniform float light" + i + "_cookieIntensity;\n";
                            if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
                        }
                    } else {
                        if (lightType === LIGHTTYPE_SPOT) {
                            code += "uniform sampler2D light" + i + "_cookie;\n";
                            code += "uniform float light" + i + "_cookieIntensity;\n";
                            if (!light.castShadows || options.noShadow) code += "uniform mat4 light" + i + "_shadowMatrix;\n";
                            if (light._cookieTransform) {
                                code += "uniform vec4 light" + i + "_cookieMatrix;\n";
                                code += "uniform vec2 light" + i + "_cookieOffset;\n";
                            }
                        }
                    }
                }
            }

            code += "\n"; // End of uniform declarations


            var tbn;
            if (!options.hasTangents && device.extStandardDerivatives) {
                tbn = chunks.TBNderivativePS;
            } else if (options.fastTbn) {
                tbn = chunks.TBNfastPS;
            } else {
                tbn = chunks.TBNPS;
            }

            if (needsNormal) {
                if (options.normalMap) {
                    code += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;

                    if (options.normalDetail) {
                        code += this._addMap("normalDetail", "normalDetailMapPS", options, chunks);
                    }

                    var transformedNormalMapUv = this._getUvSourceExpression("normalMapTransform", "normalMapUv", options);
                    if (options.normalizeNormalMap) {
                        code += chunks.normalMapPS.replace(/\$UV/g, transformedNormalMapUv);
                    } else {
                        code += chunks.normalMapFastPS.replace(/\$UV/g, transformedNormalMapUv);
                    }
                    if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedNormalMapUv);
                    code += tbn;
                } else {
                    code += chunks.normalVertexPS;

                    if (options.enableGGXSpecular) {
                        code += chunks.TBNObjectSpacePS;
                    }
                }
            }

            code += programlib.gammaCode(options.gamma, chunks);
            code += programlib.tonemapCode(options.toneMap, chunks);
            code += programlib.fogCode(options.fog, chunks);

            if (options.useRgbm) code += chunks.rgbmPS;
            if (cubemapReflection || options.prefilteredCubemap) {
                code += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;
            }

            if (needsNormal) {
                code += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;
                code += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;
            }

            if (options.diffuseDetail) {
                code += this._addMap("diffuseDetail", "diffuseDetailMapPS", options, chunks);
            }

            code += this._addMap("diffuse", "diffusePS", options, chunks);

            if (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {
                code += this._addMap("opacity", "opacityPS", options, chunks);
            }
            code += this._addMap("emissive", "emissivePS", options, chunks, options.emissiveFormat);

            if (options.useSpecular && (lighting || reflections)) {
                if (options.specularAntialias && options.normalMap) {
                    if (options.normalizeNormalMap && needsNormal) {
                        code += chunks.specularAaToksvigPS;
                    } else {
                        code += chunks.specularAaToksvigFastPS;
                    }
                } else {
                    code += chunks.specularAaNonePS;
                }

                var specularPropName = options.useMetalness ? "metalness" : "specular";
                code += this._addMap(specularPropName, specularPropName + "PS", options, chunks);
                code += this._addMap("gloss", "glossPS", options, chunks);
                if (options.fresnelModel === FRESNEL_SCHLICK) {
                    code += chunks.fresnelSchlickPS;
                }
            }

            if (options.heightMap) {
                if (!options.normalMap) {
                    var transformedHeightMapUv = this._getUvSourceExpression("heightMapTransform", "heightMapUv", options);
                    if (!options.hasTangents) tbn = tbn.replace(/\$UV/g, transformedHeightMapUv);
                    code += tbn;
                }
                code += this._addMap("height", "parallaxPS", options, chunks);
            }

            var useAo = options.aoMap || options.aoVertexColor;
            if (useAo) {
                code += this._addMap("ao", "aoPS", options, chunks);
                if (options.occludeSpecular) {
                    if (options.occludeSpecular === SPECOCC_AO) {
                        code += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;
                    } else {
                        code += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;
                    }
                }
            }

            var reflectionDecode = options.rgbmReflection ? "decodeRGBM" : (options.hdrReflection ? "" : "gammaCorrectInput");

            if (options.sphereMap) {
                var scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;
                scode = scode.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : (options.hdrReflection ? "texture2D" : "texture2DSRGB"));
                code += scode;
            } else if (cubemapReflection) {
                if (options.prefilteredCubemap) {
                    if (useTexCubeLod) {
                        code += chunks.reflectionPrefilteredCubeLodPS.replace(/\$DECODE/g, reflectionDecode);

                    } else {
                        code += chunks.reflectionPrefilteredCubePS.replace(/\$DECODE/g, reflectionDecode);
                    }
                } else {
                    code += chunks.reflectionCubePS.replace(/\$textureCubeSAMPLE/g,
                                                            options.rgbmReflection ? "textureCubeRGBM" : (options.hdrReflection ? "textureCube" : "textureCubeSRGB"));
                }
            } else if (options.dpAtlas) {
                code += chunks.reflectionDpAtlasPS.replace(/\$texture2DSAMPLE/g, options.rgbmReflection ? "texture2DRGBM" : (options.hdrReflection ? "texture2D" : "texture2DSRGB"));
            }

            if (cubemapReflection || options.sphereMap || options.dpAtlas) {
                if (options.clearCoat > 0){
                    code += chunks.reflectionCCPS;
                }
                if (options.refraction){
                    code += chunks.refractionPS;
                }
            }

            if (numShadowLights > 0) {
                if (shadowTypeUsed[SHADOW_PCF3]) {
                    code += chunks.shadowStandardPS;
                }
                if (shadowTypeUsed[SHADOW_PCF5]) {
                    code += chunks.shadowStandardGL2PS;
                }
                if (useVsm) {
                    code += chunks.shadowVSM_commonPS;
                    if (shadowTypeUsed[SHADOW_VSM8]) {
                        code += chunks.shadowVSM8PS;
                    }
                    if (shadowTypeUsed[SHADOW_VSM16]) {
                        code += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "16") : chunks.shadowEVSMnPS.replace(/\$/g, "16");
                    }
                    if (shadowTypeUsed[SHADOW_VSM32]) {
                        code += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\$/g, "32") : chunks.shadowEVSMnPS.replace(/\$/g, "32");
                    }
                }

                if (device.webgl2 || device.extStandardDerivatives) ; else {
                    code += chunks.biasConstPS;
                }
                code += chunks.shadowCoordPS + chunks.shadowCommonPS;
                if (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;

                if (mainShadowLight >= 0) {
                    if (shadowTypeUsed[SHADOW_PCF3]) {
                        code += chunks.shadowStandardVSPS;
                    }
                    if (shadowTypeUsed[SHADOW_PCF5]) {
                        code += chunks.shadowStandardGL2VSPS;
                    }
                    if (useVsm) {
                        if (shadowTypeUsed[SHADOW_VSM8]) {
                            code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM8").replace(/\$/g, "8");
                        }
                        if (shadowTypeUsed[SHADOW_VSM16]) {
                            code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM16").replace(/\$/g, "16");
                        }
                        if (shadowTypeUsed[SHADOW_VSM32]) {
                            code += chunks.shadowVSMVSPS.replace(/\$VSM/g, "VSM32").replace(/\$/g, "32");
                        }
                    }
                }
            }

            if (options.enableGGXSpecular) code += "uniform float material_anisotropy;\n";

            if (lighting) code += chunks.lightDiffuseLambertPS;
            var useOldAmbient = false;
            if (options.useSpecular) {
                if (lighting) code += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : (options.enableGGXSpecular) ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;
                if (options.sphereMap || cubemapReflection || options.dpAtlas || (options.fresnelModel > 0)) {
                    if (options.fresnelModel > 0) {
                        if (options.conserveEnergy) {
                            code += chunks.combineDiffuseSpecularPS; // this one is correct, others are old stuff
                        } else {
                            code += chunks.combineDiffuseSpecularNoConservePS; // if you don't use environment cubemaps, you may consider this
                        }
                    } else {
                        code += chunks.combineDiffuseSpecularOldPS;
                    }
                } else {
                    if (options.diffuseMap) {
                        code += chunks.combineDiffuseSpecularNoReflPS;
                    } else {
                        code += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;
                        useOldAmbient = true;
                    }
                }
            } else {
                code += chunks.combineDiffusePS;
            }

            if (options.clearCoat > 0 ) {
                code += chunks.combineClearCoatPS;
            }

            var addAmbient = true;
            if (options.lightMap || options.lightVertexColor) {
                var lightmapChunkPropName = options.dirLightMap ? 'lightmapDirPS' : 'lightmapSinglePS';
                code += this._addMap("light", lightmapChunkPropName, options, chunks, options.lightMapFormat);
                addAmbient = options.lightMapWithoutAmbient;
            }

            if (addAmbient) {

                var ambientDecode = options.rgbmAmbient ? "decodeRGBM" : (options.hdrAmbient ? "" : "gammaCorrectInput");

                if (options.ambientSH) {
                    code += chunks.ambientSHPS;
                } else if (options.prefilteredCubemap) {
                    if (useTexCubeLod) {
                        code += chunks.ambientPrefilteredCubeLodPS.replace(/\$DECODE/g, ambientDecode);
                    } else {
                        code += chunks.ambientPrefilteredCubePS.replace(/\$DECODE/g, ambientDecode);
                    }
                } else {
                    code += chunks.ambientConstantPS;
                }
            }

            if (options.ambientTint && !useOldAmbient) {
                code += "uniform vec3 material_ambient;\n";
            }

            if (options.alphaTest) {
                code += chunks.alphaTestPS;
            }

            if (options.msdf) {
                code += chunks.msdfPS;
            }

            if (needsNormal) {
                code += chunks.viewDirPS;
                if (options.useSpecular) {
                    code += (options.enableGGXSpecular) ? chunks.reflDirAnisoPS : chunks.reflDirPS;
                }
            }
            var hasPointLights = false;
            var usesLinearFalloff = false;
            var usesInvSquaredFalloff = false;
            var usesSpot = false;
            var usesCookie = false;
            var usesCookieNow;

            // FRAGMENT SHADER BODY

            code = this._fsAddStartCode(code, device, chunks, options);

            if (needsNormal) {
                if (options.twoSidedLighting) {
                    code += "   dVertexNormalW = gl_FrontFacing ? vNormalW : -vNormalW;\n";
                } else {
                    code += "   dVertexNormalW = vNormalW;\n";
                }
                if ((options.heightMap || options.normalMap) && options.hasTangents) {
                    if (options.twoSidedLighting) {
                        code += "   dTangentW = gl_FrontFacing ? vTangentW : -vTangentW;\n";
                        code += "   dBinormalW = gl_FrontFacing ? vBinormalW : -vBinormalW;\n";
                    } else {
                        code += "   dTangentW = vTangentW;\n";
                        code += "   dBinormalW = vBinormalW;\n";
                    }
                }
            }

            var opacityParallax = false;
            if (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {
                code += "   dAlpha = 1.0;\n";
            } else {
                if (options.heightMap && options.opacityMap) {
                    opacityParallax = true;
                } else {
                    code += "   getOpacity();\n"; // calculate opacity first if there's no parallax+opacityMap, to allow early out
                    if (options.alphaTest) {
                        code += "   alphaTest(dAlpha);\n";
                    }
                }
            }

            var getGlossinessCalled = false;

            if (needsNormal) {
                code += "   getViewDir();\n";
                if (options.heightMap || options.normalMap || options.enableGGXSpecular) {
                    code += "   getTBN();\n";
                }
                if (options.heightMap) {
                    code += "   getParallax();\n";
                }

                if (opacityParallax) {
                    code += "   getOpacity();\n"; // if there's parallax, calculate opacity after it, to properly distort
                    if (options.alphaTest) {
                        code += "   alphaTest(dAlpha);\n";
                    }
                }

                code += "   getNormal();\n";
                if (options.useSpecular) {
                    if (options.enableGGXSpecular) {
                        code += "   getGlossiness();\n";
                        getGlossinessCalled = true;
                    }
                    code += "   getReflDir();\n";
                }
            }

            code += "   getAlbedo();\n";

            if ((lighting && options.useSpecular) || reflections) {
                code += "   getSpecularity();\n";
                if (!getGlossinessCalled) code += "   getGlossiness();\n";
                if (options.fresnelModel > 0) code += "   getFresnel();\n";
            }

            if (addAmbient) {
                code += "   addAmbient();\n";
            }
            if (options.ambientTint && !useOldAmbient) {
                code += "   dDiffuseLight *= material_ambient;\n";
            }
            if (useAo && !options.occludeDirect) {
                code += "    applyAO();\n";
            }
            if (options.lightMap || options.lightVertexColor) {
                code += "   addLightMap();\n";
            }

            if (lighting || reflections) {
                if (cubemapReflection || options.sphereMap || options.dpAtlas) {
                    if (options.clearCoat > 0){
                        code += "   addReflectionCC();\n";
                    }
                    code += "   addReflection();\n";
                }

                if (options.dirLightMap) {
                    code += "   addDirLightMap();\n";
                }

                for (i = 0; i < options.lights.length; i++) {
                    // The following code is not decoupled to separate shader files, because most of it can be actually changed to achieve different behaviours like:
                    // - different falloffs
                    // - different shadow coords (point shadows will use drastically different genShadowCoord)
                    // - different shadow filter modes

                    // getLightDiffuse and getLightSpecular is BRDF itself.

                    light = options.lights[i];
                    lightType = light._type;
                    usesCookieNow = false;

                    if (lightType === LIGHTTYPE_DIRECTIONAL) {
                        // directional
                        code += "   dLightDirNormW = light" + i + "_direction;\n";
                        code += "   dAtten = 1.0;\n";
                    } else {

                        if (light._cookie) {
                            if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {
                                usesCookie = true;
                                usesCookieNow = true;
                            } else if (lightType === LIGHTTYPE_POINT && light._cookie._cubemap) {
                                usesCookie = true;
                                usesCookieNow = true;
                            }
                        }

                        code += "   getLightDirPoint(light" + i + "_position);\n";
                        hasPointLights = true;

                        if (usesCookieNow) {
                            if (lightType === LIGHTTYPE_SPOT) {
                                code += "   dAtten3 = getCookie2D" + (light._cookieFalloff ? "" : "Clip") + (light._cookieTransform ? "Xform" : "") + "(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity" + (light._cookieTransform ? ", light" + i + "_cookieMatrix, light" + i + "_cookieOffset" : "") + ")." + light._cookieChannel + ";\n";
                            } else {
                                code += "   dAtten3 = getCookieCube(light" + i + "_cookie, light" + i + "_shadowMatrix, light" + i + "_cookieIntensity)." + light._cookieChannel + ";\n";
                            }
                        }

                        if (light._falloffMode === LIGHTFALLOFF_LINEAR) {
                            code += "   dAtten = getFalloffLinear(light" + i + "_radius);\n";
                            usesLinearFalloff = true;
                        } else {
                            code += "   dAtten = getFalloffInvSquared(light" + i + "_radius);\n";
                            usesInvSquaredFalloff = true;
                        }

                        code += "   if (dAtten > 0.00001) {\n"; // BRANCH START

                        if (lightType === LIGHTTYPE_SPOT) {
                            if (!(usesCookieNow && !light._cookieFalloff)) {
                                code += "       dAtten *= getSpotEffect(light" + i + "_direction, light" + i + "_innerConeAngle, light" + i + "_outerConeAngle);\n";
                                usesSpot = true;
                            }
                        }
                    }

                    code += "       dAtten *= getLightDiffuse();\n";
                    if (light.castShadows && !options.noShadow) {

                        var shadowReadMode = null;
                        var evsmExp;
                        if (light._shadowType === SHADOW_VSM8) {
                            shadowReadMode = "VSM8";
                            evsmExp = "0.0";
                        } else if (light._shadowType === SHADOW_VSM16) {
                            shadowReadMode = "VSM16";
                            evsmExp = "5.54";
                        } else if (light._shadowType === SHADOW_VSM32) {
                            shadowReadMode = "VSM32";
                            if (device.textureFloatHighPrecision) {
                                evsmExp = "15.0";
                            } else {
                                evsmExp = "5.54";
                            }
                        } else if (light._shadowType === SHADOW_PCF5) {
                            shadowReadMode = "PCF5x5";
                        } else {
                            shadowReadMode = "PCF3x3";
                        }

                        if (shadowReadMode !== null) {
                            if (lightType === LIGHTTYPE_POINT) {
                                shadowCoordArgs = "(light" + i + "_shadowMap, light" + i + "_shadowParams);\n";
                                if (light._normalOffsetBias) {
                                    code += "       normalOffsetPointShadow(light" + i + "_shadowParams);\n";
                                }
                                code += "       dAtten *= getShadowPoint" + shadowReadMode + shadowCoordArgs;
                            } else {
                                if (mainShadowLight === i) {
                                    shadowReadMode += "VS";
                                } else {
                                    shadowCoordArgs = "(light" + i + "_shadowMatrix, light" + i + "_shadowParams);\n";
                                    code += this._nonPointShadowMapProjection(device, options.lights[i], shadowCoordArgs);
                                }
                                if (lightType === LIGHTTYPE_SPOT) shadowReadMode = "Spot" + shadowReadMode;
                                code += "       dAtten *= getShadow" + shadowReadMode + "(light" + i + "_shadowMap, light" + i + "_shadowParams" + (light._isVsm ? ", " + evsmExp : "") + ");\n";
                            }
                        }
                    }

                    code += "       dDiffuseLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";

                    if (options.clearCoat > 0 ) {
                        code += "       ccSpecularLight += getLightSpecularCC() * dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
                    }

                    if (options.useSpecular) {
                        code += "       dAtten *= getLightSpecular();\n";
                        code += "       dSpecularLight += dAtten * light" + i + "_color" + (usesCookieNow ? " * dAtten3" : "") + ";\n";
                    }


                    if (lightType !== LIGHTTYPE_DIRECTIONAL) {
                        code += "   }\n"; // BRANCH END
                    }

                    code += "\n";
                }

                if ((cubemapReflection || options.sphereMap || options.dpAtlas) && options.refraction) {
                    code += "   addRefraction();\n";
                }
            }
            code += "\n";

            if (useAo) {
                if (options.occludeDirect) {
                    code += "    applyAO();\n";
                }
                if (options.occludeSpecular) {
                    code += "    occludeSpecular();\n";
                }
            }

            code += chunks.endPS;
            if (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {
                code += chunks.outputAlphaPS;
            } else if (options.blendType === BLEND_PREMULTIPLIED) {
                code += chunks.outputAlphaPremulPS;
            } else {
                code += chunks.outputAlphaOpaquePS;
            }

            if (options.msdf) {
                code += "   gl_FragColor = applyMsdf(gl_FragColor);\n";
            }

            code += "\n";
            code += programlib.end();

            if (hasPointLights) {
                code = chunks.lightDirPointPS + code;
            }
            if (usesLinearFalloff) {
                code = chunks.falloffLinearPS + code;
            }
            if (usesInvSquaredFalloff) {
                code = chunks.falloffInvSquaredPS + code;
            }
            if (usesSpot) {
                code = chunks.spotPS + code;
            }
            if (usesCookie) {
                code = chunks.cookiePS + code;
            }
            var structCode = "";
            if (code.includes("dReflection")) structCode += "vec4 dReflection;\n";
            if (code.includes("dTBN")) structCode += "mat3 dTBN;\n";
            if (code.includes("dAlbedo")) structCode += "vec3 dAlbedo;\n";
            if (code.includes("dEmission")) structCode += "vec3 dEmission;\n";
            if (code.includes("dNormalW")) structCode += "vec3 dNormalW;\n";
            if (code.includes("dVertexNormalW")) structCode += "vec3 dVertexNormalW;\n";
            if (code.includes("dTangentW")) structCode += "vec3 dTangentW;\n";
            if (code.includes("dBinormalW")) structCode += "vec3 dBinormalW;\n";
            if (code.includes("dViewDirW")) structCode += "vec3 dViewDirW;\n";
            if (code.includes("dReflDirW")) structCode += "vec3 dReflDirW;\n";
            if (code.includes("dDiffuseLight")) structCode += "vec3 dDiffuseLight;\n";
            if (code.includes("dSpecularLight")) structCode += "vec3 dSpecularLight;\n";
            if (code.includes("dLightDirNormW")) structCode += "vec3 dLightDirNormW;\n";
            if (code.includes("dLightDirW")) structCode += "vec3 dLightDirW;\n";
            if (code.includes("dLightPosW")) structCode += "vec3 dLightPosW;\n";
            if (code.includes("dShadowCoord")) structCode += "vec3 dShadowCoord;\n";
            if (code.includes("dNormalMap")) structCode += "vec3 dNormalMap;\n";
            if (code.includes("dSpecularity")) structCode += "vec3 dSpecularity;\n";
            if (code.includes("dUvOffset")) structCode += "vec2 dUvOffset;\n";
            if (code.includes("dGlossiness")) structCode += "float dGlossiness;\n";
            if (code.includes("dAlpha")) structCode += "float dAlpha;\n";
            if (code.includes("dAtten")) structCode += "float dAtten;\n";
            if (code.includes("dAtten3")) structCode += "vec3 dAtten3;\n";
            if (code.includes("dAo")) structCode += "float dAo;\n";
            if (code.includes("dMsdf")) structCode += "vec4 dMsdf;\n";
            if (code.includes("ccReflection")) structCode += "vec4 ccReflection;\n";
            if (code.includes("ccNormalW")) structCode += "vec3 ccNormalW;\n";
            if (code.includes("ccReflDirW")) structCode += "vec3 ccReflDirW;\n";
            if (code.includes("ccSpecularLight")) structCode += "vec3 ccSpecularLight;\n";
            if (code.includes("ccSpecularity")) structCode += "vec3 ccSpecularity;\n";
            if (code.includes("ccGlossiness")) structCode += "float ccGlossiness=0.9;\n";

            code = codeBegin + structCode + code;

            fshader = code;

            return {
                attributes: attributes,
                vshader: vshader,
                fshader: fshader,
                tag: SHADERTAG_MATERIAL
            };
        }
    };

    var programlib = {
        gammaCode: function (value, chunks) {
            if (!chunks) chunks = shaderChunks;
            if (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {
                return chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;
            } else if (value === GAMMA_SRGBHDR) {
                return "#define HDR\n" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);
            }
            return chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;
        },

        tonemapCode: function (value, chunks) {
            if (!chunks) chunks = shaderChunks;
            if (value === TONEMAP_FILMIC) {
                return chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;
            } else if (value === TONEMAP_LINEAR) {
                return chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;
            } else if (value === TONEMAP_HEJL) {
                return chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;
            } else if (value === TONEMAP_ACES) {
                return chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;
            } else if (value === TONEMAP_ACES2) {
                return chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;
            }
            return chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;
        },

        fogCode: function (value, chunks) {
            if (!chunks) chunks = shaderChunks;
            if (value === 'linear') {
                return chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;
            } else if (value === 'exp') {
                return chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;
            } else if (value === 'exp2') {
                return chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;
            }
            return chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;
        },

        skinCode: function (device, chunks) {
            if (!chunks) chunks = shaderChunks;
            if (device.supportsBoneTextures) {
                return chunks.skinTexVS;
            }
            return "#define BONE_LIMIT " + device.getBoneLimit() + "\n" + chunks.skinConstVS;
        },

        precisionCode: function (device) {
            var pcode = 'precision ' + device.precision + ' float;\n';
            if (device.webgl2) {
                pcode += '#ifdef GL2\nprecision ' + device.precision + ' sampler2DShadow;\n#endif\n';
            }
            return pcode;
        },

        versionCode: function (device) {
            return device.webgl2 ? "#version 300 es\n" : "";
        },

        dummyFragmentCode: function () {
            return "void main(void) {gl_FragColor = vec4(0.0);}";
        },

        begin: function () {
            return 'void main(void)\n{\n';
        },

        end: function () {
            return '}\n';
        }
    };

    programlib.basic = basic;
    programlib.particle = particle;
    programlib.skybox = skybox;
    programlib.standard = standard;

    /**
     * @class
     * @name pc.Shader
     * @classdesc A shader is a program that is responsible for rendering graphical primitives on a device's
     * graphics processor. The shader is generated from a shader definition. This shader definition specifies
     * the code for processing vertices and fragments processed by the GPU. The language of the code is GLSL
     * (or more specifically ESSL, the OpenGL ES Shading Language). The shader definition also describes how
     * the PlayCanvas engine should map vertex buffer elements onto the attributes specified in the vertex
     * shader code.
     * @description Creates a new shader object.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this shader.
     * @param {object} definition - The shader definition from which to build the shader.
     * @param {object} definition.attributes - Object detailing the mapping of vertex shader attribute names
     * to semantics (pc.SEMANTIC_*). This enables the engine to match vertex buffer data as inputs to the
     * shader.
     * @param {string} definition.vshader - Vertex shader source (GLSL code).
     * @param {string} definition.fshader - Fragment shader source (GLSL code).
     * @param {boolean} [definition.useTransformFeedback] - Specifies that this shader outputs post-VS data to a buffer.
     * @example
     * // Create a shader that renders primitives with a solid red color
     * var shaderDefinition = {
     *     attributes: {
     *         aPosition: pc.SEMANTIC_POSITION
     *     },
     *     vshader: [
     *         "attribute vec3 aPosition;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_Position = vec4(aPosition, 1.0);",
     *         "}"
     *     ].join("\n"),
     *     fshader: [
     *         "precision " + graphicsDevice.precision + " float;",
     *         "",
     *         "void main(void)",
     *         "{",
     *         "    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);",
     *         "}"
     *     ].join("\n")
     * };
     *
     * var shader = new pc.Shader(graphicsDevice, shaderDefinition);
     */
    function Shader(graphicsDevice, definition) {
        this.device = graphicsDevice;
        this.definition = definition;

        this.attributes = [];
        this.uniforms = [];
        this.samplers = [];

        this.ready = false;

        this.device.createShader(this);
    }

    Object.assign(Shader.prototype, {
        /**
         * @function
         * @name pc.Shader#destroy
         * @description Frees resources associated with this shader.
         */
        destroy: function () {
            this.device.destroyShader(this);
        }
    });

    var alphaTestPS = "uniform float alpha_ref;\nvoid alphaTest(float a) {\n    if (a < alpha_ref) discard;\n}\n\n";

    var ambientConstantPS = "\nvoid addAmbient() {\n    dDiffuseLight += light_globalAmbient;\n}\n";

    var ambientPrefilteredCubePS = "#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE(textureCube(texture_prefilteredCubeMap4, fixedReflDir)).rgb);\n}\n\n";

    var ambientPrefilteredCubeLodPS = "#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvoid addAmbient() {\n    vec3 fixedReflDir = fixSeamsStatic(dNormalW, 1.0 - 1.0 / 4.0);\n    fixedReflDir.x *= -1.0;\n    dDiffuseLight += processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, 5.0) ).rgb);\n}\n\n";

    var ambientSHPS = "uniform vec3 ambientSH[9];\nvoid addAmbient() {\n    vec3 n = dNormalW;\n\n    vec3 color =\n                        ambientSH[0] +\n                        ambientSH[1] * n.x +\n                        ambientSH[2] * n.y +\n                        ambientSH[3] * n.z +\n                        ambientSH[4] * n.x * n.z +\n                        ambientSH[5] * n.z * n.y +\n                        ambientSH[6] * n.y * n.x +\n                        ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n                        ambientSH[8] * (n.x * n.x - n.y * n.y);\n\n    dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n\n";

    var aoPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_aoMap;\n#endif\n\nvoid applyAO() {\n    dAo = 1.0;\n\n    #ifdef MAPTEXTURE\n        dAo *= texture2D(texture_aoMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        dAo *= saturate(vVertexColor.$VC);\n    #endif\n\n    dDiffuseLight *= dAo;\n}\n\n";

    var aoSpecOccPS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n    specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n\n";

    var aoSpecOccConstPS = "void occludeSpecular() {\n    // approximated specular occlusion from AO\n    float specPow = exp2(dGlossiness * 11.0);\n    // http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx\n    float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\n\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n\n";

    var aoSpecOccConstSimplePS = "void occludeSpecular() {\n    float specOcc = dAo;\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n\n";

    var aoSpecOccSimplePS = "uniform float material_occludeSpecularIntensity;\nvoid occludeSpecular() {\n    float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\n    dSpecularLight *= specOcc;\n    dReflection *= specOcc;\n}\n\n";

    var bakeDirLmEndPS = "\n    vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\n    if (bakeDir > 0.5) {\n        if (dAtten > 0.00001) {\n            dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n            dAtten = saturate(dAtten);\n            gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n            gl_FragColor.a = dirLm.w + dAtten;\n            gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n        } else {\n            gl_FragColor = dirLm;\n        }\n    } else {\n        gl_FragColor.rgb = dirLm.xyz;\n        gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n    }\n\n";

    var bakeLmEndPS = "\ngl_FragColor.rgb = dDiffuseLight;\ngl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\ngl_FragColor.rgb /= 8.0;\ngl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\ngl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\ngl_FragColor.rgb /= gl_FragColor.a;\n\n";

    var basePS = "\nuniform vec3 view_position;\n\nuniform vec3 light_globalAmbient;\n\nfloat square(float x) {\n    return x*x;\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\n";

    var baseVS = "\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\nvec3 dLightPosW;\nvec3 dLightDirNormW;\nvec3 dNormalW;\n\n";

    var baseNineSlicedPS = "#define NINESLICED\n\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

    var baseNineSlicedVS = "#define NINESLICED\n\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n";

    var baseNineSlicedTiledPS = "#define NINESLICED\n#define NINESLICETILED\n\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n\nvec2 nineSlicedUv;\n";

    var biasConstPS = "#define SHADOWBIAS\nfloat getShadowBias(float resolution, float maxBias) {\n    return maxBias;\n}\n\n";

    var blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\n#endif\n\nvoid main(void) {\n    vec3 moments = vec3(0.0);\n    vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n    for(int i=0; i<SAMPLES; i++) {\n        vec4 c = texture2D(source, uv + pixelOffset * float(i));\n\n        #ifdef PACKED\n        c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n        #endif\n\n        #ifdef GAUSS\n        moments += c.xyz * weight[i];\n        #else\n        moments += c.xyz;\n        #endif\n    }\n\n    #ifndef GAUSS\n    moments /= float(SAMPLES);\n    #endif\n\n    #ifdef PACKED\n    gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n    #else\n    gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n    #endif\n}\n\n";

    var combineClearCoatPS = "vec3 combineColorCC() {\n    return combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\n}\n";

    var combineDiffusePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight;\n}\n\n";

    var combineDiffuseSpecularPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\n}\n\n";

    var combineDiffuseSpecularNoConservePS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\n}\n\n";

    var combineDiffuseSpecularNoReflPS = "vec3 combineColor() {\n    return dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\n}\n\n";

    var combineDiffuseSpecularNoReflSeparateAmbientPS = "uniform vec3 material_ambient;\nvec3 combineColor() {\n    return (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\n}\n\n";

    var combineDiffuseSpecularOldPS = "vec3 combineColor() {\n    return mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\n}\n\n";

    var cookiePS = "vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\n\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n    vec4 projPos = transform * vec4(vPositionW, 1.0);\n    projPos.xy /= projPos.w;\n    projPos.xy += cookieOffset;\n    if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n    vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n    return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\n\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n    return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n\n";

    var cubeMapProjectBoxPS = "uniform vec3 envBoxMin, envBoxMax;\n\nvec3 cubeMapProject(vec3 nrdir) {\n    vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n    vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\n    vec3 rbminmax;\n    rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n    rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n    rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\n    float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\n    vec3 posonbox = vPositionW + nrdir * fa;\n    vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n    return posonbox - envBoxPos;\n}\n\n";

    var cubeMapProjectNonePS = "vec3 cubeMapProject(vec3 dir) {\n    return dir;\n}\n\n";

    var detailModesPS = "vec3 detailMode_mul(vec3 c1, vec3 c2) {\n    return c1 * c2;\n}\n\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n    return c1 + c2;\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Screen\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n    return 1.0 - (1.0 - c1)*(1.0 - c2);\n}\n\n// https://en.wikipedia.org/wiki/Blend_modes#Overlay\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n    return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\n\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n    return min(c1, c2);\n}\n\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n    return max(c1, c2);\n}\n\n";

    var diffusePS = "#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseMap;\n#endif\n\nvoid getAlbedo() {\n    dAlbedo = vec3(1.0);\n\n    #ifdef MAPCOLOR\n        dAlbedo *= material_diffuse.rgb;\n    #endif\n\n    #ifdef MAPTEXTURE\n        dAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\n    #endif\n\n    #ifdef MAPVERTEX\n        dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n}\n\n";

    var diffuseDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_diffuseDetailMap;\n#endif\n\nvec3 addAlbedoDetail(vec3 albedo) {\n    #ifdef MAPTEXTURE\n        vec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\n        return detailMode_$DETAILMODE(albedo, albedoDetail);\n    #else\n        return albedo;\n    #endif\n}\n\n";

    var dilatePS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n    vec4 c = texture2D(source, vUv0);\n    c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\n    c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\n    gl_FragColor = c;\n}\n\n";

    var dpAtlasQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\nuniform vec4 params;\n\nvoid main(void) {\n    vec2 uv = vUv0;\n    uv = uv * 2.0 - vec2(1.0);\n    uv *= params.xy;\n    uv = uv * 0.5 + 0.5;\n    gl_FragColor = texture2D(source, uv);\n}\n";

    var emissivePS = "#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_emissiveMap;\n#endif\n\nvec3 getEmission() {\n    vec3 emission = vec3(1.0);\n\n    #ifdef MAPFLOAT\n        emission *= material_emissiveIntensity;\n    #endif\n\n    #ifdef MAPCOLOR\n        emission *= material_emissive;\n    #endif\n\n    #ifdef MAPTEXTURE\n        emission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        emission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n    #endif\n\n    return emission;\n}\n\n";

    var endPS = "  #ifdef CLEARCOAT\n   gl_FragColor.rgb = combineColorCC();\n  #else\n   gl_FragColor.rgb = combineColor();\n  #endif \n   gl_FragColor.rgb += getEmission();\n   gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n   #ifndef HDR\n    gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n    gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n   #endif\n";

    var envConstPS = "vec3 processEnvironment(vec3 color) {\n    return color;\n}\n\n";

    var envMultiplyPS = "uniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n    return color * skyboxIntensity;\n}\n\n";

    var extensionPS = "";

    var extensionVS = "\n";

    var falloffInvSquaredPS = "float getFalloffInvSquared(float lightRadius) {\n    float sqrDist = dot(dLightDirW, dLightDirW);\n    float falloff = 1.0 / (sqrDist + 1.0);\n    float invRadius = 1.0 / lightRadius;\n\n    falloff *= 16.0;\n    falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\n    return falloff;\n}\n\n";

    var falloffLinearPS = "float getFalloffLinear(float lightRadius) {\n    float d = length(dLightDirW);\n    return max(((lightRadius - d) / lightRadius), 0.0);\n}\n\n";

    var fixCubemapSeamsNonePS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    return vec;\n}\n";

    var fixCubemapSeamsStretchPS = "vec3 fixSeams(vec3 vec, float mipmapIndex) {\n    float scale = 1.0 - exp2(mipmapIndex) / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeams(vec3 vec) {\n    float scale = 1.0 - 1.0 / 128.0;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n    float scale = invRecMipSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n\n";

    var fogExpPS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";

    var fogExp2PS = "uniform vec3 fog_color;\nuniform float fog_density;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = exp(-depth * depth * fog_density * fog_density);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(fog_color, color, fogFactor);\n}\n";

    var fogLinearPS = "uniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nvec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fogFactor = (fog_end - depth) / (fog_end - fog_start);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    fogFactor = gammaCorrectInput(fogFactor);\n    return mix(fog_color, color, fogFactor);\n}\n";

    var fogNonePS = "vec3 addFog(vec3 color) {\n    return color;\n}\n\n\n";

    var fresnelSchlickPS = "// Schlick's approximation\nuniform float material_fresnelFactor; // unused\nvoid getFresnel() {\n    float fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\n    float fresnel2 = fresnel * fresnel;\n    fresnel *= fresnel2 * fresnel2;\n    fresnel *= dGlossiness * dGlossiness;\n    dSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\n    #ifdef CLEARCOAT\n        fresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\n        fresnel2 = fresnel * fresnel;\n        fresnel *= fresnel2 * fresnel2;\n        fresnel *= ccGlossiness * ccGlossiness;\n        ccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\n    #endif\n}\n";

    var fullscreenQuadPS = "varying vec2 vUv0;\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n";

    var fullscreenQuadVS = "attribute vec2 vertex_position;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n\n";

    var gamma1_0PS = "vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    return texture2D(tex, uv);\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    return texture2D(tex, uv, bias);\n}\n\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    return textureCube(tex, uvw);\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n    return color;\n}\n\nvec3 gammaCorrectInput(vec3 color) {\n    return color;\n}\n\nfloat gammaCorrectInput(float color) {\n    return color;\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return color;\n}\n";

    var gamma2_2PS = "vec3 gammaCorrectInput(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nfloat gammaCorrectInput(float color) {\n    return pow(color, 2.2);\n}\n\nvec4 gammaCorrectInput(vec4 color) {\n    return vec4(pow(color.rgb, vec3(2.2)), color.a);\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n    vec4 rgba = texture2D(tex, uv);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\n\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n    vec4 rgba = texture2D(tex, uv, bias);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\n\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\n    vec4 rgba = textureCube(tex, uvw);\n    rgba.rgb = gammaCorrectInput(rgba.rgb);\n    return rgba;\n}\n\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n    return color;\n#else\n    color += vec3(0.0000001);\n    return pow(color, vec3(0.45));\n#endif\n}\n";

    var genParaboloidPS = "varying vec2 vUv0;\n\nuniform samplerCube source;\nuniform vec4 params; // x = mip\n\nvoid main(void) {\n\n    vec2 uv = vUv0;\n\n    float side = uv.x < 0.5? 1.0 : -1.0;\n    vec2 tc;\n    tc.x = fract(uv.x * 2.0) * 2.0 - 1.0;\n    tc.y = uv.y * 2.0 - 1.0;\n\n    // scale projection a bit to have a little overlap for filtering\n    const float scale = 1.1;\n    tc *= scale;\n\n    vec3 dir;\n    dir.y = (dot(tc, tc) - 1.0) * side; // from 1.0 center to 0.0 borders quadratically\n    dir.xz = tc * -2.0;\n\n    dir.x *= -side * params.y; // flip original cubemap x instead of doing it at runtime\n\n    dir = fixSeams(dir, params.x);\n\n    vec4 color = textureCube(source, dir, -100.0);\n    gl_FragColor = color;\n}\n";

    var gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n";

    var gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n";

    var glossPS = "#ifdef MAPFLOAT\nuniform float material_shininess;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_glossMap;\n#endif\n\n#ifdef CLEARCOAT\nuniform float material_clearCoatGlossiness;\n#endif\n\nvoid getGlossiness() {\n    dGlossiness = 1.0;\n\n    #ifdef MAPFLOAT\n        dGlossiness *= material_shininess;\n    #endif\n\n    #ifdef MAPTEXTURE\n        dGlossiness *= texture2D(texture_glossMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        dGlossiness *= saturate(vVertexColor.$VC);\n    #endif\n\n    dGlossiness += 0.0000001;\n\n    #ifdef CLEARCOAT\n        ccGlossiness = 1.0;\n        ccGlossiness *= material_clearCoatGlossiness;\n        ccGlossiness += 0.0000001;\n    #endif\n}\n\n";

    var instancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n\n";

    var lightDiffuseLambertPS = "float getLightDiffuse() {\n    return max(dot(dNormalW, -dLightDirNormW), 0.0);\n}\n\n";

    var lightDirPointPS = "void getLightDirPoint(vec3 lightPosW) {\n    dLightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(dLightDirW);\n    dLightPosW = lightPosW;\n}\n\n";

    var lightmapDirPS = "uniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\n\nvoid addLightMap() {\n\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) {\n        dDiffuseLight += color;\n        return;\n    }\n\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n\n    float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\n    float flight = saturate(dot(dLightDirNormW, -dNormalW));\n    float nlight = (flight / max(vlight,0.01)) * 0.5;\n\n    dDiffuseLight += color * nlight * 2.0;\n}\n\nvoid addDirLightMap() {\n    vec4 dir = texture2D(texture_dirLightMap, $UV);\n    if (dot(dir.xyz,vec3(1.0)) < 0.00001) return;\n    vec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n\n    dLightDirNormW = normalize(dir.xyz * 2.0 - vec3(1.0));\n    dSpecularLight += vec3(getLightSpecular()) * color;\n}\n\n";

    var lightmapSinglePS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_lightMap;\n#endif\n\nvoid addLightMap() {\n    vec3 lm = vec3(1.0);\n\n    #ifdef MAPTEXTURE\n        lm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        lm *= saturate(vVertexColor.$VC);\n    #endif\n    \n    dDiffuseLight += lm;\n}\n\n";

    var lightmapSingleVertPS = "void addLightMap() {\n    dDiffuseLight += saturate(vVertexColor.$CH);\n}\n\n";

    var lightSpecularAnisoGGXPS = "// Anisotropic GGX\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n    float PI = 3.141592653589793;\n    float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\n    float anisotropy = material_anisotropy * roughness;\n \n    float at = max((roughness + anisotropy), roughness / 4.0);\n    float ab = max((roughness - anisotropy), roughness / 4.0);\n\n    vec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\n\n    float NoH = dot(tNormalW, h);\n    float ToH = dot(dTBN[0], h);\n    float BoH = dot(dTBN[1], h);\n\n    float a2 = at * ab;\n    vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n    float v2 = dot(v, v);\n    float w2 = a2 / v2;\n    float D = a2 * w2 * w2 * (1.0 / PI);\n\n    float ToV = dot(dTBN[0], dViewDirW);\n    float BoV = dot(dTBN[1], dViewDirW);\n    float ToL = dot(dTBN[0], -dLightDirNormW);\n    float BoL = dot(dTBN[1], -dLightDirNormW);\n    float NoV = dot(tNormalW, dViewDirW);\n    float NoL = dot(tNormalW, -dLightDirNormW);\n\n    float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n    float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n    float G = 0.5 / (lambdaV + lambdaL);\n\n    return D * G;\n}\n\nfloat getLightSpecular() {\n    return calcLightSpecular(dGlossiness, dNormalW);\n}\n\nfloat getLightSpecularCC() {\n    return calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

    var lightSpecularBlinnPS = "// Energy-conserving (hopefully) Blinn-Phong\nfloat calcLightSpecular(float tGlossiness, vec3 tNormalW) {\n    vec3 h = normalize( -dLightDirNormW + dViewDirW );\n    float nh = max( dot( h, tNormalW ), 0.0 );\n\n    float specPow = exp2(tGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048\n    specPow = antiAliasGlossiness(specPow);\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    specPow = max(specPow, 0.0001);\n\n    return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\n\nfloat getLightSpecular() {\n    return calcLightSpecular(dGlossiness, dNormalW);\n}\n\nfloat getLightSpecularCC() {\n    return calcLightSpecular(ccGlossiness, ccNormalW);\n}\n";

    var lightSpecularPhongPS = "float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\n    float specPow = tGlossiness;\n\n    specPow = antiAliasGlossiness(specPow);\n\n    // Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little\n    return pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\n}\n\nfloat getLightSpecular() {\n    return calcLightSpecular(dGlossiness, dReflDirW);\n}\n\nfloat getLightSpecularCC() {\n    return calcLightSpecular(ccGlossiness, ccReflDirW);\n}\n";

    var metalnessPS = "void processMetalness(float metalness) {\n    const float dielectricF0 = 0.04;\n    dSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\n    dAlbedo *= 1.0 - metalness;\n}\n\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_metalnessMap;\n#endif\n\n#ifdef CLEARCOAT\nuniform float material_clearCoatSpecularity;\n#endif\n\nvoid getSpecularity() {\n    float metalness = 1.0;\n\n    #ifdef MAPFLOAT\n        metalness *= material_metalness;\n    #endif\n\n    #ifdef MAPTEXTURE\n        metalness *= texture2D(texture_metalnessMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        metalness *= saturate(vVertexColor.$VC);\n    #endif\n\n    processMetalness(metalness);\n\n    #ifdef CLEARCOAT\n        ccSpecularity = vec3(1.0);\n        ccSpecularity *= material_clearCoatSpecularity;\n    #endif\n}\n\n";

    var msdfPS = "uniform sampler2D texture_msdfMap;\n\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n\n#ifdef GL2\n#define USE_FWIDTH\n#endif\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat map (float min, float max, float v) {\n    return (v - min) / (max - min);\n}\n\n\nuniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF\nuniform float font_textureWidth; // the width of the texture atlas\n\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n\nvec4 applyMsdf(vec4 color) {\n    // sample the field\n    vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n    vec2 uvShdw = vUv0 - shadow_offset;\n    vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n    // get the signed distance value\n    float sigDist = median(tsample.r, tsample.g, tsample.b);\n    float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\n    #ifdef USE_FWIDTH\n        // smoothing depends on size of texture on screen\n        vec2 w = fwidth(vUv0);\n        float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, 0.5);\n    #else\n        float font_size = 16.0; // TODO fix this\n        // smoothing gets smaller as the font size gets bigger\n        // don't have fwidth we can approximate from font size, this doesn't account for scaling\n        // so a big font scaled down will be wrong...\n\n        float smoothing = clamp(font_pxrange / font_size, 0.0, 0.5);\n    #endif\n    float mapMin = 0.05;\n    float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\n    // remap to a smaller range (used on smaller font sizes)\n    float sigDistInner = map(mapMin, mapMax, sigDist);\n    float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n    sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\n    float center = 0.5;\n    // calculate smoothing and use to generate opacity\n    float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n    float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n    float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\n    vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n    tcolor = mix(tcolor, color, inside);\n\n    vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n    tcolor = mix(scolor, tcolor, outline);\n    \n    return tcolor;\n}";

    var normalVS = "vec3 getNormal() {\n    #ifdef SKIN\n        dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    #elif defined(INSTANCING)\n        dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    #else\n        dNormalMatrix = matrix_normal;\n    #endif\n\n    vec3 tempNormal = vertex_normal;\n\n    #ifdef MORPHING\n        #ifdef MORPHING_NRM03\n            tempNormal += morph_weights_a[0] * morph_nrm0;\n            tempNormal += morph_weights_a[1] * morph_nrm1;\n            tempNormal += morph_weights_a[2] * morph_nrm2;\n            tempNormal += morph_weights_a[3] * morph_nrm3;\n        #endif\n        #ifdef MORPHING_NRM47\n            tempNormal += morph_weights_b[0] * morph_nrm4;\n            tempNormal += morph_weights_b[1] * morph_nrm5;\n            tempNormal += morph_weights_b[2] * morph_nrm6;\n            tempNormal += morph_weights_b[3] * morph_nrm7;\n        #endif\n    #endif\n\n    return normalize(dNormalMatrix * tempNormal);\n}\n\n";

    var normalDetailMapPS = "#ifdef MAPTEXTURE\nuniform sampler2D texture_normalDetailMap;\nuniform float material_normalDetailMapBumpiness;\n\nvec3 blendNormals(vec3 n1, vec3 n2) {\n    // https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented\n    n1 += vec3(0, 0, 1);\n    n2 *= vec3(-1, -1, 1);\n    return normalize(n1*dot(n1, n2)/n1.z - n2);\n}\n#endif\n\nvec3 addNormalDetail(vec3 normalMap) {\n    #ifdef MAPTEXTURE\n        vec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\n        normalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\n        return blendNormals(normalMap, normalDetailMap);\n    #else\n        return normalMap;\n    #endif\n}\n\n";

    var normalInstancedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n\n";

    var normalMapPS = "uniform sampler2D texture_normalMap;\nuniform float material_bumpiness;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    normalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\n    dNormalMap = addNormalDetail(normalMap);\n    dNormalW = dTBN * dNormalMap;\n    #ifdef CLEARCOAT\n        ccNormalW = normalize(dVertexNormalW);\n    #endif\n}\n";

    var normalMapFastPS = "uniform sampler2D texture_normalMap;\nvoid getNormal() {\n    vec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\n    dNormalMap = addNormalDetail(normalMap);\n    dNormalW = dTBN * dNormalMap;\n    #ifdef CLEARCOAT\n        ccNormalW = normalize(dVertexNormalW);\n    #endif\n}\n";

    var normalSkinnedVS = "vec3 getNormal() {\n    dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n    return normalize(dNormalMatrix * vertex_normal);\n}\n\n";

    var normalVertexPS = "void getNormal() {\n    dNormalW = normalize(dVertexNormalW);\n    #ifdef CLEARCOAT\n        ccNormalW = dNormalW;\n    #endif\n}\n\n";

    var normalXYPS = "vec3 unpackNormal(vec4 nmap) {\n    vec3 normal;\n    normal.xy = nmap.wy * 2.0 - 1.0;\n    normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n    return normal;\n}\n\n";

    var normalXYZPS = "vec3 unpackNormal(vec4 nmap) {\n    return nmap.xyz * 2.0 - 1.0;\n}\n\n";

    var opacityPS = "#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_opacityMap;\n#endif\n\nvoid getOpacity() {\n    dAlpha = 1.0;\n\n    #ifdef MAPFLOAT\n        dAlpha *= material_opacity;\n    #endif\n\n    #ifdef MAPTEXTURE\n        dAlpha *= texture2D(texture_opacityMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n    #endif\n}\n\n";

    var outputAlphaPS = "gl_FragColor.a = dAlpha;\n";

    var outputAlphaOpaquePS = "gl_FragColor.a = 1.0;\n";

    var outputAlphaPremulPS = "gl_FragColor.rgb *= dAlpha;\ngl_FragColor.a = dAlpha;\n";

    var outputCubemapPS = "varying vec2 vUv0;\n\nuniform samplerCube source;\nuniform vec4 params;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 encodeRGBM(vec4 color) { // modified RGBM\n    color.rgb = pow(color.rgb, vec3(0.5));\n    color.rgb *= 1.0 / 8.0;\n\n    color.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\n    color.a = ceil(color.a * 255.0) / 255.0;\n\n    color.rgb /= color.a;\n    return color;\n}\n\nvoid main(void) {\n\n    vec2 st = vUv0 * 2.0 - 1.0;\n    float face = params.x;\n\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n\n    gl_FragColor = textureCube(source, vec);\n    if (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\n}\n\n";

    var outputTex2DPS = "varying vec2 vUv0;\n\nuniform sampler2D source;\n\nvoid main(void) {\n    gl_FragColor = texture2D(source, vUv0);\n}\n\n";

    var packDepthPS = "// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n\n\n";

    var packDepthMaskPS = "vec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res.x = 0.0;\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n\n";

    var parallaxPS = "uniform sampler2D texture_heightMap;\nuniform float material_heightMapFactor;\nvoid getParallax() {\n    float parallaxScale = material_heightMapFactor;\n\n    float height = texture2D(texture_heightMap, $UV).$CH;\n    height = height * parallaxScale - parallaxScale*0.5;\n    vec3 viewDirT = dViewDirW * dTBN;\n\n    viewDirT.z += 0.42;\n    dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n\n";

    var particlePS = "varying vec4 texCoordsAlphaLife;\n\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nuniform float softening;\nuniform float colorMult;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    float depth = dot(rgbaDepth, bitShift);\n    return depth;\n}\n#endif\n\nvoid main(void) {\n    vec4 tex         = texture2DSRGB(colorMap, texCoordsAlphaLife.xy);\n    vec4 ramp     = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n    ramp.rgb *= colorMult;\n\n    ramp.a += texCoordsAlphaLife.z;\n\n    vec3 rgb =     tex.rgb * ramp.rgb;\n    float a =         tex.a * ramp.a;\n";

    var particleVS = "\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc) {\n    return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\n\nvec4 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex,tc);\n    vec4 b = texture2D(tex,tc + graphSampleSize);\n    float c = fract(tc.x*graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a, b, c);\n}\n\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n   vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n   return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvec2 safeNormalize(vec2 v) {\n    float l = length(v);\n    return (l > 1e-06) ? v / l : v;\n}\n\nvoid main(void) {\n    vec3 meshLocalPos = particle_vertexData.xyz;\n    float id = floor(particle_vertexData.w);\n\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n    float uv = id / numParticlesPot;\n    readInput(uv);\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    float particleLifetime = lifetime;\n\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n    vec2 quadXY = meshLocalPos.xy;\n    float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\n    vec3 paramDiv;\n    vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float scale = params.y;\n    float scaleDiv = paramDiv.x;\n    float alphaDiv = paramDiv.z;\n\n    scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n\n#ifndef USE_MESH\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n    texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\n    vec3 particlePos = inPos;\n    vec3 particlePosMoved = vec3(0.0);\n\n    mat2 rotMatrix;\n";

    var particleAnimFrameClampVS = "\n    float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n\n";

    var particleAnimFrameLoopVS = "\n    float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n\n";

    var particleAnimTexVS = "\n    float animationIndex;\n\n    if (animTexIndexParams.y == 1.0) {\n        animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n    } else {\n        animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n    }\n\n    float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n    float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n    atlasX = fract(atlasX);\n\n    texCoordsAlphaLife.xy *= animTexTilesParams.xy;\n    texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n\n";

    var particleInputFloatPS = "void readInput(float uv) {\n    vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\n    inPos = tex.xyz;\n    inVel = tex2.xyz;\n    inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n    inShow = tex.w >= 0.0;\n    inLife = tex2.w;\n}\n\n";

    var particleInputRgba8PS = "//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\n#define PI2 6.283185307179586\n\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\n\nuniform float maxVel;\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvoid readInput(float uv) {\n    vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n    vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n    vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n    vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\n    inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3(0.5)) * maxVel;\n\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n\n    inLife = decodeFloatRGBA(tex3);\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n\n";

    var particleOutputFloatPS = "void writeOutput() {\n    if (gl_FragCoord.y<1.0) {\n        gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n    } else {\n        gl_FragColor = vec4(outVel, outLife);\n    }\n}\n\n";

    var particleOutputRgba8PS = "uniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\n\nvec2 encodeFloatRG( float v ) {\n  vec2 enc = vec2(1.0, 255.0) * v;\n  enc = fract(enc);\n  enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n  return enc;\n}\n\nvec4 encodeFloatRGBA( float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\n\nvoid writeOutput() {\n    //outPos = (outPos - outBoundsCenter) / outBoundsSize + vec3(0.5);\n\n    outPos = outPos * outBoundsMul + outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n\n    outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul\n\n    float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n    float maxPosLife = lifetime+1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\n    if (gl_FragCoord.y < 1.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (gl_FragCoord.y < 2.0) {\n        gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (gl_FragCoord.y < 3.0) {\n        gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n    } else {\n        gl_FragColor = encodeFloatRGBA(outLife);\n    }\n}\n\n";

    var particleUpdaterAABBPS = "uniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    vec3 pos = inBounds - vec3(0.5);\n\n    vec3 posAbs = abs(pos);\n    vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\n    vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\n    //pos = edge * mix(2.0 * pos, sign(pos), equal(maxPos, posAbs));\n    pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n    pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n    pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n\n#ifndef LOCAL_SPACE\n    return emitterPos + spawnBounds * pos;\n#else\n    return spawnBounds * pos;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity -= vec3(0, 0, initialVelocity);\n}\n\n";

    var particleUpdaterEndPS = "\n    writeOutput();\n}\n\n";

    var particleUpdaterInitPS = "varying vec2 vUv0;\n\nuniform sampler2D particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform sampler2D internalTex3;\n\nuniform mat3 emitterMatrix, emitterMatrixInv;\nuniform vec3 emitterScale;\n\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\nuniform float startAngle, startAngle2;\nuniform float initialVelocity;\n\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\n\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";

    var particleUpdaterNoRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = -1.0;\n    }\n";

    var particleUpdaterOnStopPS = "    visMode = outLife < 0.0? -1.0: visMode;\n\n";

    var particleUpdaterRespawnPS = "    if (outLife >= lifetime) {\n        outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n        visMode = 1.0;\n    }\n    visMode = outLife < 0.0? 1.0: visMode;\n\n";

    var particleUpdaterSpherePS = "uniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n    float rnd4 = fract(rndFactor * 1000.0);\n    vec3 norm = normalize(inBounds.xyz - vec3(0.5));\n    float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n    return emitterPos + norm * r * spawnBoundsSphere;\n#else\n    return norm * r * spawnBoundsSphere;\n#endif\n}\n\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n    localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n\n";

    var particleUpdaterStartPS = "float saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 unpack3NFloats(float src) {\n    float r = fract(src);\n    float g = fract(src * 256.0);\n    float b = fract(src * 65536.0);\n    return vec3(r, g, b);\n}\n\nvec3 tex1Dlod_lerp(sampler2D tex, vec2 tc, out vec3 w) {\n    vec4 a = texture2D(tex, tc);\n    vec4 b = texture2D(tex, tc + graphSampleSize);\n    float c = fract(tc.x * graphNumSamples);\n\n    vec3 unpackedA = unpack3NFloats(a.w);\n    vec3 unpackedB = unpack3NFloats(b.w);\n    w = mix(unpackedA, unpackedB, c);\n\n    return mix(a.xyz, b.xyz, c);\n}\n\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\nvoid main(void)\n{\n    if (gl_FragCoord.x > numParticles) discard;\n\n    readInput(vUv0.x);\n    visMode = inShow? 1.0 : -1.0;\n\n    vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\n    float particleRate = rate + rateDiv * rndFactor.x;\n\n    outLife = inLife + delta;\n    float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\n    vec3 localVelocityDiv;\n    vec3 velocityDiv;\n    vec3 paramDiv;\n    vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\n    vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\n    vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\n    float rotSpeed = params.x;\n    float rotSpeedDiv = paramDiv.y;\n\n    vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\n    float radialSpeed = radialParams.x;\n    float radialSpeedDiv = radialParams.y;\n\n    bool respawn = inLife <= 0.0 || outLife >= lifetime;\n    inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n    inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n\n#ifndef LOCAL_SPACE\n    vec3 radialVel = inPos - emitterPos;\n#else\n    vec3 radialVel = inPos;\n#endif\n    radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n    radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\n    localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n    velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n    rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\n    addInitialVelocity(localVelocity, rndFactor.xyz);\n\n#ifndef LOCAL_SPACE\n    outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n    outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\n    outPos = inPos + outVel * delta;\n    outAngle = inAngle + rotSpeed * delta;\n";

    var particle_billboardVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = billboard(particlePos, quadXY);\n\n";

    var particle_blendAddPS = "\n    rgb *= saturate(gammaCorrectInput(a));\n    if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n\n";

    var particle_blendMultiplyPS = "\n    rgb = mix(vec3(1.0), rgb, vec3(a));\n    if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n\n";

    var particle_blendNormalPS = "\n    if (a < 0.01) discard;\n";

    var particle_cpuVS = "attribute vec4 particle_vertexData;     // XYZ = world pos, W = life\nattribute vec4 particle_vertexData2;     // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute vec4 particle_vertexData3;     // XYZ = particle local pos, W = velocity.y\nattribute float particle_vertexData4;     // particle id\n#ifndef USE_MESH\n#define VDATA5TYPE vec2\n#else\n#define VDATA5TYPE vec4\n#endif\nattribute VDATA5TYPE particle_vertexData5;     // VDATA4TYPE depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\n//uniform float graphSampleSize;\n//uniform float graphNumSamples;\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\nuniform sampler2D texLifeAndSourcePosOUT;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\nuniform vec3 emitterPos;\n\nvarying vec4 texCoordsAlphaLife;\n\n\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n    float c = cos(pRotation);\n    float s = sin(pRotation);\n    //vec4 rotationMatrix = vec4(c, -s, s, c);\n\n    mat2 m = mat2(c, -s, s, c);\n    rotMatrix = m;\n\n    return m * quadXY;\n}\n\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n    return pos;\n}\n\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n    vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n    return pos;\n}\n\nvoid main(void)\n{\n    vec3 particlePos = particle_vertexData.xyz;\n    vec3 inPos = particlePos;\n    vec3 vertPos = particle_vertexData3.xyz;\n    vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\n    float id = floor(particle_vertexData4);\n    float rndFactor = fract(sin(id + 1.0 + seed));\n    vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n#ifdef LOCAL_SPACE\n    inVel = mat3(matrix_model) * inVel;\n#endif\n    vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used\n\n    vec2 quadXY = vertPos.xy;\n    \n#ifndef USE_MESH\n    texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#else\n    texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#endif\n    mat2 rotMatrix;\n\n    float inAngle = particle_vertexData2.x;\n    vec3 particlePosMoved = vec3(0.0);\n    vec3 meshLocalPos = particle_vertexData3.xyz;\n\n";

    var particle_cpu_endVS = "\n    localPos *= particle_vertexData2.y * emitterScale;\n    localPos += particlePos;\n\n    gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";

    var particle_customFaceVS = "\n    quadXY = rotate(quadXY, inAngle, rotMatrix);\n    vec3 localPos = customFace(particlePos, quadXY);\n";

    var particle_endPS = "    rgb = addFog(rgb);\n    rgb = toneMap(rgb);\n    rgb = gammaCorrectOutput(rgb);\n    gl_FragColor = vec4(rgb, a);\n}\n";

    var particle_endVS = "\n    localPos *= scale * emitterScale;\n    localPos += particlePos;\n\n    gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n";

    var particle_halflambertPS = "\n    vec3 negNormal = normal*0.5+0.5;\n    vec3 posNormal = -normal*0.5+0.5;\n    negNormal *= negNormal;\n    posNormal *= posNormal;\n\n\n";

    var particle_initVS = "attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor\n#ifdef USE_MESH\nattribute vec2 particle_uv;         // mesh UV\n#endif\n\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform float numParticles, numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\nuniform sampler2D particleTexOUT, particleTexIN;\nuniform sampler2D internalTex0;\nuniform sampler2D internalTex1;\nuniform sampler2D internalTex2;\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n\nvarying vec4 texCoordsAlphaLife;\n\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n\n";

    var particle_lambertPS = "\n    vec3 negNormal = max(normal, vec3(0.0));\n    vec3 posNormal = max(-normal, vec3(0.0));\n\n\n";

    var particle_lightingPS = "\n    vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n                        negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n                        negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\n\n    rgb *= light;\n\n\n";

    var particle_localShiftVS = "    particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n\n";

    var particle_meshVS = "\n    vec3 localPos = meshLocalPos;\n    localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n    localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\n    billboard(particlePos, quadXY);\n\n\n";

    var particle_normalVS = "\n    Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";

    var particle_normalMapPS = "\n    vec3 normalMap         = normalize( texture2D(normalMap, texCoordsAlphaLife.xy).xyz * 2.0 - 1.0 );\n    vec3 normal = ParticleMat * normalMap;\n\n\n\n\n";

    var particle_pointAlongVS = "    inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors\n\n";

    var particle_softPS = "\n    float depth = getLinearScreenDepth();\n    float particleDepth = vDepth;\n    float depthDiff = saturate(abs(particleDepth - depth) * softening);\n    a *= depthDiff;\n";

    var particle_softVS = "\n    vDepth = getLinearDepth(localPos);\n";

    var particle_stretchVS = "    vec3 moveDir = inVel * stretch;\n    vec3 posPrev = particlePos - moveDir;\n    posPrev += particlePosMoved;\n\n    vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\n    float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\n    particlePos = mix(particlePos, posPrev, interpolation);\n\n";

    var particle_TBNVS = "\n    mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0,        rotMatrix[1][0], rotMatrix[1][1], 0.0,        0.0, 0.0, 1.0);\n    ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n\n";

    var particle_wrapVS = "\n    vec3 origParticlePos = particlePos;\n    particlePos -= matrix_model[3].xyz;\n    particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n    particlePos += matrix_model[3].xyz;\n    particlePosMoved = particlePos - origParticlePos;\n\n\n";

    var precisionTestPS = "void main(void) {\n    gl_FragColor = vec4(2147483648.0);\n}\n\n";

    var precisionTest2PS = "uniform sampler2D source;\n\nvec4 packFloat(float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n    return res;\n}\n\nvoid main(void) {\n    float c = texture2D(source, vec2(0.0)).r;\n    float diff = abs(c - 2147483648.0) / 2147483648.0;\n    gl_FragColor = packFloat(diff);\n}\n\n";

    var prefilterCubemapPS = "varying vec2 vUv0;\n\nuniform samplerCube source;\nuniform vec4 params;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat rnd(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\n\nconst float PI = 3.14159265358979;\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) { // cos + lerped cone size (better than just lerped)\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = sqrt(1.0 - uv.x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return normalize(mix(vecSpace * sampleDir, cubeDir, params.y));\n}\n\nvec3 hemisphereSample_phong(vec2 uv, mat3 vecSpace, vec3 cubeDir, float specPow) {\n    float phi = uv.y * 2.0 * PI;\n    float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    return vecSpace * sampleDir;\n}\n\nmat3 matrixFromVector(vec3 n) { // frisvad\n    float a = 1.0 / (1.0 + n.z);\n    float b = -n.x * n.y * a;\n    vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n    vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3(b1, b2, n);\n}\n\nvec4 encodeRGBM(vec3 color) { // modified RGBM\n    vec4 encoded;\n    encoded.rgb = pow(color.rgb, vec3(0.5));\n    encoded.rgb *= 1.0 / 8.0;\n\n    encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n    encoded.a = ceil(encoded.a * 255.0) / 255.0;\n\n    encoded.rgb /= encoded.a;\n    return encoded;\n}\n\nvoid main(void) {\n\n    vec2 st = vUv0 * 2.0 - 1.0;\n\n    if (params.w==1.0 || params.w==3.0) {\n        st = 2.0 * floor(gl_FragCoord.xy) / (params.z - 1.0) - 1.0;\n    }\n\n    float face = params.x;\n\n    vec3 vec;\n    if (face==0.0) {\n        vec = vec3(1, -st.y, -st.x);\n    } else if (face==1.0) {\n        vec = vec3(-1, -st.y, st.x);\n    } else if (face==2.0) {\n        vec = vec3(st.x, 1, st.y);\n    } else if (face==3.0) {\n        vec = vec3(st.x, -1, -st.y);\n    } else if (face==4.0) {\n        vec = vec3(st.x, -st.y, 1);\n    } else {\n        vec = vec3(-st.x, -st.y, -1);\n    }\n\n    mat3 vecSpace = matrixFromVector(normalize(vec));\n\n    vec3 color = vec3(0.0);\n    const int samples = $NUMSAMPLES;\n    vec3 vect;\n    for(int i=0; i<samples; i++) {\n        float sini = sin(float(i));\n        float cosi = cos(float(i));\n        float rand = rnd(vec2(sini, cosi));\n\n        vect = hemisphereSample_$METHOD(vec2(float(i) / float(samples), rand), vecSpace, vec, params.y);\n\n        color += $textureCube(source, vect).rgb;\n    }\n    color /= float(samples);\n\n    gl_FragColor = params.w < 2.0? vec4(color, 1.0) : encodeRGBM(color);\n}\n";

    var reflDirPS = "void getReflDir() {\n    dReflDirW = normalize(-reflect(dViewDirW, dNormalW));\n    #ifdef CLEARCOAT\n        ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n    #endif    \n}\n\n";

    var reflDirAnisoPS = "void getReflDir() {\n    float roughness = sqrt(1.0 - min(dGlossiness, 1.0));\n    float anisotropy = material_anisotropy * roughness;\n    vec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\n    vec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\n    vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n    vec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\n    dReflDirW = reflect(-dViewDirW, bentNormal);\n    #ifdef CLEARCOAT\n        ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\n    #endif    \n}\n\n";

    var reflectionCCPS = "#ifdef CLEARCOAT\nuniform float material_clearCoatReflectivity;\nvoid addReflectionCC() {    \n    ccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity); \n}\n#endif\n";

    var reflectionCubePS = "uniform samplerCube texture_cubeMap;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\n    lookupVec.x *= -1.0;\n    return $textureCubeSAMPLE(texture_cubeMap, lookupVec).rgb;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var reflectionDpAtlasPS = "uniform sampler2D texture_sphereMap;\n\nvec2 getDpAtlasUv(vec2 uv, float mip) {\n\n    vec4 rect;\n    float sx = saturate(mip - 2.0);\n    rect.x = sx * 0.5;\n\n    float t = mip - rect.x * 6.0;\n    float i = 1.0 - rect.x;\n    rect.y = min(t * 0.5, 0.75) * i + rect.x;\n\n    float st = saturate(t);\n    rect.z = (1.0 - st * 0.5) * i;\n    rect.w = rect.z * 0.5;\n\n    float rcRectZ = 1.0 / rect.z;\n    float scaleFactor = 0.00390625 * rcRectZ; // 0.0078125 = (256 + 2) / 256 - 1, 0.00390625 same for 512\n    vec2 scale = vec2(scaleFactor, scaleFactor * 2.0);\n    uv = uv * (vec2(1.0) - scale) + scale * 0.5;\n\n    uv = uv * rect.zw + rect.xy;\n\n    return uv;\n}\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDir = normalize(cubeMapProject(tReflDirW));\n\n    // Convert vector to DP coords\n    bool up = reflDir.y > 0.0;\n    float scale = 0.90909090909090909090909090909091;// 1.0 / 1.1;\n    vec3 reflDirWarp = reflDir.xzx * vec3(-0.25, 0.5, 0.25);\n    float reflDirVer = abs(reflDir.y) + 1.0;\n    reflDirWarp /= reflDirVer;\n    reflDirWarp *= scale;\n    reflDirWarp = vec3(0.75, 0.5, 0.25) - reflDirWarp;\n    vec2 tc = up? reflDirWarp.xy : reflDirWarp.zy;\n\n    float bias = saturate(1.0 - tGlossiness) * 5.0; // multiply by max mip level\n\n    float mip = floor(bias);\n    vec3 tex1 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\n    mip = min(mip + 1.0, 5.0);\n    vec3 tex2 = $texture2DSAMPLE(texture_sphereMap, getDpAtlasUv(tc, mip)).rgb;\n\n    tex1 = mix(tex1, tex2, fract(bias));\n    tex1 = processEnvironment(tex1);\n\n    return tex1;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var reflectionPrefilteredCubePS = "uniform samplerCube texture_prefilteredCubeMap128;\nuniform samplerCube texture_prefilteredCubeMap64;\nuniform samplerCube texture_prefilteredCubeMap32;\nuniform samplerCube texture_prefilteredCubeMap16;\nuniform samplerCube texture_prefilteredCubeMap8;\n#ifndef PMREM4\n#define PMREM4\nuniform samplerCube texture_prefilteredCubeMap4;\n#endif\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    // Unfortunately, WebGL doesn't allow us using textureCubeLod. Therefore bunch of nasty workarounds is required.\n    // We fix mip0 to 128x128, so code is rather static.\n    // Mips smaller than 4x4 aren't great even for diffuse. Don't forget that we don't have bilinear filtering between different faces.\n\n    float bias = saturate(1.0 - tGlossiness) * 5.0; // multiply by max mip level\n    int index1 = int(bias);\n    int index2 = int(min(bias + 1.0, 7.0));\n\n    vec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n\n    vec4 cubes[6];\n    cubes[0] = textureCube(texture_prefilteredCubeMap128, fixedReflDir);\n    cubes[1] = textureCube(texture_prefilteredCubeMap64, fixedReflDir);\n    cubes[2] = textureCube(texture_prefilteredCubeMap32, fixedReflDir);\n    cubes[3] = textureCube(texture_prefilteredCubeMap16, fixedReflDir);\n    cubes[4] = textureCube(texture_prefilteredCubeMap8, fixedReflDir);\n    cubes[5] = textureCube(texture_prefilteredCubeMap4, fixedReflDir);\n\n    // Also we don't have dynamic indexing in PS, so...\n    vec4 cube[2];\n    for(int i = 0; i < 6; i++) {\n        if (i == index1) {\n            cube[0] = cubes[i];\n        }\n        if (i == index2) {\n            cube[1] = cubes[i];\n        }\n    }\n\n    // another variant\n    /*if (index1==0){ cube[0]=cubes[0];\n    }else if (index1==1){ cube[0]=cubes[1];\n    }else if (index1==2){ cube[0]=cubes[2];\n    }else if (index1==3){ cube[0]=cubes[3];\n    }else if (index1==4){ cube[0]=cubes[4];\n    }else if (index1==5){ cube[0]=cubes[5];}\n\n    if (index2==0){ cube[1]=cubes[0];\n    }else if (index2==1){ cube[1]=cubes[1];\n    }else if (index2==2){ cube[1]=cubes[2];\n    }else if (index2==3){ cube[1]=cubes[3];\n    }else if (index2==4){ cube[1]=cubes[4];\n    }else if (index2==5){ cube[1]=cubes[5];}*/\n\n    vec4 cubeFinal = mix(cube[0], cube[1], fract(bias));\n    vec3 refl = processEnvironment($DECODE(cubeFinal).rgb);\n\n    return refl;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var reflectionPrefilteredCubeLodPS = "\n#ifndef PMREM4\n#define PMREM4\n#extension GL_EXT_shader_texture_lod : enable\nuniform samplerCube texture_prefilteredCubeMap128;\n#endif\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    float bias = saturate(1.0 - tGlossiness) * 5.0; // multiply by max mip level\n    vec3 fixedReflDir = fixSeams(cubeMapProject(tReflDirW), bias);\n    fixedReflDir.x *= -1.0;\n\n    vec3 refl = processEnvironment($DECODE( textureCubeLodEXT(texture_prefilteredCubeMap128, fixedReflDir, bias) ).rgb);\n\n    return refl;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var reflectionSpherePS = "#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\n\n    float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n    vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\n    return $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var reflectionSphereLowPS = "uniform sampler2D texture_sphereMap;\n\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\n    vec3 reflDirV = vNormalV;\n\n    vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\n    return $texture2DSAMPLE(texture_sphereMap, sphereMapUv).rgb;\n}\n\nuniform float material_reflectivity;\nvoid addReflection() {   \n    dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\n}\n";

    var refractionPS = "uniform float material_refraction, material_refractionIndex;\n\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\n    float vn = dot(viewVec, Normal);\n    float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n    vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\n    return refrVec;\n}\n\nvoid addRefraction() {\n\n    // use same reflection code with refraction vector\n    vec3 tmp = dReflDirW;\n    vec4 tmp2 = dReflection;\n    dReflection = vec4(0.0);\n    dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\n\n    addReflection();\n\n    dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\n    dReflDirW = tmp;\n    dReflection = tmp2;\n}\n\n";

    var rgbmPS = "vec3 decodeRGBM(vec4 rgbm) {\n    vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n    return color * color;\n}\n\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n    return decodeRGBM(texture2D(tex, uv));\n}\n\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\n    return decodeRGBM(textureCube(tex, uvw));\n}\n\n";

    var screenDepthPS = "uniform sampler2D uDepthMap;\n\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params; // 1 / camera_far,      camera_far,     (1 - f / n) / 2,        (1 + f / n) / 2\n#endif\n\n#ifdef GL2\n    float linearizeDepth(float z) {\n        z = z * 2.0 - 1.0;\n        return 1.0 / (camera_params.z * z + camera_params.w);\n    }\n#else\n    #ifndef UNPACKFLOAT\n    #define UNPACKFLOAT\n    float unpackFloat(vec4 rgbaDepth) {\n        const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n        return dot(rgbaDepth, bitShift);\n    }\n    #endif\n#endif\n\n// Retrieves rendered linear camera depth by UV\nfloat getLinearScreenDepth(vec2 uv) {\n    #ifdef GL2\n        return linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\n    #else\n        return unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\n    #endif\n}\n\n#ifndef VERTEXSHADER\n// Retrieves rendered linear camera depth under the current pixel\nfloat getLinearScreenDepth() {\n    vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n    return getLinearScreenDepth(uv);\n}\n#endif\n\n// Generates linear camera depth for the given world position\nfloat getLinearDepth(vec3 pos) {\n    return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";

    var shadowCommonPS = "void normalOffsetPointShadow(vec4 shadowParams) {\n    float distScale = length(dLightDirW);\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02\n    vec3 dir = wPos - dLightPosW;\n    dLightDirW = dir;\n}\n\n";

    var shadowCoordPS = "void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xy /= projPos.w;\n    dShadowCoord.xy = projPos.xy;\n    dShadowCoord.z = length(dLightDirW) * shadowParams.w;\n\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n}\n\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n\n";

    var shadowCoordVS = "void getLightDirPoint(vec3 lightPosW) {\n    vec3 lightDirW = vPositionW - lightPosW;\n    dLightDirNormW = normalize(lightDirW);\n    dLightPosW = lightPosW;\n}\n\nvoid _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\n\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    vMainShadowUv = projPos;\n}\n\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec3 shadowParams) {\n    _getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\n}\n\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n\n    _getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\n    vec3 wPos = vPositionW + dNormalW * shadowParams.y * clamp(1.0 - dot(dNormalW, -dLightDirNormW), 0.0, 1.0); //0.08\n\n    _getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\n}\n\n";

    var shadowCoordPerspZbufferPS = "void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n    vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n    projPos.xyz /= projPos.w;\n    dShadowCoord = projPos.xyz;\n    // depth bias is already applied on render\n}\n\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\n    float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?\n    vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\n\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\n    _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\n}\n\n";

    var shadowEVSMPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec3 moments = texture2D(tex, texCoords).xyz;\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n\n";

    var shadowEVSMnPS = "float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    float pixelSize = 1.0 / resolution;\n    texCoords -= vec2(pixelSize);\n    vec3 s00 = texture2D(tex, texCoords).xyz;\n    vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n    vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n    vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n    vec2 fr = fract(texCoords * resolution);\n    vec3 h0 = mix(s00, s10, fr.x);\n    vec3 h1 = mix(s01, s11, fr.x);\n    vec3 moments = mix(h0, h1, fr.y);\n    return calculateEVSM(moments, Z, vsmBias, exponent);\n}\n\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n\n";

    var shadowStandardPS = "vec3 lessThan2(vec3 a, vec3 b) {\n    return clamp((b - a)*1000.0, 0.0, 1.0); // softer version\n}\n\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n#endif\n\n// ----- Direct/Spot Sampling -----\n\n#ifdef GL2\n    float _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        float z = dShadowCoord.z;\n        vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n        float shadowMapSizeInv = 1.0 / shadowParams.x;\n        vec2 base_uv = floor(uv + 0.5);\n        float s = (uv.x + 0.5 - base_uv.x);\n        float t = (uv.y + 0.5 - base_uv.y);\n        base_uv -= vec2(0.5);\n        base_uv *= shadowMapSizeInv;\n\n        float sum = 0.0;\n\n        float uw0 = (3.0 - 2.0 * s);\n        float uw1 = (1.0 + 2.0 * s);\n\n        float u0 = (2.0 - s) / uw0 - 1.0;\n        float u1 = s / uw1 + 1.0;\n\n        float vw0 = (3.0 - 2.0 * t);\n        float vw1 = (1.0 + 2.0 * t);\n\n        float v0 = (2.0 - t) / vw0 - 1.0;\n        float v1 = t / vw1 + 1.0;\n\n        u0 = u0 * shadowMapSizeInv + base_uv.x;\n        v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n        u1 = u1 * shadowMapSizeInv + base_uv.x;\n        v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n        sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n        sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n        sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n        sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n\n        sum *= 1.0f / 16.0;\n        return sum;\n    }\n\n    float getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n\n    float getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#else\n    float _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\n        mat3 shadowKernel;\n        vec3 shadowCoord = dShadowCoord;\n        vec3 shadowZ = vec3(shadowCoord.z);\n        shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n        shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n        shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\n        vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\n        shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n        shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n        vec4 shadowValues;\n        shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n        shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n        shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n        shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n        return dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n    }\n\n    float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        vec3 shadowCoord = dShadowCoord;\n\n        float xoffset = 1.0 / shadowParams.x; // 1/shadow map width\n        float dx0 = -xoffset;\n        float dx1 = xoffset;\n\n        mat3 depthKernel;\n        depthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n        depthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n        depthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n        depthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n        depthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\n        depthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n        depthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n        depthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n        depthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\n        return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\n    }\n\n    float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams);\n    }\n\n    float getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\n        return _getShadowPCF3x3(shadowMap, shadowParams.xyz);\n    }\n#endif\n\n\n// ----- Point Sampling -----\n\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\n    vec3 tc = normalize(dir);\n    vec3 tcAbs = abs(tc);\n\n    vec4 dirX = vec4(1,0,0, tc.x);\n    vec4 dirY = vec4(0,1,0, tc.y);\n    float majorAxisLength = tc.z;\n    if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n        dirX = vec4(0,0,1, tc.z);\n        dirY = vec4(0,1,0, tc.y);\n        majorAxisLength = tc.x;\n    } else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n        dirX = vec4(1,0,0, tc.x);\n        dirY = vec4(0,0,1, tc.z);\n        majorAxisLength = tc.y;\n    }\n\n    float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\n    vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n    vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n    vec3 dx0 = -xoffset;\n    vec3 dy0 = -yoffset;\n    vec3 dx1 = xoffset;\n    vec3 dy1 = yoffset;\n\n    mat3 shadowKernel;\n    mat3 depthKernel;\n\n    depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n    depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n    depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n    depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n    depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n    depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n    depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n    depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n    depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\n    vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\n    shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n    shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n    shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\n    vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\n    vec2 fractionalCoord = fract( uv * shadowParams.x );\n\n    shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n    shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\n    vec4 shadowValues;\n    shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n    shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n    shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n    shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\n    return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\n\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\n    return _getShadowPoint(shadowMap, shadowParams, dLightDirW);\n}\n\n";

    var shadowStandardGL2PS = "float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    // http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/\n\n    float z = dShadowCoord.z;\n    vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    float shadowMapSizeInv = 1.0 / shadowParams.x;\n    vec2 base_uv = floor(uv + 0.5);\n    float s = (uv.x + 0.5 - base_uv.x);\n    float t = (uv.y + 0.5 - base_uv.y);\n    base_uv -= vec2(0.5);\n    base_uv *= shadowMapSizeInv;\n\n\n    float uw0 = (4.0 - 3.0 * s);\n    float uw1 = 7.0;\n    float uw2 = (1.0 + 3.0 * s);\n\n    float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n    float u1 = (3.0 + s) / uw1;\n    float u2 = s / uw2 + 2.0;\n\n    float vw0 = (4.0 - 3.0 * t);\n    float vw1 = 7.0;\n    float vw2 = (1.0 + 3.0 * t);\n\n    float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n    float v1 = (3.0 + t) / vw1;\n    float v2 = t / vw2 + 2.0;\n\n    float sum = 0.0;\n\n    u0 = u0 * shadowMapSizeInv + base_uv.x;\n    v0 = v0 * shadowMapSizeInv + base_uv.y;\n\n    u1 = u1 * shadowMapSizeInv + base_uv.x;\n    v1 = v1 * shadowMapSizeInv + base_uv.y;\n\n    u2 = u2 * shadowMapSizeInv + base_uv.x;\n    v2 = v2 * shadowMapSizeInv + base_uv.y;\n\n    sum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\n    sum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\n    sum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\n\n    sum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\n    sum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\n    sum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\n\n    sum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\n    sum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\n    sum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\n\n    sum *= 1.0f / 144.0;\n\n    sum = gammaCorrectInput(sum); // gives softer gradient\n    sum = saturate(sum);\n\n    return sum;\n}\n\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\n\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\n    return _getShadowPCF5x5(shadowMap, shadowParams.xyz);\n}\n";

    var shadowStandardGL2VSPS = "float getShadowPCF5x5VS(sampler2DShadow shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001; // prevent going to dark after the far plane\n    return _getShadowPCF5x5(shadowMap, shadowParams);\n}\n\n";

    var shadowStandardVSPS = "#ifdef GL2\n#define SHADOW_SAMPLERVS sampler2DShadow\n#else\n#define SHADOW_SAMPLERVS sampler2D\n#endif\n\nfloat getShadowPCF3x3VS(SHADOW_SAMPLERVS shadowMap, vec3 shadowParams) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\n\n    #ifdef SHADOWBIAS\n        dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\n    #endif\n\n    return _getShadowPCF3x3(shadowMap, shadowParams);\n}\n\n";

    var shadowVSM8PS = "float calculateVSM8(vec3 moments, float Z, float vsmBias) {\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * Z;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\n\nfloat decodeFloatRG(vec2 rg) {\n    return rg.y*(1.0/255.0) + rg.x;\n}\n\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n    vec4 c = texture2D(tex, texCoords);\n    vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n    return calculateVSM8(moments, Z, vsmBias);\n}\n\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\n}\n\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\n    return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n";

    var shadowVSMVSPS = "float getShadowVSM$VS(sampler2D shadowMap, vec3 shadowParams, float exponent) {\n    dShadowCoord = vMainShadowUv.xyz;\n    dShadowCoord.z += shadowParams.z;\n    dShadowCoord.xyz /= vMainShadowUv.w;\n    dShadowCoord.z = min(dShadowCoord.z, 1.0);\n\n    return $VSM(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\n}\n\n";

    var shadowVSM_commonPS = "float linstep(float a, float b, float v) {\n    return saturate((v - a) / (b - a));\n}\n\nfloat reduceLightBleeding(float pMax, float amount) {\n  // Remove the [0, amount] tail and linearly rescale (amount, 1].\n   return linstep(amount, 1.0, pMax);\n}\n\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    // Compute probabilistic upper bound\n    float d = mean - moments.x;\n    float pMax = variance / (variance + (d * d));\n\n    pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\n    // One-tailed Chebyshev\n    return (mean <= moments.x ? 1.0 : pMax);\n}\n\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n    Z = 2.0 * Z - 1.0;\n    float warpedDepth = exp(exponent * Z);\n\n    moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\n    float VSMBias = vsmBias;//0.01 * 0.25;\n    float depthScale = VSMBias * exponent * warpedDepth;\n    float minVariance1 = depthScale * depthScale;\n    return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n\n";

    var skinBatchConstVS = "attribute float vertex_boneIndices;\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i) {\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n\n";

    var skinBatchTexVS = "attribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n\n    y = dy * (y + 0.5);\n\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n\n    mat4 bone = mat4(v1, v2, v3, v4);\n\n    return bone;\n}\n\n";

    var skinConstVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform mat4 matrix_pose[BONE_LIMIT];\n\nmat4 getBoneMatrix(const in float i)\n{\n    mat4 bone = matrix_pose[int(i)];\n\n    return bone;\n}\n\n";

    var skinTexVS = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n\nuniform highp sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\n\nmat4 getBoneMatrix(const in float i)\n{\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n\n    y = dy * (y + 0.5);\n\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n\n    mat4 bone = mat4(v1, v2, v3, v4);\n\n    return bone;\n}\n\n";

    var skyboxPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture_cubeMap, fixSeams(vViewDir));\n}\n\n";

    var skyboxVS = "attribute vec3 aPosition;\n\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nuniform mat4 matrix_projectionSkybox;\n\nvarying vec3 vViewDir;\n\nvoid main(void)\n{\n    mat4 view = matrix_view;\n    view[3][0] = view[3][1] = view[3][2] = 0.0;\n    gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem\n\n    gl_Position.z = gl_Position.w - 0.00001;\n    vViewDir = aPosition;\n    vViewDir.x *= -1.0;\n}\n\n";

    var skyboxHDRPS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n\nvoid main(void) {\n    vec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(vViewDir, $FIXCONST)).rgb);\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n\n";

    var skyboxPrefilteredCubePS = "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n\nvec3 fixSeamsStretch(vec3 vec, float mipmapIndex, float cubemapSize) {\n    float scale = 1.0 - exp2(mipmapIndex) / cubemapSize;\n    float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n    if (abs(vec.x) != M) vec.x *= scale;\n    if (abs(vec.y) != M) vec.y *= scale;\n    if (abs(vec.z) != M) vec.z *= scale;\n    return vec;\n}\n\nvoid main(void) {\n    vec3 color = textureCubeRGBM(texture_cubeMap, fixSeamsStretch(vViewDir, 0.0, 128.0));\n    color = toneMap(color);\n    color = gammaCorrectOutput(color);\n    gl_FragColor = vec4(color, 1.0);\n}\n\n";

    var specularPS = "#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\n\n#ifdef MAPTEXTURE\nuniform sampler2D texture_specularMap;\n#endif\n\n#ifdef CLEARCOAT\nuniform float material_clearCoatSpecularity;\n#endif\n\nvoid getSpecularity() {\n    dSpecularity = vec3(1.0);\n\n    #ifdef MAPCOLOR\n        dSpecularity *= material_specular;\n    #endif\n\n    #ifdef MAPTEXTURE\n        dSpecularity *= texture2D(texture_specularMap, $UV).$CH;\n    #endif\n\n    #ifdef MAPVERTEX\n        dSpecularity *= saturate(vVertexColor.$VC);\n    #endif\n\n    #ifdef CLEARCOAT\n        ccSpecularity = vec3(1.0);\n        ccSpecularity *= material_clearCoatSpecularity;\n    #endif\n}\n\n";

    var specularAaNonePS = "float antiAliasGlossiness(float power) {\n    return power;\n}\n\n";

    var specularAaToksvigPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * mix(1.0, toksvig, material_bumpiness);\n}\n\n";

    var specularAaToksvigFastPS = "float antiAliasGlossiness(float power) {\n    float rlen = 1.0 / saturate(length(dNormalMap));\n    float toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\n    return power * toksvig;\n}\n\n";

    var spotPS = "float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\n    float cosAngle = dot(dLightDirNormW, lightSpotDirW);\n    return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n\n";

    var startPS = "\nvoid main(void) {\n    dDiffuseLight = vec3(0);\n    dSpecularLight = vec3(0);\n    dReflection = vec4(0);\n    dSpecularity = vec3(0);\n    #ifdef CLEARCOAT\n        ccSpecularLight = vec3(0);\n        ccReflection = vec4(0);\n        ccSpecularity = vec3(0);\n    #endif\n    ";

    var startVS = "\nvoid main(void) {\n    gl_Position = getPosition();\n";

    var startNineSlicedPS = "    nineSlicedUv = vUv0;\n\n";

    var startNineSlicedTiledPS = "\n    vec2 tileMask = step(vMask, vec2(0.99999));\n    vec2 clampedUv = mix(innerOffset.xy*0.5, vec2(1.0) - innerOffset.zw*0.5, fract(vTiledUv));\n    clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n    nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\n";

    var storeEVSMPS = "float exponent = VSM_EXPONENT;\n\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n\n";

    var tangentBinormalVS = "\nvec3 getTangent() {\n    return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\n\nvec3 getBinormal() {\n    return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n\nvec3 getObjectSpaceUp() {\n    return normalize(dNormalMatrix * vec3(0, 1, 0));\n}\n\n";

    var TBNPS = "void getTBN() {\n    dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\n}\n\n";

    var TBNderivativePS = "// http://www.thetenthplanet.de/archives/1180\nvoid getTBN() {\n    vec2 uv = $UV;\n\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( vPositionW );\n    vec3 dp2 = dFdy( vPositionW );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n\n    // solve the linear system\n    vec3 dp2perp = cross( dp2, dVertexNormalW );\n    vec3 dp1perp = cross( dVertexNormalW, dp1 );\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n    // construct a scale-invariant frame\n    float invmax = 1.0 / sqrt( max( dot(T,T), dot(B,B) ) );\n    dTBN = mat3( T * invmax, B * invmax, dVertexNormalW );\n}\n\n";

    var TBNfastPS = "void getTBN() {\n    dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\n}\n\n";

    var TBNObjectSpacePS = "void getTBN() {\n\n    vec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\n    vec3 T = cross(dVertexNormalW, B);\n\n    if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW dVertexNormalW are parallel\n    {\n        float major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\n\n        if (dVertexNormalW.x==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,1,0));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.y==major)\n        {\n            B=cross(dVertexNormalW, vec3(0,0,1));\n            T=cross(dVertexNormalW, B);\n        }\n        else if (dVertexNormalW.z==major)\n        {\n            B=cross(dVertexNormalW, vec3(1,0,0));\n            T=cross(dVertexNormalW, B);\n        }\n    }\n\n    dTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\n}\n\n";

    var tonemappingAcesPS = "uniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    vec3 x = color * exposure;\n    return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";

    var tonemappingAces2PS = "uniform float exposure;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n";

    var tonemappingFilmicPS = "const float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\n\nuniform float exposure;\n\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 toneMap(vec3 color) {\n    color = uncharted2Tonemap(color * exposure);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n    color = color * whiteScale;\n\n    return color;\n}\n\n";

    var tonemappingHejlPS = "uniform float exposure;\n\nvec3 toneMap(vec3 color) {\n    color *= exposure;\n    const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n    const float Scl = 1.25;\n\n    vec3 h = max( vec3(0.0), color - vec3(0.004) );\n    return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n\n";

    var tonemappingLinearPS = "uniform float exposure;\nvec3 toneMap(vec3 color) {\n    return color * exposure;\n}\n\n";

    var tonemappingNonePS = "vec3 toneMap(vec3 color) {\n    return color;\n}\n\n";

    var transformVS = "#ifdef PIXELSNAP\n    uniform vec4 uScreenSize;\n#endif\n\n#ifdef MORPHING\n    uniform vec4 morph_weights_a;\n    uniform vec4 morph_weights_b;\n#endif\n\nmat4 getModelMatrix() {\n    #ifdef DYNAMICBATCH\n        return getBoneMatrix(vertex_boneIndices);\n    #elif defined(SKIN)\n        return matrix_model * (getBoneMatrix(vertex_boneIndices.x) * vertex_boneWeights.x +\n               getBoneMatrix(vertex_boneIndices.y) * vertex_boneWeights.y +\n               getBoneMatrix(vertex_boneIndices.z) * vertex_boneWeights.z +\n               getBoneMatrix(vertex_boneIndices.w) * vertex_boneWeights.w);\n    #elif defined(INSTANCING)\n        return mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n    #else\n        return matrix_model;\n    #endif\n}\n\nvec4 getPosition() {\n    dModelMatrix = getModelMatrix();\n    vec3 localPos = vertex_position;\n\n    #ifdef NINESLICED\n        // outer and inner vertices are at the same position, scale both\n        localPos.xz *= outerScale;\n\n        // offset inner vertices inside\n        // (original vertices must be in [-1;1] range)\n        vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n        vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n        localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n        vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n        localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n        localPos = localPos.xzy;\n    #endif\n\n    #ifdef MORPHING\n        #ifdef MORPHING_POS03\n            localPos.xyz += morph_weights_a[0] * morph_pos0;\n            localPos.xyz += morph_weights_a[1] * morph_pos1;\n            localPos.xyz += morph_weights_a[2] * morph_pos2;\n            localPos.xyz += morph_weights_a[3] * morph_pos3;\n        #endif\n        #ifdef MORPHING_POS47\n            localPos.xyz += morph_weights_b[0] * morph_pos4;\n            localPos.xyz += morph_weights_b[1] * morph_pos5;\n            localPos.xyz += morph_weights_b[2] * morph_pos6;\n            localPos.xyz += morph_weights_b[3] * morph_pos7;\n        #endif\n    #endif\n\n    vec4 posW = dModelMatrix * vec4(localPos, 1.0);\n    #ifdef SCREENSPACE\n        posW.zw = vec2(0.0, 1.0);\n    #endif\n    dPositionW = posW.xyz;\n\n    vec4 screenPos;\n    #ifdef UV1LAYOUT\n        screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n    #else\n        #ifdef SCREENSPACE\n            screenPos = posW;\n        #else\n            screenPos = matrix_viewProjection * posW;\n        #endif\n\n        #ifdef PIXELSNAP\n            // snap vertex to a pixel boundary\n            screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n            screenPos.xy *= uScreenSize.xy;\n            screenPos.xy = floor(screenPos.xy);\n            screenPos.xy *= uScreenSize.zw;\n            screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n        #endif\n    #endif\n\n    return screenPos;\n}\n\nvec3 getWorldPosition() {\n    return dPositionW;\n}\n";

    var transformDeclVS = "attribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvec3 dPositionW;\nmat4 dModelMatrix;\n\n";

    var uv0VS = "#ifdef NINESLICED\nvec2 getUv0() {\n    vec2 uv = vertex_position.xz;\n\n    // offset inner vertices inside\n    // (original vertices must be in [-1;1] range)\n    vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n    vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n    uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\n    uv = uv * -0.5 + 0.5;\n    uv = uv * atlasRect.zw + atlasRect.xy;\n\n    vMask = vertex_texCoord0.xy;\n\n    return uv;\n}\n#else\nvec2 getUv0() {\n    return vertex_texCoord0;\n}\n#endif\n\n";

    var uv1VS = "\nvec2 getUv1() {\n    return vertex_texCoord1;\n}\n";

    var viewDirPS = "void getViewDir() {\n    dViewDirW = normalize(view_position - vPositionW);\n}\n\n";

    var viewNormalVS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n\nvec3 getViewNormal() {\n    return mat3(matrix_view) * vNormalW;\n}\n";

    /**
     * @static
     * @readonly
     * @type {object}
     * @name pc.shaderChunks
     * @description Object containing all default shader chunks used by shader generators.
     */
    var shaderChunks = {
        alphaTestPS: alphaTestPS,
        ambientConstantPS: ambientConstantPS,
        ambientPrefilteredCubePS: ambientPrefilteredCubePS,
        ambientPrefilteredCubeLodPS: ambientPrefilteredCubeLodPS,
        ambientSHPS: ambientSHPS,
        aoPS: aoPS,
        aoSpecOccPS: aoSpecOccPS,
        aoSpecOccConstPS: aoSpecOccConstPS,
        aoSpecOccConstSimplePS: aoSpecOccConstSimplePS,
        aoSpecOccSimplePS: aoSpecOccSimplePS,
        bakeDirLmEndPS: bakeDirLmEndPS,
        bakeLmEndPS: bakeLmEndPS,
        basePS: basePS,
        baseVS: baseVS,
        baseNineSlicedPS: baseNineSlicedPS,
        baseNineSlicedVS: baseNineSlicedVS,
        baseNineSlicedTiledPS: baseNineSlicedTiledPS,
        biasConstPS: biasConstPS,
        blurVSMPS: blurVSMPS,
        combineClearCoatPS: combineClearCoatPS,
        combineDiffusePS: combineDiffusePS,
        combineDiffuseSpecularPS: combineDiffuseSpecularPS,
        combineDiffuseSpecularNoConservePS: combineDiffuseSpecularNoConservePS,
        combineDiffuseSpecularNoReflPS: combineDiffuseSpecularNoReflPS,
        combineDiffuseSpecularNoReflSeparateAmbientPS: combineDiffuseSpecularNoReflSeparateAmbientPS,
        combineDiffuseSpecularOldPS: combineDiffuseSpecularOldPS,
        cookiePS: cookiePS,
        cubeMapProjectBoxPS: cubeMapProjectBoxPS,
        cubeMapProjectNonePS: cubeMapProjectNonePS,
        detailModesPS: detailModesPS,
        diffusePS: diffusePS,
        diffuseDetailMapPS: diffuseDetailMapPS,
        dilatePS: dilatePS,
        dpAtlasQuadPS: dpAtlasQuadPS,
        emissivePS: emissivePS,
        endPS: endPS,
        envConstPS: envConstPS,
        envMultiplyPS: envMultiplyPS,
        extensionPS: extensionPS,
        extensionVS: extensionVS,
        falloffInvSquaredPS: falloffInvSquaredPS,
        falloffLinearPS: falloffLinearPS,
        fixCubemapSeamsNonePS: fixCubemapSeamsNonePS,
        fixCubemapSeamsStretchPS: fixCubemapSeamsStretchPS,
        fogExpPS: fogExpPS,
        fogExp2PS: fogExp2PS,
        fogLinearPS: fogLinearPS,
        fogNonePS: fogNonePS,
        fresnelSchlickPS: fresnelSchlickPS,
        fullscreenQuadPS: fullscreenQuadPS,
        fullscreenQuadVS: fullscreenQuadVS,
        gamma1_0PS: gamma1_0PS,
        gamma2_2PS: gamma2_2PS,
        genParaboloidPS: genParaboloidPS,
        gles3PS: gles3PS,
        gles3VS: gles3VS,
        glossPS: glossPS,
        instancingVS: instancingVS,
        lightDiffuseLambertPS: lightDiffuseLambertPS,
        lightDirPointPS: lightDirPointPS,
        lightmapDirPS: lightmapDirPS,
        lightmapSinglePS: lightmapSinglePS,
        lightmapSingleVertPS: lightmapSingleVertPS,
        lightSpecularAnisoGGXPS: lightSpecularAnisoGGXPS,
        lightSpecularBlinnPS: lightSpecularBlinnPS,
        lightSpecularPhongPS: lightSpecularPhongPS,
        metalnessPS: metalnessPS,
        msdfPS: msdfPS,
        normalVS: normalVS,
        normalDetailMapPS: normalDetailMapPS,
        normalInstancedVS: normalInstancedVS,
        normalMapPS: normalMapPS,
        normalMapFastPS: normalMapFastPS,
        normalSkinnedVS: normalSkinnedVS,
        normalVertexPS: normalVertexPS,
        normalXYPS: normalXYPS,
        normalXYZPS: normalXYZPS,
        opacityPS: opacityPS,
        outputAlphaPS: outputAlphaPS,
        outputAlphaOpaquePS: outputAlphaOpaquePS,
        outputAlphaPremulPS: outputAlphaPremulPS,
        outputCubemapPS: outputCubemapPS,
        outputTex2DPS: outputTex2DPS,
        packDepthPS: packDepthPS,
        packDepthMaskPS: packDepthMaskPS,
        parallaxPS: parallaxPS,
        particlePS: particlePS,
        particleVS: particleVS,
        particleAnimFrameClampVS: particleAnimFrameClampVS,
        particleAnimFrameLoopVS: particleAnimFrameLoopVS,
        particleAnimTexVS: particleAnimTexVS,
        particleInputFloatPS: particleInputFloatPS,
        particleInputRgba8PS: particleInputRgba8PS,
        particleOutputFloatPS: particleOutputFloatPS,
        particleOutputRgba8PS: particleOutputRgba8PS,
        particleUpdaterAABBPS: particleUpdaterAABBPS,
        particleUpdaterEndPS: particleUpdaterEndPS,
        particleUpdaterInitPS: particleUpdaterInitPS,
        particleUpdaterNoRespawnPS: particleUpdaterNoRespawnPS,
        particleUpdaterOnStopPS: particleUpdaterOnStopPS,
        particleUpdaterRespawnPS: particleUpdaterRespawnPS,
        particleUpdaterSpherePS: particleUpdaterSpherePS,
        particleUpdaterStartPS: particleUpdaterStartPS,
        particle_billboardVS: particle_billboardVS,
        particle_blendAddPS: particle_blendAddPS,
        particle_blendMultiplyPS: particle_blendMultiplyPS,
        particle_blendNormalPS: particle_blendNormalPS,
        particle_cpuVS: particle_cpuVS,
        particle_cpu_endVS: particle_cpu_endVS,
        particle_customFaceVS: particle_customFaceVS,
        particle_endPS: particle_endPS,
        particle_endVS: particle_endVS,
        particle_halflambertPS: particle_halflambertPS,
        particle_initVS: particle_initVS,
        particle_lambertPS: particle_lambertPS,
        particle_lightingPS: particle_lightingPS,
        particle_localShiftVS: particle_localShiftVS,
        particle_meshVS: particle_meshVS,
        particle_normalVS: particle_normalVS,
        particle_normalMapPS: particle_normalMapPS,
        particle_pointAlongVS: particle_pointAlongVS,
        particle_softPS: particle_softPS,
        particle_softVS: particle_softVS,
        particle_stretchVS: particle_stretchVS,
        particle_TBNVS: particle_TBNVS,
        particle_wrapVS: particle_wrapVS,
        precisionTestPS: precisionTestPS,
        precisionTest2PS: precisionTest2PS,
        prefilterCubemapPS: prefilterCubemapPS,
        reflDirPS: reflDirPS,
        reflDirAnisoPS: reflDirAnisoPS,
        reflectionCCPS: reflectionCCPS,
        reflectionCubePS: reflectionCubePS,
        reflectionDpAtlasPS: reflectionDpAtlasPS,
        reflectionPrefilteredCubePS: reflectionPrefilteredCubePS,
        reflectionPrefilteredCubeLodPS: reflectionPrefilteredCubeLodPS,
        reflectionSpherePS: reflectionSpherePS,
        reflectionSphereLowPS: reflectionSphereLowPS,
        refractionPS: refractionPS,
        rgbmPS: rgbmPS,
        screenDepthPS: screenDepthPS,
        shadowCommonPS: shadowCommonPS,
        shadowCoordPS: shadowCoordPS,
        shadowCoordVS: shadowCoordVS,
        shadowCoordPerspZbufferPS: shadowCoordPerspZbufferPS,
        shadowEVSMPS: shadowEVSMPS,
        shadowEVSMnPS: shadowEVSMnPS,
        shadowStandardPS: shadowStandardPS,
        shadowStandardGL2PS: shadowStandardGL2PS,
        shadowStandardGL2VSPS: shadowStandardGL2VSPS,
        shadowStandardVSPS: shadowStandardVSPS,
        shadowVSM8PS: shadowVSM8PS,
        shadowVSMVSPS: shadowVSMVSPS,
        shadowVSM_commonPS: shadowVSM_commonPS,
        skinBatchConstVS: skinBatchConstVS,
        skinBatchTexVS: skinBatchTexVS,
        skinConstVS: skinConstVS,
        skinTexVS: skinTexVS,
        skyboxPS: skyboxPS,
        skyboxVS: skyboxVS,
        skyboxHDRPS: skyboxHDRPS,
        skyboxPrefilteredCubePS: skyboxPrefilteredCubePS,
        specularPS: specularPS,
        specularAaNonePS: specularAaNonePS,
        specularAaToksvigPS: specularAaToksvigPS,
        specularAaToksvigFastPS: specularAaToksvigFastPS,
        spotPS: spotPS,
        startPS: startPS,
        startVS: startVS,
        startNineSlicedPS: startNineSlicedPS,
        startNineSlicedTiledPS: startNineSlicedTiledPS,
        storeEVSMPS: storeEVSMPS,
        tangentBinormalVS: tangentBinormalVS,
        TBNPS: TBNPS,
        TBNderivativePS: TBNderivativePS,
        TBNfastPS: TBNfastPS,
        TBNObjectSpacePS: TBNObjectSpacePS,
        tonemappingAcesPS: tonemappingAcesPS,
        tonemappingAces2PS: tonemappingAces2PS,
        tonemappingFilmicPS: tonemappingFilmicPS,
        tonemappingHejlPS: tonemappingHejlPS,
        tonemappingLinearPS: tonemappingLinearPS,
        tonemappingNonePS: tonemappingNonePS,
        transformVS: transformVS,
        transformDeclVS: transformDeclVS,
        uv0VS: uv0VS,
        uv1VS: uv1VS,
        viewDirPS: viewDirPS,
        viewNormalVS: viewNormalVS
    };

    var attrib2Semantic = {
        vertex_position: SEMANTIC_POSITION,
        vertex_normal: SEMANTIC_NORMAL,
        vertex_tangent: SEMANTIC_TANGENT,
        vertex_texCoord0: SEMANTIC_TEXCOORD0,
        vertex_texCoord1: SEMANTIC_TEXCOORD1,
        vertex_texCoord2: SEMANTIC_TEXCOORD2,
        vertex_texCoord3: SEMANTIC_TEXCOORD3,
        vertex_texCoord4: SEMANTIC_TEXCOORD4,
        vertex_texCoord5: SEMANTIC_TEXCOORD5,
        vertex_texCoord6: SEMANTIC_TEXCOORD6,
        vertex_texCoord7: SEMANTIC_TEXCOORD7,
        vertex_color: SEMANTIC_COLOR,
        vertex_boneIndices: SEMANTIC_BLENDINDICES,
        vertex_boneWeights: SEMANTIC_BLENDWEIGHT
    };

    shaderChunks.collectAttribs = function (vsCode) {
        var attribs = {};
        var attrs = 0;

        var found = vsCode.indexOf("attribute");
        while (found >= 0) {
            if (found > 0 && vsCode[found - 1] === "/") break;
            var endOfLine = vsCode.indexOf(';', found);
            var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
            var attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));

            var semantic = attrib2Semantic[attribName];
            if (semantic !== undefined) {
                attribs[attribName] = semantic;
            } else {
                attribs[attribName] = "ATTR" + attrs;
                attrs++;
            }

            found = vsCode.indexOf("attribute", found + 1);
        }
        return attribs;
    };


    shaderChunks.createShader = function (device, vsName, psName, useTransformFeedback) {
        var vsCode = shaderChunks[vsName];
        var psCode = programlib.precisionCode(device) + "\n" + shaderChunks[psName];
        var attribs = this.collectAttribs(vsCode);

        if (device.webgl2) {
            vsCode = programlib.versionCode(device) + this.gles3VS + vsCode;
            psCode = programlib.versionCode(device) + this.gles3PS + psCode;
        }

        return new Shader(device, {
            attributes: attribs,
            vshader: vsCode,
            fshader: psCode,
            useTransformFeedback: useTransformFeedback
        });
    };

    shaderChunks.createShaderFromCode = function (device, vsCode, psCode, uName, useTransformFeedback) {
        var shaderCache = device.programLib._cache;
        var cached = shaderCache[uName];
        if (cached !== undefined) return cached;

        psCode = programlib.precisionCode(device) + "\n" + (psCode || programlib.dummyFragmentCode());
        var attribs = this.collectAttribs(vsCode);

        if (device.webgl2) {
            vsCode = programlib.versionCode(device) + this.gles3VS + vsCode;
            psCode = programlib.versionCode(device) + this.gles3PS + psCode;
        }

        shaderCache[uName] = new Shader(device, {
            attributes: attribs,
            vshader: vsCode,
            fshader: psCode,
            useTransformFeedback: useTransformFeedback
        });
        return shaderCache[uName];
    };

    /**
     * @class
     * @name pc.Texture
     * @classdesc A texture is a container for texel data that can be utilized in a fragment shader.
     * Typically, the texel data represents an image that is mapped over geometry.
     * @description Creates a new texture.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this texture.
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string} [options.name] - The name of the texture.
     * @param {number} [options.width] - The width of the texture in pixels. Defaults to 4.
     * @param {number} [options.height] - The height of the texture in pixels. Defaults to 4.
     * @param {number} [options.depth] - The number of depth slices in a 3D texture (WebGL2 only). Defaults to 1 (single 2D image).
     * @param {number} [options.format] - The pixel format of the texture. Can be:
     * * {@link pc.PIXELFORMAT_A8}
     * * {@link pc.PIXELFORMAT_L8}
     * * {@link pc.PIXELFORMAT_L8_A8}
     * * {@link pc.PIXELFORMAT_R5_G6_B5}
     * * {@link pc.PIXELFORMAT_R5_G5_B5_A1}
     * * {@link pc.PIXELFORMAT_R4_G4_B4_A4}
     * * {@link pc.PIXELFORMAT_R8_G8_B8}
     * * {@link pc.PIXELFORMAT_R8_G8_B8_A8}
     * * {@link pc.PIXELFORMAT_DXT1}
     * * {@link pc.PIXELFORMAT_DXT3}
     * * {@link pc.PIXELFORMAT_DXT5}
     * * {@link pc.PIXELFORMAT_RGB16F}
     * * {@link pc.PIXELFORMAT_RGBA16F}
     * * {@link pc.PIXELFORMAT_RGB32F}
     * * {@link pc.PIXELFORMAT_RGBA32F}
     * * {@link pc.PIXELFORMAT_ETC1}
     * * {@link pc.PIXELFORMAT_PVRTC_2BPP_RGB_1}
     * * {@link pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1}
     * * {@link pc.PIXELFORMAT_PVRTC_4BPP_RGB_1}
     * * {@link pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1}
     * * {@link pc.PIXELFORMAT_111110F}
     * * {@link pc.PIXELFORMAT_ASTC_4x4}>/li>
     * * {@link pc.PIXELFORMAT_ATC_RGB}
     * * {@link pc.PIXELFORMAT_ATC_RGBA}
     * Defaults to pc.PIXELFORMAT_R8_G8_B8_A8.
     * @param {number} [options.minFilter] - The minification filter type to use. Defaults to {@link pc.FILTER_LINEAR_MIPMAP_LINEAR}
     * @param {number} [options.magFilter] - The magnification filter type to use. Defaults to {@link pc.FILTER_LINEAR}
     * @param {number} [options.anisotropy] - The level of anisotropic filtering to use. Defaults to 1
     * @param {number} [options.addressU] - The repeat mode to use in the U direction. Defaults to {@link pc.ADDRESS_REPEAT}
     * @param {number} [options.addressV] - The repeat mode to use in the V direction. Defaults to {@link pc.ADDRESS_REPEAT}
     * @param {number} [options.addressW] - The repeat mode to use in the W direction. Defaults to {@link pc.ADDRESS_REPEAT}
     * @param {boolean} [options.mipmaps] - When enabled try to generate or use mipmaps for this texture. Default is true
     * @param {boolean} [options.cubemap] - Specifies whether the texture is to be a cubemap. Defaults to false.
     * @param {boolean} [options.volume] - Specifies whether the texture is to be a 3D volume (WebGL2 only). Defaults to false.
     * @param {string} [options.type] - Specifies the image type, see {@link pc.TEXTURETYPE_DEFAULT}
     * @param {boolean} [options.fixCubemapSeams] - Specifies whether this cubemap texture requires special
     * seam fixing shader code to look right. Defaults to false.
     * @param {boolean} [options.flipY] - Specifies whether the texture should be flipped in the Y-direction. Only affects textures
     * with a source that is an image, canvas or video element. Does not affect cubemaps, compressed textures or textures set from raw
     * pixel data. Defaults to true.
     * @param {boolean} [options.premultiplyAlpha] - If true, the alpha channel of the texture (if present) is multiplied into the color
     * channels. Defaults to false.
     * @param {boolean} [options.compareOnRead] - When enabled, and if texture format is pc.PIXELFORMAT_DEPTH or pc.PIXELFORMAT_DEPTHSTENCIL,
     * hardware PCF is enabled for this texture, and you can get filtered results of comparison using texture() in your shader (WebGL2 only).
     * Defaults to false.
     * @param {number} [options.compareFunc] - Comparison function when compareOnRead is enabled (WebGL2 only). Defaults to pc.FUNC_LESS.
     * Possible values:
     * * {@link pc.FUNC_LESS}
     * * {@link pc.FUNC_LESSEQUAL}
     * * {@link pc.FUNC_GREATER}
     * * {@link pc.FUNC_GREATEREQUAL}
     * * {@link pc.FUNC_EQUAL}
     * * {@link pc.FUNC_NOTEQUAL}
     * @example
     * // Create a 8x8x24-bit texture
     * var texture = new pc.Texture(graphicsDevice, {
     *     width: 8,
     *     height: 8,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     *
     * // Fill the texture with a gradient
     * var pixels = texture.lock();
     * var count = 0;
     * for (var i = 0; i < 8; i++) {
     *     for (var j = 0; j < 8; j++) {
     *         pixels[count++] = i * 32;
     *         pixels[count++] = j * 32;
     *         pixels[count++] = 255;
     *     }
     * }
     * texture.unlock();
     * @property {string} name The name of the texture. Defaults to null.
     */
    function Texture(graphicsDevice, options) {
        this.device = graphicsDevice;

        this.name = null;
        this._width = 4;
        this._height = 4;
        this._depth = 1;

        this._format = PIXELFORMAT_R8_G8_B8_A8;
        this.type = TEXTURETYPE_DEFAULT;

        this._cubemap = false;
        this._volume = false;
        this.fixCubemapSeams = false;
        this._flipY = true;
        this._premultiplyAlpha = false;

        this._mipmaps = true;

        this._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
        this._magFilter = FILTER_LINEAR;
        this._anisotropy = 1;
        this._addressU = ADDRESS_REPEAT;
        this._addressV = ADDRESS_REPEAT;
        this._addressW = ADDRESS_REPEAT;

        this._compareOnRead = false;
        this._compareFunc = FUNC_LESS;


        if (options !== undefined) {
            if (options.name !== undefined) {
                this.name = options.name;
            }
            this._width = (options.width !== undefined) ? options.width : this._width;
            this._height = (options.height !== undefined) ? options.height : this._height;

            this._format = (options.format !== undefined) ? options.format : this._format;

            if (options.hasOwnProperty('type')) {
                this.type = options.type;
            } else if (options.hasOwnProperty('rgbm')) {
                this.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
            } else if (options.hasOwnProperty('swizzleGGGR')) {
                this.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
            }

            if (options.mipmaps !== undefined) {
                this._mipmaps = options.mipmaps;
            } else {
                this._mipmaps = (options.autoMipmap !== undefined) ? options.autoMipmap : this._mipmaps;
            }

            this._levels = options.levels;

            this._cubemap = (options.cubemap !== undefined) ? options.cubemap : this._cubemap;
            this.fixCubemapSeams = (options.fixCubemapSeams !== undefined) ? options.fixCubemapSeams : this.fixCubemapSeams;

            this._minFilter = (options.minFilter !== undefined) ? options.minFilter : this._minFilter;
            this._magFilter = (options.magFilter !== undefined) ? options.magFilter : this._magFilter;
            this._anisotropy = (options.anisotropy !== undefined) ? options.anisotropy : this._anisotropy;
            this._addressU = (options.addressU !== undefined) ? options.addressU : this._addressU;
            this._addressV = (options.addressV !== undefined) ? options.addressV : this._addressV;

            this._compareOnRead = (options.compareOnRead !== undefined) ? options.compareOnRead : this._compareOnRead;
            this._compareFunc = (options._compareFunc !== undefined) ? options._compareFunc : this._compareFunc;

            this._flipY = (options.flipY !== undefined) ? options.flipY : this._flipY;
            this._premultiplyAlpha = (options.premultiplyAlpha !== undefined) ? options.premultiplyAlpha : this._premultiplyAlpha;

            if (graphicsDevice.webgl2) {
                this._depth = (options.depth !== undefined) ? options.depth : this._depth;
                this._volume = (options.volume !== undefined) ? options.volume : this._volume;
                this._addressW = (options.addressW !== undefined) ? options.addressW : this._addressW;
            }

        }

        this._compressed = (this._format === PIXELFORMAT_DXT1 ||
                            this._format === PIXELFORMAT_DXT3 ||
                            this._format === PIXELFORMAT_DXT5 ||
                            this._format >= PIXELFORMAT_ETC1);

        // Mip levels
        this._invalid = false;
        this._lockedLevel = -1;
        if (!this._levels) {
            this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];
        }

        this.dirtyAll();

        this._gpuSize = 0;
    }

    Object.defineProperties(Texture.prototype, {
        /**
         * @name pc.Texture#minFilter
         * @type {number}
         * @description The minification filter to be applied to the texture. Can be:
         * * {@link pc.FILTER_NEAREST}
         * * {@link pc.FILTER_LINEAR}
         * * {@link pc.FILTER_NEAREST_MIPMAP_NEAREST}
         * * {@link pc.FILTER_NEAREST_MIPMAP_LINEAR}
         * * {@link pc.FILTER_LINEAR_MIPMAP_NEAREST}
         * * {@link pc.FILTER_LINEAR_MIPMAP_LINEAR}
         */
        minFilter: {
            get: function () {
                return this._minFilter;
            },
            set: function (v) {
                if (this._minFilter !== v) {
                    this._minFilter = v;
                    this._parameterFlags |= 1;
                }
            }
        },

        /**
         * @name pc.Texture#magFilter
         * @type {number}
         * @description The magnification filter to be applied to the texture. Can be:
         * * {@link pc.FILTER_NEAREST}
         * * {@link pc.FILTER_LINEAR}
         */
        magFilter: {
            get: function () {
                return this._magFilter;
            },
            set: function (v) {
                if (this._magFilter !== v) {
                    this._magFilter = v;
                    this._parameterFlags |= 2;
                }
            }
        },

        /**
         * @name pc.Texture#addressU
         * @type {number}
         * @description The addressing mode to be applied to the texture horizontally. Can be:
         * * {@link pc.ADDRESS_REPEAT}
         * * {@link pc.ADDRESS_CLAMP_TO_EDGE}
         * * {@link pc.ADDRESS_MIRRORED_REPEAT}
         */
        addressU: {
            get: function () {
                return this._addressU;
            },
            set: function (v) {
                if (this._addressU !== v) {
                    this._addressU = v;
                    this._parameterFlags |= 4;
                }
            }
        },

        /**
         * @name pc.Texture#addressV
         * @type {number}
         * @description The addressing mode to be applied to the texture vertically. Can be:
         * * {@link pc.ADDRESS_REPEAT}
         * * {@link pc.ADDRESS_CLAMP_TO_EDGE}
         * * {@link pc.ADDRESS_MIRRORED_REPEAT}
         */
        addressV: {
            get: function () {
                return this._addressV;
            },
            set: function (v) {
                if (this._addressV !== v) {
                    this._addressV = v;
                    this._parameterFlags |= 8;
                }
            }
        },

        /**
         * @name pc.Texture#addressW
         * @type {number}
         * @description The addressing mode to be applied to the 3D texture depth (WebGL2 only). Can be:
         * * {@link pc.ADDRESS_REPEAT}
         * * {@link pc.ADDRESS_CLAMP_TO_EDGE}
         * * {@link pc.ADDRESS_MIRRORED_REPEAT}
         */
        addressW: {
            get: function () {
                return this._addressW;
            },
            set: function (addressW) {
                if (!this.device.webgl2) return;
                if (!this._volume) {
                    return;
                }
                if (addressW !== this._addressW) {
                    this._addressW = addressW;
                    this._parameterFlags |= 16;
                }
            }
        },

        /**
         * @name pc.Texture#compareOnRead
         * @type {boolean}
         * @description When enabled, and if texture format is pc.PIXELFORMAT_DEPTH or pc.PIXELFORMAT_DEPTHSTENCIL,
         * hardware PCF is enabled for this texture, and you can get filtered results of comparison using texture() in your shader (WebGL2 only).
         */
        compareOnRead: {
            get: function () {
                return this._compareOnRead;
            },
            set: function (v) {
                if (this._compareOnRead !== v) {
                    this._compareOnRead = v;
                    this._parameterFlags |= 32;
                }
            }
        },

        /**
         * @name pc.Texture#compareFunc
         * @type {number}
         * @description Comparison function when compareOnRead is enabled (WebGL2 only).
         * Possible values:
         * * {@link pc.FUNC_LESS}
         * * {@link pc.FUNC_LESSEQUAL}
         * * {@link pc.FUNC_GREATER}
         * * {@link pc.FUNC_GREATEREQUAL}
         * * {@link pc.FUNC_EQUAL}
         * * {@link pc.FUNC_NOTEQUAL}
         */
        compareFunc: {
            get: function () {
                return this._compareFunc;
            },
            set: function (v) {
                if (this._compareFunc !== v) {
                    this._compareFunc = v;
                    this._parameterFlags |= 64;
                }
            }
        },

        /**
         * @name pc.Texture#anisotropy
         * @type {number}
         * @description Integer value specifying the level of anisotropic to apply to the texture
         * ranging from 1 (no anisotropic filtering) to the {@link pc.GraphicsDevice} property maxAnisotropy.
         */
        anisotropy: {
            get: function () {
                return this._anisotropy;
            },
            set: function (v) {
                if (this._anisotropy !== v) {
                    this._anisotropy = v;
                    this._parameterFlags |= 128;
                }
            }
        },

        /**
         * @private
         * @deprecated
         * @name pc.Texture#autoMipmap
         * @type {boolean}
         * @description Toggles automatic mipmap generation. Can't be used on non power of two textures.
         */
        autoMipmap: {
            get: function () {
                return this._mipmaps;
            },
            set: function (v) {
                this._mipmaps = v;
            }
        },

        /**
         * @name pc.Texture#mipmaps
         * @type {boolean}
         * @description Defines if texture should generate/upload mipmaps if possible.
         */
        mipmaps: {
            get: function () {
                return this._mipmaps;
            },
            set: function (v) {
                if (this._mipmaps !== v) {
                    this._mipmaps = v;
                    this._minFilterDirty = true;

                    if (v) this._needsMipmapsUpload = true;
                }
            }
        },

        /**
         * @readonly
         * @name pc.Texture#width
         * @type {number}
         * @description The width of the texture in pixels.
         */
        width: {
            get: function () {
                return this._width;
            }
        },

        /**
         * @readonly
         * @name pc.Texture#height
         * @type {number}
         * @description The height of the texture in pixels.
         */
        height: {
            get: function () {
                return this._height;
            }
        },

        /**
         * @readonly
         * @name pc.Texture#depth
         * @type {number}
         * @description The number of depth slices in a 3D texture (WebGL2 only).
         */
        depth: {
            get: function () {
                return this._depth;
            }
        },

        /**
         * @readonly
         * @name pc.Texture#format
         * @type {number}
         * @description The pixel format of the texture. Can be:
         * * {@link pc.PIXELFORMAT_A8}
         * * {@link pc.PIXELFORMAT_L8}
         * * {@link pc.PIXELFORMAT_L8_A8}
         * * {@link pc.PIXELFORMAT_R5_G6_B5}
         * * {@link pc.PIXELFORMAT_R5_G5_B5_A1}
         * * {@link pc.PIXELFORMAT_R4_G4_B4_A4}
         * * {@link pc.PIXELFORMAT_R8_G8_B8}
         * * {@link pc.PIXELFORMAT_R8_G8_B8_A8}
         * * {@link pc.PIXELFORMAT_DXT1}
         * * {@link pc.PIXELFORMAT_DXT3}
         * * {@link pc.PIXELFORMAT_DXT5}
         * * {@link pc.PIXELFORMAT_RGB16F}
         * * {@link pc.PIXELFORMAT_RGBA16F}
         * * {@link pc.PIXELFORMAT_RGB32F}
         * * {@link pc.PIXELFORMAT_RGBA32F}
         * * {@link pc.PIXELFORMAT_ETC1}
         * * {@link pc.PIXELFORMAT_PVRTC_2BPP_RGB_1}
         * * {@link pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1}
         * * {@link pc.PIXELFORMAT_PVRTC_4BPP_RGB_1}
         * * {@link pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1}
         * * {@link pc.PIXELFORMAT_111110F}
         * * {@link pc.PIXELFORMAT_ASTC_4x4}>/li>
         * * {@link pc.PIXELFORMAT_ATC_RGB}
         * * {@link pc.PIXELFORMAT_ATC_RGBA}
         */
        format: {
            get: function () {
                return this._format;
            }
        },

        /**
         * @readonly
         * @name pc.Texture#cubemap
         * @type {boolean}
         * @description Returns true if this texture is a cube map and false otherwise.
         */
        cubemap: {
            get: function () {
                return this._cubemap;
            }
        },

        gpuSize: {
            get: function () {
                var mips = this.pot &&
                        (this._mipmaps ||
                            this._minFilter === FILTER_NEAREST_MIPMAP_NEAREST ||
                            this._minFilter === FILTER_NEAREST_MIPMAP_LINEAR ||
                            this._minFilter === FILTER_LINEAR_MIPMAP_NEAREST ||
                            this._minFilter === FILTER_LINEAR_MIPMAP_LINEAR) &&
                            !(this._compressed && this._levels.length === 1);

                return Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
            }
        },

        /**
         * @readonly
         * @name pc.Texture#volume
         * @type {boolean}
         * @description Returns true if this texture is a 3D volume and false otherwise.
         */
        volume: {
            get: function () {
                return this._volume;
            }
        },

        /**
         * @name pc.Texture#flipY
         * @type {boolean}
         * @description Specifies whether the texture should be flipped in the Y-direction. Only affects textures
         * with a source that is an image, canvas or video element. Does not affect cubemaps, compressed textures
         * or textures set from raw pixel data. Defaults to true.
         */
        flipY: {
            get: function () {
                return this._flipY;
            },
            set: function (flipY) {
                if (this._flipY !== flipY) {
                    this._flipY = flipY;
                    this._needsUpload = true;
                }
            }
        },

        premultiplyAlpha: {
            get: function () {
                return this._premultiplyAlpha;
            },
            set: function (premultiplyAlpha) {
                if (this._premultiplyAlpha !== premultiplyAlpha) {
                    this._premultiplyAlpha = premultiplyAlpha;
                    this._needsUpload = true;
                }
            }
        },

        /**
         * @readonly
         * @name pc.Texture#pot
         * @type {boolean}
         * @description Returns true if all dimensions of the texture are power of two, and false otherwise.
         */
        pot: {
            get: function () {
                return pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height);
            }
        }
    });

    var _pixelSizeTable = null;
    var _blockSizeTable = null;

    // static functions
    Object.assign(Texture, {
        /**
         * @private
         * @function
         * @name pc.Texture.calcGpuSize
         * @description Calculate the GPU memory required for a texture.
         * @param {number} [width] - Texture's width.
         * @param {number} [height] - Texture's height.
         * @param {number} [depth] - Texture's depth.
         * @param {number} [format] - Texture's pixel format (pc.PIXELFORMAT_***).
         * @param {boolean} [mipmaps] - True if the texture includes mipmaps, false otherwise.
         * @param {boolean} [cubemap] - True is the texture is a cubemap, false otherwise.
         * @returns {number} The amount of GPU memory required for the texture, in bytes.
         */
        calcGpuSize: function (width, height, depth, format, mipmaps, cubemap) {
            if (!_pixelSizeTable) {
                _pixelSizeTable = [];
                _pixelSizeTable[PIXELFORMAT_A8] = 1;
                _pixelSizeTable[PIXELFORMAT_L8] = 1;
                _pixelSizeTable[PIXELFORMAT_L8_A8] = 1;
                _pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;
                _pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;
                _pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;
                _pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;
                _pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;
                _pixelSizeTable[PIXELFORMAT_RGB16F] = 8;
                _pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;
                _pixelSizeTable[PIXELFORMAT_RGB32F] = 16;
                _pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;
                _pixelSizeTable[PIXELFORMAT_R32F] = 4;
                _pixelSizeTable[PIXELFORMAT_DEPTH] = 4; // can be smaller using WebGL1 extension?
                _pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;
                _pixelSizeTable[PIXELFORMAT_111110F] = 4;
                _pixelSizeTable[PIXELFORMAT_SRGB] = 4;
                _pixelSizeTable[PIXELFORMAT_SRGBA] = 4;
            }

            if (!_blockSizeTable) {
                _blockSizeTable = [];
                _blockSizeTable[PIXELFORMAT_ETC1] = 8;
                _blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;
                _blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;
                _blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;
                _blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;
                _blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;
                _blockSizeTable[PIXELFORMAT_DXT1] = 8;
                _blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;
                _blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;
                _blockSizeTable[PIXELFORMAT_DXT3] = 16;
                _blockSizeTable[PIXELFORMAT_DXT5] = 16;
                _blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;
                _blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;
            }

            var pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;
            var blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;
            var result = 0;

            while (1) {
                if (pixelSize > 0) {
                    // handle uncompressed formats
                    result += width * height * depth * pixelSize;
                } else {
                    // handle block formats
                    var blockWidth = Math.floor((width + 3) / 4);
                    var blockHeight = Math.floor((height + 3) / 4);
                    var blockDepth = Math.floor((depth + 3) / 4);

                    if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 ||
                        format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
                        blockWidth = Math.floor(blockWidth / 2, 1);
                    }

                    result += blockWidth * blockHeight * blockDepth * blockSize;
                }
                // we're done if mipmaps aren't required or we've calculated the smallest mipmap level
                if (!mipmaps || ((width === 1) && (height === 1) && (depth === 1))) {
                    break;
                }
                width = Math.max(Math.floor(width / 2), 1);
                height = Math.max(Math.floor(height / 2), 1);
                depth = Math.max(Math.floor(depth / 2), 1);
            }

            return result * (cubemap ? 6 : 1);
        }
    });

    // Public methods
    Object.assign(Texture.prototype, {
        /**
         * @function
         * @name pc.Texture#destroy
         * @description Forcibly free up the underlying WebGL resource owned by the texture.
         */
        destroy: function () {
            if (this.device) {
                this.device.destroyTexture(this);
            }
            this.device = null;
            this._levels = null;
        },

        // Force a full resubmission of the texture to WebGL (used on a context restore event)
        dirtyAll: function () {
            this._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];

            this._needsUpload = true;
            this._needsMipmapsUpload = this._mipmaps;
            this._mipmapsUploaded = false;

            this._parameterFlags = 255; // 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128
        },

        /**
         * @function
         * @name pc.Texture#lock
         * @description Locks a miplevel of the texture, returning a typed array to be filled with pixel data.
         * @param {object} [options] - Optional options object. Valid properties are as follows:
         * @param {number} [options.level] - The mip level to lock with 0 being the top level. Defaults to 0.
         * @param {number} [options.face] - If the texture is a cubemap, this is the index of the face to lock.
         * @returns {Uint8Array|Uint16Array|Float32Array} A typed array containing the pixel data of the locked mip level.
         */
        lock: function (options) {
            // Initialize options to some sensible defaults
            options = options || { level: 0, face: 0, mode: TEXTURELOCK_WRITE };
            if (options.level === undefined) {
                options.level = 0;
            }
            if (options.face === undefined) {
                options.face = 0;
            }
            if (options.mode === undefined) {
                options.mode = TEXTURELOCK_WRITE;
            }

            this._lockedLevel = options.level;

            if (this._levels[options.level] === null) {
                switch (this._format) {
                    case PIXELFORMAT_A8:
                    case PIXELFORMAT_L8:
                        this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);
                        break;
                    case PIXELFORMAT_L8_A8:
                        this._levels[options.level] = new Uint8Array(this._width * this._height *  this._depth * 2);
                        break;
                    case PIXELFORMAT_R5_G6_B5:
                    case PIXELFORMAT_R5_G5_B5_A1:
                    case PIXELFORMAT_R4_G4_B4_A4:
                        this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);
                        break;
                    case PIXELFORMAT_R8_G8_B8:
                        this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);
                        break;
                    case PIXELFORMAT_R8_G8_B8_A8:
                        this._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);
                        break;
                    case PIXELFORMAT_DXT1:
                        this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
                        break;
                    case PIXELFORMAT_DXT3:
                    case PIXELFORMAT_DXT5:
                        this._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
                        break;
                    case PIXELFORMAT_RGB16F:
                        this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);
                        break;
                    case PIXELFORMAT_RGB32F:
                        this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);
                        break;
                    case PIXELFORMAT_RGBA16F:
                        this._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);
                        break;
                    case PIXELFORMAT_RGBA32F:
                        this._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);
                        break;
                }
            }

            return this._levels[options.level];
        },

        /**
         * @function
         * @name pc.Texture#setSource
         * @description Set the pixel data of the texture from a canvas, image, video DOM element. If the
         * texture is a cubemap, the supplied source must be an array of 6 canvases, images or videos.
         * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement[]|HTMLImageElement[]|HTMLVideoElement[]} source - A canvas, image or video element,
         * or an array of 6 canvas, image or video elements.
         * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail. Defaults to 0, which represents the base image source.
         * A level value of N, that is greater than 0, represents the image source for the Nth mipmap reduction level.
         */
        setSource: function (source, mipLevel) {
            var i;
            var invalid = false;
            var width, height;

            mipLevel = mipLevel || 0;

            if (this._cubemap) {
                if (source[0]) {
                    // rely on first face sizes
                    width = source[0].width || 0;
                    height = source[0].height || 0;

                    for (i = 0; i < 6; i++) {
                        var face = source[i];
                        // cubemap becomes invalid if any condition is not satisfied
                        if (!face ||                  // face is missing
                            face.width !== width ||   // face is different width
                            face.height !== height || // face is different height
                            !((typeof HTMLImageElement !== 'undefined' && face instanceof HTMLImageElement) ||   // not image or
                              (typeof HTMLCanvasElement !== 'undefined' && face instanceof HTMLCanvasElement) || // canvas or
                              (typeof HTMLVideoElement !== 'undefined' && face instanceof HTMLVideoElement))) {  // video
                            invalid = true;
                            break;
                        }
                    }
                } else {
                    // first face is missing
                    invalid = true;
                }

                if (!invalid) {
                    // mark levels as updated
                    for (i = 0; i < 6; i++) {
                        if (this._levels[mipLevel][i] !== source[i])
                            this._levelsUpdated[mipLevel][i] = true;
                    }
                }
            } else {
                // check if source is valid type of element
                if (!((typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement) ||
                      (typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement) ||
                      (typeof HTMLVideoElement !== 'undefined' && source instanceof HTMLVideoElement)))
                    invalid = true;

                if (!invalid) {
                    // mark level as updated
                    if (source !== this._levels[mipLevel])
                        this._levelsUpdated[mipLevel] = true;

                    width = source.width;
                    height = source.height;
                }
            }

            if (invalid) {
                // invalid texture

                // default sizes
                this._width = 4;
                this._height = 4;

                // remove levels
                if (this._cubemap) {
                    for (i = 0; i < 6; i++) {
                        this._levels[mipLevel][i] = null;
                        this._levelsUpdated[mipLevel][i] = true;
                    }
                } else {
                    this._levels[mipLevel] = null;
                    this._levelsUpdated[mipLevel] = true;
                }
            } else {
                // valid texture
                if (mipLevel === 0) {
                    this._width = width;
                    this._height = height;
                }

                this._levels[mipLevel] = source;
            }

            // valid or changed state of validity
            if (this._invalid !== invalid || !invalid) {
                this._invalid = invalid;

                // reupload
                this.upload();
            }
        },

        /**
         * @function
         * @name pc.Texture#getSource
         * @description Get the pixel data of the texture. If this is a cubemap then an array of 6 images will be returned otherwise
         * a single image.
         * @param {number} [mipLevel] - A non-negative integer specifying the image level of detail. Defaults to 0, which represents the base image source.
         * A level value of N, that is greater than 0, represents the image source for the Nth mipmap reduction level.
         * @returns {HTMLImageElement} The source image of this texture. Can be null if source not assigned for specific image level.
         */
        getSource: function (mipLevel) {
            mipLevel = mipLevel || 0;
            return this._levels[mipLevel];
        },

        /**
         * @function
         * @name pc.Texture#unlock
         * @description Unlocks the currently locked mip level and uploads it to VRAM.
         */
        unlock: function () {

            // Upload the new pixel data
            this.upload();
            this._lockedLevel = -1;
        },

        /**
         * @function
         * @name pc.Texture#upload
         * @description Forces a reupload of the textures pixel data to graphics memory. Ordinarily, this function
         * is called by internally by {@link pc.Texture#setSource} and {@link pc.Texture#unlock}. However, it still needs to
         * be called explicitly in the case where an HTMLVideoElement is set as the source of the texture.  Normally,
         * this is done once every frame before video textured geometry is rendered.
         */
        upload: function () {
            this._needsUpload = true;
            this._needsMipmapsUpload = this._mipmaps;
        },

        getDds: function () {
            if (this.format !== PIXELFORMAT_R8_G8_B8_A8)
                console.error("This format is not implemented yet");

            var fsize = 128;
            var i = 0;
            var j;
            var face;
            while (this._levels[i]) {
                var mipSize;
                if (!this.cubemap) {
                    mipSize = this._levels[i].length;
                    if (!mipSize) {
                        console.error("No byte array for mip " + i);
                        return;
                    }
                    fsize += mipSize;
                } else {
                    for (face = 0; face < 6; face++) {
                        if (!this._levels[i][face]) {
                            console.error('No level data for mip ' + i + ', face ' + face);
                            return;
                        }
                        mipSize = this._levels[i][face].length;
                        if (!mipSize) {
                            console.error("No byte array for mip " + i + ", face " + face);
                            return;
                        }
                        fsize += mipSize;
                    }
                }
                fsize += this._levels[i].length;
                i++;
            }

            var buff = new ArrayBuffer(fsize);
            var header = new Uint32Array(buff, 0, 128 / 4);

            var DDS_MAGIC = 542327876; // "DDS"
            var DDS_HEADER_SIZE = 124;
            var DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000; // caps | height | width | pixelformat | linearsize
            var DDS_FLAGS_MIPMAP = 0x20000;
            var DDS_PIXELFORMAT_SIZE = 32;
            var DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40; // alpha | rgb
            var DDS_CAPS_REQUIRED = 0x1000;
            var DDS_CAPS_MIPMAP = 0x400000;
            var DDS_CAPS_COMPLEX = 0x8;
            var DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000; // cubemap | all faces

            var flags = DDS_FLAGS_REQUIRED;
            if (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;

            var caps = DDS_CAPS_REQUIRED;
            if (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;
            if (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;

            var caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;

            header[0] = DDS_MAGIC;
            header[1] = DDS_HEADER_SIZE;
            header[2] = flags;
            header[3] = this.height;
            header[4] = this.width;
            header[5] = this.width * this.height * 4;
            header[6] = 0; // depth
            header[7] = this._levels.length;
            for (i = 0; i < 11; i++) header[8 + i] = 0;
            header[19] = DDS_PIXELFORMAT_SIZE;
            header[20] = DDS_PIXELFLAGS_RGBA8;
            header[21] = 0; // fourcc
            header[22] = 32; // bpp
            header[23] = 0x00FF0000; // R mask
            header[24] = 0x0000FF00; // G mask
            header[25] = 0x000000FF; // B mask
            header[26] = 0xFF000000; // A mask
            header[27] = caps;
            header[28] = caps2;
            header[29] = 0;
            header[30] = 0;
            header[31] = 0;

            var offset = 128;
            var level, mip;
            if (!this.cubemap) {
                for (i = 0; i < this._levels.length; i++) {
                    level = this._levels[i];
                    mip = new Uint8Array(buff, offset, level.length);
                    for (j = 0; j < level.length; j++) mip[j] = level[j];
                    offset += level.length;
                }
            } else {
                for (face = 0; face < 6; face++) {
                    for (i = 0; i < this._levels.length; i++) {
                        level = this._levels[i][face];
                        mip = new Uint8Array(buff, offset, level.length);
                        for (j = 0; j < level.length; j++) mip[j] = level[j];
                        offset += level.length;
                    }
                }
            }

            return buff;
        }
    });

    var dpMult = 2.0;

    function paraboloidFromCubemap(device, sourceCubemap, fixSeamsAmount, dontFlipX) {
        var chunks = shaderChunks;
        var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS,
                                                 (sourceCubemap.fixCubemapSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS) + chunks.genParaboloidPS, "genParaboloid");
        var constantTexSource = device.scope.resolve("source");
        var constantParams = device.scope.resolve("params");
        var params = new Vec4();
        var size = sourceCubemap.width;
        var format = sourceCubemap.format;

        size = Math.max(size, 8) * dpMult;

        var tex = new Texture(device, {
            type: sourceCubemap.type,
            format: format,
            width: size * 2,
            height: size,
            mipmaps: false
        });
        tex.name = 'paraboloid';

        var targ = new RenderTarget(device, tex, {
            depth: false
        });

        params.x = fixSeamsAmount;
        params.y = dontFlipX ? -1.0 : 1.0;
        constantTexSource.setValue(sourceCubemap);
        constantParams.setValue(params.data);
        drawQuadWithShader(device, targ, shader);

        return tex;
    }

    function getDpAtlasRect(rect, mip) {

        rect.x = math.clamp(mip - 2.0, 0, 1) * 0.5;

        var t = mip - rect.x * 6.0;
        var i = 1.0 - rect.x;
        rect.y = Math.min(t * 0.5, 0.75) * i + rect.x;

        rect.z = (1.0 - math.clamp(t, 0, 1) * 0.5) * i;
        rect.w = rect.z * 0.5;

        return 1.0 / rect.z;
    }

    function generateDpAtlas(device, sixCubemaps, dontFlipX) {
        var dp, rect;
        rect = new Vec4();
        var params = new Vec4();
        var size = sixCubemaps[0].width * 2 * dpMult;

        var chunks = shaderChunks;
        var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.dpAtlasQuadPS, "dpAtlasQuad");
        var constantTexSource = device.scope.resolve("source");
        var constantParams = device.scope.resolve("params");

        var tex = new Texture(device, {
            type: sixCubemaps[0].type,
            format: sixCubemaps[0].format,
            width: size,
            height: size,
            mipmaps: false
        });
        tex.name = 'paraboloid';
        var targ = new RenderTarget(device, tex, {
            depth: false
        });

        var borderSize = 2; // 1 pixel from each side
        var mip0Width = size;
        var scaleFactor = (mip0Width + borderSize) / mip0Width - 1;
        var scaleAmount;
        for (var i = 0; i < 6; i++) {
            dp = paraboloidFromCubemap(device, sixCubemaps[i], i, dontFlipX);
            constantTexSource.setValue(dp);
            scaleAmount = getDpAtlasRect(rect, i);
            params.x = scaleAmount * scaleFactor;
            params.y = params.x * 2;
            params.x += 1;
            params.y += 1;
            constantParams.setValue(params.data);
            rect.x *= size;
            rect.y *= size;
            rect.z *= size;
            rect.w *= size;
            drawQuadWithShader(device, targ, shader, rect);
        }

        return tex;
    }

    /**
     * @class
     * @name pc.IndexBuffer
     * @classdesc An index buffer is the mechanism via which the application specifies primitive
     * index data to the graphics hardware.
     * @description Creates a new index buffer.
     * @example
     * // Create an index buffer holding 3 16-bit indices
     * // The buffer is marked as static, hinting that the buffer will never be modified
     * var indexBuffer = new pc.IndexBuffer(graphicsDevice, pc.INDEXFORMAT_UINT16, 3, pc.BUFFER_STATIC);
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this index buffer.
     * @param {number} format - The type of each index to be stored in the index buffer (see pc.INDEXFORMAT_*).
     * @param {number} numIndices - The number of indices to be stored in the index buffer.
     * @param {number} [usage] - The usage type of the vertex buffer (see pc.BUFFER_*).
     * @param {ArrayBuffer} [initialData] - Initial data.
     */
    function IndexBuffer(graphicsDevice, format, numIndices, usage, initialData) {
        // By default, index buffers are static (better for performance since buffer data can be cached in VRAM)
        this.usage = usage || BUFFER_STATIC;
        this.format = format;
        this.numIndices = numIndices;
        this.device = graphicsDevice;

        var gl = this.device.gl;

        // Allocate the storage
        var bytesPerIndex;
        if (format === INDEXFORMAT_UINT8) {
            bytesPerIndex = 1;
            this.glFormat = gl.UNSIGNED_BYTE;
        } else if (format === INDEXFORMAT_UINT16) {
            bytesPerIndex = 2;
            this.glFormat = gl.UNSIGNED_SHORT;
        } else if (format === INDEXFORMAT_UINT32) {
            bytesPerIndex = 4;
            this.glFormat = gl.UNSIGNED_INT;
        }
        this.bytesPerIndex = bytesPerIndex;

        this.numBytes = this.numIndices * bytesPerIndex;

        if (initialData) {
            this.setData(initialData);
        } else {
            this.storage = new ArrayBuffer(this.numBytes);
        }

        graphicsDevice._vram.ib += this.numBytes;

        this.device.buffers.push(this);
    }

    Object.assign(IndexBuffer.prototype, {
        /**
         * @function
         * @name pc.IndexBuffer#destroy
         * @description Frees resources associated with this index buffer.
         */
        destroy: function () {
            var device = this.device;
            var idx = device.buffers.indexOf(this);
            if (idx !== -1) {
                device.buffers.splice(idx, 1);
            }

            if (this.bufferId) {
                var gl = this.device.gl;
                gl.deleteBuffer(this.bufferId);
                this.device._vram.ib -= this.storage.byteLength;
                this.bufferId = null;

                if (this.device.indexBuffer === this) {
                    this.device.indexBuffer = null;
                }
            }
        },

        /**
         * @function
         * @name pc.IndexBuffer#getFormat
         * @description Returns the data format of the specified index buffer.
         * @returns {number} The data format of the specified index buffer (see pc.INDEXFORMAT_*).
         */
        getFormat: function () {
            return this.format;
        },

        /**
         * @function
         * @name pc.IndexBuffer#getNumIndices
         * @description Returns the number of indices stored in the specified index buffer.
         * @returns {number} The number of indices stored in the specified index buffer.
         */
        getNumIndices: function () {
            return this.numIndices;
        },

        /**
         * @function
         * @name pc.IndexBuffer#lock
         * @description Gives access to the block of memory that stores the buffer's indices.
         * @returns {ArrayBuffer} A contiguous block of memory where index data can be written to.
         */
        lock: function () {
            return this.storage;
        },

        /**
         * @function
         * @name pc.IndexBuffer#unlock
         * @description Signals that the block of memory returned by a call to the lock function is
         * ready to be given to the graphics hardware. Only unlocked index buffers can be set on the
         * currently active device.
         */
        unlock: function () {
            // Upload the new index data
            var gl = this.device.gl;

            if (!this.bufferId) {
                this.bufferId = gl.createBuffer();
            }

            var glUsage;
            switch (this.usage) {
                case BUFFER_STATIC:
                    glUsage = gl.STATIC_DRAW;
                    break;
                case BUFFER_DYNAMIC:
                    glUsage = gl.DYNAMIC_DRAW;
                    break;
                case BUFFER_STREAM:
                    glUsage = gl.STREAM_DRAW;
                    break;
                case BUFFER_GPUDYNAMIC:
                    if (this.device.webgl2) {
                        glUsage = gl.DYNAMIC_COPY;
                    } else {
                        glUsage = gl.STATIC_DRAW;
                    }
                    break;
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);
        },

        setData: function (data) {
            if (data.byteLength !== this.numBytes) {
                console.error("IndexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + data.byteLength);
                return false;
            }
            this.storage = data;
            this.unlock();
            return true;
        },

        _lockTypedArray: function () {

            var lock = this.lock();
            var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) :
                (this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock) );
            return indices;
        },

        // Copies count elements from data into index buffer.
        // optimized for performance from both typed array as well as array
        writeData: function (data, count) {

            var indices = this._lockTypedArray();

            // if data contains more indices than needed, copy from its subarray
            if (data.length > count) {

                // if data is typed array
                if (ArrayBuffer.isView(data)) {
                    data = data.subarray(0, count);
                    indices.set(data);
                } else {
                    // data is array, copy right amount manually
                    var i;
                    for (i = 0; i < count; i++)
                        indices[i] = data[i];
                }
            } else {
                // copy whole data
                indices.set(data);
            }

            this.unlock();
        },

        // copies index data from index buffer into provided data array
        readData: function (data) {

            // note: there is no need to unlock this buffer, as we are only reading from it
            var indices = this._lockTypedArray();
            var count = this.numIndices;

            if (ArrayBuffer.isView(data)) {
                // destination data is typed array
                data.set(indices);
            } else {
                // data is array, copy right amount manually
                data.length = 0;
                var i;
                for (i = 0; i < count; i++)
                    data[i] = indices[i];
            }

            return count;
        }
    });

    var id = 0;

    // Helper class used to store vertex / index data streams and related properties, when mesh is programatically modified
    function GeometryData() {
        this.initDefaults();
    }

    Object.assign(GeometryData.prototype, {
        initDefaults: function () {

            // by default, existing mesh is updated but not recreated, until .clear function is called
            this.recreate = false;

            // usage for buffers
            this.verticesUsage = BUFFER_STATIC;
            this.indicesUsage = BUFFER_STATIC;

            // vertex and index buffer allocated size (maximum number of vertices / indices that can be stored in those without the need to reallocate them)
            this.maxVertices = 0;
            this.maxIndices = 0;

            // current number of vertices and indices in use
            this.vertexCount = 0;
            this.indexCount = 0;

            // dirty flags representing what needs be updated
            this.vertexStreamsUpdated = false;
            this.indexStreamUpdated = false;

            // dictionary of vertex streams that need to be updated, looked up by semantic
            this.vertexStreamDictionary = {};

            // index stream data that needs to be updated
            this.indices = null;
        },

        _validateVertexCount: function (count, semantic) {

        },

        // function called when vertex stream is requested to be updated, and validates / updates currently used vertex count
        _changeVertexCount: function (count, semantic) {

            // update vertex count and validate it with existing streams
            if (!this.vertexCount) {
                this.vertexCount = count;
            } else {
                this._validateVertexCount(count, semantic);
            }
        }
    });

    // default counts for vertex components
    Object.defineProperties(GeometryData, {
        DEFAULT_COMPONENTS_POSITION: { value: 3 },
        DEFAULT_COMPONENTS_NORMAL: { value: 3 },
        DEFAULT_COMPONENTS_UV: { value: 2 },
        DEFAULT_COMPONENTS_COLORS: { value: 4 }
    });

    // class storing information about single vertex data stream
    function GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize) {
        this.data = data;                           // array of data
        this.componentCount = componentCount;       // number of components
        this.dataType = dataType;                   // format of elements (pc.TYPE_FLOAT32 ..)
        this.dataTypeNormalize = dataTypeNormalize; // normalize element (divide by 255)
    }

    /**
     * @class
     * @name pc.Mesh
     * @classdesc A graphical primitive. The mesh is defined by a {@link pc.VertexBuffer} and an optional
     * {@link pc.IndexBuffer}. It also contains a primitive definition which controls the type of the
     * primitive and the portion of the vertex or index buffer to use.
     * ***
     * Mesh APIs
     * =========
     * There are two ways a mesh can be generated or updated.
     *
     * Simple Mesh API
     * ---------
     * {@link pc.Mesh} class provides interfaces such as {@link pc.Mesh#setPositions} and {@link pc.Mesh#setUvs} that provide a simple way to provide
     * vertex and index data for the Mesh, and hiding the complexity of creating the {@link pc.VertexFormat}. This is the recommended interface to use.
     *
     * A simple example which creates a Mesh with 3 vertices, containing position coordinates only, to form a single triangle.
     * ~~~
     * var mesh = new pc.Mesh(device);
     * var positions = [0, 0, 0,     1, 0, 0,     1, 1, 0];
     * mesh.setPositions(positions);
     * mesh.update();
     * ~~~
     *
     * An example which creates a Mesh with 4 vertices, containing position and uv coordinates in channel 0, and an index buffer to form two triangles.
     * Float32Array is used for positions and uvs.
     * ~~~
     * var mesh = new pc.Mesh(device);
     * var positions = new Float32Array([0, 0, 0,     1, 0, 0,     1, 1, 0,      0, 1, 0]);
     * var uvs = new Float32Array([0, 0,     1, 0,     1, 1,     0, 1]);
     * var indices = [0, 1, 2,    0, 2, 3];
     * mesh.setPositions(positions);
     * mesh.setUvs(0, uvs);
     * mesh.setIndices(indices);
     * mesh.update();
     * ~~~
     *
     * This example demonstrated that vertex attributes such as position and normals, and also indices can be provided using Arrays ([]) and also Typed Arrays
     * (Float32Array and similar). Note that typed arrays have higher performance, and are generaly recommended for per-frame operations or larger meshes,
     * but their construction using new operator is costly operation. If you only need to operate on small number of vertices or indices, consider using the
     * Arrays instead to avoid Type Array allocation overhead.
     *
     * Follow these links for more complex examples showing the functionality.
     * * {@link http://playcanvas.github.io/#graphics/mesh-decals.html}
     * * {@link http://playcanvas.github.io/#graphics/mesh-deformation.html}
     * * {@link http://playcanvas.github.io/#graphics/mesh-generation.html}
     * * {@link http://playcanvas.github.io/#graphics/point-cloud-simulation.html}
     *
     * Update Vertex and Index buffers.
     * ---------
     * This allows greater flexibility, but is more complex to use. It allows more advanced setups, for example sharing a Vertex or Index Buffer between multiple meshes.
     * See {@link pc.VertexBuffer}, {@link pc.IndexBuffer} and {@link pc.VertexFormat} for details.
     * ***
     * @description Create a new mesh.
     * @param {pc.GraphicsDevice} [graphicsDevice] - The graphics device used to manage this mesh. If it is not provided, a device is obtained
     * from the {@link pc.Application}.
     * @property {pc.VertexBuffer} vertexBuffer The vertex buffer holding the vertex data of the mesh.
     * @property {pc.IndexBuffer[]} indexBuffer An array of index buffers. For unindexed meshes, this array can
     * be empty. The first index buffer in the array is used by {@link pc.MeshInstance}s with a renderStyle
     * property set to pc.RENDERSTYLE_SOLID. The second index buffer in the array is used if renderStyle is
     * set to pc.RENDERSTYLE_WIREFRAME.
     * @property {object[]} primitive Array of primitive objects defining how vertex (and index) data in the
     * mesh should be interpreted by the graphics device. For details on the primitive object, see.
     * @property {number} primitive[].type The type of primitive to render. Can be:
     *
     * * {@link pc.PRIMITIVE_POINTS}
     * * {@link pc.PRIMITIVE_LINES}
     * * {@link pc.PRIMITIVE_LINELOOP}
     * * {@link pc.PRIMITIVE_LINESTRIP}
     * * {@link pc.PRIMITIVE_TRIANGLES}
     * * {@link pc.PRIMITIVE_TRISTRIP}
     * * {@link pc.PRIMITIVE_TRIFAN}
     *
     * @property {number} primitive[].base The offset of the first index or vertex to dispatch in the draw call.
     * @property {number} primitive[].count The number of indices or vertices to dispatch in the draw call.
     * @property {boolean} [primitive[].indexed] True to interpret the primitive as indexed, thereby using the currently set index buffer and false otherwise.
     * {@link pc.GraphicsDevice#draw}. The primitive is ordered based on render style like the indexBuffer property.
     * @property {pc.BoundingBox} aabb The axis-aligned bounding box for the object space vertices of this mesh.
     * @property {pc.Skin} [skin] The skin data (if any) that drives skinned mesh animations for this mesh.
     * @property {pc.Morph} [morph] The morph data (if any) that drives morph target animations for this mesh.
     */
    function Mesh(graphicsDevice) {
        this._refCount = 0;
        this.id = id++;
        this.device = graphicsDevice || Application.getApplication().graphicsDevice;
        this.vertexBuffer = null;
        this.indexBuffer = [null];
        this.primitive = [{
            type: 0,
            base: 0,
            count: 0
        }];
        this.skin = null;
        this.morph = null;
        this._geometryData = null;

        // AABB for object space mesh vertices
        this._aabb = new BoundingBox();

        // Array of object space AABBs of vertices affected by each bone
        this.boneAabb = null;
    }

    Object.defineProperties(Mesh.prototype, {
        'aabb': {
            get: function () {
                return this._aabb;
            },
            set: function (aabb) {
                this._aabb = aabb;
            }
        },

        'refCount': {
            get: function () {
                return this._refCount;
            }
        }
    });

    Object.assign(Mesh.prototype, {

        incReference: function () {
            this._refCount++;
        },

        decReference: function () {
            this._refCount--;
        },

        /**
         * @function
         * @name pc.Mesh#destroy
         * @description Destroys {@link pc.VertexBuffer} and {@link pc.IndexBuffer} associate with the mesh.
         * This is normally called by {@link pc.Model#destroy} and does not need to be called manually.
         */
        destroy: function () {

            if (this.vertexBuffer) {
                this.vertexBuffer.destroy();
                this.vertexBuffer = null;
            }

            var j, ib;
            for (j = 0; j < this.indexBuffer.length; j++) {
                ib = this.indexBuffer[j];
                if (ib)
                    ib.destroy();
            }

            this.indexBuffer.length = 0;
            this._geometryData = null;
        },

        // initializes local bounding boxes for each bone based on vertices affected by the bone
        // if morph targets are provided, it also adjusts local bone bounding boxes by maximum morph displacement
        _initBoneAabbs: function (morphTargets) {

            this.boneAabb = [];
            this.boneUsed = [];
            var numVerts = this.vertexBuffer.numVertices;
            var i, j, k, l;
            var x, y, z;
            var bMax, bMin;
            var boneMin = [];
            var boneMax = [];
            var boneUsed = this.boneUsed;
            var numBones = this.skin.boneNames.length;
            var aabb;
            var boneWeight, boneIndex;
            var minMorphX, minMorphY, minMorphZ;
            var maxMorphX, maxMorphY, maxMorphZ;
            var dx, dy, dz;
            var target;

            // start with empty bone bounds
            for (i = 0; i < numBones; i++) {
                boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            }

            // access to mesh from vertex buffer
            var iterator = new VertexIterator(this.vertexBuffer);
            var posElement = iterator.element[SEMANTIC_POSITION];
            var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
            var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];


            // Find bone AABBs of attached vertices
            for (j = 0; j < numVerts; j++) {
                for (k = 0; k < 4; k++) {
                    boneWeight = weightsElement.array[weightsElement.index + k];
                    if (boneWeight > 0) {
                        boneIndex = indicesElement.array[indicesElement.index + k];
                        boneUsed[boneIndex] = true;

                        x = posElement.array[posElement.index];
                        y = posElement.array[posElement.index + 1];
                        z = posElement.array[posElement.index + 2];

                        // adjust bounds of a bone by the vertex
                        bMax = boneMax[boneIndex];
                        bMin = boneMin[boneIndex];

                        if (bMin.x > x) bMin.x = x;
                        if (bMin.y > y) bMin.y = y;
                        if (bMin.z > z) bMin.z = z;

                        if (bMax.x < x) bMax.x = x;
                        if (bMax.y < y) bMax.y = y;
                        if (bMax.z < z) bMax.z = z;

                        if (morphTargets) {

                            // find maximum displacement of the vertex by all targets
                            minMorphX = maxMorphX = x;
                            minMorphY = maxMorphY = y;
                            minMorphZ = maxMorphZ = z;

                            // morph this vertex by all morph targets
                            for (l = 0; l < morphTargets.length; l++) {
                                target = morphTargets[l];

                                dx = target.deltaPositions[j * 3];
                                dy = target.deltaPositions[j * 3 + 1];
                                dz = target.deltaPositions[j * 3 + 2];

                                if (dx < 0) {
                                    minMorphX += dx;
                                } else {
                                    maxMorphX += dx;
                                }

                                if (dy < 0) {
                                    minMorphY += dy;
                                } else {
                                    maxMorphY += dy;
                                }

                                if (dz < 0) {
                                    minMorphZ += dz;
                                } else {
                                    maxMorphZ += dz;
                                }
                            }

                            if (bMin.x > minMorphX) bMin.x = minMorphX;
                            if (bMin.y > minMorphY) bMin.y = minMorphY;
                            if (bMin.z > minMorphZ) bMin.z = minMorphZ;

                            if (bMax.x < maxMorphX) bMax.x = maxMorphX;
                            if (bMax.y < maxMorphY) bMax.y = maxMorphY;
                            if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
                        }
                    }
                }
                iterator.next();
            }

            // store bone bounding boxes
            for (i = 0; i < numBones; i++) {
                aabb = new BoundingBox();
                aabb.setMinMax(boneMin[i], boneMax[i]);
                this.boneAabb.push(aabb);
            }
        },

        // when mesh API to modify vertex / index data are used, this allocates structure to store the data
        _initGeometryData: function () {
            if (!this._geometryData) {
                this._geometryData = new GeometryData();

                // if vertex buffer exists aleady, store the sizes
                if (this.vertexBuffer) {
                    this._geometryData.vertexCount = this.vertexBuffer.numVertices;
                    this._geometryData.maxVertices = this.vertexBuffer.numVertices;
                }

                // if index buffer exists aleady, store the sizes
                if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                    this._geometryData.indexCount = this.indexBuffer[0].numIndices;
                    this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
                }
            }
        },

        /**
         * @function
         * @name pc.Mesh#clear
         * @description Clears the mesh of existing vertices and indices and resets the
         * {@link pc.VertexFormat} associated with the mesh. This call is typically followed by calls
         * to methods such as {@link pc.Mesh#setPositions}, {@link pc.Mesh#setVertexStream} or {@link pc.Mesh#setIndices} and
         * finally {@link pc.Mesh#update} to rebuild the mesh, allowing different {@link pc.VertexFormat}.
         * @param {boolean} [verticesDynamic] - Indicates the {@link pc.VertexBuffer} should be created with {@link pc.BUFFER_DYNAMIC} usage. If not specified, {@link pc.BUFFER_STATIC} is used.
         * @param {boolean} [indicesDynamic] - Indicates the {@link pc.IndexBuffer} should be created with {@link pc.BUFFER_DYNAMIC} usage. If not specified, {@link pc.BUFFER_STATIC} is used.
         * @param {number} [maxVertices] - {@link pc.VertexBuffer} will be allocated with at least maxVertices, allowing additional vertices to be added to it without the allocation. If
         * no value is provided, a size to fit the provided vertices will be allocated.
         * @param {number} [maxIndices] - {@link pc.IndexBuffer} will be allocated with at least maxIndices, allowing additional indices to be added to it without the allocation. If
         * no value is provided, a size to fit the provided indices will be allocated.
         */
        clear: function (verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
            this._initGeometryData();
            this._geometryData.initDefaults();

            this._geometryData.recreate = true;
            this._geometryData.maxVertices = maxVertices || 0;
            this._geometryData.maxIndices = maxIndices || 0;
            this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
            this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
        },

        /**
         * @function
         * @name pc.Mesh#setVertexStream
         * @description Sets the vertex data for any supported semantic.
         * @param {string} semantic - The meaning of the vertex element. For supported semantics, see pc.SEMANTIC_* in {@link pc.VertexFormat}.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - Vertex data for the specified semantic.
         * @param {number} componentCount - The number of values that form a single Vertex element. For example when setting a 3D position represented by 3 numbers
         * per vertex, number 3 should be specified.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         * @param {number} [dataType] - The format of data when stored in the {@link pc.VertexBuffer}, see pc.TYPE_* in {@link pc.VertexFormat}. When not specified, pc.TYPE_FLOAT32 is used.
         * @param {boolean} [dataTypeNormalize] - If true, vertex attribute data will be mapped from a 0 to 255 range down to 0 to 1 when fed to a shader.
         * If false, vertex attribute data is left unchanged. If this property is unspecified, false is assumed.
         */
        setVertexStream: function (semantic, data, componentCount, numVertices, dataType, dataTypeNormalize) {
            this._initGeometryData();
            var vertexCount = numVertices || data.length / componentCount;
            this._geometryData._changeVertexCount(vertexCount, semantic);
            this._geometryData.vertexStreamsUpdated = true;

            this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(
                data,
                componentCount,
                dataType || TYPE_FLOAT32,
                dataTypeNormalize || false
            );
        },

        /**
         * @function
         * @name pc.Mesh#getVertexStream
         * @description Gets the vertex data corresponding to a semantic.
         * @param {string} semantic - The semantic of the vertex element to get. For supported semantics, see pc.SEMANTIC_* in {@link pc.VertexFormat}.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} data - An array to populate with the vertex data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of vertices populated.
         */
        getVertexStream: function (semantic, data) {
            var count = 0;
            var done = false;

            // see if we have un-applied stream
            if (this._geometryData) {
                var stream = this._geometryData.vertexStreamDictionary[semantic];
                if (stream) {
                    done = true;
                    count = this._geometryData.vertexCount;

                    if (ArrayBuffer.isView(data)) {
                        // destination data is typed array
                        data.set(stream.data);
                    } else {
                        // destination data is array
                        data.length = 0;
                        data.push(stream.data);
                    }
                }
            }

            if (!done) {
                // get stream from VertexBuffer
                if (this.vertexBuffer) {
                    // note: there is no need to .end the iterator, as we are only reading data from it
                    var iterator = new VertexIterator(this.vertexBuffer);
                    count = iterator.readData(semantic, data);
                }
            }

            return count;
        },

        /**
         * @function
         * @name pc.Mesh#setPositions
         * @description Sets the vertex positions array. Vertices are stored using pc.TYPE_FLOAT32 format.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - Vertex data containing positions.
         * @param {number} [componentCount] - The number of values that form a single position element. Defaults to 3 if not specified, corresponding to x, y and z coordinates.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setPositions: function (positions, componentCount, numVertices) {
            this.setVertexStream(SEMANTIC_POSITION, positions, componentCount || GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices, TYPE_FLOAT32, false);
        },

        /**
         * @function
         * @name pc.Mesh#setNormals
         * @description Sets the vertex normals array. Normals are stored using pc.TYPE_FLOAT32 format.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - Vertex data containing normals.
         * @param {number} [componentCount] - The number of values that form a single normal element. Defaults to 3 if not specified, corresponding to x, y and z direction.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setNormals: function (normals, componentCount, numVertices) {
            this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount || GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices, TYPE_FLOAT32, false);
        },

        /**
         * @function
         * @name pc.Mesh#setUvs
         * @description Sets the vertex uv array. Uvs are stored using pc.TYPE_FLOAT32 format.
         * @param {number} channel - The uv channel in [0..7] range.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - Vertex data containing uv-coordinates.
         * @param {number} [componentCount] - The number of values that form a single uv element. Defaults to 2 if not specified, corresponding to u and v coordinates.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setUvs: function (channel, uvs, componentCount, numVertices) {
            this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount || GeometryData.DEFAULT_COMPONENTS_UV, numVertices, TYPE_FLOAT32, false);
        },

        /**
         * @function
         * @name pc.Mesh#setColors
         * @description Sets the vertex color array. Colors are stored using pc.TYPE_FLOAT32 format, which is useful for HDR colors.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex data containing colors.
         * @param {number} [componentCount] - The number of values that form a single color element. Defaults to 4 if not specified, corresponding to r, g, b and a.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setColors: function (colors, componentCount, numVertices) {
            this.setVertexStream(SEMANTIC_COLOR, colors, componentCount || GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_FLOAT32, false);
        },

        /**
         * @function
         * @name pc.Mesh#setColors32
         * @description Sets the vertex color array. Colors are stored using pc.TYPE_UINT8 format, which is useful for LDR colors. Values in the array are expected in
         * [0..255] range, and are mapped to [0..1] range in the shader.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - Vertex data containing colors. The array is
         * expected to contain 4 components per vertex, corresponding to r, g, b and a.
         * @param {number} [numVertices] - The number of vertices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setColors32: function (colors, numVertices) {
            this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
        },

        /**
         * @function
         * @name pc.Mesh#setIndices
         * @description Sets the index array. Indices are stored using 16-bit format by default, unless more than 65535 vertices are specified, in which case 32-bit format is used.
         * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - The array of indicies that define primitives (lines, triangles, etc.).
         * @param {number} [numIndices] - The number of indices to be used from data array. If not provided, the whole data array is used. This allows to use only part of the data array.
         */
        setIndices: function (indices, numIndices) {
            this._initGeometryData();
            this._geometryData.indexStreamUpdated = true;
            this._geometryData.indices = indices;
            this._geometryData.indexCount = numIndices || indices.length;
        },

        /**
         * @function
         * @name pc.Mesh#getPositions
         * @description Gets the vertex positions data.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} positions - An array to populate with the vertex data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of vertices populated.
         */
        getPositions: function (positions) {
            return this.getVertexStream(SEMANTIC_POSITION, positions);
        },

        /**
         * @function
         * @name pc.Mesh#getNormals
         * @description Gets the vertex normals data.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} normals - An array to populate with the vertex data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of vertices populated.
         */
        getNormals: function (normals) {
            return this.getVertexStream(SEMANTIC_NORMAL, normals);
        },

        /**
         * @function
         * @name pc.Mesh#getUvs
         * @description Gets the vertex uv data.
         * @param {number} channel - The uv channel in [0..7] range.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} uvs - An array to populate with the vertex data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of vertices populated.
         */
        getUvs: function (channel, uvs) {
            return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
        },

        /**
         * @function
         * @name pc.Mesh#getColors
         * @description Gets the vertex color data.
         * @param {number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array} colors - An array to populate with the vertex data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of vertices populated.
         */
        getColors: function (colors) {
            return this.getVertexStream(SEMANTIC_COLOR, colors);
        },

        /**
         * @function
         * @name pc.Mesh#getColors
         * @description Gets the index data.
         * @param {number[]|Uint8Array|Uint16Array|Uint32Array} indices - An array to populate with the index data.
         * When typed array is supplied, enough space needs to be reserved, otherwise only partial data is copied.
         * @returns {number} Returns the number of indices populated.
         */
        getIndices: function (indices) {

            var count = 0;

            // see if we have un-applied indices
            if (this._geometryData && this._geometryData.indices) {
                var streamIndices = this._geometryData.indices;
                count = this._geometryData.indexCount;

                if (ArrayBuffer.isView(indices)) {
                    // destination data is typed array
                    indices.set(streamIndices);
                } else {
                    // destination data is array
                    indices.length = 0;
                    indices.push(streamIndices);
                }
            } else {
                // get data from IndexBuffer
                if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                    var indexBuffer = this.indexBuffer[0];
                    count = indexBuffer.readData(indices);
                }
            }

            return count;
        },

        /**
         * @function
         * @name pc.Mesh#update
         * @description Applies any changes to vertex stream and indices to mesh. This allocates or reallocates {@link pc.vertexBuffer} or {@link pc.IndexBuffer}
         * to fit all provided vertices and indices, and fills them with data.
         * @param {number} [primitiveType] - The type of primitive to render. Can be one of pc.PRIMITIVE_* - see primitive[].type section above. Defaults
         * to pc.PRIMITIVE_TRIANGLES if unspecified.
         * @param {boolean} [updateBoundingBox] - True to update bounding box. Bounding box is updated only if positions were set since last time update
         * was called, and componentCount for position was 3, otherwise bounding box is not updated. See {@link pc.Mesh#setPositions}. Defaults to true if unspecified.
         * Set this to false to avoid update of the bounding box and use aabb property to set it instead.
         */
        update: function (primitiveType, updateBoundingBox) {

            if (this._geometryData) {

                // update bounding box if needed
                if (updateBoundingBox || updateBoundingBox === undefined) {

                    // find vec3 position stream
                    var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
                    if (stream) {
                        if (stream.componentCount == 3) {
                            this._aabb.compute(stream.data, this._geometryData.vertexCount);
                        }
                    }
                }

                // destroy vertex buffer if recreate was requested or if vertices don't fit
                var destroyVB = this._geometryData.recreate;
                if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
                    destroyVB = true;
                    this._geometryData.maxVertices = this._geometryData.vertexCount;
                }

                if (destroyVB) {
                    if (this.vertexBuffer) {
                        this.vertexBuffer.destroy();
                        this.vertexBuffer = null;
                    }
                }

                // destroy index buffer if recreate was requested or if indices don't fit
                var destroyIB = this._geometryData.recreate;
                if (this._geometryData.indexCount > this._geometryData.maxIndices) {
                    destroyIB = true;
                    this._geometryData.maxIndices = this._geometryData.indexCount;
                }

                if (destroyIB) {
                    if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                        this.indexBuffer[0].destroy();
                        this.indexBuffer[0] = null;
                    }
                }

                // update vertices if needed
                if (this._geometryData.vertexStreamsUpdated) {
                    this._updateVertexBuffer();
                }

                // update indices if needed
                if (this._geometryData.indexStreamUpdated) {
                    this._updateIndexBuffer();
                }

                // set up primitive parameters
                this.primitive[0].type = (primitiveType === undefined ? PRIMITIVE_TRIANGLES : primitiveType);

                if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {      // indexed
                    if (this._geometryData.indexStreamUpdated) {
                        this.primitive[0].count = this._geometryData.indexCount;
                        this.primitive[0].indexed = true;
                    }
                } else {        // non-indexed
                    if (this._geometryData.vertexStreamsUpdated) {
                        this.primitive[0].count = this._geometryData.vertexCount;
                        this.primitive[0].indexed = false;
                    }
                }

                // counts can be changed on next frame, so set them to 0
                this._geometryData.vertexCount = 0;
                this._geometryData.indexCount = 0;

                this._geometryData.vertexStreamsUpdated = false;
                this._geometryData.indexStreamUpdated = false;
                this._geometryData.recreate = false;
            }
        },

        // builds vertex format based on attached vertex streams
        _buildVertexFormat: function (vertexCount) {

            var vertexDesc = [];

            for (var semantic in this._geometryData.vertexStreamDictionary) {
                var stream = this._geometryData.vertexStreamDictionary[semantic];
                vertexDesc.push({
                    semantic: semantic,
                    components: stream.componentCount,
                    type: stream.dataType,
                    normalize: stream.dataTypeNormalize
                });
            }

            return new VertexFormat(this.device, vertexDesc, vertexCount);
        },

        // copy attached data into vertex buffer
        _updateVertexBuffer: function () {

            // if we don't have vertex buffer, create new one, otherwise update existing one
            if (!this.vertexBuffer) {
                var allocateVertexCount = this._geometryData.maxVertices;
                var format = this._buildVertexFormat(allocateVertexCount);
                this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);
            }

            // lock vertex buffer and create typed access arrays for individual elements
            var iterator = new VertexIterator(this.vertexBuffer);

            // copy all stream data into vertex buffer
            var numVertices = this._geometryData.vertexCount;
            for (var semantic in this._geometryData.vertexStreamDictionary) {
                var stream = this._geometryData.vertexStreamDictionary[semantic];
                iterator.writeData(semantic, stream.data, numVertices);

                // remove stream
                delete this._geometryData.vertexStreamDictionary[semantic];
            }

            iterator.end();
        },

        // copy attached data into index buffer
        _updateIndexBuffer: function () {

            // if we don't have index buffer, create new one, otherwise update existing one
            if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
                var createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
                this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);
            }

            var srcIndices = this._geometryData.indices;
            if (srcIndices) {

                var indexBuffer = this.indexBuffer[0];
                indexBuffer.writeData(srcIndices, this._geometryData.indexCount);

                // remove data
                this._geometryData.indices = null;
            }
        },

        generateWireframe: function () {
            var typedArray = function (indexBuffer) {
                switch (indexBuffer.format) {
                    case INDEXFORMAT_UINT8:
                        return new Uint8Array(indexBuffer.storage);
                    case INDEXFORMAT_UINT16:
                        return new Uint16Array(indexBuffer.storage);
                    case INDEXFORMAT_UINT32:
                        return new Uint32Array(indexBuffer.storage);
                    default:
                        return null;
                }
            };

            var lines = [];
            var format;
            if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                var offsets = [[0, 1], [1, 2], [2, 0]];

                var base = this.primitive[RENDERSTYLE_SOLID].base;
                var count = this.primitive[RENDERSTYLE_SOLID].count;
                var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
                var srcIndices = typedArray(indexBuffer);

                var uniqueLineIndices = {};

                for (var j = base; j < base + count; j += 3) {
                    for (var k = 0; k < 3; k++) {
                        var i1 = srcIndices[j + offsets[k][0]];
                        var i2 = srcIndices[j + offsets[k][1]];
                        var line = (i1 > i2) ? ((i2 << 16) | i1) : ((i1 << 16) | i2);
                        if (uniqueLineIndices[line] === undefined) {
                            uniqueLineIndices[line] = 0;
                            lines.push(i1, i2);
                        }
                    }
                }
                format = indexBuffer.format;
            } else {
                for (var i = 0; i < this.vertexBuffer.numVertices; i += 3) {
                    lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
                }
                format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
            }

            var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
            var dstIndices = typedArray(wireBuffer);
            dstIndices.set(lines);
            wireBuffer.unlock();

            this.primitive[RENDERSTYLE_WIREFRAME] = {
                type: PRIMITIVE_LINES,
                base: 0,
                count: lines.length,
                indexed: true
            };
            this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
        }
    });

    var _tmpAabb = new BoundingBox();
    var _tempBoneAabb = new BoundingBox();

    /**
     * @class
     * @name pc.MeshInstance
     * @classdesc An instance of a {@link pc.Mesh}. A single mesh can be referenced by many
     * mesh instances that can have different transforms and materials.
     * @description Create a new mesh instance.
     * @param {pc.GraphNode} node - The graph node defining the transform for this instance.
     * @param {pc.Mesh} mesh - The graphics mesh being instanced.
     * @param {pc.Material} material - The material used to render this instance.
     * @property {pc.BoundingBox} aabb The world space axis-aligned bounding box for this
     * mesh instance.
     * @property {boolean} castShadow Controls whether the mesh instance casts shadows.
     * Defaults to false.
     * @property {boolean} visible Enable rendering for this mesh instance. Use visible property to enable/disable rendering without overhead of removing from scene.
     * But note that the mesh instance is still in the hierarchy and still in the draw call list.
     * @property {pc.GraphNode} node The graph node defining the transform for this instance.
     * @property {pc.Mesh} mesh The graphics mesh being instanced.
     * @property {pc.Material} material The material used by this mesh instance.
     * @property {number} renderStyle The render style of the mesh instance. Can be:
     *
     * * {@link pc.RENDERSTYLE_SOLID}
     * * {@link pc.RENDERSTYLE_WIREFRAME}
     * * {@link pc.RENDERSTYLE_POINTS}
     *
     * Defaults to pc.RENDERSTYLE_SOLID.
     * @property {boolean} cull Controls whether the mesh instance can be culled by with frustum culling ({@link pc.CameraComponent#frustumCulling}).
     * @property {number} drawOrder Use this value to affect rendering order of mesh instances.
     * Only used when mesh instances are added to a {@link pc.Layer} with {@link pc.Layer#opaqueSortMode} or {@link pc.Layer#transparentSortMode} (depending on the material) set to {@link pc.SORTMODE_MANUAL}.
     * @property {pc.callbacks.CalculateSortDistance} calculateSortDistance In some circumstances mesh instances are sorted by a distance calculation to determine their rendering order.
     * Set this callback to override the default distance calculation, which gives the dot product of the camera forward vector and the vector between the camera position and
     * the center of the mesh instance's axis-aligned bounding box. This option can be particularly useful for rendering transparent meshes in a better order than default.
     * @property {boolean} visibleThisFrame Read this value in {@link pc.Layer#onPostCull} to determine if the object is actually going to be rendered.
     * @example
     * // Create a mesh instance pointing to a 1x1x1 'cube' mesh
     * var mesh = pc.createBox(graphicsDevice);
     * var material = new pc.StandardMaterial();
     * var node = new pc.GraphNode();
     * var meshInstance = new pc.MeshInstance(node, mesh, material);
     *
     * @example
     * // A script you can attach on an entity to test if it is visible on a Layer
     * var MeshVisScript = pc.createScript('meshVisScript');
     * MeshVisScript.prototype.initialize = function () {
     *     var _this = this;
     *     this.app.scene.layers.getLayerByName("World").onPostCull = function (cameraIndex) {
     *         var meshInstance = _this.entity.model.model.meshInstances[0];
     *         console.log("visible: " + meshInstance.visibleThisFrame);
     *     };
     * };
     */
    function MeshInstance(node, mesh, material) {
        this._key = [0, 0];
        this._shader = [null, null, null];

        this.isStatic = false;
        this._staticLightList = null;
        this._staticSource = null;

        this.node = node;           // The node that defines the transform of the mesh instance
        this._mesh = mesh;           // The mesh that this instance renders
        mesh.incReference();
        this.material = material;   // The material with which to render this instance

        this._shaderDefs = MASK_DYNAMIC << 16; // 2 byte toggles, 2 bytes light mask; Default value is no toggles and mask = pc.MASK_DYNAMIC
        this._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;
        this._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;
        this._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;
        this._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;

        this._lightHash = 0;

        // Render options
        this.visible = true;
        this.layer = LAYER_WORLD; // legacy
        this.renderStyle = RENDERSTYLE_SOLID;
        this.castShadow = false;
        this._receiveShadow = true;
        this._screenSpace = false;
        this._noDepthDrawGl1 = false;
        this.cull = true;
        this.pick = true;
        this._updateAabb = true;
        this._updateAabbFunc = null;
        this._calculateSortDistance = null;

        // 64-bit integer key that defines render order of this mesh instance
        this.updateKey();

        this._skinInstance = null;
        this._morphInstance = null;
        this.instancingData = null;

        // World space AABB
        this.aabb = new BoundingBox();
        this._aabbVer = -1;

        this.drawOrder = 0;
        this.visibleThisFrame = 0;

        // custom function used to customize culling (e.g. for 2D UI elements)
        this.isVisibleFunc = null;

        this.parameters = {};

        this.stencilFront = null;
        this.stencilBack = null;
        // Negative scale batching support
        this.flipFaces = false;
    }

    Object.defineProperty(MeshInstance.prototype, 'mesh', {
        get: function () {
            return this._mesh;
        },
        set: function (mesh) {
            if (this._mesh) this._mesh.decReference();
            this._mesh = mesh;
            if (mesh) mesh.incReference();
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'aabb', {
        get: function () {
            var i;

            if (!this._updateAabb) {
                return this._aabb;
            }

            if (this._updateAabbFunc) {
                return this._updateAabbFunc(this._aabb);
            }

            if (this.skinInstance) {

                // Initialize local bone AABBs if needed
                if (!this.mesh.boneAabb) {
                    var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
                    this.mesh._initBoneAabbs(morphTargets);
                }

                // evaluate world space bounds based on all active bones
                var boneUsed = this.mesh.boneUsed;
                var rootNodeTransform = this.node.getWorldTransform();
                var first = true;

                for (i = 0; i < this.mesh.boneAabb.length; i++) {
                    if (boneUsed[i]) {

                        // transform bone AABB by bone matrix
                        _tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);

                        // add them up
                        if (first) {
                            first = false;
                            _tmpAabb.center.copy(_tempBoneAabb.center);
                            _tmpAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
                        } else {
                            _tmpAabb.add(_tempBoneAabb);
                        }
                    }
                }

                // store world space bounding box
                this._aabb.setFromTransformedAabb(_tmpAabb, rootNodeTransform);

            } else if (this.node._aabbVer !== this._aabbVer) {

                // local space bounding box - either from mesh or empty
                if (this.mesh) {
                    _tmpAabb.center.copy(this.mesh.aabb.center);
                    _tmpAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
                } else {
                    _tmpAabb.center.set(0, 0, 0);
                    _tmpAabb.halfExtents.set(0, 0, 0);
                }

                // update local space bounding box by morph targets
                if (this.mesh && this.mesh.morph) {
                    _tmpAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());
                }

                // store world space bounding box
                this._aabb.setFromTransformedAabb(_tmpAabb, this.node.getWorldTransform());
                this._aabbVer = this.node._aabbVer;
            }
            return this._aabb;
        },
        set: function (aabb) {
            this._aabb = aabb;
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'material', {
        get: function () {
            return this._material;
        },
        set: function (material) {
            var i;
            for (i = 0; i < this._shader.length; i++) {
                this._shader[i] = null;
            }
            // Remove the material's reference to this mesh instance
            if (this._material) {
                var meshInstances = this._material.meshInstances;
                i = meshInstances.indexOf(this);
                if (i !== -1) {
                    meshInstances.splice(i, 1);
                }
            }

            var prevMat = this._material;

            this._material = material;

            if (this._material) {
                // Record that the material is referenced by this mesh instance
                this._material.meshInstances.push(this);

                this.updateKey();

                var prevBlend = prevMat && (prevMat.blendType !== BLEND_NONE);
                var thisBlend = this._material.blendType !== BLEND_NONE;
                if (prevBlend !== thisBlend) {
                    var scene = this._material._scene;
                    if (!scene && prevMat && prevMat._scene) scene = prevMat._scene;

                    if (scene) {
                        scene.layers._dirtyBlend = true;
                    } else {
                        this._material._dirtyBlend = true;
                    }
                }
            }
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'layer', {
        get: function () {
            return this._layer;
        },
        set: function (layer) {
            this._layer = layer;
            this.updateKey();
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'calculateSortDistance', {
        get: function () {
            return this._calculateSortDistance;
        },
        set: function (calculateSortDistance) {
            this._calculateSortDistance = calculateSortDistance;
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'receiveShadow', {
        get: function () {
            return this._receiveShadow;
        },
        set: function (val) {
            this._receiveShadow = val;
            this._shaderDefs = val ? (this._shaderDefs & ~SHADERDEF_NOSHADOW) : (this._shaderDefs | SHADERDEF_NOSHADOW);
            this._shader[SHADER_FORWARD] = null;
            this._shader[SHADER_FORWARDHDR] = null;
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'skinInstance', {
        get: function () {
            return this._skinInstance;
        },
        set: function (val) {
            this._skinInstance = val;
            this._shaderDefs = val ? (this._shaderDefs | SHADERDEF_SKIN) : (this._shaderDefs & ~SHADERDEF_SKIN);
            for (var i = 0; i < this._shader.length; i++) {
                this._shader[i] = null;
            }
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'morphInstance', {
        get: function () {
            return this._morphInstance;
        },
        set: function (val) {
            this._morphInstance = val;

            this._shaderDefs = (val && val.morph.morphPositions) ? (this._shaderDefs | SHADERDEF_MORPH_POSITION) : (this._shaderDefs & ~SHADERDEF_MORPH_POSITION);
            this._shaderDefs = (val && val.morph.morphNormals) ? (this._shaderDefs | SHADERDEF_MORPH_NORMAL) : (this._shaderDefs & ~SHADERDEF_MORPH_NORMAL);
            for (var i = 0; i < this._shader.length; i++) {
                this._shader[i] = null;
            }
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'screenSpace', {
        get: function () {
            return this._screenSpace;
        },
        set: function (val) {
            this._screenSpace = val;
            this._shaderDefs = val ? (this._shaderDefs | SHADERDEF_SCREENSPACE) : (this._shaderDefs & ~SHADERDEF_SCREENSPACE);
            this._shader[SHADER_FORWARD] = null;
        }
    });

    Object.defineProperty(MeshInstance.prototype, 'key', {
        get: function () {
            return this._key[SORTKEY_FORWARD];
        },
        set: function (val) {
            this._key[SORTKEY_FORWARD] = val;
        }
    });

    /**
     * @name pc.MeshInstance#mask
     * @type {number}
     * @description Mask controlling which {@link pc.LightComponent}s light this mesh instance, which {@link pc.CameraComponent} sees it and in which {@link pc.Layer} it is rendered.
     * Defaults to 1.
     */
    Object.defineProperty(MeshInstance.prototype, 'mask', {
        get: function () {
            return this._shaderDefs >> 16;
        },
        set: function (val) {
            var toggles = this._shaderDefs & 0x0000FFFF;
            this._shaderDefs = toggles | (val << 16);
            this._shader[SHADER_FORWARD] = null;
            this._shader[SHADER_FORWARDHDR] = null;
        }
    });

    /**
     * @name pc.MeshInstance#instancingCount
     * @type {number}
     * @description Number of instances when using hardware instancing to render the mesh.
     */
    Object.defineProperty(MeshInstance.prototype, 'instancingCount', {
        get: function () {
            return this.instancingData ? this.instancingData.count : 0;
        },
        set: function (value) {
            if (this.instancingData)
                this.instancingData.count = value;
        }
    });

    Object.assign(MeshInstance.prototype, {
        syncAabb: function () {
            // Deprecated
        },

        updateKey: function () {
            var material = this.material;
            this._key[SORTKEY_FORWARD] = getKey(this.layer,
                                                (material.alphaToCoverage || material.alphaTest) ? BLEND_NORMAL : material.blendType, // render alphatest/atoc after opaque
                                                false, material.id);
        },

        /**
         * @function
         * @name pc.MeshInstance#setInstancing
         * @description Sets up {@link pc.MeshInstance} to be rendered using Hardware Instancing.
         * @param {pc.VertexBuffer|null} vertexBuffer - Vertex buffer to hold per-instance vertex data (usually world matrices).
         * Pass null to turn off hardware instancing.
         */
        setInstancing: function (vertexBuffer) {
            if (vertexBuffer) {
                this.instancingData = new InstancingData(vertexBuffer.numVertices);
                this.instancingData.offset = 0;
                this.instancingData.vertexBuffer = vertexBuffer;

                // turn off culling - we do not do per-instance culling, all instances are submitted to GPU
                this.cull = false;
            } else {
                this.instancingData = null;
                this.cull = true;
            }
        },

        // Parameter management
        clearParameters: function () {
            this.parameters = {};
        },

        getParameters: function () {
            return this.parameters;
        },

        getParameter: function (name) {
            return this.parameters[name];
        },

        setParameter: function (name, data, passFlags) {
            if (passFlags === undefined) passFlags = -524285; // All bits set except 2 - 18 range

            if (data === undefined && typeof name === 'object') {
                var uniformObject = name;
                if (uniformObject.length) {
                    for (var i = 0; i < uniformObject.length; i++) {
                        this.setParameter(uniformObject[i]);
                    }
                    return;
                }
                name = uniformObject.name;
                data = uniformObject.value;
            }

            var param = this.parameters[name];
            if (param) {
                param.data = data;
                param.passFlags = passFlags;
            } else {
                this.parameters[name] = {
                    scopeId: null,
                    data: data,
                    passFlags: passFlags
                };
            }
        },

        deleteParameter: function (name) {
            if (this.parameters[name]) {
                delete this.parameters[name];
            }
        },

        setParameters: function () {
            // Push each shader parameter into scope
            for (var paramName in this.parameters) {
                var parameter = this.parameters[paramName];
                parameter.scopeId.setValue(parameter.data);
            }
        }
    });

    function Command(layer, blendType, command) {
        this._key = [];
        this._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);
        this.command = command;
    }

    Object.defineProperty(Command.prototype, 'key', {
        get: function () {
            return this._key[SORTKEY_FORWARD];
        },
        set: function (val) {
            this._key[SORTKEY_FORWARD] = val;
        }
    });

    // internal data structure used to store data used by hardware instancing
    function InstancingData(numObjects) {
        this.count = numObjects;
        this.vertexBuffer = null;
        this.offset = 0;
    }

    function getKey(layer, blendType, isCommand, materialId) {
        // Key definition:
        // Bit
        // 31      : sign bit (leave)
        // 27 - 30 : layer
        // 26      : translucency type (opaque/transparent)
        // 25      : Command bit (1: this key is for a command, 0: it's a mesh instance)
        // 0 - 24  : Material ID (if oqaque) or 0 (if transparent - will be depth)
        return ((layer & 0x0f) << 27) |
               ((blendType === BLEND_NONE ? 1 : 0) << 26) |
               ((isCommand ? 1 : 0) << 25) |
               ((materialId & 0x1ffffff) << 0);
    }

    /**
     * @class
     * @name pc.MorphInstance
     * @classdesc An instance of pc.Morph. Contains weights to assign to every pc.MorphTarget, manages selection of active morph targets.
     * @param {pc.Morph} morph - The pc.Morph to instance.
     */
    function MorphInstance(morph) {
        this.morph = morph;

        // weights
        this._weights = [];
        this._dirty = true;

        // weights of active vertex buffers in format used by rendering
        this._shaderMorphWeights = new Float32Array(MorphInstance.RENDER_TARGET_COUNT);          // whole array
        this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);        // first 4 elements
        this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);    // second 4 elements

        // temporary array of targets with non-zero weight
        this._activeTargets = [];

        // pre-allocate array of active vertex buffers used by rendering
        this._activeVertexBuffers = new Array(MorphInstance.RENDER_TARGET_COUNT);
    }

    Object.defineProperties(MorphInstance, {
        // number of vertex buffer / weight slots
        RENDER_TARGET_COUNT: { value: 8 }
    });

    Object.assign(MorphInstance.prototype, {

        /**
         * @function
         * @name pc.MorphInstance#destroy
         * @description Frees video memory allocated by this object.
         */
        destroy: function () {
            if (this.morph) {
                this.morph.destroy();
                this.morph = null;
            }
        },

        /**
         * @function
         * @name pc.MorphInstance#getWeight
         * @description Gets current weight of the specified morph target.
         * @param {number} index - An index of morph target.
         * @returns {number} Weight.
         */
        getWeight: function (index) {
            return this._weights[index];
        },

        /**
         * @function
         * @name pc.MorphInstance#setWeight
         * @description Sets weight of the specified morph target.
         * @param {number} index - An index of morph target.
         * @param {number} weight - Weight.
         */
        setWeight: function (index, weight) {
            this._weights[index] = weight;
            this._dirty = true;
        },

        /**
         * @function
         * @name pc.MorphInstance#update
         * @description Selects active morph targets and prepares morph for rendering. Called automatically by renderer.
         */
        update: function () {

            var targets = this.morph._targets;

            // collect active targets, reuse objects in _activeTargets array to avoid allocations
            var activeCount = 0, activeTarget;
            var i, absWeight, epsilon = 0.00001;
            for (i = 0; i < targets.length; i++) {
                absWeight = Math.abs(this.getWeight(i));
                if (absWeight > epsilon) {

                    // create new object if needed
                    if (this._activeTargets.length <= activeCount) {
                        this._activeTargets[activeCount] = {};
                    }

                    activeTarget = this._activeTargets[activeCount++];
                    activeTarget.absWeight = absWeight;
                    activeTarget.weight = this.getWeight(i);
                    activeTarget.target = targets[i];
                }
            }
            this._activeTargets.length = activeCount;


            // if there's more active targets then rendering supports
            var maxActiveTargets = this.morph.maxActiveTargets;
            if (this._activeTargets.length > maxActiveTargets) {

                // sort them by absWeight
                this._activeTargets.sort(function (l, r) {
                    return (l.absWeight < r.absWeight) ? 1 : (r.absWeight < l.absWeight ? -1 : 0);
                });

                // remove excess
                this._activeTargets.length = maxActiveTargets;
            }

            // prepare 8 slots for rendering. these are supported combinations: PPPPPPPP, NNNNNNNN, PPPPNNNN
            var count = MorphInstance.RENDER_TARGET_COUNT;
            for (i = 0; i < count; i++) {
                this._shaderMorphWeights[i] = 0;
                this._activeVertexBuffers[i] = null;
            }

            var posIndex = 0;
            var nrmIndex = this.morph.morphPositions ? 4 : 0;
            var target;
            for (i = 0; i < this._activeTargets.length; i++) {
                target = this._activeTargets[i].target;

                if (target._vertexBufferPositions) {
                    this._activeVertexBuffers[posIndex] = target._vertexBufferPositions;
                    this._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;
                    posIndex++;
                }

                if (target._vertexBufferNormals) {
                    this._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;
                    this._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;
                    nrmIndex++;
                }
            }
        }
    });

    /**
     * @class
     * @name pc.Skin
     * @classdesc A skin contains data about the bones in a hierarchy that drive a skinned mesh animation.
     * Specifically, the skin stores the bone name and inverse bind matrix and for each bone.
     * Inverse bind matrices are instrumental in the mathematics of vertex skinning.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this skin.
     * @param {pc.Mat4[]} ibp - The array of inverse bind matrices.
     * @param {string[]} boneNames - The array of bone names for the bones referenced by this skin.
     */

    var _invMatrix = new Mat4();

    function Skin(graphicsDevice, ibp, boneNames) {
        // Constant between clones
        this.device = graphicsDevice;
        this.inverseBindPose = ibp;
        this.boneNames = boneNames;
    }

    /**
     * @class
     * @name pc.SkinInstance
     * @classdesc A skin instance is responsible for generating the matrix palette that is used to
     * skin vertices from object space to world space.
     * @param {pc.Skin} skin - The skin that will provide the inverse bind pose matrices to
     * generate the final matrix palette.
     * @property {pc.GraphNode[]} bones An array of nodes representing each bone in this skin instance.
     */
    function SkinInstance(skin) {
        this.skin = skin;
        this._dirty = true;

        // Unique per clone
        this.bones = [];

        var numBones = skin.inverseBindPose.length;

        var device = skin.device;
        if (device.supportsBoneTextures) {

            // texture size - square texture with power of two side, large enough to fit 4 pixels per bone
            var size = numBones > 16 ? math.nextPowerOfTwo(Math.ceil(Math.sqrt(numBones * 4))) : 8;

            this.boneTexture = new Texture(device, {
                width: size,
                height: size,
                format: PIXELFORMAT_RGBA32F,
                mipmaps: false,
                minFilter: FILTER_NEAREST,
                magFilter: FILTER_NEAREST
            });
            this.boneTexture.name = 'skin';
            this.matrixPalette = this.boneTexture.lock();
        } else {
            this.matrixPalette = new Float32Array(numBones * 16);
        }
        this.matrices = [];
        for (var i = 0; i < numBones; i++) {
            this.matrices[i] = new Mat4();
        }
    }

    Object.assign(SkinInstance.prototype, {

        updateMatrices: function (rootNode) {

            _invMatrix.copy(rootNode.getWorldTransform()).invert();
            for (var i = this.bones.length - 1; i >= 0; i--) {
                this.matrices[i].mul2(_invMatrix, this.bones[i].getWorldTransform()); // world space -> rootNode space
                this.matrices[i].mul2(this.matrices[i], this.skin.inverseBindPose[i]); // rootNode space -> bind space
            }
        },

        updateMatrixPalette: function () {
            var pe;
            var mp = this.matrixPalette;
            var base;

            for (var i = this.bones.length - 1; i >= 0; i--) {
                pe = this.matrices[i].data;

                // Copy the matrix into the palette, ready to be sent to the vertex shader
                base = i * 16;
                mp[base] = pe[0];
                mp[base + 1] = pe[1];
                mp[base + 2] = pe[2];
                mp[base + 3] = pe[3];
                mp[base + 4] = pe[4];
                mp[base + 5] = pe[5];
                mp[base + 6] = pe[6];
                mp[base + 7] = pe[7];
                mp[base + 8] = pe[8];
                mp[base + 9] = pe[9];
                mp[base + 10] = pe[10];
                mp[base + 11] = pe[11];
                mp[base + 12] = pe[12];
                mp[base + 13] = pe[13];
                mp[base + 14] = pe[14];
                mp[base + 15] = pe[15];
            }

            // TODO: this is a bit strange looking. Change the Texture API to do a reupload
            if (this.skin.device.supportsBoneTextures) {
                this.boneTexture.lock();
                this.boneTexture.unlock();
            }
        }
    });

    /**
     * @class
     * @name pc.Model
     * @classdesc A model is a graphical object that can be added to or removed from a scene.
     * It contains a hierarchy and any number of mesh instances.
     * @description Creates a new model.
     * @example
     * // Create a new model
     * var model = new pc.Model();
     * @property {pc.GraphNode} graph The root node of the model's graph node hierarchy.
     * @property {pc.MeshInstance[]} meshInstances An array of MeshInstances contained in this model.
     * @property {pc.SkinInstance[]} skinInstances An array of SkinInstances contained in this model.
     * @property {pc.MorphInstance[]} morphInstances An array of MorphInstances contained in this model.
     */
    function Model() {
        this.graph = null;
        this.meshInstances = [];
        this.skinInstances = [];
        this.morphInstances = [];

        this.cameras = [];
        this.lights = [];

        this._shadersVersion = 0;

        // used by the model component to flag that this
        // model has been assigned
        this._immutable = false;
    }

    Object.assign(Model.prototype, {
        getGraph: function () {
            return this.graph;
        },

        setGraph: function (graph) {
            this.graph = graph;
        },

        getCameras: function () {
            return this.cameras;
        },

        setCameras: function (cameras) {
            this.cameras = cameras;
        },

        getLights: function () {
            return this.lights;
        },

        setLights: function (lights) {
            this.lights = lights;
        },

        getMaterials: function () {
            var i;
            var materials = [];
            for (i = 0; i < this.meshInstances.length; i++) {
                var meshInstance = this.meshInstances[i];
                if (materials.indexOf(meshInstance.material) === -1) {
                    materials.push(meshInstance.material);
                }
            }
            return materials;
        },

        /**
         * @function
         * @name pc.Model#clone
         * @description Clones a model. The returned model has a newly created hierarchy
         * and mesh instances, but meshes are shared between the clone and the specified
         * model.
         * @returns {pc.Model} A clone of the specified model.
         * @example
         * var clonedModel = model.clone();
         */
        clone: function () {
            var i, j;

            // Duplicate the node hierarchy
            var srcNodes = [];
            var cloneNodes = [];

            var _duplicate = function (node) {
                var newNode = node.clone();

                srcNodes.push(node);
                cloneNodes.push(newNode);

                for (var idx = 0; idx < node._children.length; idx++) {
                    newNode.addChild(_duplicate(node._children[idx]));
                }

                return newNode;
            };

            var cloneGraph = _duplicate(this.graph);
            var cloneMeshInstances = [];
            var cloneSkinInstances = [];
            var cloneMorphInstances = [];

            // Clone the skin instances
            for (i = 0; i < this.skinInstances.length; i++) {
                var skin = this.skinInstances[i].skin;
                var cloneSkinInstance = new SkinInstance(skin);

                // Resolve bone IDs to actual graph nodes
                var bones = [];
                for (j = 0; j < skin.boneNames.length; j++) {
                    var boneName = skin.boneNames[j];
                    var bone = cloneGraph.findByName(boneName);
                    bones.push(bone);
                }
                cloneSkinInstance.bones = bones;

                cloneSkinInstances.push(cloneSkinInstance);
            }

            // Clone the morph instances
            for (i = 0; i < this.morphInstances.length; i++) {
                var morph = this.morphInstances[i].morph;
                var cloneMorphInstance = new MorphInstance(morph);
                cloneMorphInstances.push(cloneMorphInstance);
            }

            // Clone the mesh instances
            for (i = 0; i < this.meshInstances.length; i++) {
                var meshInstance = this.meshInstances[i];
                var nodeIndex = srcNodes.indexOf(meshInstance.node);
                var cloneMeshInstance = new MeshInstance(cloneNodes[nodeIndex], meshInstance.mesh, meshInstance.material);

                if (meshInstance.skinInstance) {
                    var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
                    cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
                }

                if (meshInstance.morphInstance) {
                    var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
                    cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
                }

                cloneMeshInstances.push(cloneMeshInstance);
            }

            var clone = new Model();
            clone.graph = cloneGraph;
            clone.meshInstances = cloneMeshInstances;
            clone.skinInstances = cloneSkinInstances;
            clone.morphInstances = cloneMorphInstances;

            clone.getGraph().syncHierarchy();

            return clone;
        },

        /**
         * @function
         * @name pc.Model#destroy
         * @description Destroys skinning texture and possibly deletes vertex/index buffers of a model.
         * Mesh is reference-counted, so buffers are only deleted if all models with referencing mesh instances were deleted.
         * That means all in-scene models + the "base" one (asset.resource) which is created when the model is parsed.
         * It is recommended to use asset.unload() instead, which will also remove the model from the scene.
         */
        destroy: function () {
            var meshInstances = this.meshInstances;
            var meshInstance, mesh, skin, morph, boneTex;
            for (var i = 0; i < meshInstances.length; i++) {
                meshInstance = meshInstances[i];

                mesh = meshInstance.mesh;
                if (mesh) {
                    meshInstance.mesh = null;   // this calls decReference on mesh
                    if (mesh.refCount < 1) {
                        mesh.destroy();
                    }
                }

                skin = meshInstance.skinInstance;
                if (skin) {
                    boneTex = skin.boneTexture;
                    if (boneTex) {
                        boneTex.destroy();
                    }
                }
                meshInstance.skinInstance = null;

                morph = meshInstance.morphInstance;
                if (morph) {
                    morph.destroy();
                }
                meshInstance.morphInstance = null;

                meshInstance.material = null; // make sure instance and material clear references
            }
        },

        /**
         * @function
         * @name pc.Model#generateWireframe
         * @description Generates the necessary internal data for a model to be
         * renderable as wireframe. Once this function has been called, any mesh
         * instance in the model can have its renderStyle property set to
         * pc.RENDERSTYLE_WIREFRAME.
         * @example
         * model.generateWireframe();
         * for (var i = 0; i < model.meshInstances.length; i++) {
         *     model.meshInstances[i].renderStyle = pc.RENDERSTYLE_WIREFRAME;
         * }
         */
        generateWireframe: function () {
            var i;
            var mesh;

            // Build an array of unique meshes in this model
            var meshes = [];
            for (i = 0; i < this.meshInstances.length; i++) {
                mesh = this.meshInstances[i].mesh;
                if (meshes.indexOf(mesh) === -1) {
                    meshes.push(mesh);
                }
            }

            for (i = 0; i < meshes.length; ++i) {
                mesh = meshes[i];
                if (!mesh.primitive[RENDERSTYLE_WIREFRAME]) {
                    mesh.generateWireframe();
                }
            }
        }
    });

    // TODO: split by new layers

    /**
     * @class
     * @name pc.Batch
     * @classdesc Holds information about batched mesh instances. Created in {@link pc.BatchManager#create}.
     * @param {pc.MeshInstance[]} meshInstances - The mesh instances to be batched.
     * @param {boolean} dynamic - Whether this batch is dynamic (supports transforming mesh instances at runtime).
     * @param {number} batchGroupId - Link this batch to a specific batch group. This is done automatically with default batches.
     * @property {pc.MeshInstance[]} origMeshInstances An array of original mesh instances, from which this batch was generated.
     * @property {pc.MeshInstance} meshInstance A single combined mesh instance, the result of batching.
     * @property {pc.Model} model A handy model object.
     * @property {boolean} dynamic Whether this batch is dynamic (supports transforming mesh instances at runtime).
     * @property {number} [batchGroupId] Link this batch to a specific batch group. This is done automatically with default batches.
     */
    function Batch(meshInstances, dynamic, batchGroupId) {
        this.origMeshInstances = meshInstances;
        this._aabb = new BoundingBox();
        this.meshInstance = null;
        this.model = null;
        this.dynamic = dynamic;
        this.batchGroupId = batchGroupId;
        this.refCounter = 0;
    }

    /**
     * @class
     * @name pc.BatchGroup
     * @classdesc Holds mesh batching settings and a unique id. Created via {@link pc.BatchManager#addGroup}.
     * @param {number} id - Unique id. Can be assigned to model and element components.
     * @param {string} name - The name of the group.
     * @param {boolean} dynamic - Whether objects within this batch group should support transforming at runtime.
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched objects.
     * {@link pc.BatchManager#prepare} will split objects into local groups based on this size.
     * @param {number[]} [layers] - Layer ID array. Default is [pc.LAYERID_WORLD]. The whole batch group will belong
     * to these layers. Layers of source models will be ignored.
     * @property {boolean} dynamic Whether objects within this batch group should support transforming at runtime.
     * @property {number} maxAabbSize Maximum size of any dimension of a bounding box around batched objects.
     * {@link pc.BatchManager#prepare} will split objects into local groups based on this size.
     * @property {number} id Unique id. Can be assigned to model and element components.
     * @property {string} name Name of the group.
     * @property {number[]} [layers] Layer ID array. Default is [pc.LAYERID_WORLD]. The whole batch group will belong
     * to these layers. Layers of source models will be ignored.
     */
    function BatchGroup(id, name, dynamic, maxAabbSize, layers) {
        this.dynamic = dynamic;
        this.maxAabbSize = maxAabbSize;
        this.id = id;
        this.name = name;
        this.layers = layers === undefined ? [LAYERID_WORLD] : layers;
        this._ui = false;
        this._sprite = false;
        this._obj = {
            model: [],
            element: [],
            sprite: []
        };
    }

    BatchGroup.MODEL = 'model';
    BatchGroup.ELEMENT = 'element';
    BatchGroup.SPRITE = 'sprite';

    // Modified SkinInstance for batching
    // Doesn't contain bind matrices, simplier
    function SkinBatchInstance(device, nodes, rootNode) {
        this.device = device;
        this.rootNode = rootNode;
        this._dirty = true;

        // Unique per clone
        this.bones = nodes;

        var numBones = nodes.length;

        if (device.supportsBoneTextures) {
            var size;
            if (numBones > 256)
                size = 64;
            else if (numBones > 64)
                size = 32;
            else if (numBones > 16)
                size = 16;
            else
                size = 8;

            this.boneTexture = new Texture(device, {
                width: size,
                height: size,
                format: PIXELFORMAT_RGBA32F,
                mipmaps: false,
                minFilter: FILTER_NEAREST,
                magFilter: FILTER_NEAREST
            });
            this.boneTexture.name = 'batching';
            this.matrixPalette = this.boneTexture.lock();
        } else {
            this.matrixPalette = new Float32Array(numBones * 16);
        }
    }

    Object.assign(SkinBatchInstance.prototype, {
        updateMatrices: function (rootNode) {
        },

        updateMatrixPalette: function () {
            var pe;
            var mp = this.matrixPalette;
            var base;

            for (var i = this.bones.length - 1; i >= 0; i--) {
                pe = this.bones[i].getWorldTransform().data;

                // Copy the matrix into the palette, ready to be sent to the vertex shader
                base = i * 16;
                mp[base] = pe[0];
                mp[base + 1] = pe[1];
                mp[base + 2] = pe[2];
                mp[base + 3] = pe[3];
                mp[base + 4] = pe[4];
                mp[base + 5] = pe[5];
                mp[base + 6] = pe[6];
                mp[base + 7] = pe[7];
                mp[base + 8] = pe[8];
                mp[base + 9] = pe[9];
                mp[base + 10] = pe[10];
                mp[base + 11] = pe[11];
                mp[base + 12] = pe[12];
                mp[base + 13] = pe[13];
                mp[base + 14] = pe[14];
                mp[base + 15] = pe[15];
            }

            if (this.device.supportsBoneTextures) {
                this.boneTexture.lock();
                this.boneTexture.unlock();
            }
        }
    });

    /**
     * @class
     * @name pc.BatchManager
     * @classdesc Glues many mesh instances into a single one for better performance.
     * @param {pc.GraphicsDevice} device - The graphics device used by the batch manager.
     * @param {pc.Entity} root - The entity under which batched models are added.
     * @param {pc.Scene} scene - The scene that the batch manager affects.
     */
    function BatchManager(device, root, scene) {
        this.device = device;
        this.rootNode = root;
        this.scene = scene;
        this._init = false;

        this._batchGroups = {};
        this._batchGroupCounter = 0;
        this._batchList = [];
        this._dirtyGroups = [];

    }

    // TODO: rename destroy() to something else and rename this to destroy
    BatchManager.prototype.destroyManager = function () {
        this.device = null;
        this.rootNode = null;
        this.scene = null;
        this._batchGroups = {};
        this._batchList = [];
        this._dirtyGroups = [];
    };

    /**
     * @function
     * @name pc.BatchManager#addGroup
     * @description Adds new global batch group.
     * @param {string} name - Custom name.
     * @param {boolean} dynamic - Is this batch group dynamic? Will these objects move/rotate/scale after being batched?
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched objects.
     * {@link pc.BatchManager#prepare} will split objects into local groups based on this size.
     * @param {number} [id] - Optional custom unique id for the group (will be generated automatically otherwise).
     * @param {number[]} [layers] - Optional layer ID array. Default is [pc.LAYERID_WORLD]. The whole batch group will
     * belong to these layers. Layers of source models will be ignored.
     * @returns {pc.BatchGroup} Group object.
     */
    BatchManager.prototype.addGroup = function (name, dynamic, maxAabbSize, id, layers) {
        if (id === undefined) {
            id = this._batchGroupCounter;
            this._batchGroupCounter++;
        }

        if (this._batchGroups[id]) {
            return;
        }

        var group;
        this._batchGroups[id] = group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);

        return group;
    };

    /**
     * @function
     * @name pc.BatchManager#removeGroup
     * @description Remove global batch group by id.
     * Note, this traverses the entire scene graph and clears the batch group id from all components.
     * @param {number} id - Batch Group ID.
     */
    BatchManager.prototype.removeGroup = function (id) {
        if (!this._batchGroups[id]) {
            return;
        }

        // delete batches with matching id
        var newBatchList = [];
        for (var i = 0; i < this._batchList.length; i++) {
            if (this._batchList[i].batchGroupId !== id) {
                newBatchList.push(this._batchList[i]);
                continue;
            }
            this.destroy(this._batchList[i]);
        }
        this._batchList = newBatchList;
        this._removeModelsFromBatchGroup(this.rootNode, id);

        delete this._batchGroups[id];
    };

    /**
     * @function
     * @name pc.BatchManager#markGroupDirty
     * @description Mark a specific batch group as dirty. Dirty groups are re-batched before the next frame is rendered.
     * Note, re-batching a group is a potentially expensive operation.
     * @param  {number} id - Batch Group ID to mark as dirty.
     */
    BatchManager.prototype.markGroupDirty = function (id) {
        if (this._dirtyGroups.indexOf(id) < 0) {
            this._dirtyGroups.push(id);
        }
    };

    /**
     * @function
     * @name pc.BatchManager#getGroupByName
     * @description Retrieves a {@link pc.BatchGroup} object with a corresponding name, if it exists, or null otherwise.
     * @param {string} name - Name.
     * @returns {pc.BatchGroup} Group object.
     */
    BatchManager.prototype.getGroupByName = function (name) {
        var groups = this._batchGroups;
        for (var group in groups) {
            if (!groups.hasOwnProperty(group)) continue;
            if (groups[group].name === name) {
                return groups[group];
            }
        }
        return null;
    };

    /**
     * @private
     * @function
     * @name pc.BatchManager#getBatches
     * @description  Return a list of all {@link pc.Batch} objects that belong to the Batch Group supplied.
     * @param  {number} batchGroupId - The id of the batch group.
     * @returns {pc.Batch[]} A list of batches that are used to render the batch group.
     */
    BatchManager.prototype.getBatches = function (batchGroupId) {
        var results = [];
        var len = this._batchList.length;
        for (var i = 0; i < len; i++) {
            var batch = this._batchList[i];
            if (batch.batchGroupId === batchGroupId) {
                results.push(batch);
            }
        }

        return results;
    };

    // traverse full hierarchy and clear the batch group id from all model, element and sprite components
    BatchManager.prototype._removeModelsFromBatchGroup = function (node, id) {
        if (!node.enabled) return;

        if (node.model && node.model.batchGroupId === id) {
            node.model.batchGroupId = -1;
        }
        if (node.element && node.element.batchGroupId === id) {
            node.element.batchGroupId = -1;
        }
        if (node.sprite && node.sprite.batchGroupId === id) {
            node.sprite.batchGroupId = -1;
        }

        for (var i = 0; i < node._children.length; i++) {
            this._removeModelsFromBatchGroup(node._children[i], id);
        }
    };

    BatchManager.prototype.insert = function (type, groupId, node) {
        var group = this._batchGroups[groupId];
        if (group) {
            if (group._obj[type].indexOf(node) < 0) {
                group._obj[type].push(node);
                this.markGroupDirty(groupId);
            }
        }
    };

    BatchManager.prototype.remove = function (type, groupId, node) {
        var group = this._batchGroups[groupId];
        if (group) {
            var idx = group._obj[type].indexOf(node);
            if (idx >= 0) {
                group._obj[type].splice(idx, 1);
                this.markGroupDirty(groupId);
            }
        }
    };

    BatchManager.prototype._extractModel = function (node, arr, group, groupMeshInstances) {
        if (!node.model || !node.model.model) return arr;

        var i;
        if (node.model.isStatic) {
            // static mesh instances can be in both drawCall array with _staticSource linking to original
            // and in the original array as well, if no triangle splitting was done
            var drawCalls = this.scene.drawCalls;
            var nodeMeshInstances = node.model.meshInstances;
            for (i = 0; i < drawCalls.length; i++) {
                if (!drawCalls[i]._staticSource) continue;
                if (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;
                arr.push(drawCalls[i]);
            }
            for (i = 0; i < nodeMeshInstances.length; i++) {
                if (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {
                    arr.push(nodeMeshInstances[i]);
                }
            }
        } else {
            arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
        }

        node.model.removeModelFromLayers();

        return arr;
    };

    BatchManager.prototype._extractElement = function (node, arr, group) {
        if (!node.element) return;
        var valid = false;
        if (node.element._text && node.element._text._model.meshInstances.length > 0) {
            arr.push(node.element._text._model.meshInstances[0]);
            node.element.removeModelFromLayers(node.element._text._model);

            valid = true;
        } else if (node.element._image) {
            arr.push(node.element._image._renderable.meshInstance);
            node.element.removeModelFromLayers(node.element._image._renderable.model);

            if (node.element._image._renderable.unmaskMeshInstance) {
                arr.push(node.element._image._renderable.unmaskMeshInstance);
                if (!node.element._image._renderable.unmaskMeshInstance.stencilFront ||
                    !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
                    node.element._dirtifyMask();
                    node.element._onPrerender();
                }
            }

            valid = true;
        }

        if (valid) {
            group._ui = true;
        }
    };

    // traverse scene hierarchy down from `node` and collect all components that are marked
    // with a batch group id. Remove from layers any models that these components contains.
    // Fill the `groupMeshInstances` with all the mesh instances to be included in the batch groups,
    // indexed by batch group id.
    BatchManager.prototype._collectAndRemoveModels = function (groupMeshInstances, groupIds) {
        var node, group, arr, id;
        for (var g = 0; g < groupIds.length; g++) {
            id = groupIds[g];
            group = this._batchGroups[id];
            if (!group) continue;
            arr = groupMeshInstances[id];
            if (!arr) arr = groupMeshInstances[id] = [];

            for (var m = 0; m < group._obj.model.length; m++) {
                arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
            }

            for (var e = 0; e < group._obj.element.length; e++) {
                this._extractElement(group._obj.element[e], arr, group);
            }

            for (var s = 0; s < group._obj.sprite.length; s++) {
                node = group._obj.sprite[s];
                if (node.sprite && node.sprite._meshInstance &&
                    (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
                    arr.push(node.sprite._meshInstance);
                    node.sprite.removeModelFromLayers();
                    group._sprite = true;
                    node.sprite._batchGroup = group;
                }
            }
        }
    };

    /**
     * @function
     * @name pc.BatchManager#generate
     * @description Destroys all batches and creates new based on scene models. Hides original models. Called by engine automatically on app start, and if batchGroupIds on models are changed.
     * @param {number[]} [groupIds] - Optional array of batch group IDs to update. Otherwise all groups are updated.
     */
    BatchManager.prototype.generate = function (groupIds) {
        var i, j;
        var groupMeshInstances = {};

        if (!groupIds) {
            // Full scene
            groupIds = Object.keys(this._batchGroups);
        }

        // delete old batches with matching batchGroupId
        var newBatchList = [];
        for (i = 0; i < this._batchList.length; i++) {
            if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
                newBatchList.push(this._batchList[i]);
                continue;
            }
            this.destroy(this._batchList[i]);
        }
        this._batchList = newBatchList;

        // collect
        this._collectAndRemoveModels(groupMeshInstances, groupIds);

        if (groupIds === this._dirtyGroups) {
            this._dirtyGroups.length = 0;
        } else {
            var newDirtyGroups = [];
            for (i = 0; i < this._dirtyGroups.length; i++) {
                if (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);
            }
            this._dirtyGroups = newDirtyGroups;
        }

        var group, lists, groupData, batch;
        for (var groupId in groupMeshInstances) {
            if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
            group = groupMeshInstances[groupId];

            groupData = this._batchGroups[groupId];
            if (!groupData) {
                continue;
            }

            lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
            for (i = 0; i < lists.length; i++) {
                batch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));
                if (!batch) continue;
                for (j = 0; j < groupData.layers.length; j++) {
                    var layer = this.scene.layers.getLayerById(groupData.layers[j]);
                    if (layer)
                        layer.addMeshInstances(batch.model.meshInstances);
                }
            }
        }
    };

    function paramsIdentical(a, b) {
        if (a && !b) return false;
        if (!a && b) return false;
        a = a.data;
        b = b.data;
        if (a === b) return true;
        if (a instanceof Float32Array && b instanceof Float32Array) {
            if (a.length !== b.length) return false;
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        return false;
    }

    function equalParamSets(params1, params2) {
        var param;
        for (param in params1) { // compare A -> B
            if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param]))
                return false;
        }
        for (param in params2) { // compare B -> A
            if (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param]))
                return false;
        }
        return true;
    }

    function equalLightLists(lightList1, lightList2) {
        var k;
        for (k = 0; k < lightList1.length; k++) {
            if (lightList2.indexOf(lightList1[k]) < 0)
                return false;
        }
        for (k = 0; k < lightList2.length; k++) {
            if (lightList1.indexOf(lightList2[k]) < 0)
                return false;
        }
        return  true;
    }

    var worldMatX = new Vec3();
    var worldMatY = new Vec3();
    var worldMatZ = new Vec3();
    function getScaleSign(mi) {
        var wt = mi.node.worldTransform;
        wt.getX(worldMatX);
        wt.getY(worldMatY);
        wt.getZ(worldMatZ);
        worldMatX.cross(worldMatX, worldMatY);
        return worldMatX.dot(worldMatZ) >= 0 ? 1 : -1;
    }

    /**
     * @function
     * @name pc.BatchManager#prepare
     * @description Takes a list of mesh instances to be batched and sorts them into lists one for each draw call.
     * The input list will be split, if:
     *
     * * Mesh instances use different materials.
     * * Mesh instances have different parameters (e.g. lightmaps or static lights).
     * * Mesh instances have different shader defines (shadow receiving, being aligned to screen space, etc).
     * * Too many vertices for a single batch (65535 is maximum).
     * * Too many instances for a single batch (hardware-dependent, expect 128 on low-end and 1024 on high-end).
     * * Bounding box of a batch is larger than maxAabbSize in any dimension.
     *
     * @param {pc.MeshInstance[]} meshInstances - Input list of mesh instances
     * @param {boolean} dynamic - Are we preparing for a dynamic batch? Instance count will matter then (otherwise not).
     * @param {number} maxAabbSize - Maximum size of any dimension of a bounding box around batched objects.
     * @param {boolean} translucent - Are we batching UI elements or sprites
     * This is useful to keep a balance between the number of draw calls and the number of drawn triangles, because smaller batches can be hidden when not visible in camera.
     * @returns {pc.MeshInstance[]} An array of arrays of mesh instances, each valid to pass to {@link pc.BatchManager#create}.
     */
    BatchManager.prototype.prepare = function (meshInstances, dynamic, maxAabbSize, translucent) {
        if (meshInstances.length === 0) return [];
        if (maxAabbSize === undefined) maxAabbSize = Number.POSITIVE_INFINITY;
        var halfMaxAabbSize = maxAabbSize * 0.5;
        var maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;

        // maximum number of vertices that can be used in batch depends on 32bit index buffer support (do this for non-indexed as well,
        // as in some cases (UI elements) non-indexed geometry gets batched into indexed)
        var maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;

        var material, layer, vertCount, params, lightList, defs, stencil, staticLights, scaleSign, drawOrder, indexed, vertexFormatBatchingHash;
        var aabb = new BoundingBox();
        var testAabb = new BoundingBox();
        var skipTranslucentAabb = null;
        var mi, sf;

        var lists = [];
        var i, j = 0;
        if (translucent) {
            meshInstances.sort(function (a, b) {
                return a.drawOrder - b.drawOrder;
            });
        }
        var meshInstancesLeftA = meshInstances;
        var meshInstancesLeftB;

        var skipMesh = translucent ? function (mi) {
            if (skipTranslucentAabb) {
                skipTranslucentAabb.add(mi.aabb);
            } else {
                skipTranslucentAabb = mi.aabb.clone();
            }
            meshInstancesLeftB.push(mi);
        } : function (mi) {
            meshInstancesLeftB.push(mi);
        };

        while (meshInstancesLeftA.length > 0) {
            lists[j] = [meshInstancesLeftA[0]];
            meshInstancesLeftB = [];
            material = meshInstancesLeftA[0].material;
            layer = meshInstancesLeftA[0].layer;
            defs = meshInstancesLeftA[0]._shaderDefs;
            params = meshInstancesLeftA[0].parameters;
            stencil = meshInstancesLeftA[0].stencilFront;
            lightList = meshInstancesLeftA[0]._staticLightList;
            vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
            drawOrder = meshInstancesLeftA[0].drawOrder;
            aabb.copy(meshInstancesLeftA[0].aabb);
            scaleSign = getScaleSign(meshInstancesLeftA[0]);
            vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
            indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
            skipTranslucentAabb = null;

            for (i = 1; i < meshInstancesLeftA.length; i++) {
                mi = meshInstancesLeftA[i];

                // Split by instance number
                if (dynamic && lists[j].length >= maxInstanceCount) {
                    meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
                    break;
                }

                // Split by material, layer (legacy), vertex format & index compatibility, shader defines, static source, vert count, overlaping UI
                if ((material !== mi.material) ||
                    (layer !== mi.layer) ||
                    (vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash) ||
                    (indexed !== mi.mesh.primitive[0].indexed) ||
                    (defs !== mi._shaderDefs) ||
                    (vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices)) {
                    skipMesh(mi);
                    continue;
                }
                // Split by AABB
                testAabb.copy(aabb);
                testAabb.add(mi.aabb);
                if (testAabb.halfExtents.x > halfMaxAabbSize ||
                    testAabb.halfExtents.y > halfMaxAabbSize ||
                    testAabb.halfExtents.z > halfMaxAabbSize) {
                    skipMesh(mi);
                    continue;
                }
                // Split stencil mask (UI elements), both front and back expected to be the same
                if (stencil) {
                    if (!(sf = mi.stencilFront) || stencil.func != sf.func || stencil.zpass != sf.zpass) {
                        skipMesh(mi);
                        continue;
                    }
                }
                // Split by negative scale
                if (scaleSign != getScaleSign(mi)) {
                    skipMesh(mi);
                    continue;
                }

                // Split by parameters
                if (!equalParamSets(params, mi.parameters)) {
                    skipMesh(mi);
                    continue;
                }
                // Split by static light list
                staticLights = mi._staticLightList;
                if (lightList && staticLights) {
                    if (!equalLightLists(lightList, staticLights)) {
                        skipMesh(mi);
                        continue;
                    }
                } else if (lightList || staticLights) { // Split by static/non static
                    skipMesh(mi);
                    continue;
                }

                if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
                    skipMesh(mi);
                    continue;
                }

                aabb.add(mi.aabb);
                vertCount += mi.mesh.vertexBuffer.getNumVertices();
                lists[j].push(mi);
            }

            j++;
            meshInstancesLeftA = meshInstancesLeftB;
        }

        return lists;
    };

    /**
     * @function
     * @name pc.BatchManager#create
     * @description Takes a mesh instance list that has been prepared by {@link pc.BatchManager#prepare}, and returns a {@link pc.Batch} object. This method assumes that all mesh instances provided can be rendered in a single draw call.
     * @param {pc.MeshInstance[]} meshInstances - Input list of mesh instances.
     * @param {boolean} dynamic - Is it a static or dynamic batch? Will objects be transformed after batching?
     * @param {number} [batchGroupId] - Link this batch to a specific batch group. This is done automatically with default batches.
     * @returns {pc.Batch} The resulting batch object.
     */
    BatchManager.prototype.create = function (meshInstances, dynamic, batchGroupId) {


        if (!this._init) {
            var boneLimit = "#define BONE_LIMIT " + this.device.getBoneLimit() + "\n";
            this.transformVS = boneLimit + "#define DYNAMICBATCH\n" + shaderChunks.transformVS;
            this.skinTexVS = shaderChunks.skinBatchTexVS;
            this.skinConstVS = shaderChunks.skinBatchConstVS;
            this.vertexFormats = {};
            this._init = true;
        }

        var i, j;
        var streams = null, stream;
        var semantic;
        var material = null;
        var mesh, elems, numVerts;
        var batchNumVerts = 0;
        var batchNumIndices = 0;
        var batch = null;

        for (i = 0; i < meshInstances.length; i++) {
            if (meshInstances[i].visible) {

                // vertex counts
                mesh = meshInstances[i].mesh;
                numVerts = mesh.vertexBuffer.numVertices;
                batchNumVerts += numVerts;

                // index counts (handles special case of TRI-FAN-type non-indexed primitive used by UI)
                batchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count :
                    (mesh.primitive[0].type == PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0);

                // if first mesh
                if (!streams) {

                    // material
                    material = meshInstances[i].material;

                    // collect used vertex buffer semantic information from first mesh (they all match)
                    streams = {};
                    elems = mesh.vertexBuffer.format.elements;
                    for (j = 0; j < elems.length; j++) {
                        semantic = elems[j].name;
                        streams[semantic] = {
                            numComponents: elems[j].numComponents,
                            dataType: elems[j].dataType,
                            normalize: elems[j].normalize,
                            count: 0
                        };
                    }

                    // for dynamic meshes we need bone indices
                    if (dynamic) {
                        streams[SEMANTIC_BLENDINDICES] = {
                            numComponents: 1,
                            dataType: TYPE_FLOAT32,
                            normalize: false,
                            count: 0
                        };
                    }
                }
            }
        }

        // if anything to batch
        if (streams) {

            batch = new Batch(meshInstances, dynamic, batchGroupId);
            this._batchList.push(batch);

            var indexBase, numIndices, indexData;
            var verticesOffset = 0;
            var indexOffset = 0;
            var transform, vec = new Vec3();

            // allocate indices
            var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
            var indices = new indexArrayType(batchNumIndices);

            // allocate typed arrays to store final vertex stream data
            for (semantic in streams) {
                stream = streams[semantic];
                stream.typeArrayType = typedArrayTypes[stream.dataType];
                stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
                stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
            }

            // build vertex and index data for final mesh
            for (i = 0; i < meshInstances.length; i++) {
                if (!meshInstances[i].visible)
                    continue;

                mesh = meshInstances[i].mesh;
                numVerts = mesh.vertexBuffer.numVertices;

                // matrix to transform vertices to world space for static batching
                if (!dynamic) {
                    transform = meshInstances[i].node.getWorldTransform();
                }

                for (semantic in streams) {
                    if (semantic !== SEMANTIC_BLENDINDICES) {
                        stream = streams[semantic];

                        // get vertex stream to typed view subarray
                        var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
                        var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
                        stream.count += totalComponents;

                        // transform position, normal and tangent to world space
                        if (!dynamic && stream.numComponents >= 3) {
                            if (semantic == SEMANTIC_POSITION || semantic == SEMANTIC_NORMAL || semantic == SEMANTIC_TANGENT) {
                                transform.transformFunction = semantic == SEMANTIC_POSITION ? Mat4.prototype.transformPoint : Mat4.prototype.transformVector;

                                for (j = 0; j < totalComponents; j += stream.numComponents) {
                                    vec.set(subarray[j], subarray[j + 1], subarray[j + 2]);
                                    transform.transformFunction(vec, vec);
                                    subarray[j] = vec.x;
                                    subarray[j + 1] = vec.y;
                                    subarray[j + 2] = vec.z;
                                }
                            }
                        }
                    }
                }

                // bone index is mesh index
                if (dynamic) {
                    stream = streams[SEMANTIC_BLENDINDICES];
                    for (j = 0; j < numVerts; j++)
                        stream.buffer[stream.count++] = i;
                }

                // index buffer
                if (mesh.primitive[0].indexed) {
                    indexBase = mesh.primitive[0].base;
                    numIndices = mesh.primitive[0].count;

                    // source index buffer data mapped to its format
                    var srcFormat = mesh.indexBuffer[0].getFormat();
                    indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
                } else if (mesh.primitive[0].type == PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {
                    // Special case for UI image elements
                    indexBase = 0;
                    numIndices = 6;
                    indexData = [0, 1, 3, 2, 3, 1];
                } else {
                    numIndices = 0;
                    continue;
                }

                for (j = 0; j < numIndices; j++) {
                    indices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;
                }

                indexOffset += numIndices;
                verticesOffset += numVerts;
            }

            // Create mesh
            mesh = new Mesh(this.device);
            for (semantic in streams) {
                stream = streams[semantic];
                mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
            }

            if (indices.length > 0)
                mesh.setIndices(indices);

            mesh.update(PRIMITIVE_TRIANGLES, false);

            // Patch the material
            if (dynamic) {
                material = material.clone();
                material.chunks.transformVS = this.transformVS;
                material.chunks.skinTexVS = this.skinTexVS;
                material.chunks.skinConstVS = this.skinConstVS;
                material.update();
            }

            // Create meshInstance
            var meshInstance = new MeshInstance(this.rootNode, mesh, material);
            meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
            meshInstance.parameters = batch.origMeshInstances[0].parameters;
            meshInstance.isStatic = batch.origMeshInstances[0].isStatic;
            meshInstance.layer = batch.origMeshInstances[0].layer;
            meshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;
            meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;

            // meshInstance culling - don't cull UI elements, as they use custom culling Component.isVisibleForCamera
            meshInstance.cull = batch.origMeshInstances[0].cull;
            var batchGroup = this._batchGroups[batchGroupId];
            if (batchGroup && batchGroup._ui)
                meshInstance.cull = false;

            if (dynamic) {
                // Create skinInstance
                var nodes = [];
                for (i = 0; i < batch.origMeshInstances.length; i++) {
                    nodes.push(batch.origMeshInstances[i].node);
                }
                meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
            }

            // disable aabb update, gets updated manually by batcher
            meshInstance._updateAabb = false;

            meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
            meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
            meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
            meshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;
            batch.meshInstance = meshInstance;
            this.update(batch);

            var newModel = new Model();
            newModel.meshInstances = [batch.meshInstance];
            newModel.castShadows = batch.origMeshInstances[0].castShadows;

            batch.model = newModel;
        }


        return batch;
    };

    /**
     * @private
     * @function
     * @name pc.BatchManager#update
     * @description Updates bounding box for a batch. Called automatically.
     * @param {pc.Batch} batch - A batch object.
     */
    BatchManager.prototype.update = function (batch) {
        batch._aabb.copy(batch.origMeshInstances[0].aabb);
        for (var i = 1; i < batch.origMeshInstances.length; i++) {
            batch._aabb.add(batch.origMeshInstances[i].aabb); // this is the slowest part
        }
        batch.meshInstance.aabb = batch._aabb;
        batch._aabb._radiusVer = -1;
        batch.meshInstance._aabbVer = 0;
    };

    /**
     * @private
     * @function
     * @name pc.BatchManager#updateAll
     * @description Updates bounding boxes for all dynamic batches. Called automatically.
     */
    BatchManager.prototype.updateAll = function () {
        // TODO: only call when needed. Applies to skinning matrices as well

        if (this._dirtyGroups.length > 0) {
            this.generate(this._dirtyGroups);
        }


        for (var i = 0; i < this._batchList.length; i++) {
            if (!this._batchList[i].dynamic) continue;
            this.update(this._batchList[i]);
        }

    };

    /**
     * @function
     * @name pc.BatchManager#clone
     * @description Clones a batch. This method doesn't rebuild batch geometry, but only creates a new model and batch objects, linked to different source mesh instances.
     * @param {pc.Batch} batch - A batch object.
     * @param {pc.MeshInstance[]} clonedMeshInstances - New mesh instances.
     * @returns {pc.Batch} New batch object.
     */
    BatchManager.prototype.clone = function (batch, clonedMeshInstances) {
        var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
        this._batchList.push(batch2);

        var nodes = [];
        for (var i = 0; i < clonedMeshInstances.length; i++) {
            nodes.push(clonedMeshInstances[i].node);
        }

        batch2.meshInstance = new MeshInstance(batch.meshInstance.node, batch.meshInstance.mesh, batch.meshInstance.material);
        batch2.meshInstance._updateAabb = false;
        batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
        batch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;
        batch2.meshInstance.cull = clonedMeshInstances[0].cull;
        batch2.meshInstance.layer = clonedMeshInstances[0].layer;
        batch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;

        if (batch.dynamic) {
            batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
        }

        batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
        batch2.meshInstance._shader = batch.meshInstance._shader;

        var newModel = new Model();

        newModel.meshInstances = [batch2.meshInstance];
        newModel.castShadows = batch.origMeshInstances[0].castShadows;
        batch2.model = newModel;

        return batch2;
    };

    /**
     * @private
     * @function
     * @name pc.BatchManager#destroy
     * @description Mark the batches ref counter to 0, remove the batch model out of all layers and destroy it.
     * @param {pc.Batch} batch - A batch object.
     */
    BatchManager.prototype.destroy = function (batch) {
        batch.refCounter = 0;
        if (!batch.model)
            return;
        var layers = this._batchGroups[batch.batchGroupId].layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = this.scene.layers.getLayerById(layers[i]);
            if (layer)
                layer.removeMeshInstances(batch.model.meshInstances);
        }
        batch.model.destroy();
    };

    /**
     * @private
     * @function
     * @name pc.BatchManager#decrement
     * @description Decrements reference counter on a batch. If it's zero, the batch is removed from scene, and its geometry is deleted from memory.
     * @param {pc.Batch} batch - A batch object.
     */
    BatchManager.prototype.decrement = function (batch) {
        batch.refCounter--;
        if (batch.refCounter === 0) {
            this.destroy(batch);
        }
    };

    // pre-allocated temp variables
    var _deviceCoord = new Vec3();
    var _far = new Vec3();
    var _farW = new Vec3();
    var _invViewProjMat = new Mat4();

    /**
     * @private
     * @class
     * @name pc.Camera
     * @classdesc A camera.
     */
    function Camera() {
        this._projection = PROJECTION_PERSPECTIVE;
        this._nearClip = 0.1;
        this._farClip = 10000;
        this._shaderParams = new Float32Array(4);
        this._fov = 45;
        this._orthoHeight = 10;
        this._aspect = 16 / 9;
        this._aspectRatioMode = ASPECT_AUTO;
        this._horizontalFov = false;
        this.frustumCulling = false;
        this.cullingMask = 0xFFFFFFFF;
        this._renderDepthRequests = 0;

        this._projMatDirty = true;
        this._projMat = new Mat4();
        this._projMatSkybox = new Mat4();    // projection matrix used by skybox rendering shader is always perspective
        this._viewMatDirty = true;
        this._viewMat = new Mat4();
        this._viewProjMatDirty = true;
        this._viewProjMat = new Mat4();

        this.vrDisplay = null;

        this._rect = {
            x: 0,
            y: 0,
            width: 1,
            height: 1
        };

        this._scissorRect = {
            x: 0,
            y: 0,
            width: 1,
            height: 1
        };

        this.frustum = new Frustum(this._projMat, this._viewMat);

        // Create a full size viewport onto the backbuffer
        this.renderTarget = null;
        this._depthTarget = null;

        // Create the clear options
        this._clearOptions = {
            color: [0.5, 0.5, 0.5, 1.0],
            depth: 1.0,
            stencil: 0,
            flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH | CLEARFLAG_STENCIL
        };

        this._node = null;

        this.calculateTransform = null;
        this.overrideCalculateTransform = false;
        this.calculateProjection = null;
        this.overrideCalculateProjection = false;
        this._cullFaces = true;
        this._flipFaces = false;

        this._component = null;
    }

    Object.assign(Camera.prototype, {
        /**
         * @private
         * @function
         * @name pc.Camera#clone
         * @description Duplicates a camera node but does not 'deep copy' the hierarchy.
         * @returns {pc.Camera} A cloned Camera.
         */
        clone: function () {
            var clone = new Camera();
            clone.projection = this._projection;
            clone.nearClip = this._nearClip;
            clone.farClip = this._farClip;
            clone._shaderParams = this._shaderParams.slice();
            clone.fov = this._fov;
            clone.aspectRatio = this._aspect;
            clone._aspectRatioMode = this._aspectRatioMode;
            clone.renderTarget = this.renderTarget;
            clone.setClearOptions(this.getClearOptions());
            clone.frustumCulling = this.frustumCulling;
            clone.cullingMask = this.cullingMask;
            return clone;
        },

        /**
         * @private
         * @function
         * @name pc.Camera#worldToScreen
         * @description Convert a point from 3D world space to 2D canvas pixel space.
         * @param {pc.Vec3} worldCoord - The world space coordinate to transform.
         * @param {number} cw - The width of PlayCanvas' canvas element.
         * @param {number} ch - The height of PlayCanvas' canvas element.
         * @param {pc.Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
         * @returns {pc.Vec3} The screen space coordinate.
         */
        worldToScreen: function (worldCoord, cw, ch, screenCoord) {
            if (screenCoord === undefined) {
                screenCoord = new Vec3();
            }

            if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
                var projMat = this.getProjectionMatrix();
                var viewMat = this.getViewMatrix();
                this._viewProjMat.mul2(projMat, viewMat);
                this._viewProjMatDirty = false;
            }
            this._viewProjMat.transformPoint(worldCoord, screenCoord);

            // calculate w co-coord
            var vpm = this._viewProjMat.data;
            var w = worldCoord.x * vpm[3] +
                    worldCoord.y * vpm[7] +
                    worldCoord.z * vpm[11] +
                               1 * vpm[15];

            screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
            screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;

            return screenCoord;
        },

        /**
         * @private
         * @function
         * @name pc.Camera#screenToWorld
         * @description Convert a point from 2D canvas pixel space to 3D world space.
         * @param {number} x - X coordinate on PlayCanvas' canvas element.
         * @param {number} y - Y coordinate on PlayCanvas' canvas element.
         * @param {number} z - The distance from the camera in world space to create the new point.
         * @param {number} cw - The width of PlayCanvas' canvas element.
         * @param {number} ch - The height of PlayCanvas' canvas element.
         * @param {pc.Vec3} [worldCoord] - 3D vector to receive world coordinate result.
         * @returns {pc.Vec3} The world space coordinate.
         */
        screenToWorld: function (x, y, z, cw, ch, worldCoord) {
            if (worldCoord === undefined) {
                worldCoord = new Vec3();
            }

            if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
                var projMat = this.getProjectionMatrix();
                var viewMat = this.getViewMatrix();
                this._viewProjMat.mul2(projMat, viewMat);
                this._viewProjMatDirty = false;
            }
            _invViewProjMat.copy(this._viewProjMat).invert();

            if (this._projection === PROJECTION_PERSPECTIVE) {
                // Calculate the screen click as a point on the far plane of the
                // normalized device coordinate 'box' (z=1)
                _far.set(x / cw * 2 - 1, (ch - y) / ch * 2 - 1, 1);

                // Transform to world space
                _invViewProjMat.transformPoint(_far, _farW);

                var w = _far.x * _invViewProjMat.data[3] +
                        _far.y * _invViewProjMat.data[7] +
                        _far.z * _invViewProjMat.data[11] +
                        _invViewProjMat.data[15];

                _farW.scale(1 / w);

                var alpha = z / this._farClip;
                worldCoord.lerp(this._node.getPosition(), _farW, alpha);
            } else {
                // Calculate the screen click as a point on the far plane of the
                // normalized device coordinate 'box' (z=1)
                var range = this._farClip - this._nearClip;
                _deviceCoord.set(x / cw, (ch - y) / ch, z / range);
                _deviceCoord.scale(2);
                _deviceCoord.sub(Vec3.ONE);

                // Transform to world space
                _invViewProjMat.transformPoint(_deviceCoord, worldCoord);
            }

            return worldCoord;
        },

        /**
         * @private
         * @function
         * @name pc.Camera#getClearOptions
         * @description Retrieves the options used to determine how the camera's render target will be cleared.
         * @returns {object} The options determining the behaviour of render target clears.
         */
        getClearOptions: function () {
            return this._clearOptions;
        },

        _evaluateProjectionMatrix: function () {
            if (this._projMatDirty) {
                if (this._projection === PROJECTION_PERSPECTIVE) {
                    this._projMat.setPerspective(this._fov, this._aspect, this._nearClip, this._farClip, this._horizontalFov);
                    this._projMatSkybox.copy(this._projMat);
                } else {
                    var y = this._orthoHeight;
                    var x = y * this._aspect;
                    this._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);
                    this._projMatSkybox.setPerspective(this._fov, this._aspect, this._nearClip, this._farClip);
                }

                var n = this._nearClip;
                var f = this._farClip;
                this._shaderParams[0] = 1 / f;
                this._shaderParams[1] = f;
                this._shaderParams[2] = (1 - f / n) / 2;
                this._shaderParams[3] = (1 + f / n) / 2;

                this._projMatDirty = false;
            }
        },

        /**
         * @private
         * @function
         * @name pc.Camera#getProjectionMatrix
         * @description Retrieves the projection matrix for the specified camera.
         * @returns {pc.Mat4} The camera's projection matrix.
         */
        getProjectionMatrix: function () {
            this._evaluateProjectionMatrix();
            return this._projMat;
        },

        getProjectionMatrixSkybox: function () {
            this._evaluateProjectionMatrix();
            return this._projMatSkybox;
        },

        /**
         * @private
         * @function
         * @name pc.Camera#getViewMatrix
         * @description Retrieves the view matrix for the specified camera based on the entity world transformation.
         * @returns {pc.Mat4} The camera's view matrix.
         */
        getViewMatrix: function () {
            if (this._viewMatDirty) {
                var wtm = this._node.getWorldTransform();
                this._viewMat.copy(wtm).invert();
                this._viewMatDirty = false;
            }
            return this._viewMat;
        },

        getRect: function () {
            return this._rect;
        },

        /**
         * @private
         * @function
         * @name pc.Camera#setClearOptions
         * @description Sets the options used to determine how the camera's render target will be cleared.
         * @param {object} options - The options determining the behaviour of subsequent render target clears.
         * @param {number[]} options.color - The options determining the behaviour of subsequent render target clears.
         * @param {number} options.depth - The options determining the behaviour of subsequent render target clears.
         * @param {number} options.flags - The options determining the behaviour of subsequent render target clears.
         */
        setClearOptions: function (options) {
            this._clearOptions.color[0] = options.color[0];
            this._clearOptions.color[1] = options.color[1];
            this._clearOptions.color[2] = options.color[2];
            this._clearOptions.color[3] = options.color[3];
            this._clearOptions.depth = options.depth;
            this._clearOptions.stencil = options.stencil;
            this._clearOptions.flags = options.flags;
        },

        setRect: function (x, y, width, height) {
            this._rect.x = x;
            this._rect.y = y;
            this._rect.width = width;
            this._rect.height = height;
        },

        setScissorRect: function (x, y, width, height) {
            this._scissorRect.x = x;
            this._scissorRect.y = y;
            this._scissorRect.width = width;
            this._scissorRect.height = height;
        },

        requestDepthMap: function () {
            this._renderDepthRequests++;
        },

        releaseDepthMap: function () {
            this._renderDepthRequests--;
        }
    });

    /**
     * @private
     * @name pc.Camera#aspectRatio
     * @type {number}
     * @description Camera's aspect ratio.
     */
    Object.defineProperty(Camera.prototype, 'aspectRatio', {
        get: function () {
            return this._aspect;
        },
        set: function (v) {
            if (this._aspect !== v) {
                this._aspect = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#projection
     * @type {number}
     * @description Camera's projection type, to specify whether projection is orthographic
     * (parallel projection) or perspective. Can be:
     *
     * * {@link pc.PROJECTION_PERSPECTIVE}
     * * {@link pc.PROJECTION_ORTHOGRAPHIC}
     */
    Object.defineProperty(Camera.prototype, 'projection', {
        get: function () {
            return this._projection;
        },
        set: function (v) {
            if (this._projection !== v) {
                this._projection = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#nearClip
     * @type {number}
     * @description Camera's distance to near clipping plane.
     */
    Object.defineProperty(Camera.prototype, 'nearClip', {
        get: function () {
            return this._nearClip;
        },
        set: function (v) {
            if (this._nearClip !== v) {
                this._nearClip = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#farClip
     * @type {number}
     * @description Camera's distance to far clipping plane.
     */
    Object.defineProperty(Camera.prototype, 'farClip', {
        get: function () {
            return this._farClip;
        },
        set: function (v) {
            if (this._farClip !== v) {
                this._farClip = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#fov
     * @type {number}
     * @description Camera's field of view in degrees. This angle is in degrees
     * and is measured vertically or horizontally between the sides of camera planes.
     * hirozontalFov property defines the fov axis - vertical or horizontal.
     */
    Object.defineProperty(Camera.prototype, 'fov', {
        get: function () {
            return this._fov;
        },
        set: function (v) {
            if (this._fov !== v) {
                this._fov = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#horizontalFov
     * @type {boolean}
     * @description Camera's horizontal or vertical field of view.
     */
    Object.defineProperty(Camera.prototype, 'horizontalFov', {
        get: function () {
            return this._horizontalFov;
        },
        set: function (v) {
            if (this._horizontalFov !== v) {
                this._horizontalFov = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#orthoHeight
     * @type {number}
     * @description Camera's half height of the orthographics view.
     */
    Object.defineProperty(Camera.prototype, 'orthoHeight', {
        get: function () {
            return this._orthoHeight;
        },
        set: function (v) {
            if (this._orthoHeight !== v) {
                this._orthoHeight = v;
                this._projMatDirty = true;
            }
        }
    });

    /**
     * @private
     * @name pc.Camera#clearColor
     * @type {number[]}
     * @description Camera's clear color.
     */
    Object.defineProperty(Camera.prototype, 'clearColor', {
        get: function () {
            return this._clearOptions.color;
        },
        set: function (v) {
            this._clearOptions.color[0] = v[0];
            this._clearOptions.color[1] = v[1];
            this._clearOptions.color[2] = v[2];
            this._clearOptions.color[3] = v[3];
        }
    });

    /**
     * @private
     * @name pc.Camera#clearDepth
     * @type {number}
     * @description Camera's clear depth value.
     */
    Object.defineProperty(Camera.prototype, 'clearDepth', {
        get: function () {
            return this._clearOptions.depth;
        },
        set: function (v) {
            this._clearOptions.depth = v;
        }
    });

    /**
     * @private
     * @name pc.Camera#clearStencil
     * @type {number}
     * @description Camera's clear stencil value.
     */
    Object.defineProperty(Camera.prototype, 'clearStencil', {
        get: function () {
            return this._clearOptions.stencil;
        },
        set: function (v) {
            this._clearOptions.stencil = v;
        }
    });

    /**
     * @private
     * @name pc.Camera#clearFlags
     * @type {number}
     * @description Camera's clear flags bits value.
     */
    Object.defineProperty(Camera.prototype, 'clearFlags', {
        get: function () {
            return this._clearOptions.flags;
        },
        set: function (v) {
            this._clearOptions.flags = v;
        }
    });

    var scaleCompensatePosTransform = new Mat4();
    var scaleCompensatePos = new Vec3();
    var scaleCompensateRot = new Quat();
    var scaleCompensateRot2 = new Quat();
    var scaleCompensateScale = new Vec3();
    var scaleCompensateScaleForParent = new Vec3();
    var tmpMat4$1 = new Mat4();
    var tmpQuat = new Quat();

    /**
     * @class
     * @name pc.GraphNode
     * @augments pc.EventHandler
     * @classdesc A hierarchical scene node.
     * @param {string} [name] - The non-unique name of the graph node, default is "Untitled".
     * @property {string} name The non-unique name of a graph node.
     * @property {pc.Tags} tags Interface for tagging graph nodes. Tag based searches can be performed using the {@link pc.GraphNode#findByTag} function.
     */
    function GraphNode(name) {
        EventHandler.call(this);

        this.name = typeof name === "string" ? name : "Untitled"; // Non-unique human readable name
        this.tags = new Tags(this);

        this._labels = {};

        // Local-space properties of transform (only first 3 are settable by the user)
        this.localPosition = new Vec3(0, 0, 0);
        this.localRotation = new Quat(0, 0, 0, 1);
        this.localScale = new Vec3(1, 1, 1);
        this.localEulerAngles = new Vec3(0, 0, 0); // Only calculated on request

        // World-space properties of transform
        this.position = new Vec3(0, 0, 0);
        this.rotation = new Quat(0, 0, 0, 1);
        this.eulerAngles = new Vec3(0, 0, 0);
        this._scale = null;

        this.localTransform = new Mat4();
        this._dirtyLocal = false;
        this._aabbVer = 0;

        // _frozen flag marks the node to ignore hierarchy sync etirely (including children nodes)
        // engine code automatically freezes and unfreezes objects whenever required
        // segrigating dynamic and stationary nodes into subhierarchies allows to reduce sync time significantly
        this._frozen = false;

        this.worldTransform = new Mat4();
        this._dirtyWorld = false;

        this.normalMatrix = new Mat3();
        this._dirtyNormal = true;

        this._right = null;
        this._up = null;
        this._forward = null;

        this._parent = null;
        this._children = [];
        this._graphDepth = 0;

        this._enabled = true;
        this._enabledInHierarchy = false;

        this.scaleCompensation = false;
    }
    GraphNode.prototype = Object.create(EventHandler.prototype);
    GraphNode.prototype.constructor = GraphNode;

    /**
     * @readonly
     * @name pc.GraphNode#right
     * @type {pc.Vec3}
     * @description The normalized local space X-axis vector of the graph node in world space.
     */
    Object.defineProperty(GraphNode.prototype, 'right', {
        get: function () {
            if (!this._right) {
                this._right = new Vec3();
            }
            return this.getWorldTransform().getX(this._right).normalize();
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#up
     * @type {pc.Vec3}
     * @description The normalized local space Y-axis vector of the graph node in world space.
     */
    Object.defineProperty(GraphNode.prototype, 'up', {
        get: function () {
            if (!this._up) {
                this._up = new Vec3();
            }
            return this.getWorldTransform().getY(this._up).normalize();
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#forward
     * @type {pc.Vec3}
     * @description The normalized local space negative Z-axis vector of the graph node in world space.
     */
    Object.defineProperty(GraphNode.prototype, 'forward', {
        get: function () {
            if (!this._forward) {
                this._forward = new Vec3();
            }
            return this.getWorldTransform().getZ(this._forward).normalize().scale(-1);
        }
    });

    /**
     * @name pc.GraphNode#enabled
     * @type {boolean}
     * @description Enable or disable a GraphNode. If one of the GraphNode's parents is disabled
     * there will be no other side effects. If all the parents are enabled then
     * the new value will activate / deactivate all the enabled children of the GraphNode.
     */
    Object.defineProperty(GraphNode.prototype, 'enabled', {
        get: function () {
            // make sure to check this._enabled too because if that
            // was false when a parent was updated the _enabledInHierarchy
            // flag may not have been updated for optimization purposes
            return this._enabled && this._enabledInHierarchy;
        },

        set: function (enabled) {
            if (this._enabled !== enabled) {
                this._enabled = enabled;

                if (!this._parent || this._parent.enabled)
                    this._notifyHierarchyStateChanged(this, enabled);
            }
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#parent
     * @type {pc.GraphNode}
     * @description A read-only property to get a parent graph node.
     */
    Object.defineProperty(GraphNode.prototype, 'parent', {
        get: function () {
            return this._parent;
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#path
     * @type {string}
     * @description A read-only property to get the path of the graph node relative to
     * the root of the hierarchy.
     */
    Object.defineProperty(GraphNode.prototype, 'path', {
        get: function () {
            var parent = this._parent;
            if (parent) {
                var path = this.name;

                while (parent && parent._parent) {
                    path = parent.name + "/" + path;
                    parent = parent._parent;
                }

                return path;
            }
            return '';
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#root
     * @type {pc.GraphNode}
     * @description A read-only property to get highest graph node from current node.
     */
    Object.defineProperty(GraphNode.prototype, 'root', {
        get: function () {
            var parent = this._parent;
            if (!parent)
                return this;

            while (parent._parent)
                parent = parent._parent;

            return parent;
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#children
     * @type {pc.GraphNode[]}
     * @description A read-only property to get the children of this graph node.
     */
    Object.defineProperty(GraphNode.prototype, 'children', {
        get: function () {
            return this._children;
        }
    });

    /**
     * @readonly
     * @name pc.GraphNode#graphDepth
     * @type {number}
     * @description A read-only property to get the depth of this child within the graph. Note that for performance reasons this is only recalculated when a node is added to a new parent, i.e. It is not recalculated when a node is simply removed from the graph.
     */
    Object.defineProperty(GraphNode.prototype, 'graphDepth', {
        get: function () {
            return this._graphDepth;
        }
    });

    Object.assign(GraphNode.prototype, {
        _notifyHierarchyStateChanged: function (node, enabled) {
            node._onHierarchyStateChanged(enabled);

            var c = node._children;
            for (var i = 0, len = c.length; i < len; i++) {
                if (c[i]._enabled)
                    this._notifyHierarchyStateChanged(c[i], enabled);
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphNode#_onHierarchyStateChanged
         * @description Called when the enabled flag of the entity or one of its parents changes.
         * @param {boolean} enabled - True if enabled in the hierarchy, false if disabled.
         */
        _onHierarchyStateChanged: function (enabled) {
            // Override in derived classes
            this._enabledInHierarchy = enabled;
            if (enabled && !this._frozen)
                this._unfreezeParentToRoot();
        },

        _cloneInternal: function (clone) {
            clone.name = this.name;

            var tags = this.tags._list;
            for (var i = 0; i < tags.length; i++)
                clone.tags.add(tags[i]);

            clone._labels = Object.assign({}, this._labels);

            clone.localPosition.copy(this.localPosition);
            clone.localRotation.copy(this.localRotation);
            clone.localScale.copy(this.localScale);
            clone.localEulerAngles.copy(this.localEulerAngles);

            clone.position.copy(this.position);
            clone.rotation.copy(this.rotation);
            clone.eulerAngles.copy(this.eulerAngles);

            clone.localTransform.copy(this.localTransform);
            clone._dirtyLocal = this._dirtyLocal;

            clone.worldTransform.copy(this.worldTransform);
            clone._dirtyWorld = this._dirtyWorld;
            clone._dirtyNormal = this._dirtyNormal;
            clone._aabbVer = this._aabbVer + 1;

            clone._enabled = this._enabled;

            clone.scaleCompensation = this.scaleCompensation;

            // false as this node is not in the hierarchy yet
            clone._enabledInHierarchy = false;
        },

        clone: function () {
            var clone = new GraphNode();
            this._cloneInternal(clone);
            return clone;
        },

        /**
         * @function
         * @name pc.GraphNode#find
         * @description Search the graph node and all of its descendants for the nodes that satisfy some search criteria.
         * @param {pc.callbacks.FindNode|string} attr - This can either be a function or a string. If it's a function, it is executed
         * for each descendant node to test if node satisfies the search logic. Returning true from the function will
         * include the node into the results. If it's a string then it represents the name of a field or a method of the
         * node. If this is the name of a field then the value passed as the second argument will be checked for equality.
         * If this is the name of a function then the return value of the function will be checked for equality against
         * the valued passed as the second argument to this function.
         * @param {object} [value] - If the first argument (attr) is a property name then this value will be checked against
         * the value of the property.
         * @returns {pc.GraphNode[]} The array of graph nodes that match the search criteria.
         * @example
         * // Finds all nodes that have a model component and have `door` in their lower-cased name
         * var doors = house.find(function (node) {
         *     return node.model && node.name.toLowerCase().indexOf('door') !== -1;
         * });
         * @example
         * // Finds all nodes that have the name property set to 'Test'
         * var entities = parent.find('name', 'Test');
         */
        find: function (attr, value) {
            var result, results = [];
            var len = this._children.length;
            var i, descendants;

            if (attr instanceof Function) {
                var fn = attr;

                result = fn(this);
                if (result)
                    results.push(this);

                for (i = 0; i < len; i++) {
                    descendants = this._children[i].find(fn);
                    if (descendants.length)
                        results = results.concat(descendants);
                }
            } else {
                var testValue;

                if (this[attr]) {
                    if (this[attr] instanceof Function) {
                        testValue = this[attr]();
                    } else {
                        testValue = this[attr];
                    }
                    if (testValue === value)
                        results.push(this);
                }

                for (i = 0; i < len; ++i) {
                    descendants = this._children[i].find(attr, value);
                    if (descendants.length)
                        results = results.concat(descendants);
                }
            }

            return results;
        },

        /**
         * @function
         * @name pc.GraphNode#findOne
         * @description Search the graph node and all of its descendants for the first node that satisfies some search criteria.
         * @param {pc.callbacks.FindNode|string} attr - This can either be a function or a string. If it's a function, it is executed
         * for each descendant node to test if node satisfies the search logic. Returning true from the function will
         * result in that node being returned from findOne. If it's a string then it represents the name of a field or a method of the
         * node. If this is the name of a field then the value passed as the second argument will be checked for equality.
         * If this is the name of a function then the return value of the function will be checked for equality against
         * the valued passed as the second argument to this function.
         * @param {object} [value] - If the first argument (attr) is a property name then this value will be checked against
         * the value of the property.
         * @returns {pc.GraphNode} A graph node that match the search criteria.
         * @example
         * // Find the first node that is called `head` and has a model component
         * var head = player.findOne(function (node) {
         *     return node.model && node.name === 'head';
         * });
         * @example
         * // Finds the first node that has the name property set to 'Test'
         * var node = parent.findOne('name', 'Test');
         */
        findOne: function (attr, value) {
            var i;
            var len = this._children.length;
            var result = null;

            if (attr instanceof Function) {
                var fn = attr;

                result = fn(this);
                if (result)
                    return this;

                for (i = 0; i < len; i++) {
                    result = this._children[i].findOne(fn);
                    if (result)
                        return result;
                }
            } else {
                var testValue;
                if (this[attr]) {
                    if (this[attr] instanceof Function) {
                        testValue = this[attr]();
                    } else {
                        testValue = this[attr];
                    }
                    if (testValue === value) {
                        return this;
                    }
                }

                for (i = 0; i < len; i++) {
                    result = this._children[i].findOne(attr, value);
                    if (result !== null)
                        return result;
                }
            }

            return null;
        },

        /**
         * @function
         * @name pc.GraphNode#findByTag
         * @description Return all graph nodes that satisfy the search query.
         * Query can be simply a string, or comma separated strings,
         * to have inclusive results of assets that match at least one query.
         * A query that consists of an array of tags can be used to match graph nodes that have each tag of array.
         * @param {string|string[]} query - Name of a tag or array of tags.
         * @returns {pc.GraphNode[]} A list of all graph nodes that match the query.
         * @example
         * // Return all graph nodes that tagged by `animal`
         * var animals = node.findByTag("animal");
         * @example
         * // Return all graph nodes that tagged by `bird` OR `mammal`
         * var birdsAndMammals = node.findByTag("bird", "mammal");
         * @example
         * // Return all assets that tagged by `carnivore` AND `mammal`
         * var meatEatingMammals = node.findByTag(["carnivore", "mammal"]);
         * @example
         * // Return all assets that tagged by (`carnivore` AND `mammal`) OR (`carnivore` AND `reptile`)
         * var meatEatingMammalsAndReptiles = node.findByTag(["carnivore", "mammal"], ["carnivore", "reptile"]);
         */
        findByTag: function () {
            var tags = this.tags._processArguments(arguments);
            return this._findByTag(tags);
        },

        _findByTag: function (tags) {
            var result = [];
            var i, len = this._children.length;
            var descendants;

            for (i = 0; i < len; i++) {
                if (this._children[i].tags._has(tags))
                    result.push(this._children[i]);

                descendants = this._children[i]._findByTag(tags);
                if (descendants.length)
                    result = result.concat(descendants);
            }

            return result;
        },

        /**
         * @function
         * @name pc.GraphNode#findByName
         * @description Get the first node found in the graph with the name. The search
         * is depth first.
         * @param {string} name - The name of the graph.
         * @returns {pc.GraphNode} The first node to be found matching the supplied name.
         */
        findByName: function (name) {
            if (this.name === name) return this;

            for (var i = 0; i < this._children.length; i++) {
                var found = this._children[i].findByName(name);
                if (found !== null) return found;
            }
            return null;
        },

        /**
         * @function
         * @name pc.GraphNode#findByPath
         * @description Get the first node found in the graph by its full path in the graph.
         * The full path has this form 'parent/child/sub-child'. The search is depth first.
         * @param {string} path - The full path of the pc.GraphNode.
         * @returns {pc.GraphNode} The first node to be found matching the supplied path.
         * @example
         * var path = this.entity.findByPath('child/another_child');
         */
        findByPath: function (path) {
            // split the paths in parts. Each part represents a deeper hierarchy level
            var parts = path.split('/');
            var currentParent = this;
            var result = null;

            for (var i = 0, imax = parts.length; i < imax && currentParent; i++) {
                var part = parts[i];

                result = null;

                // check all the children
                var children = currentParent._children;
                for (var j = 0, jmax = children.length; j < jmax; j++) {
                    if (children[j].name == part) {
                        result = children[j];
                        break;
                    }
                }

                // keep going deeper in the hierarchy
                currentParent = result;
            }

            return result;
        },

        /**
         * @function
         * @name pc.GraphNode#forEach
         * @description Executes a provided function once on this graph node and all of its descendants.
         * @param {pc.callbacks.ForEach} callback - The function to execute on the graph node and each descendant.
         * @param {object} [thisArg] - Optional value to use as this when executing callback function.
         * @example
         * // Log the path and name of each node in descendant tree starting with "parent"
         * parent.forEach(function (node) {
         *     console.log(node.path + "/" + node.name);
         * });
         */
        forEach: function (callback, thisArg) {
            callback.call(thisArg, this);

            var children = this._children;
            for (var i = 0; i < children.length; i++) {
                children[i].forEach(callback, thisArg);
            }
        },

        /**
         * @function
         * @name pc.GraphNode#isDescendantOf
         * @description Check if node is descendant of another node.
         * @param {pc.GraphNode} node - Potential ancestor of node.
         * @returns {boolean} If node is descendant of another node.
         * @example
         * if (roof.isDescendantOf(house)) {
         *     // roof is descendant of house entity
         * }
         */
        isDescendantOf: function (node) {
            var parent = this._parent;
            while (parent) {
                if (parent === node)
                    return true;

                parent = parent._parent;
            }
            return false;
        },

        /**
         * @function
         * @name pc.GraphNode#isAncestorOf
         * @description Check if node is ancestor for another node.
         * @param {pc.GraphNode} node - Potential descendant of node.
         * @returns {boolean} If node is ancestor for another node.
         * @example
         * if (body.isAncestorOf(foot)) {
         *     // foot is within body's hierarchy
         * }
         */
        isAncestorOf: function (node) {
            return node.isDescendantOf(this);
        },

        /**
         * @function
         * @name pc.GraphNode#getEulerAngles
         * @description Get the world space rotation for the specified GraphNode in Euler angle
         * form. The order of the returned Euler angles is XYZ. The value returned by this function
         * should be considered read-only. In order to set the world-space rotation of the graph
         * node, use {@link pc.GraphNode#setEulerAngles}.
         * @returns {pc.Vec3} The world space rotation of the graph node in Euler angle form.
         * @example
         * var angles = this.entity.getEulerAngles(); // [0,0,0]
         * angles[1] = 180; // rotate the entity around Y by 180 degrees
         * this.entity.setEulerAngles(angles);
         */
        getEulerAngles: function () {
            this.getWorldTransform().getEulerAngles(this.eulerAngles);
            return this.eulerAngles;
        },

        /**
         * @function
         * @name pc.GraphNode#getLocalEulerAngles
         * @description Get the rotation in local space for the specified GraphNode. The rotation
         * is returned as euler angles in a 3-dimensional vector where the order is XYZ. The
         * returned vector should be considered read-only. To update the local rotation, use
         * {@link pc.GraphNode#setLocalEulerAngles}.
         * @returns {pc.Vec3} The local space rotation of the graph node as euler angles in XYZ order.
         * @example
         * var angles = this.entity.getLocalEulerAngles();
         * angles[1] = 180;
         * this.entity.setLocalEulerAngles(angles);
         */
        getLocalEulerAngles: function () {
            this.localRotation.getEulerAngles(this.localEulerAngles);
            return this.localEulerAngles;
        },

        /**
         * @function
         * @name pc.GraphNode#getLocalPosition
         * @description Get the position in local space for the specified GraphNode. The position
         * is returned as a 3-dimensional vector. The returned vector should be considered read-only.
         * To update the local position, use {@link pc.GraphNode#setLocalPosition}.
         * @returns {pc.Vec3} The local space position of the graph node.
         * @example
         * var position = this.entity.getLocalPosition();
         * position[0] += 1; // move the entity 1 unit along x.
         * this.entity.setLocalPosition(position);
         */
        getLocalPosition: function () {
            return this.localPosition;
        },

        /**
         * @function
         * @name pc.GraphNode#getLocalRotation
         * @description Get the rotation in local space for the specified GraphNode. The rotation
         * is returned as a quaternion. The returned quaternion should be considered read-only.
         * To update the local rotation, use {@link pc.GraphNode#setLocalRotation}.
         * @returns {pc.Quat} The local space rotation of the graph node as a quaternion.
         * @example
         * var rotation = this.entity.getLocalRotation();
         */
        getLocalRotation: function () {
            return this.localRotation;
        },

        /**
         * @function
         * @name pc.GraphNode#getLocalScale
         * @description Get the scale in local space for the specified GraphNode. The scale
         * is returned as a 3-dimensional vector. The returned vector should be considered read-only.
         * To update the local scale, use {@link pc.GraphNode#setLocalScale}.
         * @returns {pc.Vec3} The local space scale of the graph node.
         * @example
         * var scale = this.entity.getLocalScale();
         * scale.x = 100;
         * this.entity.setLocalScale(scale);
         */
        getLocalScale: function () {
            return this.localScale;
        },

        /**
         * @function
         * @name pc.GraphNode#getLocalTransform
         * @description Get the local transform matrix for this graph node. This matrix
         * is the transform relative to the node's parent's world transformation matrix.
         * @returns {pc.Mat4} The node's local transformation matrix.
         * @example
         * var transform = this.entity.getLocalTransform();
         */
        getLocalTransform: function () {
            if (this._dirtyLocal) {
                this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
                this._dirtyLocal = false;
            }
            return this.localTransform;
        },

        /**
         * @function
         * @name pc.GraphNode#getPosition
         * @description Get the world space position for the specified GraphNode. The
         * value returned by this function should be considered read-only. In order to set
         * the world-space position of the graph node, use {@link pc.GraphNode#setPosition}.
         * @returns {pc.Vec3} The world space position of the graph node.
         * @example
         * var position = this.entity.getPosition();
         * position.x = 10;
         * this.entity.setPosition(position);
         */
        getPosition: function () {
            this.getWorldTransform().getTranslation(this.position);
            return this.position;
        },

        /**
         * @function
         * @name pc.GraphNode#getRotation
         * @description Get the world space rotation for the specified GraphNode in quaternion
         * form. The value returned by this function should be considered read-only. In order
         * to set the world-space rotation of the graph node, use {@link pc.GraphNode#setRotation}.
         * @returns {pc.Quat} The world space rotation of the graph node as a quaternion.
         * @example
         * var rotation = this.entity.getRotation();
         */
        getRotation: function () {
            this.rotation.setFromMat4(this.getWorldTransform());
            return this.rotation;
        },

        /**
         * @private
         * @function
         * @name pc.GraphNode#getScale
         * @description Get the world space scale for the specified GraphNode. The returned value
         * will only be correct for graph nodes that have a non-skewed world transform (a skew can
         * be introduced by the compounding of rotations and scales higher in the graph node
         * hierarchy). The value returned by this function should be considered read-only. Note
         * that it is not possible to set the world space scale of a graph node directly.
         * @returns {pc.Vec3} The world space scale of the graph node.
         * @example
         * var scale = this.entity.getScale();
         */
        getScale: function () {
            if (!this._scale) {
                this._scale = new Vec3();
            }
            return this.getWorldTransform().getScale(this._scale);
        },

        /**
         * @function
         * @name pc.GraphNode#getWorldTransform
         * @description Get the world transformation matrix for this graph node.
         * @returns {pc.Mat4} The node's world transformation matrix.
         * @example
         * var transform = this.entity.getWorldTransform();
         */
        getWorldTransform: function () {
            if (!this._dirtyLocal && !this._dirtyWorld)
                return this.worldTransform;

            if (this._parent)
                this._parent.getWorldTransform();

            this._sync();

            return this.worldTransform;
        },

        /**
         * @function
         * @name pc.GraphNode#reparent
         * @description Remove graph node from current parent and add as child to new parent.
         * @param {pc.GraphNode} parent - New parent to attach graph node to.
         * @param {number} [index] - The child index where the child node should be placed.
         */
        reparent: function (parent, index) {
            var current = this._parent;

            if (current)
                current.removeChild(this);

            if (parent) {
                if (index >= 0) {
                    parent.insertChild(this, index);
                } else {
                    parent.addChild(this);
                }
            }
        },

        /**
         * @function
         * @name pc.GraphNode#setLocalEulerAngles
         * @description Sets the local-space rotation of the specified graph node using euler angles.
         * Eulers are interpreted in XYZ order. Eulers must be specified in degrees. This function
         * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
         * local-space euler rotation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding eulers or rotation around local-space
         * x-axis in degrees.
         * @param {number} [y] - Rotation around local-space y-axis in degrees.
         * @param {number} [z] - Rotation around local-space z-axis in degrees.
         * @example
         * // Set rotation of 90 degrees around y-axis via 3 numbers
         * this.entity.setLocalEulerAngles(0, 90, 0);
         * @example
         * // Set rotation of 90 degrees around y-axis via a vector
         * var angles = new pc.Vec3(0, 90, 0);
         * this.entity.setLocalEulerAngles(angles);
         */
        setLocalEulerAngles: function (x, y, z) {
            if (x instanceof Vec3) {
                this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
            } else {
                this.localRotation.setFromEulerAngles(x, y, z);
            }

            if (!this._dirtyLocal)
                this._dirtifyLocal();
        },

        /**
         * @function
         * @name pc.GraphNode#setLocalPosition
         * @description Sets the local-space position of the specified graph node. This function
         * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
         * local-space position.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding local-space position or
         * x-coordinate of local-space position.
         * @param {number} [y] - Y-coordinate of local-space position.
         * @param {number} [z] - Z-coordinate of local-space position.
         * @example
         * // Set via 3 numbers
         * this.entity.setLocalPosition(0, 10, 0);
         * @example
         * // Set via vector
         * var pos = new pc.Vec3(0, 10, 0);
         * this.entity.setLocalPosition(pos);
         */
        setLocalPosition: function (x, y, z) {
            if (x instanceof Vec3) {
                this.localPosition.copy(x);
            } else {
                this.localPosition.set(x, y, z);
            }

            if (!this._dirtyLocal)
                this._dirtifyLocal();
        },

        /**
         * @function
         * @name pc.GraphNode#setLocalRotation
         * @description Sets the local-space rotation of the specified graph node. This function
         * has two valid signatures: you can either pass a quaternion or 3 numbers to specify the
         * local-space rotation.
         * @param {pc.Quat|number} x - Quaternion holding local-space rotation or x-component of
         * local-space quaternion rotation.
         * @param {number} [y] - Y-component of local-space quaternion rotation.
         * @param {number} [z] - Z-component of local-space quaternion rotation.
         * @param {number} [w] - W-component of local-space quaternion rotation.
         * @example
         * // Set via 4 numbers
         * this.entity.setLocalRotation(0, 0, 0, 1);
         * @example
         * // Set via quaternion
         * var q = pc.Quat();
         * this.entity.setLocalRotation(q);
         */
        setLocalRotation: function (x, y, z, w) {
            if (x instanceof Quat) {
                this.localRotation.copy(x);
            } else {
                this.localRotation.set(x, y, z, w);
            }

            if (!this._dirtyLocal)
                this._dirtifyLocal();
        },

        /**
         * @function
         * @name pc.GraphNode#setLocalScale
         * @description Sets the local-space scale factor of the specified graph node. This function
         * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
         * local-space scale.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding local-space scale or x-coordinate
         * of local-space scale.
         * @param {number} [y] - Y-coordinate of local-space scale.
         * @param {number} [z] - Z-coordinate of local-space scale.
         * @example
         * // Set via 3 numbers
         * this.entity.setLocalScale(10, 10, 10);
         * @example
         * // Set via vector
         * var scale = new pc.Vec3(10, 10, 10);
         * this.entity.setLocalScale(scale);
         */
        setLocalScale: function (x, y, z) {
            if (x instanceof Vec3) {
                this.localScale.copy(x);
            } else {
                this.localScale.set(x, y, z);
            }

            if (!this._dirtyLocal)
                this._dirtifyLocal();
        },

        _dirtifyLocal: function () {
            if (!this._dirtyLocal) {
                this._dirtyLocal = true;
                if (!this._dirtyWorld)
                    this._dirtifyWorld();
            }
        },

        _unfreezeParentToRoot: function () {
            var p = this._parent;
            while (p) {
                p._frozen = false;
                p = p._parent;
            }
        },

        _dirtifyWorld: function () {
            if (!this._dirtyWorld)
                this._unfreezeParentToRoot();
            this._dirtifyWorldInternal();
        },

        _dirtifyWorldInternal: function () {
            if (!this._dirtyWorld) {
                this._frozen = false;
                this._dirtyWorld = true;
                for (var i = 0; i < this._children.length; i++) {
                    if (!this._children[i]._dirtyWorld)
                        this._children[i]._dirtifyWorldInternal();
                }
            }
            this._dirtyNormal = true;
            this._aabbVer++;
        },

        /**
         * @function
         * @name pc.GraphNode#setPosition
         * @description Sets the world-space position of the specified graph node. This function
         * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
         * world-space position.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding world-space position or
         * x-coordinate of world-space position.
         * @param {number} [y] - Y-coordinate of world-space position.
         * @param {number} [z] - Z-coordinate of world-space position.
         * @example
         * // Set via 3 numbers
         * this.entity.setPosition(0, 10, 0);
         * @example
         * // Set via vector
         * var position = new pc.Vec3(0, 10, 0);
         * this.entity.setPosition(position);
         */
        setPosition: function () {
            var position = new Vec3();
            var invParentWtm = new Mat4();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    position.copy(x);
                } else {
                    position.set(x, y, z);
                }

                if (this._parent === null) {
                    this.localPosition.copy(position);
                } else {
                    invParentWtm.copy(this._parent.getWorldTransform()).invert();
                    invParentWtm.transformPoint(position, this.localPosition);
                }

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#setRotation
         * @description Sets the world-space rotation of the specified graph node. This function
         * has two valid signatures: you can either pass a quaternion or 3 numbers to specify the
         * world-space rotation.
         * @param {pc.Quat|number} x - Quaternion holding world-space rotation or x-component of
         * world-space quaternion rotation.
         * @param {number} [y] - Y-component of world-space quaternion rotation.
         * @param {number} [z] - Z-component of world-space quaternion rotation.
         * @param {number} [w] - W-component of world-space quaternion rotation.
         * @example
         * // Set via 4 numbers
         * this.entity.setRotation(0, 0, 0, 1);
         * @example
         * // Set via quaternion
         * var q = pc.Quat();
         * this.entity.setRotation(q);
         */
        setRotation: function () {
            var rotation = new Quat();
            var invParentRot = new Quat();

            return function (x, y, z, w) {
                if (x instanceof Quat) {
                    rotation.copy(x);
                } else {
                    rotation.set(x, y, z, w);
                }

                if (this._parent === null) {
                    this.localRotation.copy(rotation);
                } else {
                    var parentRot = this._parent.getRotation();
                    invParentRot.copy(parentRot).invert();
                    this.localRotation.copy(invParentRot).mul(rotation);
                }

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#setEulerAngles
         * @description Sets the world-space rotation of the specified graph node using euler angles.
         * Eulers are interpreted in XYZ order. Eulers must be specified in degrees. This function
         * has two valid signatures: you can either pass a 3D vector or 3 numbers to specify the
         * world-space euler rotation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding eulers or rotation around world-space
         * x-axis in degrees.
         * @param {number} [y] - Rotation around world-space y-axis in degrees.
         * @param {number} [z] - Rotation around world-space z-axis in degrees.
         * @example
         * // Set rotation of 90 degrees around world-space y-axis via 3 numbers
         * this.entity.setEulerAngles(0, 90, 0);
         * @example
         * // Set rotation of 90 degrees around world-space y-axis via a vector
         * var angles = new pc.Vec3(0, 90, 0);
         * this.entity.setEulerAngles(angles);
         */
        setEulerAngles: function () {
            var invParentRot = new Quat();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    this.localRotation.setFromEulerAngles(x.x, x.y, x.z);
                } else {
                    this.localRotation.setFromEulerAngles(x, y, z);
                }

                if (this._parent !== null) {
                    var parentRot = this._parent.getRotation();
                    invParentRot.copy(parentRot).invert();
                    this.localRotation.mul2(invParentRot, this.localRotation);
                }

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#addChild
         * @description Add a new child to the child list and update the parent value of the child node.
         * @param {pc.GraphNode} node - The new child to add.
         * @example
         * var e = new pc.Entity(app);
         * this.entity.addChild(e);
         */
        addChild: function (node) {
            if (node._parent !== null)
                throw new Error("GraphNode is already parented");


            this._children.push(node);
            this._onInsertChild(node);
        },

        addChildAndSaveTransform: function (node) {

            var wPos = node.getPosition();
            var wRot = node.getRotation();

            var current = node._parent;
            if (current)
                current.removeChild(node);

            node.setPosition(tmpMat4$1.copy(this.worldTransform).invert().transformPoint(wPos));
            node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));

            this._children.push(node);
            this._onInsertChild(node);
        },

        /**
         * @function
         * @name pc.GraphNode#insertChild
         * @description Insert a new child to the child list at the specified index and update the parent value of the child node.
         * @param {pc.GraphNode} node - The new child to insert.
         * @param {number} index - The index in the child list of the parent where the new node will be inserted.
         * @example
         * var e = new pc.Entity(app);
         * this.entity.insertChild(e, 1);
         */
        insertChild: function (node, index) {
            if (node._parent !== null)
                throw new Error("GraphNode is already parented");


            this._children.splice(index, 0, node);
            this._onInsertChild(node);
        },


        _onInsertChild: function (node) {
            node._parent = this;

            // the child node should be enabled in the hierarchy only if itself is enabled and if
            // this parent is enabled
            var enabledInHierarchy = (node._enabled && this.enabled);
            if (node._enabledInHierarchy !== enabledInHierarchy) {
                node._enabledInHierarchy = enabledInHierarchy;

                // propagate the change to the children - necessary if we reparent a node
                // under a parent with a different enabled state (if we reparent a node that is
                // not active in the hierarchy under a parent who is active in the hierarchy then
                // we want our node to be activated)
                node._notifyHierarchyStateChanged(node, enabledInHierarchy);
            }

            // The graph depth of the child and all of its descendants will now change
            node._updateGraphDepth();

            // The child (plus subhierarchy) will need world transforms to be recalculated
            node._dirtifyWorld();
            // node might be already marked as dirty, in that case the whole chain stays frozen, so let's enforce unfreeze
            if (this._frozen)
                node._unfreezeParentToRoot();

            // alert an entity that it has been inserted
            if (node.fire) node.fire('insert', this);

            // alert the parent that it has had a child inserted
            if (this.fire) this.fire('childinsert', node);
        },

        _updateGraphDepth: function () {
            if (this._parent) {
                this._graphDepth = this._parent._graphDepth + 1;
            } else {
                this._graphDepth = 0;
            }

            for (var i = 0, len = this._children.length; i < len; i++) {
                this._children[i]._updateGraphDepth();
            }
        },

        /**
         * @function
         * @name pc.GraphNode#removeChild
         * @description Remove the node from the child list and update the parent value of the child.
         * @param {pc.GraphNode} child - The node to remove.
         * @example
         * var child = this.entity.children[0];
         * this.entity.removeChild(child);
         */
        removeChild: function (child) {
            var i;
            var length = this._children.length;

            // Remove from child list
            for (i = 0; i < length; ++i) {
                if (this._children[i] === child) {
                    this._children.splice(i, 1);

                    // Clear parent
                    child._parent = null;

                    // alert child that it has been removed
                    if (child.fire) child.fire('remove', this);

                    // alert the parent that it has had a child removed
                    if (this.fire) this.fire('childremove', child);

                    return;
                }
            }
        },

        _sync: function () {
            if (this._dirtyLocal) {
                this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);

                this._dirtyLocal = false;
            }

            if (this._dirtyWorld) {
                if (this._parent === null) {
                    this.worldTransform.copy(this.localTransform);
                } else {
                    if (this.scaleCompensation) {
                        var parentWorldScale;
                        var parent = this._parent;

                        // Find a parent of the first uncompensated node up in the hierarchy and use its scale * localScale
                        var scale = this.localScale;
                        var parentToUseScaleFrom = parent; // current parent
                        if (parentToUseScaleFrom) {
                            while (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {
                                parentToUseScaleFrom = parentToUseScaleFrom._parent;
                            }
                            // topmost node with scale compensation
                            if (parentToUseScaleFrom) {
                                parentToUseScaleFrom = parentToUseScaleFrom._parent; // node without scale compensation
                                if (parentToUseScaleFrom) {
                                    parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
                                    scaleCompensateScale.mul2(parentWorldScale, this.localScale);
                                    scale = scaleCompensateScale;
                                }
                            }
                        }

                        // Rotation is as usual
                        scaleCompensateRot2.setFromMat4(parent.worldTransform);
                        scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);

                        // Find matrix to transform position
                        var tmatrix = parent.worldTransform;
                        if (parent.scaleCompensation) {
                            scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
                            scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos),
                                                               scaleCompensateRot2,
                                                               scaleCompensateScaleForParent);
                            tmatrix = scaleCompensatePosTransform;
                        }
                        tmatrix.transformPoint(this.localPosition, scaleCompensatePos);

                        this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);

                    } else {
                        this.worldTransform.mul2(this._parent.worldTransform, this.localTransform);
                    }
                }

                this._dirtyWorld = false;
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphNode#syncHierarchy
         * @description Updates the world transformation matrices at this node and all of its descendants.
         */
        syncHierarchy: function () {
            if (!this._enabled)
                return;

            if (this._frozen)
                return;
            this._frozen = true;

            if (this._dirtyLocal || this._dirtyWorld) {
                this._sync();
            }

            var children = this._children;
            for (var i = 0, len = children.length; i < len; i++) {
                children[i].syncHierarchy();
            }
        },

        /**
         * @function
         * @name pc.GraphNode#lookAt
         * @description Reorients the graph node so that the negative z-axis points towards the target.
         * This function has two valid signatures. Either pass 3D vectors for the look at coordinate and up
         * vector, or pass numbers to represent the vectors.
         * @param {pc.Vec3|number} x - If passing a 3D vector, this is the world-space coordinate to look at.
         * Otherwise, it is the x-component of the world-space coordinate to look at.
         * @param {pc.Vec3|number} [y] - If passing a 3D vector, this is the world-space up vector for look at
         * transform. Otherwise, it is the y-component of the world-space coordinate to look at.
         * @param {number} [z] - Z-component of the world-space coordinate to look at.
         * @param {number} [ux=0] - X-component of the up vector for the look at transform.
         * @param {number} [uy=1] - Y-component of the up vector for the look at transform.
         * @param {number} [uz=0] - Z-component of the up vector for the look at transform.
         * @example
         * // Look at another entity, using the (default) positive y-axis for up
         * var position = otherEntity.getPosition();
         * this.entity.lookAt(position);
         * @example
         * // Look at another entity, using the negative world y-axis for up
         * var position = otherEntity.getPosition();
         * this.entity.lookAt(position, pc.Vec3.DOWN);
         * @example
         * // Look at the world space origin, using the (default) positive y-axis for up
         * this.entity.lookAt(0, 0, 0);
         * @example
         * // Look at world-space coordinate [10, 10, 10], using the negative world y-axis for up
         * this.entity.lookAt(10, 10, 10, 0, -1, 0);
         */
        lookAt: function () {
            var matrix = new Mat4();
            var target = new Vec3();
            var up = new Vec3();
            var rotation = new Quat();

            return function (tx, ty, tz, ux, uy, uz) {
                if (tx instanceof Vec3) {
                    target.copy(tx);

                    if (ty instanceof Vec3) { // vec3, vec3
                        up.copy(ty);
                    } else { // vec3
                        up.copy(Vec3.UP);
                    }
                } else if (tz === undefined) {
                    return;
                } else {
                    target.set(tx, ty, tz);

                    if (ux !== undefined) { // number, number, number, number, number, number
                        up.set(ux, uy, uz);
                    } else { // number, number, number
                        up.copy(Vec3.UP);
                    }
                }

                matrix.setLookAt(this.getPosition(), target, up);
                rotation.setFromMat4(matrix);
                this.setRotation(rotation);
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#translate
         * @description Translates the graph node in world-space by the specified translation vector.
         * This function has two valid signatures: you can either pass a 3D vector or 3 numbers to
         * specify the world-space translation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding world-space translation or
         * x-coordinate of world-space translation.
         * @param {number} [y] - Y-coordinate of world-space translation.
         * @param {number} [z] - Z-coordinate of world-space translation.
         * @example
         * // Translate via 3 numbers
         * this.entity.translate(10, 0, 0);
         * @example
         * // Translate via vector
         * var t = new pc.Vec3(10, 0, 0);
         * this.entity.translate(t);
         */
        translate: function () {
            var translation = new Vec3();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    translation.copy(x);
                } else {
                    translation.set(x, y, z);
                }

                translation.add(this.getPosition());
                this.setPosition(translation);
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#translateLocal
         * @description Translates the graph node in local-space by the specified translation vector.
         * This function has two valid signatures: you can either pass a 3D vector or 3 numbers to
         * specify the local-space translation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding local-space translation or
         * x-coordinate of local-space translation.
         * @param {number} [y] - Y-coordinate of local-space translation.
         * @param {number} [z] - Z-coordinate of local-space translation.
         * @example
         * // Translate via 3 numbers
         * this.entity.translateLocal(10, 0, 0);
         * @example
         * // Translate via vector
         * var t = new pc.Vec3(10, 0, 0);
         * this.entity.translateLocal(t);
         */
        translateLocal: function () {
            var translation = new Vec3();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    translation.copy(x);
                } else {
                    translation.set(x, y, z);
                }

                this.localRotation.transformVector(translation, translation);
                this.localPosition.add(translation);

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#rotate
         * @description Rotates the graph node in world-space by the specified Euler angles.
         * Eulers are specified in degrees in XYZ order. This function has two valid signatures:
         * you can either pass a 3D vector or 3 numbers to specify the world-space rotation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding world-space rotation or
         * rotation around world-space x-axis in degrees.
         * @param {number} [y] - Rotation around world-space y-axis in degrees.
         * @param {number} [z] - Rotation around world-space z-axis in degrees.
         * @example
         * // Rotate via 3 numbers
         * this.entity.rotate(0, 90, 0);
         * @example
         * // Rotate via vector
         * var r = new pc.Vec3(0, 90, 0);
         * this.entity.rotate(r);
         */
        rotate: function () {
            var quaternion = new Quat();
            var invParentRot = new Quat();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    quaternion.setFromEulerAngles(x.x, x.y, x.z);
                } else {
                    quaternion.setFromEulerAngles(x, y, z);
                }

                if (this._parent === null) {
                    this.localRotation.mul2(quaternion, this.localRotation);
                } else {
                    var rot = this.getRotation();
                    var parentRot = this._parent.getRotation();

                    invParentRot.copy(parentRot).invert();
                    quaternion.mul2(invParentRot, quaternion);
                    this.localRotation.mul2(quaternion, rot);
                }

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        /**
         * @function
         * @name pc.GraphNode#rotateLocal
         * @description Rotates the graph node in local-space by the specified Euler angles.
         * Eulers are specified in degrees in XYZ order. This function has two valid signatures:
         * you can either pass a 3D vector or 3 numbers to specify the local-space rotation.
         * @param {pc.Vec3|number} x - 3-dimensional vector holding local-space rotation or
         * rotation around local-space x-axis in degrees.
         * @param {number} [y] - Rotation around local-space y-axis in degrees.
         * @param {number} [z] - Rotation around local-space z-axis in degrees.
         * @example
         * // Rotate via 3 numbers
         * this.entity.rotateLocal(0, 90, 0);
         * @example
         * // Rotate via vector
         * var r = new pc.Vec3(0, 90, 0);
         * this.entity.rotateLocal(r);
         */
        rotateLocal: function () {
            var quaternion = new Quat();

            return function (x, y, z) {
                if (x instanceof Vec3) {
                    quaternion.setFromEulerAngles(x.x, x.y, x.z);
                } else {
                    quaternion.setFromEulerAngles(x, y, z);
                }

                this.localRotation.mul(quaternion);

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }()
    });

    var keyA, keyB, sortPos, sortDir;

    function sortManual(drawCallA, drawCallB) {
        return drawCallA.drawOrder - drawCallB.drawOrder;
    }

    function sortMaterialMesh(drawCallA, drawCallB) {
        keyA = drawCallA._key[SORTKEY_FORWARD];
        keyB = drawCallB._key[SORTKEY_FORWARD];
        if (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {
            return drawCallB.mesh.id - drawCallA.mesh.id;
        }
        return keyB - keyA;
    }

    function sortBackToFront(drawCallA, drawCallB) {
        return drawCallB.zdist - drawCallA.zdist;
    }

    function sortFrontToBack(drawCallA, drawCallB) {
        return drawCallA.zdist - drawCallB.zdist;
    }

    var sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];

    function sortCameras(camA, camB) {
        return camA.priority - camB.priority;
    }

    function sortLights(lightA, lightB) {
        return lightB.key - lightA.key;
    }

    // Layers
    var layerCounter = 0;

    function VisibleInstanceList() {
        this.list = [];
        this.length = 0;
        this.done = false;
    }

    function InstanceList() {
        this.opaqueMeshInstances = [];
        this.transparentMeshInstances = [];
        this.shadowCasters = [];

        // arrays of VisibleInstanceList for each camera
        this.visibleOpaque = [];
        this.visibleTransparent = [];
    }

    InstanceList.prototype.clearVisibleLists = function (cameraPass) {
        if (this.visibleOpaque[cameraPass]) {
            this.visibleOpaque[cameraPass].length = 0;
            this.visibleOpaque[cameraPass].list.length = 0;
        }

        if (this.visibleTransparent[cameraPass]) {
            this.visibleTransparent[cameraPass].length = 0;
            this.visibleTransparent[cameraPass].list.length = 0;
        }
    };

    /**
     * @class
     * @name pc.Layer
     * @classdesc Layer represents a renderable subset of the scene. It can contain a list of mesh instances, lights and cameras,
     * their render settings and also defines custom callbacks before, after or during rendering.
     * Layers are organized inside {@link pc.LayerComposition} in a desired order.
     * @description Create a new layer.
     * @param {object} options - Object for passing optional arguments. These arguments are the same as properties of the Layer.
     * @property {boolean} enabled Enable the layer. Disabled layers are skipped. Defaults to true.
     * @property {string} name Name of the layer. Can be used in {@link pc.LayerComposition#getLayerByName}.
     * @property {number} opaqueSortMode Defines the method used for sorting opaque (that is, not semi-transparent) mesh instances before rendering.
     * Possible values are:
     *
     * * {@link pc.SORTMODE_NONE}
     * * {@link pc.SORTMODE_MANUAL}
     * * {@link pc.SORTMODE_MATERIALMESH}
     * * {@link pc.SORTMODE_BACK2FRONT}
     * * {@link pc.SORTMODE_FRONT2BACK}
     *
     * Defaults to pc.SORTMODE_MATERIALMESH.
     * @property {number} transparentSortMode Defines the method used for sorting semi-transparent mesh instances before rendering.
     * Possible values are:
     *
     * * {@link pc.SORTMODE_NONE}
     * * {@link pc.SORTMODE_MANUAL}
     * * {@link pc.SORTMODE_MATERIALMESH}
     * * {@link pc.SORTMODE_BACK2FRONT}
     * * {@link pc.SORTMODE_FRONT2BACK}
     *
     * Defaults to pc.SORTMODE_BACK2FRONT.
     * @property {pc.RenderTarget} renderTarget Render target to which rendering is performed. If not set, will render simply to the screen.
     * @property {number} shaderPass A type of shader to use during rendering. Possible values are:
     *
     * * {@link pc.SHADER_FORWARD}
     * * {@link pc.SHADER_FORWARDHDR}
     * * {@link pc.SHADER_DEPTH}
     * * Your own custom value. Should be in 19 - 31 range. Use {@link pc.StandardMaterial#onUpdateShader} to apply shader modifications based on this value.
     *
     * Defaults to pc.SHADER_FORWARD.
     * @property {boolean} passThrough Tells that this layer is simple and needs to just render a bunch of mesh instances without lighting, skinning and morphing (faster).
     *
     * @property {boolean} overrideClear Defines if layer should use camera clear parameters (true) or ignore them and use {@link pc.Layer#clearColor}, {@link pc.Layer#clearColorBuffer},
     * {@link pc.Layer#clearDepthBuffer} and {@link pc.Layer#clearStencilBuffer}.
     * @property {pc.Color} clearColor The color used to clear the canvas to before each camera starts to render.
     * @property {boolean} clearColorBuffer If true cameras will clear the color buffer to the color set in clearColor.
     * @property {boolean} clearDepthBuffer If true cameras will clear the depth buffer.
     * @property {boolean} clearStencilBuffer If true cameras will clear the stencil buffer.
     *
     * @property {pc.Layer} layerReference Make this layer render the same mesh instances that another layer does instead of having its own mesh instance list.
     * Both layers must share cameras. Frustum culling is only performed for one layer.
     * @property {Function} cullingMask Visibility mask that interacts with {@link pc.MeshInstance#mask}.
     * @property {Function} onEnable Custom function that is called after the layer has been enabled.
     * This happens when:
     *
     * * The layer is created with {@link pc.Layer#enabled} set to true (which is the default value).
     * * {@link pc.Layer#enabled} was changed from false to true
     * * {@link pc.Layer#incrementCounter} was called and incremented the counter above zero.
     *
     * Useful for allocating resources this layer will use (e.g. creating render targets).
     * @property {Function} onDisable Custom function that is called after the layer has been disabled.
     * This happens when:
     *
     * * {@link pc.Layer#enabled} was changed from true to false
     * * {@link pc.Layer#decrementCounter} was called and set the counter to zero.
     *
     * @property {Function} onPreCull Custom function that is called before visibility culling is performed for this layer.
     * Useful, for example, if you want to modify camera projection while still using the same camera and make frustum culling work correctly with it
     * (see {@link pc.CameraComponent#calculateTransform} and {@link pc.CameraComponent#calculateProjection}).
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPostCull Custom function that is called after visibiliy culling is performed for this layer.
     * Useful for reverting changes done in {@link pc.Layer#onPreCull} and determining final mesh instance visibility (see {@link pc.MeshInstance#visibleThisFrame}).
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPreRender Custom function that is called before this layer is rendered.
     * Useful, for example, for reacting on screen size changes.
     * This function is called before the first occurrence of this layer in {@link pc.LayerComposition}.
     * It will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPreRenderOpaque Custom function that is called before opaque mesh instances (not semi-transparent) in this layer are rendered.
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPreRenderTransparent Custom function that is called before semi-transparent mesh instances in this layer are rendered.
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPostRender Custom function that is called after this layer is rendered.
     * Useful to revert changes made in {@link pc.Layer#onPreRender} or performing some processing on {@link pc.Layer#renderTarget}.
     * This function is called after the last occurrence of this layer in {@link pc.LayerComposition}.
     * It will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPostRenderOpaque Custom function that is called after opaque mesh instances (not semi-transparent) in this layer are rendered.
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onPostRenderTransparent Custom function that is called after semi-transparent mesh instances in this layer are rendered.
     * This function will receive camera index as the only argument. You can get the actual camera being used by looking up {@link pc.LayerComposition#cameras} with this index.
     * @property {Function} onDrawCall Custom function that is called before every mesh instance in this layer is rendered.
     * It is not recommended to set this function when rendering many objects every frame due to performance reasons.
     * @property {number} id A unique ID of the layer.
     * Layer IDs are stored inside {@link pc.ModelComponent#layers}, {@link pc.CameraComponent#layers}, {@link pc.LightComponent#layers} and {@link pc.ElementComponent#layers} instead of names.
     * Can be used in {@link pc.LayerComposition#getLayerById}.
     */
    function Layer(options) {
        options = options || {};

        if (options.id !== undefined) {
            this.id = options.id;
            layerCounter = Math.max(this.id + 1, layerCounter);
        } else {
            this.id = layerCounter++;
        }

        this.name = options.name;

        this._enabled = options.enabled === undefined ? true : options.enabled;
        this._refCounter = this._enabled ? 1 : 0;

        this.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;
        this.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;
        this.renderTarget = options.renderTarget;
        this.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;
        this.passThrough = options.passThrough === undefined ? false : options.passThrough;

        this.overrideClear = options.overrideClear === undefined ? false : options.overrideClear;
        this._clearColor = new Color(0, 0, 0, 1);
        if (options.clearColor) {
            this._clearColor.copy(options.clearColor);
        }
        this._clearColorBuffer = options.clearColorBuffer === undefined ? false : options.clearColorBuffer;
        this._clearDepthBuffer = options.clearDepthBuffer === undefined ? false : options.clearDepthBuffer;
        this._clearStencilBuffer = options.clearStencilBuffer === undefined ? false : options.clearStencilBuffer;
        this._clearOptions = {
            color: [this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a],
            depth: 1,
            stencil: 0,
            flags: (this._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (this._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (this._clearStencilBuffer ? CLEARFLAG_STENCIL : 0)
        };

        this.onPreCull = options.onPreCull;
        this.onPreRender = options.onPreRender;
        this.onPreRenderOpaque = options.onPreRenderOpaque;
        this.onPreRenderTransparent = options.onPreRenderTransparent;

        this.onPostCull = options.onPostCull;
        this.onPostRender = options.onPostRender;
        this.onPostRenderOpaque = options.onPostRenderOpaque;
        this.onPostRenderTransparent = options.onPostRenderTransparent;

        this.onDrawCall = options.onDrawCall;
        this.onEnable = options.onEnable;
        this.onDisable = options.onDisable;

        if (this._enabled && this.onEnable) {
            this.onEnable();
        }

        this.layerReference = options.layerReference; // should use the same camera
        this.instances = options.layerReference ? options.layerReference.instances : new InstanceList();
        this.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;

        this.opaqueMeshInstances = this.instances.opaqueMeshInstances;
        this.transparentMeshInstances = this.instances.transparentMeshInstances;
        this.shadowCasters = this.instances.shadowCasters;

        this.customSortCallback = null;
        this.customCalculateSortValues = null;

        this._lightComponents = [];
        this._lights = [];
        this._sortedLights = [[], [], []];
        this.cameras = [];
        this._dirty = false;
        this._dirtyLights = false;
        this._dirtyCameras = false;
        this._cameraHash = 0;
        this._lightHash = 0;
        this._staticLightHash = 0;
        this._needsStaticPrepare = true;
        this._staticPrepareDone = false;


        this._shaderVersion = -1;
        this._version = 0;
        this._lightCube = null;
    }

    Object.defineProperty(Layer.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (val) {
            if (val !== this._enabled) {
                this._enabled = val;
                if (val) {
                    this.incrementCounter();
                    if (this.onEnable) this.onEnable();
                } else {
                    this.decrementCounter();
                    if (this.onDisable) this.onDisable();
                }
            }
        }
    });

    Object.defineProperty(Layer.prototype, "clearColor", {
        get: function () {
            return this._clearColor;
        },
        set: function (val) {
            this._clearColor.copy(val);
        }
    });

    Layer.prototype._updateClearFlags = function () {
        var flags = 0;

        if (this._clearColorBuffer)
            flags |= CLEARFLAG_COLOR;

        if (this._clearDepthBuffer)
            flags |= CLEARFLAG_DEPTH;

        if (this._clearStencilBuffer)
            flags |= CLEARFLAG_STENCIL;

        this._clearOptions.flags = flags;
    };

    Object.defineProperty(Layer.prototype, "clearColorBuffer", {
        get: function () {
            return this._clearColorBuffer;
        },
        set: function (val) {
            this._clearColorBuffer = val;
            this._updateClearFlags();
        }
    });

    Object.defineProperty(Layer.prototype, "clearDepthBuffer", {
        get: function () {
            return this._clearDepthBuffer;
        },
        set: function (val) {
            this._clearDepthBuffer = val;
            this._updateClearFlags();
        }
    });

    Object.defineProperty(Layer.prototype, "clearStencilBuffer", {
        get: function () {
            return this._clearStencilBuffer;
        },
        set: function (val) {
            this._clearStencilBuffer = val;
            this._updateClearFlags();
        }
    });

    /**
     * @private
     * @function
     * @name pc.Layer#incrementCounter
     * @description Increments the usage counter of this layer.
     * By default, layers are created with counter set to 1 (if {@link pc.Layer.enabled} is true) or 0 (if it was false).
     * Incrementing the counter from 0 to 1 will enable the layer and call {@link pc.Layer.onEnable}.
     * Use this function to "subscribe" multiple effects to the same layer. For example, if the layer is used to render a reflection texture which is used by 2 mirrors,
     * then each mirror can call this function when visible and {@link pc.Layer.decrementCounter} if invisible.
     * In such case the reflection texture won't be updated, when there is nothing to use it, saving performance.
     */
    Layer.prototype.incrementCounter = function () {
        if (this._refCounter === 0) {
            this._enabled = true;
            if (this.onEnable) this.onEnable();
        }
        this._refCounter++;
    };

    /**
     * @private
     * @function
     * @name pc.Layer#decrementCounter
     * @description Decrements the usage counter of this layer.
     * Decrementing the counter from 1 to 0 will disable the layer and call {@link pc.Layer.onDisable}.
     * See {@link pc.Layer#incrementCounter} for more details.
     */
    Layer.prototype.decrementCounter = function () {
        if (this._refCounter === 1) {
            this._enabled = false;
            if (this.onDisable) this.onDisable();

        } else if (this._refCounter === 0) {
            return;
        }
        this._refCounter--;
    };

    // SUBLAYER GROUPS
    // If there are multiple sublayer with identical _cameraHash without anything in between, these
    // are called a SUBLAYER GROUP instead of:
    //     for each sublayer
    //         for each camera
    // we go:
    //     for each sublayerGroup

    /**
     * @function
     * @name pc.Layer#addMeshInstances
     * @description Adds an array of mesh instances to this layer.
     * @param {pc.MeshInstance[]} meshInstances - Array of {@link pc.MeshInstance}.
     * @param {boolean} [skipShadowCasters] - Set it to true if you don't want these mesh instances to cast shadows in this layer.
     */
    Layer.prototype.addMeshInstances = function (meshInstances, skipShadowCasters) {
        var sceneShaderVer = this._shaderVersion;

        var m, arr, mat;
        var casters = this.shadowCasters;
        for (var i = 0; i < meshInstances.length; i++) {
            m = meshInstances[i];
            mat = m.material;
            if (mat.blendType === BLEND_NONE) {
                arr = this.opaqueMeshInstances;
            } else {
                arr = this.transparentMeshInstances;
            }
            if (arr.indexOf(m) < 0) arr.push(m);
            if (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);
            if (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) { // clear old shader if needed
                if (mat.updateShader !== Material.prototype.updateShader) {
                    mat.clearVariants();
                    mat.shader = null;
                }
                mat._shaderVersion = sceneShaderVer;
            }
        }
        if (!this.passThrough) this._dirty = true;
    };

    /**
     * @function
     * @name pc.Layer#removeMeshInstances
     * @description Removes multiple mesh instances from this layer.
     * @param {pc.MeshInstance[]} meshInstances - Array of {@link pc.MeshInstance}. If they were added to this layer, they will be removed.
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from removed mesh instances or if they never did cast shadows before.
     */
    Layer.prototype.removeMeshInstances = function (meshInstances, skipShadowCasters) {

        var i, j, m, spliceOffset, spliceCount, len, drawCall;
        var opaque = this.opaqueMeshInstances;
        var transparent = this.transparentMeshInstances;
        var casters = this.shadowCasters;

        for (i = 0; i < meshInstances.length; i++) {
            m = meshInstances[i];

            // remove from opaque
            spliceOffset = -1;
            spliceCount = 0;
            len = opaque.length;
            for (j = 0; j < len; j++) {
                drawCall = opaque[j];
                if (drawCall === m) {
                    spliceOffset = j;
                    spliceCount = 1;
                    break;
                }
                if (drawCall._staticSource === m) {
                    if (spliceOffset < 0) spliceOffset = j;
                    spliceCount++;
                } else if (spliceOffset >= 0) {
                    break;
                }
            }
            if (spliceOffset >= 0) opaque.splice(spliceOffset, spliceCount);

            // remove from transparent
            spliceOffset = -1;
            spliceCount = 0;
            len = transparent.length;
            for (j = 0; j < len; j++) {
                drawCall = transparent[j];
                if (drawCall === m) {
                    spliceOffset = j;
                    spliceCount = 1;
                    break;
                }
                if (drawCall._staticSource === m) {
                    if (spliceOffset < 0) spliceOffset = j;
                    spliceCount++;
                } else if (spliceOffset >= 0) {
                    break;
                }
            }
            if (spliceOffset >= 0) transparent.splice(spliceOffset, spliceCount);

            // remove from shadows
            if (skipShadowCasters) continue;
            j = casters.indexOf(m);
            if (j >= 0) casters.splice(j, 1);
        }
        this._dirty = true;
    };

    /**
     * @function
     * @name pc.Layer#clearMeshInstances
     * @description Removes all mesh instances from this layer.
     * @param {boolean} [skipShadowCasters] - Set it to true if you want to still cast shadows from removed mesh instances or if they never did cast shadows before.
     */
    Layer.prototype.clearMeshInstances = function (skipShadowCasters) {
        if (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {
            if (skipShadowCasters || this.shadowCasters.length === 0) return;
        }
        this.opaqueMeshInstances.length = 0;
        this.transparentMeshInstances.length = 0;
        if (!skipShadowCasters) this.shadowCasters.length = 0;
        if (!this.passThrough) this._dirty = true;
    };

    /**
     * @function
     * @name pc.Layer#addLight
     * @description Adds a light to this layer.
     * @param {pc.LightComponent} light - A {@link pc.LightComponent}.
     */
    Layer.prototype.addLight = function (light) {
        if (this._lightComponents.indexOf(light) >= 0) return;
        this._lightComponents.push(light);
        this._lights.push(light.light);
        this._dirtyLights = true;
        this._generateLightHash();
    };

    /**
     * @function
     * @name pc.Layer#removeLight
     * @description Removes a light from this layer.
     * @param {pc.LightComponent} light - A {@link pc.LightComponent}.
     */
    Layer.prototype.removeLight = function (light) {
        var id = this._lightComponents.indexOf(light);
        if (id < 0) return;
        this._lightComponents.splice(id, 1);

        id = this._lights.indexOf(light.light);
        this._lights.splice(id, 1);

        this._dirtyLights = true;
        this._generateLightHash();
    };

    /**
     * @function
     * @name pc.Layer#clearLights
     * @description Removes all lights from this layer.
     */
    Layer.prototype.clearLights = function () {
        this._lightComponents.length = 0;
        this._lights.length = 0;
        this._dirtyLights = true;
    };

    /**
     * @function
     * @name pc.Layer#addShadowCasters
     * @description Adds an array of mesh instances to this layer, but only as shadow casters (they will not be rendered anywhere, but only cast shadows on other objects).
     * @param {pc.MeshInstance[]} meshInstances - Array of {@link pc.MeshInstance}.
     */
    Layer.prototype.addShadowCasters = function (meshInstances) {
        var m;
        var arr = this.shadowCasters;
        for (var i = 0; i < meshInstances.length; i++) {
            m = meshInstances[i];
            if (!m.castShadow) continue;
            if (arr.indexOf(m) < 0) arr.push(m);
        }
        this._dirtyLights = true;
    };

    /**
     * @function
     * @name pc.Layer#removeShadowCasters
     * @description Removes multiple mesh instances from the shadow casters list of this layer, meaning they will stop casting shadows.
     * @param {pc.MeshInstance[]} meshInstances - Array of {@link pc.MeshInstance}. If they were added to this layer, they will be removed.
     */
    Layer.prototype.removeShadowCasters = function (meshInstances) {
        var id;
        var arr = this.shadowCasters;
        for (var i = 0; i < meshInstances.length; i++) {
            id = arr.indexOf(meshInstances[i]);
            if (id >= 0) arr.splice(id, 1);
        }
        this._dirtyLights = true;
    };

    Layer.prototype._generateLightHash = function () {
        // generate hash to check if layers have the same set of static lights
        // order of lights shouldn't matter
        if (this._lights.length > 0) {
            this._lights.sort(sortLights);
            var str = "";
            var strStatic = "";

            for (var i = 0; i < this._lights.length; i++) {
                if (this._lights[i].isStatic) {
                    strStatic += this._lights[i].key;
                } else {
                    str += this._lights[i].key;
                }
            }

            if (str.length === 0) {
                this._lightHash = 0;
            } else {
                this._lightHash = hashCode(str);
            }

            if (strStatic.length === 0) {
                this._staticLightHash = 0;
            } else {
                this._staticLightHash = hashCode(strStatic);
            }

        } else {
            this._lightHash = 0;
            this._staticLightHash = 0;
        }
    };

    Layer.prototype._generateCameraHash = function () {
        // generate hash to check if cameras in layers are identical
        // order of cameras shouldn't matter
        if (this.cameras.length > 1) {
            this.cameras.sort(sortCameras);
            var str = "";
            for (var i = 0; i < this.cameras.length; i++) {
                str += this.cameras[i].entity.getGuid();
            }
            this._cameraHash = hashCode(str);
        } else {
            this._cameraHash = 0;
        }
        this._dirtyCameras = true;
    };

    /**
     * @function
     * @name pc.Layer#addCamera
     * @description Adds a camera to this layer.
     * @param {pc.CameraComponent} camera - A {@link pc.CameraComponent}.
     */
    Layer.prototype.addCamera = function (camera) {
        if (this.cameras.indexOf(camera) >= 0) return;
        this.cameras.push(camera);
        this._generateCameraHash();
    };

    /**
     * @function
     * @name pc.Layer#removeCamera
     * @description Removes a camera from this layer.
     * @param {pc.CameraComponent} camera - A {@link pc.CameraComponent}.
     */
    Layer.prototype.removeCamera = function (camera) {
        var id = this.cameras.indexOf(camera);
        if (id < 0) return;
        this.cameras.splice(id, 1);
        this._generateCameraHash();

        // visible lists in layer are not updated after camera is removed
        // so clear out any remaining mesh instances
        this.instances.clearVisibleLists(id);
    };

    /**
     * @function
     * @name pc.Layer#clearCameras
     * @description Removes all cameras from this layer.
     */
    Layer.prototype.clearCameras = function () {
        this.cameras.length = 0;
        this._cameraHash = 0;
        this._dirtyCameras = true;
    };

    Layer.prototype._sortCameras = function () {
        this._generateCameraHash();
    };

    Layer.prototype._calculateSortDistances = function (drawCalls, drawCallsCount, camPos, camFwd) {
        var i, drawCall, meshPos;
        var tempx, tempy, tempz;
        for (i = 0; i < drawCallsCount; i++) {
            drawCall = drawCalls[i];
            if (drawCall.command) continue;
            if (drawCall.layer <= LAYER_FX) continue; // Only alpha sort mesh instances in the main world (backwards comp)
            if (drawCall.calculateSortDistance) {
                drawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
                continue;
            }
            meshPos = drawCall.aabb.center;
            tempx = meshPos.x - camPos.x;
            tempy = meshPos.y - camPos.y;
            tempz = meshPos.z - camPos.z;
            drawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;
        }
    };

    Layer.prototype._sortVisible = function (transparent, cameraNode, cameraPass) {
        var objects = this.instances;
        var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
        if (sortMode === SORTMODE_NONE) return;

        var visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

        if (sortMode === SORTMODE_CUSTOM) {
            sortPos = cameraNode.getPosition();
            sortDir = cameraNode.forward;
            if (this.customCalculateSortValues) {
                this.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);
            }

            if (visible.list.length !== visible.length) {
                visible.list.length = visible.length;
            }

            if (this.customSortCallback) {
                visible.list.sort(this.customSortCallback);
            }
        } else {
            if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
                sortPos = cameraNode.getPosition();
                sortDir = cameraNode.forward;
                this._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);
            }

            if (visible.list.length !== visible.length) {
                visible.list.length = visible.length;
            }

            visible.list.sort(sortCallbacks[sortMode]);
        }
    };

    // Global shadowmap resources
    var scaleShift = new Mat4().mul2(
        new Mat4().setTranslate(0.5, 0.5, 0.5),
        new Mat4().setScale(0.5, 0.5, 0.5)
    );

    var opChanId = { r: 1, g: 2, b: 3, a: 4 };

    var pointLightRotations = [
        new Quat().setFromEulerAngles(0, 90, 180),
        new Quat().setFromEulerAngles(0, -90, 180),
        new Quat().setFromEulerAngles(90, 0, 0),
        new Quat().setFromEulerAngles(-90, 0, 0),
        new Quat().setFromEulerAngles(0, 180, 180),
        new Quat().setFromEulerAngles(0, 0, 180)
    ];

    var numShadowModes = 5;
    var shadowMapCache = [{}, {}, {}, {}, {}]; // must be a size of numShadowModes

    var directionalShadowEpsilon = 0.01;
    var pixelOffset = new Float32Array(2);
    var blurScissorRect = { x: 1, y: 1, z: 0, w: 0 };

    var shadowCamView = new Mat4();
    var shadowCamViewProj = new Mat4();
    var c2sc = new Mat4();

    var viewInvMat = new Mat4();
    var viewMat = new Mat4();
    var viewMat3 = new Mat3();
    var viewProjMat = new Mat4();
    var projMat;

    var viewInvL = new Mat4();
    var viewInvR = new Mat4();
    var viewL = new Mat4();
    var viewR = new Mat4();
    var viewPosL = new Vec3();
    var viewPosR = new Vec3();
    var projL, projR;
    var viewMat3L = new Mat4();
    var viewMat3R = new Mat4();
    var viewProjMatL = new Mat4();
    var viewProjMatR = new Mat4();

    var worldMatX$1 = new Vec3();
    var worldMatY$1 = new Vec3();
    var worldMatZ$1 = new Vec3();

    var frustumDiagonal = new Vec3();
    var tempSphere = { center: null, radius: 0 };
    var meshPos;
    var visibleSceneAabb = new BoundingBox();
    var boneTextureSize = [0, 0];
    var boneTexture, instancingData, modelMatrix, normalMatrix;

    var shadowMapCubeCache = {};
    var maxBlurSize = 25;

    var keyA$1, keyB$1;

    var _autoInstanceBuffer = null;

    // The 8 points of the camera frustum transformed to light space
    var frustumPoints = [];
    for (var fp = 0; fp < 8; fp++) {
        frustumPoints.push(new Vec3());
    }

    function _getFrustumPoints(camera, farClip, points) {
        var nearClip = camera._nearClip;
        var fov = camera._fov * Math.PI / 180.0;
        var aspect = camera._aspect;
        var projection = camera._projection;

        var x, y;
        if (projection === PROJECTION_PERSPECTIVE) {
            y = Math.tan(fov / 2.0) * nearClip;
        } else {
            y = camera._orthoHeight;
        }
        x = y * aspect;

        points[0].x = x;
        points[0].y = -y;
        points[0].z = -nearClip;
        points[1].x = x;
        points[1].y = y;
        points[1].z = -nearClip;
        points[2].x = -x;
        points[2].y = y;
        points[2].z = -nearClip;
        points[3].x = -x;
        points[3].y = -y;
        points[3].z = -nearClip;

        if (projection === PROJECTION_PERSPECTIVE) {
            y = Math.tan(fov / 2.0) * farClip;
            x = y * aspect;
        }
        points[4].x = x;
        points[4].y = -y;
        points[4].z = -farClip;
        points[5].x = x;
        points[5].y = y;
        points[5].z = -farClip;
        points[6].x = -x;
        points[6].y = y;
        points[6].z = -farClip;
        points[7].x = -x;
        points[7].y = -y;
        points[7].z = -farClip;

        return points;
    }

    var _sceneAABB_LS = [
        new Vec3(), new Vec3(), new Vec3(), new Vec3(),
        new Vec3(), new Vec3(), new Vec3(), new Vec3()
    ];

    function _getZFromAABBSimple(w2sc, aabbMin, aabbMax, lcamMinX, lcamMaxX, lcamMinY, lcamMaxY) {
        _sceneAABB_LS[0].x = _sceneAABB_LS[1].x = _sceneAABB_LS[2].x = _sceneAABB_LS[3].x = aabbMin.x;
        _sceneAABB_LS[1].y = _sceneAABB_LS[3].y = _sceneAABB_LS[7].y = _sceneAABB_LS[5].y = aabbMin.y;
        _sceneAABB_LS[2].z = _sceneAABB_LS[3].z = _sceneAABB_LS[6].z = _sceneAABB_LS[7].z = aabbMin.z;
        _sceneAABB_LS[4].x = _sceneAABB_LS[5].x = _sceneAABB_LS[6].x = _sceneAABB_LS[7].x = aabbMax.x;
        _sceneAABB_LS[0].y = _sceneAABB_LS[2].y = _sceneAABB_LS[4].y = _sceneAABB_LS[6].y = aabbMax.y;
        _sceneAABB_LS[0].z = _sceneAABB_LS[1].z = _sceneAABB_LS[4].z = _sceneAABB_LS[5].z = aabbMax.z;

        var minz = 9999999999;
        var maxz = -9999999999;
        var z;

        for ( var i = 0; i < 8; ++i ) {
            w2sc.transformPoint( _sceneAABB_LS[i], _sceneAABB_LS[i] );
            z = _sceneAABB_LS[i].z;
            if (z < minz) minz = z;
            if (z > maxz) maxz = z;
        }

        return { min: minz, max: maxz };
    }

    // SHADOW MAPPING SUPPORT FUNCTIONS

    function getShadowFormat(device, shadowType) {
        if (shadowType === SHADOW_VSM32) {
            return PIXELFORMAT_RGBA32F;
        } else if (shadowType === SHADOW_VSM16) {
            return PIXELFORMAT_RGBA16F;
        } else if (shadowType === SHADOW_PCF5) {
            return PIXELFORMAT_DEPTH;
        } else if (shadowType === SHADOW_PCF3 && device.webgl2) {
            return PIXELFORMAT_DEPTH;
        }
        return PIXELFORMAT_R8_G8_B8_A8;
    }

    function getShadowFiltering(device, shadowType) {
        if (shadowType === SHADOW_PCF3 && !device.webgl2) {
            return FILTER_NEAREST;
        } else if (shadowType === SHADOW_VSM32) {
            return device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
        } else if (shadowType === SHADOW_VSM16) {
            return device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
        }
        return FILTER_LINEAR;
    }

    function createShadowMap(device, width, height, shadowType) {
        var format = getShadowFormat(device, shadowType);
        var filter = getShadowFiltering(device, shadowType);

        var shadowMap = new Texture(device, {
            format: format,
            width: width,
            height: height,
            mipmaps: false,
            minFilter: filter,
            magFilter: filter,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE
        });
        shadowMap.name = 'shadowmap';

        if (shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF3 && device.webgl2)) {
            shadowMap.compareOnRead = true;
            shadowMap.compareFunc = FUNC_LESS;
            // depthbuffer only
            return new RenderTarget({
                depthBuffer: shadowMap
            });
        }

        // encoded rgba depth
        return new RenderTarget({
            colorBuffer: shadowMap,
            depth: true
        });
    }

    function createShadowCubeMap(device, size) {
        var cubemap = new Texture(device, {
            format: PIXELFORMAT_R8_G8_B8_A8,
            width: size,
            height: size,
            cubemap: true,
            mipmaps: false,
            minFilter: FILTER_NEAREST,
            magFilter: FILTER_NEAREST,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE
        });
        cubemap.name = 'shadowcube';

        var targets = [];
        var target;
        for (var i = 0; i < 6; i++) {
            target = new RenderTarget({
                colorBuffer: cubemap,
                face: i,
                depth: true
            });
            targets.push(target);
        }
        return targets;
    }

    function gauss(x, sigma) {
        return Math.exp(-(x * x) / (2.0 * sigma * sigma));
    }

    function gaussWeights(kernelSize) {
        if (kernelSize > maxBlurSize) kernelSize = maxBlurSize;
        var sigma = (kernelSize - 1) / (2 * 3);
        var i, values, sum, halfWidth;

        halfWidth = (kernelSize - 1) * 0.5;
        values = new Array(kernelSize);
        sum = 0.0;
        for (i = 0; i < kernelSize; ++i) {
            values[i] = gauss(i - halfWidth, sigma);
            sum += values[i];
        }

        for (i = 0; i < kernelSize; ++i) {
            values[i] /= sum;
        }
        return values;
    }

    function createShadowCamera(device, shadowType, type) {
        // We don't need to clear the color buffer if we're rendering a depth map
        var flags = CLEARFLAG_DEPTH;
        var hwPcf = shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF3 && device.webgl2);
        if (type === LIGHTTYPE_POINT) hwPcf = false;
        if (!hwPcf) flags |= CLEARFLAG_COLOR;
        var shadowCam = new Camera();

        if (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {
            shadowCam.clearColor[0] = 0;
            shadowCam.clearColor[1] = 0;
            shadowCam.clearColor[2] = 0;
            shadowCam.clearColor[3] = 0;
        } else {
            shadowCam.clearColor[0] = 1;
            shadowCam.clearColor[1] = 1;
            shadowCam.clearColor[2] = 1;
            shadowCam.clearColor[3] = 1;
        }

        shadowCam.clearDepth = 1;
        shadowCam.clearFlags = flags;
        shadowCam.clearStencil = null;

        shadowCam._node = new GraphNode();

        return shadowCam;
    }

    function getShadowMapFromCache(device, res, mode, layer) {
        if (!layer) layer = 0;
        var id = layer * 10000 + res;
        var shadowBuffer = shadowMapCache[mode][id];
        if (!shadowBuffer) {
            shadowBuffer = createShadowMap(device, res, res, mode ? mode : SHADOW_PCF3);
            shadowMapCache[mode][id] = shadowBuffer;
        }
        return shadowBuffer;
    }

    function createShadowBuffer(device, light) {
        var shadowBuffer;
        if (light._type === LIGHTTYPE_POINT) {
            if (light._shadowType > SHADOW_PCF3) light._shadowType = SHADOW_PCF3; // no VSM or HW PCF point lights yet
            if (light._cacheShadowMap) {
                shadowBuffer = shadowMapCubeCache[light._shadowResolution];
                if (!shadowBuffer) {
                    shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
                    shadowMapCubeCache[light._shadowResolution] = shadowBuffer;
                }
            } else {
                shadowBuffer = createShadowCubeMap(device, light._shadowResolution);
            }
            light._shadowCamera.renderTarget = shadowBuffer[0];
            light._shadowCubeMap = shadowBuffer;

        } else {

            if (light._cacheShadowMap) {
                shadowBuffer = getShadowMapFromCache(device, light._shadowResolution, light._shadowType);
            } else {
                shadowBuffer = createShadowMap(device, light._shadowResolution, light._shadowResolution, light._shadowType);
            }

            light._shadowCamera.renderTarget = shadowBuffer;
        }
        light._isCachedShadowMap = light._cacheShadowMap;
    }

    function getDepthKey(meshInstance) {
        var material = meshInstance.material;
        var x = meshInstance.skinInstance ? 10 : 0;
        var y = 0;
        if (material.opacityMap) {
            var opChan = material.opacityMapChannel;
            if (opChan) {
                y = opChanId[opChan];
            }
        }
        return x + y;
    }

    /**
     * @class
     * @name pc.ForwardRenderer
     * @classdesc The forward renderer render scene objects.
     * @description Creates a new forward renderer object.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     */
    function ForwardRenderer(graphicsDevice) {
        this.device = graphicsDevice;
        var device = this.device;

        this._shadowDrawCalls = 0;
        this._forwardDrawCalls = 0;
        this._skinDrawCalls = 0;
        this._camerasRendered = 0;
        this._materialSwitches = 0;
        this._shadowMapUpdates = 0;
        this._shadowMapTime = 0;
        this._depthMapTime = 0;
        this._forwardTime = 0;
        this._cullTime = 0;
        this._sortTime = 0;
        this._skinTime = 0;
        this._morphTime = 0;
        this._instancingTime = 0;

        // Shaders
        var library = device.getProgramLibrary();
        this.library = library;

        // Uniforms
        var scope = device.scope;
        this.projId = scope.resolve('matrix_projection');
        this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
        this.viewId = scope.resolve('matrix_view');
        this.viewId3 = scope.resolve('matrix_view3');
        this.viewInvId = scope.resolve('matrix_viewInverse');
        this.viewProjId = scope.resolve('matrix_viewProjection');
        this.viewPos = new Float32Array(3);
        this.viewPosId = scope.resolve('view_position');
        this.nearClipId = scope.resolve('camera_near');
        this.farClipId = scope.resolve('camera_far');
        this.cameraParamsId = scope.resolve('camera_params');
        this.shadowMapLightRadiusId = scope.resolve('light_radius');

        this.fogColorId = scope.resolve('fog_color');
        this.fogStartId = scope.resolve('fog_start');
        this.fogEndId = scope.resolve('fog_end');
        this.fogDensityId = scope.resolve('fog_density');

        this.modelMatrixId = scope.resolve('matrix_model');
        this.normalMatrixId = scope.resolve('matrix_normal');
        this.poseMatrixId = scope.resolve('matrix_pose[0]');
        this.boneTextureId = scope.resolve('texture_poseMap');
        this.boneTextureSizeId = scope.resolve('texture_poseMapSize');

        this.morphWeightsA = scope.resolve('morph_weights_a');
        this.morphWeightsB = scope.resolve('morph_weights_b');

        this.alphaTestId = scope.resolve('alpha_ref');
        this.opacityMapId = scope.resolve('texture_opacityMap');

        this.ambientId = scope.resolve("light_globalAmbient");
        this.exposureId = scope.resolve("exposure");
        this.skyboxIntensityId = scope.resolve("skyboxIntensity");
        this.lightColorId = [];
        this.lightDir = [];
        this.lightDirId = [];
        this.lightShadowMapId = [];
        this.lightShadowMatrixId = [];
        this.lightShadowParamsId = [];
        this.lightShadowMatrixVsId = [];
        this.lightShadowParamsVsId = [];
        this.lightDirVs = [];
        this.lightDirVsId = [];
        this.lightRadiusId = [];
        this.lightPos = [];
        this.lightPosId = [];
        this.lightInAngleId = [];
        this.lightOutAngleId = [];
        this.lightPosVsId = [];
        this.lightCookieId = [];
        this.lightCookieIntId = [];
        this.lightCookieMatrixId = [];
        this.lightCookieOffsetId = [];

        this.depthMapId = scope.resolve('uDepthMap');
        this.screenSizeId = scope.resolve('uScreenSize');
        this._screenSize = new Float32Array(4);

        this.sourceId = scope.resolve("source");
        this.pixelOffsetId = scope.resolve("pixelOffset");
        this.weightId = scope.resolve("weight[0]");
        var chunks = shaderChunks;
        this.blurVsmShaderCode = [chunks.blurVSMPS, "#define GAUSS\n" + chunks.blurVSMPS];
        var packed = "#define PACKED\n";
        this.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];
        this.blurVsmShader = [{}, {}];
        this.blurPackedVsmShader = [{}, {}];
        this.blurVsmWeights = {};

        this.polygonOffsetId = scope.resolve("polygonOffset");
        this.polygonOffset = new Float32Array(2);

        this.fogColor = new Float32Array(3);
        this.ambientColor = new Float32Array(3);

        // temp arrays to avoid allocations
        this.tempSemanticArray = [];
    }

    function mat3FromMat4(m3, m4) {
        m3.data[0] = m4.data[0];
        m3.data[1] = m4.data[1];
        m3.data[2] = m4.data[2];

        m3.data[3] = m4.data[4];
        m3.data[4] = m4.data[5];
        m3.data[5] = m4.data[6];

        m3.data[6] = m4.data[8];
        m3.data[7] = m4.data[9];
        m3.data[8] = m4.data[10];
    }

    Object.assign(ForwardRenderer.prototype, {

        sortCompare: function (drawCallA, drawCallB) {
            if (drawCallA.layer === drawCallB.layer) {
                if (drawCallA.drawOrder && drawCallB.drawOrder) {
                    return drawCallA.drawOrder - drawCallB.drawOrder;
                } else if (drawCallA.zdist && drawCallB.zdist) {
                    return drawCallB.zdist - drawCallA.zdist; // back to front
                } else if (drawCallA.zdist2 && drawCallB.zdist2) {
                    return drawCallA.zdist2 - drawCallB.zdist2; // front to back
                }
            }

            return drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];
        },

        sortCompareMesh: function (drawCallA, drawCallB) {
            if (drawCallA.layer === drawCallB.layer) {
                if (drawCallA.drawOrder && drawCallB.drawOrder) {
                    return drawCallA.drawOrder - drawCallB.drawOrder;
                } else if (drawCallA.zdist && drawCallB.zdist) {
                    return drawCallB.zdist - drawCallA.zdist; // back to front
                }
            }

            keyA$1 = drawCallA._key[SORTKEY_FORWARD];
            keyB$1 = drawCallB._key[SORTKEY_FORWARD];

            if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
                return drawCallB.mesh.id - drawCallA.mesh.id;
            }

            return keyB$1 - keyA$1;
        },

        depthSortCompare: function (drawCallA, drawCallB) {
            keyA$1 = drawCallA._key[SORTKEY_DEPTH];
            keyB$1 = drawCallB._key[SORTKEY_DEPTH];

            if (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {
                return drawCallB.mesh.id - drawCallA.mesh.id;
            }

            return keyB$1 - keyA$1;
        },

        lightCompare: function (lightA, lightB) {
            return lightA.key - lightB.key;
        },

        _isVisible: function (camera, meshInstance) {
            if (!meshInstance.visible) return false;

            // custom visibility method on MeshInstance
            if (meshInstance.isVisibleFunc) {
                return meshInstance.isVisibleFunc(camera);
            }

            meshPos = meshInstance.aabb.center;
            if (meshInstance._aabb._radiusVer !== meshInstance._aabbVer) {
                meshInstance._aabb._radius = meshInstance._aabb.halfExtents.length();
                meshInstance._aabb._radiusVer = meshInstance._aabbVer;
            }

            tempSphere.radius = meshInstance._aabb._radius;
            tempSphere.center = meshPos;

            return camera.frustum.containsSphere(tempSphere);
        },

        getShadowCamera: function (device, light) {
            var shadowCam = light._shadowCamera;
            var shadowBuffer;

            if (shadowCam === null) {
                shadowCam = light._shadowCamera = createShadowCamera(device, light._shadowType, light._type);
                createShadowBuffer(device, light);
            } else {
                shadowBuffer = shadowCam.renderTarget;
                if ((shadowBuffer.width !== light._shadowResolution) || (shadowBuffer.height !== light._shadowResolution)) {
                    createShadowBuffer(device, light);
                }
            }

            return shadowCam;
        },

        updateCameraFrustum: function (camera) {
            if (camera.vrDisplay && camera.vrDisplay.presenting) {
                projMat = camera.vrDisplay.combinedProj;
                var parent = camera._node.parent;
                if (parent) {
                    viewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();
                } else {
                    viewMat.copy(camera.vrDisplay.combinedView);
                }
                viewInvMat.copy(viewMat).invert();
                this.viewInvId.setValue(viewInvMat.data);
                camera.frustum.update(projMat, viewMat);
            } else if (camera.xr && camera.xr.views.length) {
                // calculate frustum based on XR view
                var view = camera.xr.views[0];
                camera.frustum.update(view.projMat, view.viewOffMat);
                return;
            }

            projMat = camera.getProjectionMatrix();
            if (camera.overrideCalculateProjection) camera.calculateProjection(projMat, VIEW_CENTER);

            if (camera.overrideCalculateTransform) {
                camera.calculateTransform(viewInvMat, VIEW_CENTER);
            } else {
                var pos = camera._node.getPosition();
                var rot = camera._node.getRotation();
                viewInvMat.setTRS(pos, rot, Vec3.ONE);
                this.viewInvId.setValue(viewInvMat.data);
            }
            viewMat.copy(viewInvMat).invert();

            camera.frustum.update(projMat, viewMat);
        },

        // make sure colorWrite is set to true to all channels, if you want to fully clear the target
        setCamera: function (camera, target, clear, cullBorder) {
            var vrDisplay = camera.vrDisplay;
            var parent, transform;

            if (vrDisplay && vrDisplay.presenting) {
                // Projection LR
                projL = vrDisplay.leftProj;
                projR = vrDisplay.rightProj;
                projMat = vrDisplay.combinedProj;
                if (camera.overrideCalculateProjection) {
                    camera.calculateProjection(projL, VIEW_LEFT);
                    camera.calculateProjection(projR, VIEW_RIGHT);
                    camera.calculateProjection(projMat, VIEW_CENTER);
                }

                if (camera.overrideCalculateTransform) {
                    camera.calculateTransform(viewInvL, VIEW_LEFT);
                    camera.calculateTransform(viewInvR, VIEW_RIGHT);
                    camera.calculateTransform(viewInvMat, VIEW_CENTER);
                    viewL.copy(viewInvL).invert();
                    viewR.copy(viewInvR).invert();
                    viewMat.copy(viewInvMat).invert();
                } else {
                    parent = camera._node.parent;
                    if (parent) {
                        transform = parent.getWorldTransform();

                        // ViewInverse LR (parent)
                        viewInvL.mul2(transform, vrDisplay.leftViewInv);
                        viewInvR.mul2(transform, vrDisplay.rightViewInv);

                        // View LR (parent)
                        viewL.copy(viewInvL).invert();
                        viewR.copy(viewInvR).invert();

                        // Combined view (parent)
                        viewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();
                    } else {
                        // ViewInverse LR
                        viewInvL.copy(vrDisplay.leftViewInv);
                        viewInvR.copy(vrDisplay.rightViewInv);

                        // View LR
                        viewL.copy(vrDisplay.leftView);
                        viewR.copy(vrDisplay.rightView);

                        // Combined view
                        viewMat.copy(vrDisplay.combinedView);
                    }
                }

                // View 3x3 LR
                mat3FromMat4(viewMat3L, viewL);
                mat3FromMat4(viewMat3R, viewR);

                // ViewProjection LR
                viewProjMatL.mul2(projL, viewL);
                viewProjMatR.mul2(projR, viewR);

                // View Position LR
                viewPosL.x = viewInvL.data[12];
                viewPosL.y = viewInvL.data[13];
                viewPosL.z = viewInvL.data[14];

                viewPosR.x = viewInvR.data[12];
                viewPosR.y = viewInvR.data[13];
                viewPosR.z = viewInvR.data[14];

                camera.frustum.update(projMat, viewMat);
            } else if (camera.xr && camera.xr.session) {
                parent = camera._node.parent;
                if (parent) transform = parent.getWorldTransform();

                var views = camera.xr.views;

                for (var v = 0; v < views.length; v++) {
                    var view = views[v];

                    if (parent) {
                        view.viewInvOffMat.mul2(transform, view.viewInvMat);
                        view.viewOffMat.copy(view.viewInvOffMat).invert();
                    } else {
                        view.viewInvOffMat.copy(view.viewInvMat);
                        view.viewOffMat.copy(view.viewMat);
                    }

                    mat3FromMat4(view.viewMat3, view.viewOffMat);
                    view.projViewOffMat.mul2(view.projMat, view.viewOffMat);

                    view.position[0] = view.viewInvOffMat.data[12];
                    view.position[1] = view.viewInvOffMat.data[13];
                    view.position[2] = view.viewInvOffMat.data[14];

                    camera.frustum.update(view.projMat, view.viewOffMat);
                }
            } else {
                // Projection Matrix
                projMat = camera.getProjectionMatrix();
                if (camera.overrideCalculateProjection) camera.calculateProjection(projMat, VIEW_CENTER);
                this.projId.setValue(projMat.data);

                // Skybox Projection Matrix
                this.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);

                // ViewInverse Matrix
                if (camera.overrideCalculateTransform) {
                    camera.calculateTransform(viewInvMat, VIEW_CENTER);
                } else {
                    var pos = camera._node.getPosition();
                    var rot = camera._node.getRotation();
                    viewInvMat.setTRS(pos, rot, Vec3.ONE);
                }
                this.viewInvId.setValue(viewInvMat.data);

                // View Matrix
                viewMat.copy(viewInvMat).invert();
                this.viewId.setValue(viewMat.data);

                // View 3x3
                mat3FromMat4(viewMat3, viewMat);
                this.viewId3.setValue(viewMat3.data);

                // ViewProjection Matrix
                viewProjMat.mul2(projMat, viewMat);
                this.viewProjId.setValue(viewProjMat.data);

                // View Position (world space)
                var cameraPos = camera._node.getPosition();
                this.viewPos[0] = cameraPos.x;
                this.viewPos[1] = cameraPos.y;
                this.viewPos[2] = cameraPos.z;

                this.viewPosId.setValue(this.viewPos);

                camera.frustum.update(projMat, viewMat);
            }

            // Near and far clip values
            this.nearClipId.setValue(camera._nearClip);
            this.farClipId.setValue(camera._farClip);
            this.cameraParamsId.setValue(camera._shaderParams);

            var device = this.device;
            device.setRenderTarget(target);
            device.updateBegin();

            var rect = camera.getRect();
            var pixelWidth = target ? target.width : device.width;
            var pixelHeight = target ? target.height : device.height;
            var x = Math.floor(rect.x * pixelWidth);
            var y = Math.floor(rect.y * pixelHeight);
            var w = Math.floor(rect.width * pixelWidth);
            var h = Math.floor(rect.height * pixelHeight);
            device.setViewport(x, y, w, h);
            device.setScissor(x, y, w, h);
            if (clear) device.clear(camera._clearOptions); // clear full RT

            rect = camera._scissorRect;
            x = Math.floor(rect.x * pixelWidth);
            y = Math.floor(rect.y * pixelHeight);
            w = Math.floor(rect.width * pixelWidth);
            h = Math.floor(rect.height * pixelHeight);
            device.setScissor(x, y, w, h);

            if (cullBorder) device.setScissor(1, 1, pixelWidth - 2, pixelHeight - 2); // optionally clip borders when rendering
        },

        dispatchGlobalLights: function (scene) {
            var i;
            this.mainLight = -1;

            this.ambientColor[0] = scene.ambientLight.r;
            this.ambientColor[1] = scene.ambientLight.g;
            this.ambientColor[2] = scene.ambientLight.b;
            if (scene.gammaCorrection) {
                for (i = 0; i < 3; i++) {
                    this.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);
                }
            }
            this.ambientId.setValue(this.ambientColor);
            this.exposureId.setValue(scene.exposure);
            if (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);
        },

        _resolveLight: function (scope, i) {
            var light = "light" + i;
            this.lightColorId[i] = scope.resolve(light + "_color");
            this.lightDir[i] = new Float32Array(3);
            this.lightDirId[i] = scope.resolve(light + "_direction");
            this.lightShadowMapId[i] = scope.resolve(light + "_shadowMap");
            this.lightShadowMatrixId[i] = scope.resolve(light + "_shadowMatrix");
            this.lightShadowParamsId[i] = scope.resolve(light + "_shadowParams");
            this.lightShadowMatrixVsId[i] = scope.resolve(light + "_shadowMatrixVS");
            this.lightShadowParamsVsId[i] = scope.resolve(light + "_shadowParamsVS");
            this.lightDirVs[i] = new Float32Array(3);
            this.lightDirVsId[i] = scope.resolve(light + "_directionVS");
            this.lightRadiusId[i] = scope.resolve(light + "_radius");
            this.lightPos[i] = new Float32Array(3);
            this.lightPosId[i] = scope.resolve(light + "_position");
            this.lightInAngleId[i] = scope.resolve(light + "_innerConeAngle");
            this.lightOutAngleId[i] = scope.resolve(light + "_outerConeAngle");
            this.lightPosVsId[i] = scope.resolve(light + "_positionVS");
            this.lightCookieId[i] = scope.resolve(light + "_cookie");
            this.lightCookieIntId[i] = scope.resolve(light + "_cookieIntensity");
            this.lightCookieMatrixId[i] = scope.resolve(light + "_cookieMatrix");
            this.lightCookieOffsetId[i] = scope.resolve(light + "_cookieOffset");
        },

        dispatchDirectLights: function (dirs, scene, mask) {
            var numDirs = dirs.length;
            var i;
            var directional, wtm;
            var cnt = 0;
            this.mainLight = -1;

            var scope = this.device.scope;

            for (i = 0; i < numDirs; i++) {
                if (!(dirs[i].mask & mask)) continue;

                directional = dirs[i];
                wtm = directional._node.getWorldTransform();

                if (!this.lightColorId[cnt]) {
                    this._resolveLight(scope, cnt);
                }

                this.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);

                // Directionals shine down the negative Y axis
                wtm.getY(directional._direction).scale(-1);
                directional._direction.normalize();
                this.lightDir[cnt][0] = directional._direction.x;
                this.lightDir[cnt][1] = directional._direction.y;
                this.lightDir[cnt][2] = directional._direction.z;
                this.lightDirId[cnt].setValue(this.lightDir[cnt]);

                if (directional.castShadows) {
                    var shadowMap = directional._isPcf && this.device.webgl2 ?
                        directional._shadowCamera.renderTarget.depthBuffer :
                        directional._shadowCamera.renderTarget.colorBuffer;

                    // make bias dependent on far plane because it's not constant for direct light
                    var bias;
                    if (directional._isVsm) {
                        bias = -0.00001 * 20;
                    } else {
                        bias = (directional.shadowBias / directional._shadowCamera._farClip) * 100;
                        if (!this.device.webgl2 && this.device.extStandardDerivatives) bias *= -100;
                    }
                    var normalBias = directional._isVsm ?
                        directional.vsmBias / (directional._shadowCamera._farClip / 7.0) :
                        directional._normalOffsetBias;

                    this.lightShadowMapId[cnt].setValue(shadowMap);
                    this.lightShadowMatrixId[cnt].setValue(directional._shadowMatrix.data);
                    var params = directional._rendererParams;
                    if (params.length !== 3) params.length = 3;
                    params[0] = directional._shadowResolution;
                    params[1] = normalBias;
                    params[2] = bias;
                    this.lightShadowParamsId[cnt].setValue(params);
                    if (this.mainLight < 0) {
                        this.lightShadowMatrixVsId[cnt].setValue(directional._shadowMatrix.data);
                        this.lightShadowParamsVsId[cnt].setValue(params);
                        directional._direction.normalize();
                        this.lightDirVs[cnt][0] = directional._direction.x;
                        this.lightDirVs[cnt][1] = directional._direction.y;
                        this.lightDirVs[cnt][2] = directional._direction.z;
                        this.lightDirVsId[cnt].setValue(this.lightDirVs[cnt]);
                        this.mainLight = i;
                    }
                }
                cnt++;
            }
            return cnt;
        },

        dispatchPointLight: function (scene, scope, point, cnt) {
            var wtm = point._node.getWorldTransform();

            if (!this.lightColorId[cnt]) {
                this._resolveLight(scope, cnt);
            }

            this.lightRadiusId[cnt].setValue(point.attenuationEnd);
            this.lightColorId[cnt].setValue(scene.gammaCorrection ? point._linearFinalColor : point._finalColor);
            wtm.getTranslation(point._position);
            this.lightPos[cnt][0] = point._position.x;
            this.lightPos[cnt][1] = point._position.y;
            this.lightPos[cnt][2] = point._position.z;
            this.lightPosId[cnt].setValue(this.lightPos[cnt]);

            if (point.castShadows) {
                var shadowMap = point._shadowCamera.renderTarget.colorBuffer;
                this.lightShadowMapId[cnt].setValue(shadowMap);
                var params = point._rendererParams;
                if (params.length !== 4) params.length = 4;
                params[0] = point._shadowResolution;
                params[1] = point._normalOffsetBias;
                params[2] = point.shadowBias;
                params[3] = 1.0 / point.attenuationEnd;
                this.lightShadowParamsId[cnt].setValue(params);
            }
            if (point._cookie) {
                this.lightCookieId[cnt].setValue(point._cookie);
                this.lightShadowMatrixId[cnt].setValue(wtm.data);
                this.lightCookieIntId[cnt].setValue(point.cookieIntensity);
            }
        },

        dispatchSpotLight: function (scene, scope, spot, cnt) {
            var wtm = spot._node.getWorldTransform();

            if (!this.lightColorId[cnt]) {
                this._resolveLight(scope, cnt);
            }

            this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
            this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
            this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
            this.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);
            wtm.getTranslation(spot._position);
            this.lightPos[cnt][0] = spot._position.x;
            this.lightPos[cnt][1] = spot._position.y;
            this.lightPos[cnt][2] = spot._position.z;
            this.lightPosId[cnt].setValue(this.lightPos[cnt]);
            // Spots shine down the negative Y axis
            wtm.getY(spot._direction).scale(-1);
            spot._direction.normalize();
            this.lightDir[cnt][0] = spot._direction.x;
            this.lightDir[cnt][1] = spot._direction.y;
            this.lightDir[cnt][2] = spot._direction.z;
            this.lightDirId[cnt].setValue(this.lightDir[cnt]);

            if (spot.castShadows) {
                var bias;
                if (spot._isVsm) {
                    bias = -0.00001 * 20;
                } else {
                    bias = spot.shadowBias * 20; // approx remap from old bias values
                    if (!this.device.webgl2 && this.device.extStandardDerivatives) bias *= -100;
                }
                var normalBias = spot._isVsm ?
                    spot.vsmBias / (spot.attenuationEnd / 7.0) :
                    spot._normalOffsetBias;

                var shadowMap = spot._isPcf && this.device.webgl2 ?
                    spot._shadowCamera.renderTarget.depthBuffer :
                    spot._shadowCamera.renderTarget.colorBuffer;
                this.lightShadowMapId[cnt].setValue(shadowMap);
                this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
                var params = spot._rendererParams;
                if (params.length !== 4) params.length = 4;
                params[0] = spot._shadowResolution;
                params[1] = normalBias;
                params[2] = bias;
                params[3] = 1.0 / spot.attenuationEnd;
                this.lightShadowParamsId[cnt].setValue(params);
            }
            if (spot._cookie) {
                this.lightCookieId[cnt].setValue(spot._cookie);
                if (!spot.castShadows) {
                    var shadowCam = this.getShadowCamera(this.device, spot);
                    var shadowCamNode = shadowCam._node;

                    shadowCamNode.setPosition(spot._node.getPosition());
                    shadowCamNode.setRotation(spot._node.getRotation());
                    shadowCamNode.rotateLocal(-90, 0, 0);

                    shadowCam.projection = PROJECTION_PERSPECTIVE;
                    shadowCam.aspectRatio = 1;
                    shadowCam.fov = spot._outerConeAngle * 2;

                    shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
                    shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
                    spot._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
                }
                this.lightShadowMatrixId[cnt].setValue(spot._shadowMatrix.data);
                this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
                if (spot._cookieTransform) {
                    spot._cookieTransformUniform[0] = spot._cookieTransform.x;
                    spot._cookieTransformUniform[1] = spot._cookieTransform.y;
                    spot._cookieTransformUniform[2] = spot._cookieTransform.z;
                    spot._cookieTransformUniform[3] = spot._cookieTransform.w;
                    this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
                    spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
                    spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
                    this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
                }
            }
        },

        dispatchLocalLights: function (sortedLights, scene, mask, usedDirLights, staticLightList) {
            var i;
            var point, spot;

            var pnts = sortedLights[LIGHTTYPE_POINT];
            var spts = sortedLights[LIGHTTYPE_SPOT];

            var numDirs = usedDirLights;
            var numPnts = pnts.length;
            var numSpts = spts.length;
            var cnt = numDirs;

            var scope = this.device.scope;

            for (i = 0; i < numPnts; i++) {
                point = pnts[i];
                if (!(point.mask & mask)) continue;
                if (point.isStatic) continue;
                this.dispatchPointLight(scene, scope, point, cnt);
                cnt++;
            }

            var staticId = 0;
            if (staticLightList) {
                point = staticLightList[staticId];
                while (point && point._type === LIGHTTYPE_POINT) {
                    this.dispatchPointLight(scene, scope, point, cnt);
                    cnt++;
                    staticId++;
                    point = staticLightList[staticId];
                }
            }

            for (i = 0; i < numSpts; i++) {
                spot = spts[i];
                if (!(spot.mask & mask)) continue;
                if (spot.isStatic) continue;
                this.dispatchSpotLight(scene, scope, spot, cnt);
                cnt++;
            }

            if (staticLightList) {
                spot = staticLightList[staticId];
                while (spot && spot._type === LIGHTTYPE_SPOT) {
                    this.dispatchSpotLight(scene, scope, spot, cnt);
                    cnt++;
                    staticId++;
                    spot = staticLightList[staticId];
                }
            }
        },

        cull: function (camera, drawCalls, visibleList) {

            var visibleLength = 0;
            var i, drawCall, visible;
            var drawCallsCount = drawCalls.length;

            var cullingMask = camera.cullingMask || 0xFFFFFFFF; // if missing assume camera's default value

            if (!camera.frustumCulling) {
                for (i = 0; i < drawCallsCount; i++) {
                    // need to copy array anyway because sorting will happen and it'll break original draw call order assumption
                    drawCall = drawCalls[i];
                    if (!drawCall.visible && !drawCall.command) continue;

                    // if the object's mask AND the camera's cullingMask is zero then the game object will be invisible from the camera
                    if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;

                    visibleList[visibleLength] = drawCall;
                    visibleLength++;
                    drawCall.visibleThisFrame = true;
                }
                return visibleLength;
            }

            for (i = 0; i < drawCallsCount; i++) {
                drawCall = drawCalls[i];
                if (!drawCall.command) {
                    if (!drawCall.visible) continue; // use visible property to quickly hide/show meshInstances
                    visible = true;

                    // if the object's mask AND the camera's cullingMask is zero then the game object will be invisible from the camera
                    if (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;

                    if (drawCall.cull) {
                        visible = this._isVisible(camera, drawCall);
                    }

                    if (visible) {
                        visibleList[visibleLength] = drawCall;
                        visibleLength++;
                        drawCall.visibleThisFrame = true;
                    }
                } else {
                    visibleList[visibleLength] = drawCall;
                    visibleLength++;
                    drawCall.visibleThisFrame = true;
                }
            }


            return visibleLength;
        },

        cullLights: function (camera, lights) {
            var i, light, type;
            for (i = 0; i < lights.length; i++) {
                light = lights[i];
                type = light._type;
                if (light.castShadows && light.enabled && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
                    if (type !== LIGHTTYPE_DIRECTIONAL) {
                        light.getBoundingSphere(tempSphere);
                        if (!camera.frustum.containsSphere(tempSphere)) continue;
                        light.visibleThisFrame = true;
                    }
                }
            }
        },

        updateCpuSkinMatrices: function (drawCalls) {
            var drawCallsCount = drawCalls.length;
            if (drawCallsCount === 0) return;


            var i, skin;
            for (i = 0; i < drawCallsCount; i++) {
                skin = drawCalls[i].skinInstance;
                if (skin) {
                    skin.updateMatrices(drawCalls[i].node);
                    skin._dirty = true;
                }
            }

        },

        updateGpuSkinMatrices: function (drawCalls) {

            var i, skin;
            var drawCallsCount = drawCalls.length;
            for (i = 0; i < drawCallsCount; i++) {
                if (!drawCalls[i].visibleThisFrame) continue;
                skin = drawCalls[i].skinInstance;
                if (skin) {
                    if (skin._dirty) {
                        skin.updateMatrixPalette();
                        skin._dirty = false;
                    }
                }
            }

        },

        updateMorphing: function (drawCalls) {

            var i, morph;
            var drawCallsCount = drawCalls.length;
            for (i = 0; i < drawCallsCount; i++) {
                morph = drawCalls[i].morphInstance;
                if (morph && morph._dirty && drawCalls[i].visibleThisFrame) {
                    morph.update();
                    morph._dirty = false;
                }
            }
        },

        setBaseConstants: function (device, material) {
            // Cull mode
            device.setCullMode(material.cull);
            // Alpha test
            if (material.opacityMap) {
                this.opacityMapId.setValue(material.opacityMap);
                this.alphaTestId.setValue(material.alphaTest);
            }
        },

        setSkinning: function (device, meshInstance, material) {
            if (meshInstance.skinInstance) {
                this._skinDrawCalls++;
                if (device.supportsBoneTextures) {
                    boneTexture = meshInstance.skinInstance.boneTexture;
                    this.boneTextureId.setValue(boneTexture);
                    boneTextureSize[0] = boneTexture.width;
                    boneTextureSize[1] = boneTexture.height;
                    this.boneTextureSizeId.setValue(boneTextureSize);
                } else {
                    this.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);
                }
            }
        },

        // returns number of extra draw calls to skip - used to skip auto instanced meshes draw calls. by default return 0 to not skip any additional draw calls
        drawInstance: function (device, meshInstance, mesh, style, normal) {
            instancingData = meshInstance.instancingData;
            if (instancingData) {
                if (instancingData.count > 0) {
                    this._instancedDrawCalls++;
                    this._removedByInstancing += instancingData.count;
                    device.setVertexBuffer(instancingData.vertexBuffer, 1, instancingData.offset);
                    device.draw(mesh.primitive[style], instancingData.count);
                    if (instancingData.vertexBuffer === _autoInstanceBuffer) {
                        meshInstance.instancingData = null;
                        return instancingData.count - 1;
                    }
                }
            } else {
                modelMatrix = meshInstance.node.worldTransform;
                this.modelMatrixId.setValue(modelMatrix.data);

                if (normal) {
                    normalMatrix = meshInstance.node.normalMatrix;
                    if (meshInstance.node._dirtyNormal) {
                        modelMatrix.invertTo3x3(normalMatrix);
                        normalMatrix.transpose();
                        meshInstance.node._dirtyNormal = false;
                    }
                    this.normalMatrixId.setValue(normalMatrix.data);
                }

                device.draw(mesh.primitive[style]);
            }
            return 0;
        },

        // used for stereo
        drawInstance2: function (device, meshInstance, mesh, style) {
            instancingData = meshInstance.instancingData;
            if (instancingData) {
                if (instancingData.count > 0) {
                    this._instancedDrawCalls++;
                    this._removedByInstancing += instancingData.count;
                    device.setVertexBuffer(instancingData.vertexBuffer, 1, instancingData.offset);
                    device.draw(mesh.primitive[style], instancingData.count);
                    if (instancingData.vertexBuffer === _autoInstanceBuffer) {
                        meshInstance.instancingData = null;
                        return instancingData.count - 1;
                    }
                }
            } else {
                // matrices are already set
                device.draw(mesh.primitive[style]);
            }
            return 0;
        },

        renderShadows: function (lights, cameraPass) {
            var device = this.device;
            var i, j, light, shadowShader, type, shadowCam, shadowCamNode, pass, passes, shadowType, smode;
            var numInstances;
            var meshInstance, mesh, material;
            var style;
            var settings;
            var visibleList, visibleLength;

            var passFlag = 1 << SHADER_SHADOW;
            var paramName, parameter, parameters;

            for (i = 0; i < lights.length; i++) {
                light = lights[i];
                type = light._type;

                if (!light.castShadows || !light.enabled) continue;

                if (!light._shadowCamera) {
                    this.getShadowCamera(device, light); // fix accessing non-existing shadow map/camera when the light was created/applied, but shadowmap was never initialized
                }

                if (light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {
                    var cameraPos;
                    shadowCam = this.getShadowCamera(device, light);
                    shadowCamNode = shadowCam._node;
                    pass = 0;
                    passes = 1;

                    if (type === LIGHTTYPE_DIRECTIONAL) {
                        if (light._visibleLength[cameraPass] < 0) continue; // prevent light from rendering more than once for this camera
                        settings = light._visibleCameraSettings[cameraPass];
                        shadowCamNode.setPosition(settings.x, settings.y, settings.z);
                        shadowCam.orthoHeight = settings.orthoHeight;
                        shadowCam.farClip = settings.farClip;
                        pass = cameraPass;

                    } else if (type === LIGHTTYPE_SPOT) {
                        cameraPos = shadowCamNode.getPosition();
                        this.viewPos[0] = cameraPos.x;
                        this.viewPos[1] = cameraPos.y;
                        this.viewPos[2] = cameraPos.z;
                        this.viewPosId.setValue(this.viewPos);
                        this.shadowMapLightRadiusId.setValue(light.attenuationEnd);

                    } else if (type === LIGHTTYPE_POINT) {
                        cameraPos = shadowCamNode.getPosition();
                        this.viewPos[0] = cameraPos.x;
                        this.viewPos[1] = cameraPos.y;
                        this.viewPos[2] = cameraPos.z;
                        this.viewPosId.setValue(this.viewPos);
                        this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
                        passes = 6;

                    }


                    if (type !== LIGHTTYPE_POINT) {
                        shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
                        shadowCamViewProj.mul2(shadowCam.getProjectionMatrix(), shadowCamView);
                        light._shadowMatrix.mul2(scaleShift, shadowCamViewProj);
                    }

                    if (device.webgl2) {
                        if (type === LIGHTTYPE_POINT) {
                            device.setDepthBias(false);
                        } else {
                            device.setDepthBias(true);
                            device.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);
                        }
                    } else if (device.extStandardDerivatives) {
                        if (type === LIGHTTYPE_POINT) {
                            this.polygonOffset[0] = 0;
                            this.polygonOffset[1] = 0;
                            this.polygonOffsetId.setValue(this.polygonOffset);
                        } else {
                            this.polygonOffset[0] = light.shadowBias * -1000.0;
                            this.polygonOffset[1] = light.shadowBias * -1000.0;
                            this.polygonOffsetId.setValue(this.polygonOffset);
                        }
                    }

                    if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) light.shadowUpdateMode = SHADOWUPDATE_NONE;

                    this._shadowMapUpdates += passes;

                    // Set standard shadowmap states
                    device.setBlending(false);
                    device.setDepthWrite(true);
                    device.setDepthTest(true);
                    if (light._isPcf && device.webgl2 && type !== LIGHTTYPE_POINT) {
                        device.setColorWrite(false, false, false, false);
                    } else {
                        device.setColorWrite(true, true, true, true);
                    }

                    if (pass) {
                        passes = pass + 1; // predefined single pass
                    } else {
                        pass = 0; // point light passes
                    }

                    while (pass < passes) {


                        if (type === LIGHTTYPE_POINT) {
                            shadowCamNode.setRotation(pointLightRotations[pass]);
                            shadowCam.renderTarget = light._shadowCubeMap[pass];
                        }

                        this.setCamera(shadowCam, shadowCam.renderTarget, true, type !== LIGHTTYPE_POINT);

                        visibleList = light._visibleList[pass];
                        visibleLength = light._visibleLength[pass];

                        // Sort shadow casters
                        shadowType = light._shadowType;
                        smode = shadowType + type * numShadowModes;

                        // Render
                        for (j = 0, numInstances = visibleLength; j < numInstances; j++) {
                            meshInstance = visibleList[j];
                            mesh = meshInstance.mesh;
                            material = meshInstance.material;

                            // set basic material states/parameters
                            this.setBaseConstants(device, material);
                            this.setSkinning(device, meshInstance, material);

                            if (material.dirty) {
                                material.updateUniforms();
                                material.dirty = false;
                            }

                            if (material.chunks) {
                                // Uniforms I (shadow): material
                                parameters = material.parameters;
                                for (paramName in parameters) {
                                    parameter = parameters[paramName];
                                    if (parameter.passFlags & passFlag) {
                                        if (!parameter.scopeId) {
                                            parameter.scopeId = device.scope.resolve(paramName);
                                        }
                                        parameter.scopeId.setValue(parameter.data);
                                    }
                                }
                                this.setCullMode(true, false, meshInstance);

                                // Uniforms II (shadow): meshInstance overrides
                                parameters = meshInstance.parameters;
                                for (paramName in parameters) {
                                    parameter = parameters[paramName];
                                    if (parameter.passFlags & passFlag) {
                                        if (!parameter.scopeId) {
                                            parameter.scopeId = device.scope.resolve(paramName);
                                        }
                                        parameter.scopeId.setValue(parameter.data);
                                    }
                                }
                            }

                            // set shader
                            shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
                            if (!shadowShader) {
                                this.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);
                                shadowShader = meshInstance._shader[SHADER_SHADOW + smode];
                                meshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);
                            }
                            device.setShader(shadowShader);
                            // set buffers
                            style = meshInstance.renderStyle;

                            this.setVertexBuffers(device, mesh, meshInstance.morphInstance);

                            device.setIndexBuffer(mesh.indexBuffer[style]);
                            // draw
                            j += this.drawInstance(device, meshInstance, mesh, style);
                            this._shadowDrawCalls++;
                        }
                        pass++;
                        if (type === LIGHTTYPE_DIRECTIONAL) light._visibleLength[cameraPass] = -1; // prevent light from rendering more than once for this camera


                    } // end pass

                    if (light._isVsm) {


                        var filterSize = light._vsmBlurSize;
                        if (filterSize > 1) {
                            var origShadowMap = shadowCam.renderTarget;
                            var tempRt = getShadowMapFromCache(device, light._shadowResolution, light._shadowType, 1);

                            var isVsm8 = light._shadowType === SHADOW_VSM8;
                            var blurMode = light.vsmBlurMode;
                            var blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];
                            if (!blurShader) {
                                this.blurVsmWeights[filterSize] = gaussWeights(filterSize);

                                var blurVS = shaderChunks.fullscreenQuadVS;
                                var blurFS = "#define SAMPLES " + filterSize + "\n";
                                if (isVsm8) {
                                    blurFS += this.blurPackedVsmShaderCode[blurMode];
                                } else {
                                    blurFS += this.blurVsmShaderCode[blurMode];
                                }
                                var blurShaderName = "blurVsm" + blurMode + "" + filterSize + "" + isVsm8;
                                blurShader = shaderChunks.createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);

                                if (isVsm8) {
                                    this.blurPackedVsmShader[blurMode][filterSize] = blurShader;
                                } else {
                                    this.blurVsmShader[blurMode][filterSize] = blurShader;
                                }
                            }

                            blurScissorRect.z = light._shadowResolution - 2;
                            blurScissorRect.w = blurScissorRect.z;

                            // Blur horizontal
                            this.sourceId.setValue(origShadowMap.colorBuffer);
                            pixelOffset[0] = 1 / light._shadowResolution;
                            pixelOffset[1] = 0;
                            this.pixelOffsetId.setValue(pixelOffset);
                            if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
                            drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);

                            // Blur vertical
                            this.sourceId.setValue(tempRt.colorBuffer);
                            pixelOffset[1] = pixelOffset[0];
                            pixelOffset[0] = 0;
                            this.pixelOffsetId.setValue(pixelOffset);
                            drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
                        }

                    }

                }
            }

            if (device.webgl2) {
                device.setDepthBias(false);
            } else if (device.extStandardDerivatives) {
                this.polygonOffset[0] = 0;
                this.polygonOffset[1] = 0;
                this.polygonOffsetId.setValue(this.polygonOffset);
            }

        },

        updateShader: function (meshInstance, objDefs, staticLightList, pass, sortedLights) {
            meshInstance.material._scene = this.scene;
            meshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);
            meshInstance._shader[pass] = meshInstance.material.shader;
        },

        setCullMode: function (cullFaces, flip, drawCall) {
            var material = drawCall.material;
            var mode = CULLFACE_NONE;
            if (cullFaces) {
                var flipFaces = 1;

                if (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {
                    if (drawCall.flipFaces)
                        flipFaces *= -1;

                    if (flip)
                        flipFaces *= -1;

                    var wt = drawCall.node.worldTransform;
                    wt.getX(worldMatX$1);
                    wt.getY(worldMatY$1);
                    wt.getZ(worldMatZ$1);
                    worldMatX$1.cross(worldMatX$1, worldMatY$1);
                    if (worldMatX$1.dot(worldMatZ$1) < 0)
                        flipFaces *= -1;
                }

                if (flipFaces < 0) {
                    mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
                } else {
                    mode = material.cull;
                }
            }
            this.device.setCullMode(mode);
        },

        setVertexBuffers: function (device, mesh, morphInstance) {

            // morphing vertex attributes
            if (morphInstance) {
                this.tempSemanticArray.length = 0;
                var tempVertexBuffer;
                for (var t = 0; t < morphInstance._activeVertexBuffers.length; t++) {

                    var semantic = SEMANTIC_ATTR + t;
                    tempVertexBuffer = morphInstance._activeVertexBuffers[t];

                    if (tempVertexBuffer) {
                        // patch semantic for the buffer to current ATTR slot
                        tempVertexBuffer.format.elements[0].name = semantic;
                        tempVertexBuffer.format.elements[0].scopeId = device.scope.resolve(semantic);

                        device.setVertexBuffer(tempVertexBuffer, t + 1);
                    } else {
                        // for null morph buffers set attributes to default constant value
                        device.setVertexBuffer(null, t + 1);
                        this.tempSemanticArray.push(semantic);
                    }
                }

                if (this.tempSemanticArray.length)
                    device.disableVertexBufferElements(this.tempSemanticArray);

                // set all 8 weights
                this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);
                this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);
            }

            // main vertex buffer
            device.setVertexBuffer(mesh.vertexBuffer, 0);
        },

        renderForward: function (camera, drawCalls, drawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer) {
            var device = this.device;
            var scene = this.scene;
            var vrDisplay = camera.vrDisplay;
            var passFlag = 1 << pass;

            var lightHash = layer ? layer._lightHash : 0;


            var i, drawCall, mesh, material, objDefs, variantKey, lightMask, style, usedDirLights;
            var prevMaterial = null, prevObjDefs, prevLightMask, prevStatic;
            var paramName, parameter, parameters;
            var stencilFront, stencilBack;

            var halfWidth = device.width * 0.5;

            // Render the scene
            for (i = 0; i < drawCallsCount; i++) {

                drawCall = drawCalls[i];
                if (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue; // apply visibility override

                if (drawCall.command) {
                    // We have a command
                    drawCall.command();
                } else {


                    // We have a mesh instance
                    mesh = drawCall.mesh;
                    material = drawCall.material;
                    objDefs = drawCall._shaderDefs;
                    lightMask = drawCall.mask;

                    this.setSkinning(device, drawCall, material);

                    if (material && material === prevMaterial && objDefs !== prevObjDefs) {
                        prevMaterial = null; // force change shader if the object uses a different variant of the same material
                    }

                    if (drawCall.isStatic || prevStatic) {
                        prevMaterial = null;
                    }

                    if (material !== prevMaterial) {
                        this._materialSwitches++;

                        if (material.dirty) {
                            material.updateUniforms();
                            material.dirty = false;
                        }

                        if (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {
                            if (!drawCall.isStatic) {
                                variantKey = pass + "_" + objDefs + "_" + lightHash;
                                drawCall._shader[pass] = material.variants[variantKey];
                                if (!drawCall._shader[pass]) {
                                    this.updateShader(drawCall, objDefs, null, pass, sortedLights);
                                    material.variants[variantKey] = drawCall._shader[pass];
                                }
                            } else {
                                this.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);
                            }
                            drawCall._shaderDefs = objDefs;
                            drawCall._lightHash = lightHash;
                        }

                        device.setShader(drawCall._shader[pass]);

                        // Uniforms I: material
                        parameters = material.parameters;
                        for (paramName in parameters) {
                            parameter = parameters[paramName];
                            if (parameter.passFlags & passFlag) {
                                if (!parameter.scopeId) {
                                    parameter.scopeId = device.scope.resolve(paramName);
                                }
                                parameter.scopeId.setValue(parameter.data);
                            }
                        }

                        if (!prevMaterial || lightMask !== prevLightMask) {
                            usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask);
                            this.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);
                        }

                        this.alphaTestId.setValue(material.alphaTest);

                        device.setBlending(material.blend);
                        if (material.blend) {
                            if (material.separateAlphaBlend) {
                                device.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
                                device.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);
                            } else {
                                device.setBlendFunction(material.blendSrc, material.blendDst);
                                device.setBlendEquation(material.blendEquation);
                            }
                        }
                        device.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
                        device.setDepthWrite(material.depthWrite);
                        device.setDepthTest(material.depthTest);
                        device.setAlphaToCoverage(material.alphaToCoverage);

                        if (material.depthBias || material.slopeDepthBias) {
                            device.setDepthBias(true);
                            device.setDepthBiasValues(material.depthBias, material.slopeDepthBias);
                        } else {
                            device.setDepthBias(false);
                        }
                    }

                    this.setCullMode(camera._cullFaces, camera._flipFaces, drawCall);

                    stencilFront = drawCall.stencilFront || material.stencilFront;
                    stencilBack = drawCall.stencilBack || material.stencilBack;

                    if (stencilFront || stencilBack) {
                        device.setStencilTest(true);
                        if (stencilFront === stencilBack) {
                            // identical front/back stencil
                            device.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
                            device.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
                        } else {
                            // separate
                            if (stencilFront) {
                                // set front
                                device.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
                                device.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
                            } else {
                                // default front
                                device.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);
                                device.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
                            }
                            if (stencilBack) {
                                // set back
                                device.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
                                device.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
                            } else {
                                // default back
                                device.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);
                                device.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);
                            }
                        }
                    } else {
                        device.setStencilTest(false);
                    }

                    // Uniforms II: meshInstance overrides
                    parameters = drawCall.parameters;
                    for (paramName in parameters) {
                        parameter = parameters[paramName];
                        if (parameter.passFlags & passFlag) {
                            if (!parameter.scopeId) {
                                parameter.scopeId = device.scope.resolve(paramName);
                            }
                            parameter.scopeId.setValue(parameter.data);
                        }
                    }

                    this.setVertexBuffers(device, mesh, drawCall.morphInstance);

                    style = drawCall.renderStyle;
                    device.setIndexBuffer(mesh.indexBuffer[style]);

                    if (drawCallback) {
                        drawCallback(drawCall, i);
                    }

                    if (vrDisplay && vrDisplay.presenting) {
                        // Left
                        device.setViewport(0, 0, halfWidth, device.height);
                        this.projId.setValue(projL.data);
                        this.projSkyboxId.setValue(projL.data);
                        this.viewInvId.setValue(viewInvL.data);
                        this.viewId.setValue(viewL.data);
                        this.viewId3.setValue(viewMat3L.data);
                        this.viewProjId.setValue(viewProjMatL.data);
                        this.viewPos[0] = viewPosL.x;
                        this.viewPos[1] = viewPosL.y;
                        this.viewPos[2] = viewPosL.z;
                        this.viewPosId.setValue(this.viewPos);
                        i += this.drawInstance(device, drawCall, mesh, style, true);
                        this._forwardDrawCalls++;

                        // Right
                        device.setViewport(halfWidth, 0, halfWidth, device.height);
                        this.projId.setValue(projR.data);
                        this.projSkyboxId.setValue(projR.data);
                        this.viewInvId.setValue(viewInvR.data);
                        this.viewId.setValue(viewR.data);
                        this.viewId3.setValue(viewMat3R.data);
                        this.viewProjId.setValue(viewProjMatR.data);
                        this.viewPos[0] = viewPosR.x;
                        this.viewPos[1] = viewPosR.y;
                        this.viewPos[2] = viewPosR.z;
                        this.viewPosId.setValue(this.viewPos);
                        i += this.drawInstance2(device, drawCall, mesh, style);
                        this._forwardDrawCalls++;
                    } else if (camera.xr && camera.xr.session && camera.xr.views.length) {
                        var views = camera.xr.views;

                        for (var v = 0; v < views.length; v++) {
                            var view = views[v];

                            device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);

                            this.projId.setValue(view.projMat.data);
                            this.projSkyboxId.setValue(view.projMat.data);
                            this.viewId.setValue(view.viewOffMat.data);
                            this.viewInvId.setValue(view.viewInvOffMat.data);
                            this.viewId3.setValue(view.viewMat3.data);
                            this.viewProjId.setValue(view.projViewOffMat.data);
                            this.viewPosId.setValue(view.position);

                            if (v === 0) {
                                i += this.drawInstance(device, drawCall, mesh, style, true);
                            } else {
                                i += this.drawInstance2(device, drawCall, mesh, style, true);
                            }

                            this._forwardDrawCalls++;
                        }
                    } else {
                        i += this.drawInstance(device, drawCall, mesh, style, true);
                        this._forwardDrawCalls++;
                    }

                    // Unset meshInstance overrides back to material values if next draw call will use the same material
                    if (i < drawCallsCount - 1 && drawCalls[i + 1].material === material) {
                        for (paramName in parameters) {
                            parameter = material.parameters[paramName];
                            if (parameter) {
                                if (!parameter.scopeId) {
                                    parameter.scopeId = device.scope.resolve(paramName);
                                }
                                parameter.scopeId.setValue(parameter.data);
                            }
                        }
                    }

                    prevMaterial = material;
                    prevObjDefs = objDefs;
                    prevLightMask = lightMask;
                    prevStatic = drawCall.isStatic;
                }
            }
            device.updateEnd();

        },

        setupInstancing: function (device) {
            if (device.enableAutoInstancing) {
                if (!_autoInstanceBuffer) {
                    _autoInstanceBuffer = new VertexBuffer(device, VertexFormat.defaultInstancingFormat, device.autoInstancingMaxObjects, BUFFER_DYNAMIC);
                }
            }
        },

        revertStaticMeshes: function (meshInstances) {
            var i;
            var drawCalls = meshInstances;
            var drawCallsCount = drawCalls.length;
            var drawCall;
            var newDrawCalls = [];

            var prevStaticSource;
            for (i = 0; i < drawCallsCount; i++) {
                drawCall = drawCalls[i];
                if (drawCall._staticSource) {
                    if (drawCall._staticSource !== prevStaticSource) {
                        newDrawCalls.push(drawCall._staticSource);
                        prevStaticSource = drawCall._staticSource;
                    }
                } else {
                    newDrawCalls.push(drawCall);
                }
            }

            // Set array to new
            meshInstances.length = newDrawCalls.length;
            for (i = 0; i < newDrawCalls.length; i++) {
                meshInstances[i] = newDrawCalls[i];
            }
        },

        prepareStaticMeshes: function (meshInstances, lights) {

            var i, j, k, v, s, index;

            var device = this.device;
            var scene = this.scene;
            var drawCalls = meshInstances;
            var drawCallsCount = drawCalls.length;
            var drawCall, light;

            var newDrawCalls = [];
            var mesh;
            var indices, verts, numTris, elems, vertSize, offsetP, baseIndex;
            var _x, _y, _z;
            var minx, miny, minz, maxx, maxy, maxz;
            var minv, maxv;
            var minVec = new Vec3();
            var maxVec = new Vec3();
            var localLightBounds = new BoundingBox();
            var invMatrix = new Mat4();
            var triLightComb = [];
            var triLightCombUsed;
            var indexBuffer, vertexBuffer;
            var combIndices, combIbName, combIb;
            var lightTypePass;
            var lightAabb = [];
            var aabb;
            var triBounds = [];
            var staticLights = [];
            var bit;
            var lht;
            for (i = 0; i < drawCallsCount; i++) {
                drawCall = drawCalls[i];
                if (!drawCall.isStatic) {
                    newDrawCalls.push(drawCall);
                } else {
                    aabb = drawCall.aabb;
                    staticLights.length = 0;
                    for (lightTypePass = LIGHTTYPE_POINT; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {
                        for (j = 0; j < lights.length; j++) {
                            light = lights[j];
                            if (light._type !== lightTypePass) continue;
                            if (light.enabled) {
                                if (light.mask & drawCall.mask) {
                                    if (light.isStatic) {
                                        if (!lightAabb[j]) {
                                            lightAabb[j] = new BoundingBox();
                                            // light.getBoundingBox(lightAabb[j]); // box from sphere seems to give better granularity
                                            light._node.getWorldTransform();
                                            light.getBoundingSphere(tempSphere);
                                            lightAabb[j].center.copy(tempSphere.center);
                                            lightAabb[j].halfExtents.x = tempSphere.radius;
                                            lightAabb[j].halfExtents.y = tempSphere.radius;
                                            lightAabb[j].halfExtents.z = tempSphere.radius;
                                        }
                                        if (!lightAabb[j].intersects(aabb)) continue;
                                        staticLights.push(j);
                                    }
                                }
                            }
                        }
                    }

                    if (staticLights.length === 0) {
                        newDrawCalls.push(drawCall);
                        continue;
                    }

                    mesh = drawCall.mesh;
                    vertexBuffer = mesh.vertexBuffer;
                    indexBuffer = mesh.indexBuffer[drawCall.renderStyle];
                    indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());
                    numTris = mesh.primitive[drawCall.renderStyle].count / 3;
                    baseIndex = mesh.primitive[drawCall.renderStyle].base;
                    elems = vertexBuffer.format.elements;
                    vertSize = vertexBuffer.format.size / 4; // / 4 because float
                    verts = new Float32Array(vertexBuffer.storage);

                    for (k = 0; k < elems.length; k++) {
                        if (elems[k].name === SEMANTIC_POSITION) {
                            offsetP = elems[k].offset / 4; // / 4 because float
                        }
                    }


                    triLightComb.length = numTris;
                    for (k = 0; k < numTris; k++) {
                        // triLightComb[k] = ""; // uncomment to remove 32 lights limit
                        triLightComb[k] = 0; // comment to remove 32 lights limit
                    }
                    triLightCombUsed = false;

                    triBounds.length = numTris * 6;
                    for (k = 0; k < numTris; k++) {
                        minx = Number.MAX_VALUE;
                        miny = Number.MAX_VALUE;
                        minz = Number.MAX_VALUE;
                        maxx = -Number.MAX_VALUE;
                        maxy = -Number.MAX_VALUE;
                        maxz = -Number.MAX_VALUE;
                        for (v = 0; v < 3; v++) {
                            index = indices[k * 3 + v + baseIndex];
                            index = index * vertSize + offsetP;
                            _x = verts[index];
                            _y = verts[index + 1];
                            _z = verts[index + 2];
                            if (_x < minx) minx = _x;
                            if (_y < miny) miny = _y;
                            if (_z < minz) minz = _z;
                            if (_x > maxx) maxx = _x;
                            if (_y > maxy) maxy = _y;
                            if (_z > maxz) maxz = _z;
                        }
                        index = k * 6;
                        triBounds[index] = minx;
                        triBounds[index + 1] = miny;
                        triBounds[index + 2] = minz;
                        triBounds[index + 3] = maxx;
                        triBounds[index + 4] = maxy;
                        triBounds[index + 5] = maxz;
                    }

                    for (s = 0; s < staticLights.length; s++) {
                        j = staticLights[s];
                        light = lights[j];

                        invMatrix.copy(drawCall.node.worldTransform).invert();
                        localLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);
                        minv = localLightBounds.getMin();
                        maxv = localLightBounds.getMax();
                        bit = 1 << s;

                        for (k = 0; k < numTris; k++) {
                            index = k * 6;
                            if ((triBounds[index] <= maxv.x) && (triBounds[index + 3] >= minv.x) &&
                                (triBounds[index + 1] <= maxv.y) && (triBounds[index + 4] >= minv.y) &&
                                (triBounds[index + 2] <= maxv.z) && (triBounds[index + 5] >= minv.z)) {

                                // triLightComb[k] += j + "_";  // uncomment to remove 32 lights limit
                                triLightComb[k] |= bit; // comment to remove 32 lights limit
                                triLightCombUsed = true;
                            }
                        }
                    }

                    if (triLightCombUsed) {


                        combIndices = {};
                        for (k = 0; k < numTris; k++) {
                            j = k * 3 + baseIndex; // can go beyond 0xFFFF if base was non-zero?
                            combIbName = triLightComb[k];
                            if (!combIndices[combIbName]) combIndices[combIbName] = [];
                            combIb = combIndices[combIbName];
                            combIb.push(indices[j]);
                            combIb.push(indices[j + 1]);
                            combIb.push(indices[j + 2]);
                        }



                        for (combIbName in combIndices) {
                            combIb = combIndices[combIbName];
                            var ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);
                            var ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());
                            ib2.set(combIb);
                            ib.unlock();

                            minx = Number.MAX_VALUE;
                            miny = Number.MAX_VALUE;
                            minz = Number.MAX_VALUE;
                            maxx = -Number.MAX_VALUE;
                            maxy = -Number.MAX_VALUE;
                            maxz = -Number.MAX_VALUE;
                            for (k = 0; k < combIb.length; k++) {
                                index = combIb[k];
                                _x = verts[index * vertSize + offsetP];
                                _y = verts[index * vertSize + offsetP + 1];
                                _z = verts[index * vertSize + offsetP + 2];
                                if (_x < minx) minx = _x;
                                if (_y < miny) miny = _y;
                                if (_z < minz) minz = _z;
                                if (_x > maxx) maxx = _x;
                                if (_y > maxy) maxy = _y;
                                if (_z > maxz) maxz = _z;
                            }
                            minVec.set(minx, miny, minz);
                            maxVec.set(maxx, maxy, maxz);
                            var chunkAabb = new BoundingBox();
                            chunkAabb.setMinMax(minVec, maxVec);

                            var mesh2 = new Mesh(device);
                            mesh2.vertexBuffer = vertexBuffer;
                            mesh2.indexBuffer[0] = ib;
                            mesh2.primitive[0].type = PRIMITIVE_TRIANGLES;
                            mesh2.primitive[0].base = 0;
                            mesh2.primitive[0].count = combIb.length;
                            mesh2.primitive[0].indexed = true;
                            mesh2.aabb = chunkAabb;

                            var instance = new MeshInstance(drawCall.node, mesh2, drawCall.material);
                            instance.isStatic = drawCall.isStatic;
                            instance.visible = drawCall.visible;
                            instance.layer = drawCall.layer;
                            instance.castShadow = drawCall.castShadow;
                            instance._receiveShadow = drawCall._receiveShadow;
                            instance.cull = drawCall.cull;
                            instance.pick = drawCall.pick;
                            instance.mask = drawCall.mask;
                            instance.parameters = drawCall.parameters;
                            instance._shaderDefs = drawCall._shaderDefs;
                            instance._staticSource = drawCall;

                            if (drawCall._staticLightList) {
                                instance._staticLightList = drawCall._staticLightList; // add forced assigned lights
                            } else {
                                instance._staticLightList = [];
                            }

                            // uncomment to remove 32 lights limit
                            // var lnames = combIbName.split("_");
                            // lnames.length = lnames.length - 1;
                            // for(k = 0; k < lnames.length; k++) {
                            //     instance._staticLightList[k] = lights[parseInt(lnames[k])];
                            // }

                            // comment to remove 32 lights limit
                            for (k = 0; k < staticLights.length; k++) {
                                bit = 1 << k;
                                if (combIbName & bit) {
                                    lht = lights[staticLights[k]];
                                    if (instance._staticLightList.indexOf(lht) < 0) {
                                        instance._staticLightList.push(lht);
                                    }
                                }
                            }

                            instance._staticLightList.sort(this.lightCompare);

                            newDrawCalls.push(instance);
                        }

                    } else {
                        newDrawCalls.push(drawCall);
                    }
                }
            }
            // Set array to new
            meshInstances.length = newDrawCalls.length;
            for (i = 0; i < newDrawCalls.length; i++) {
                meshInstances[i] = newDrawCalls[i];
            }
        },

        updateShaders: function (drawCalls) {

            var i;
            // Collect materials
            var materials = [];
            for (i = 0; i < drawCalls.length; i++) {
                var drawCall = drawCalls[i];
                if (drawCall.material !== undefined) {
                    if (materials.indexOf(drawCall.material) === -1) {
                        materials.push(drawCall.material);
                    }
                }
            }
            // Clear material shaders
            for (i = 0; i < materials.length; i++) {
                var mat = materials[i];
                if (mat.updateShader !== Material.prototype.updateShader) {
                    mat.clearVariants();
                    mat.shader = null;
                }
            }

        },

        updateLitShaders: function (drawCalls) {

            for (var i = 0; i < drawCalls.length; i++) {
                var drawCall = drawCalls[i];
                if (drawCall.material !== undefined) {
                    var mat = drawCall.material;
                    if (mat.updateShader !== Material.prototype.updateShader) {
                        if (mat.useLighting === false || (mat.emitter && !mat.emitter.lighting)) {
                            // skip unlit standard and particles materials
                            continue;
                        }
                        mat.clearVariants();
                        mat.shader = null;
                    }
                }
            }

        },

        beginFrame: function (comp) {
            var scene = this.scene;
            var meshInstances = comp._meshInstances;
            var lights = comp._lights;

            // Update shaders if needed
            // all mesh instances (TODO: ideally can update less if only lighting changed)
            if (scene.updateShaders) {
                this.updateShaders(meshInstances);
                scene.updateShaders = false;
                scene.updateLitShaders = false;
                scene._shaderVersion++;
            } else if (scene.updateLitShaders) {
                this.updateLitShaders(meshInstances);
                scene.updateLitShaders = false;
                scene._shaderVersion++;
            }

            // Update all skin matrices to properly cull skinned objects (but don't update rendering data yet)
            this.updateCpuSkinMatrices(meshInstances);

            var i;
            var len = meshInstances.length;
            for (i = 0; i < len; i++) {
                meshInstances[i].visibleThisFrame = false;
            }

            len = lights.length;
            for (i = 0; i < len; i++) {
                lights[i].visibleThisFrame = lights[i]._type === LIGHTTYPE_DIRECTIONAL;
            }
        },

        beginLayers: function (comp) {
            var scene = this.scene;
            var len = comp.layerList.length;
            var layer;
            var i, j;
            var shaderVersion = this.scene._shaderVersion;
            for (i = 0; i < len; i++) {
                comp.layerList[i]._postRenderCounter = 0;
            }
            var transparent;
            for (i = 0; i < len; i++) {
                layer = comp.layerList[i];
                layer._shaderVersion = shaderVersion;

                layer._preRenderCalledForCameras = 0;
                layer._postRenderCalledForCameras = 0;
                transparent = comp.subLayerList[i];
                if (transparent) {
                    layer._postRenderCounter |= 2;
                } else {
                    layer._postRenderCounter |= 1;
                }
                layer._postRenderCounterMax = layer._postRenderCounter;

                for (j = 0; j < layer.cameras.length; j++) {
                    // Create visible arrays for every camera inside each layer if not present
                    if (!layer.instances.visibleOpaque[j]) layer.instances.visibleOpaque[j] = new VisibleInstanceList();
                    if (!layer.instances.visibleTransparent[j]) layer.instances.visibleTransparent[j] = new VisibleInstanceList();
                    // Mark visible arrays as not processed yet
                    layer.instances.visibleOpaque[j].done = false;
                    layer.instances.visibleTransparent[j].done = false;
                }

                // remove visible lists if cameras have been removed, remove one per frame
                if (layer.cameras.length < layer.instances.visibleOpaque.length) {
                    layer.instances.visibleOpaque.splice(layer.cameras.length, 1);
                }

                if (layer.cameras.length < layer.instances.visibleTransparent.length) {
                    layer.instances.visibleTransparent.splice(layer.cameras.length, 1);
                }

                // Generate static lighting for meshes in this layer if needed
                if (layer._needsStaticPrepare && layer._staticLightHash) {
                    // TODO: reuse with the same staticLightHash
                    if (layer._staticPrepareDone) {
                        this.revertStaticMeshes(layer.opaqueMeshInstances);
                        this.revertStaticMeshes(layer.transparentMeshInstances);
                    }
                    this.prepareStaticMeshes(layer.opaqueMeshInstances, layer._lights);
                    this.prepareStaticMeshes(layer.transparentMeshInstances, layer._lights);
                    comp._dirty = true;
                    scene.updateShaders = true;
                    layer._needsStaticPrepare = false;
                    layer._staticPrepareDone = true;
                }
            }
        },

        cullLocalShadowmap: function (light, drawCalls) {
            var i, type, shadowCam, shadowCamNode, passes, pass, numInstances, meshInstance, visibleList, vlen, visible;
            var lightNode;
            type = light._type;
            if (type === LIGHTTYPE_DIRECTIONAL) return;
            light.visibleThisFrame = true; // force light visibility if function was manually called

            shadowCam = this.getShadowCamera(this.device, light);

            shadowCam.projection = PROJECTION_PERSPECTIVE;
            shadowCam.nearClip = light.attenuationEnd / 1000;
            shadowCam.farClip = light.attenuationEnd;
            shadowCam.aspectRatio = 1;
            if (type === LIGHTTYPE_SPOT) {
                shadowCam.fov = light._outerConeAngle * 2;
                passes = 1;
            } else {
                shadowCam.fov = 90;
                passes = 6;
            }
            shadowCamNode = shadowCam._node;
            lightNode = light._node;
            shadowCamNode.setPosition(lightNode.getPosition());
            if (type === LIGHTTYPE_SPOT) {
                shadowCamNode.setRotation(lightNode.getRotation());
                shadowCamNode.rotateLocal(-90, 0, 0); // Camera's look down negative Z, and directional lights point down negative Y // TODO: remove eulers
            }

            for (pass = 0; pass < passes; pass++) {
                if (type === LIGHTTYPE_POINT) {
                    shadowCamNode.setRotation(pointLightRotations[pass]);
                    shadowCam.renderTarget = light._shadowCubeMap[pass];
                }

                this.updateCameraFrustum(shadowCam);

                visibleList = light._visibleList[pass];
                if (!visibleList) {
                    visibleList = light._visibleList[pass] = [];
                }
                light._visibleLength[pass] = 0;
                vlen = 0;
                for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
                    meshInstance = drawCalls[i];
                    visible = true;
                    if (meshInstance.cull) {
                        visible = this._isVisible(shadowCam, meshInstance);
                    }
                    if (visible) {
                        visibleList[vlen] = meshInstance;
                        vlen++;
                        meshInstance.visibleThisFrame = true;
                    }
                }
                light._visibleLength[pass] = vlen;

                if (visibleList.length !== vlen) {
                    visibleList.length = vlen;
                }
                visibleList.sort(this.depthSortCompare); // sort shadowmap drawcalls here, not in render
            }
        },


        cullDirectionalShadowmap: function (light, drawCalls, camera, pass) {
            var i, shadowCam, shadowCamNode, lightNode, frustumSize, vlen, visibleList;
            var unitPerTexel, delta, p;
            var minx, miny, minz, maxx, maxy, maxz, centerx, centery;
            var visible, numInstances;
            var meshInstance;
            var emptyAabb;
            var drawCallAabb;
            var device = this.device;
            light.visibleThisFrame = true; // force light visibility if function was manually called

            shadowCam = this.getShadowCamera(device, light);
            shadowCamNode = shadowCam._node;
            lightNode = light._node;

            shadowCamNode.setPosition(lightNode.getPosition());
            shadowCamNode.setRotation(lightNode.getRotation());
            shadowCamNode.rotateLocal(-90, 0, 0); // Camera's look down negative Z, and directional lights point down negative Y

            // Positioning directional light frustum I
            // Construct light's orthographic frustum around camera frustum
            // Use very large near/far planes this time

            // 1. Get the frustum of the camera
            _getFrustumPoints(camera, light.shadowDistance || camera._farClip, frustumPoints);

            // 2. Figure out the maximum diagonal of the frustum in light's projected space.
            frustumSize = frustumDiagonal.sub2( frustumPoints[0], frustumPoints[6] ).length();
            frustumSize = Math.max( frustumSize, frustumDiagonal.sub2( frustumPoints[4], frustumPoints[6] ).length() );

            // 3. Transform the 8 corners of the camera frustum into the shadow camera's view space
            shadowCamView.copy( shadowCamNode.getWorldTransform() ).invert();
            c2sc.copy( shadowCamView ).mul( camera._node.getWorldTransform() );
            for (i = 0; i < 8; i++) {
                c2sc.transformPoint(frustumPoints[i], frustumPoints[i]);
            }

            // 4. Come up with a bounding box (in light-space) by calculating the min
            // and max X, Y, and Z values from your 8 light-space frustum coordinates.
            minx = miny = minz = 1000000;
            maxx = maxy = maxz = -1000000;
            for (i = 0; i < 8; i++) {
                p = frustumPoints[i];
                if (p.x < minx) minx = p.x;
                if (p.x > maxx) maxx = p.x;
                if (p.y < miny) miny = p.y;
                if (p.y > maxy) maxy = p.y;
                if (p.z < minz) minz = p.z;
                if (p.z > maxz) maxz = p.z;
            }

            // 5. Enlarge the light's frustum so that the frustum will be the same size
            // no matter how the view frustum moves.
            // And also snap the frustum to align with shadow texel. ( Avoid shadow shimmering )
            unitPerTexel = frustumSize / light._shadowResolution;
            delta = (frustumSize - (maxx - minx)) * 0.5;
            minx = Math.floor( (minx - delta) / unitPerTexel ) * unitPerTexel;
            delta = (frustumSize - (maxy - miny)) * 0.5;
            miny = Math.floor( (miny - delta) / unitPerTexel ) * unitPerTexel;
            maxx = minx + frustumSize;
            maxy = miny + frustumSize;

            // 6. Use your min and max values to create an off-center orthographic projection.
            centerx = (maxx + minx) * 0.5;
            centery = (maxy + miny) * 0.5;
            shadowCamNode.translateLocal(centerx, centery, 100000);

            shadowCam.projection = PROJECTION_ORTHOGRAPHIC;
            shadowCam.nearClip = 0;
            shadowCam.farClip = 200000;
            shadowCam.aspectRatio = 1; // The light's frustum is a cuboid.
            shadowCam.orthoHeight = frustumSize * 0.5;

            this.updateCameraFrustum(shadowCam);

            // Cull shadow casters and find their AABB
            emptyAabb = true;
            visibleList = light._visibleList[pass];
            if (!visibleList) {
                visibleList = light._visibleList[pass] = [];
            }
            vlen = light._visibleLength[pass] = 0;

            for (i = 0, numInstances = drawCalls.length; i < numInstances; i++) {
                meshInstance = drawCalls[i];
                visible = true;
                if (meshInstance.cull) {
                    visible = this._isVisible(shadowCam, meshInstance);
                }
                if (visible) {
                    visibleList[vlen] = meshInstance;
                    vlen++;
                    meshInstance.visibleThisFrame = true;

                    drawCallAabb = meshInstance.aabb;
                    if (emptyAabb) {
                        visibleSceneAabb.copy(drawCallAabb);
                        emptyAabb = false;
                    } else {
                        visibleSceneAabb.add(drawCallAabb);
                    }
                }
            }
            light._visibleLength[pass] = vlen;

            if (visibleList.length !== vlen) {
                visibleList.length = vlen;
            }
            visibleList.sort(this.depthSortCompare); // sort shadowmap drawcalls here, not in render

            // Positioning directional light frustum II
            // Fit clipping planes tightly around visible shadow casters

            // 1. Calculate minz/maxz based on casters' AABB
            var z = _getZFromAABBSimple( shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());

            // Always use the scene's aabb's Z value
            // Otherwise object between the light and the frustum won't cast shadow.
            maxz = z.max;
            if (z.min > minz) minz = z.min;

            // 2. Fix projection
            shadowCamNode.setPosition(lightNode.getPosition());
            shadowCamNode.translateLocal(centerx, centery, maxz + directionalShadowEpsilon);
            shadowCam.farClip = maxz - minz;

            // Save projection variables to use in rendering later
            var settings = light._visibleCameraSettings[pass];
            if (!settings) {
                settings = light._visibleCameraSettings[pass] = {};
            }
            var lpos = shadowCamNode.getPosition();
            settings.x = lpos.x;
            settings.y = lpos.y;
            settings.z = lpos.z;
            settings.orthoHeight = shadowCam.orthoHeight;
            settings.farClip = shadowCam.farClip;
        },


        gpuUpdate: function (drawCalls) {
            // skip everything with visibleThisFrame === false
            this.updateGpuSkinMatrices(drawCalls);
            this.updateMorphing(drawCalls);
        },

        clearView: function (camera, target, options) {
            camera = camera.camera;
            var device = this.device;
            device.setRenderTarget(target);
            device.updateBegin();

            device.setColorWrite(true, true, true, true);
            device.setDepthWrite(true);

            var rect = camera.getRect();
            var pixelWidth = target ? target.width : device.width;
            var pixelHeight = target ? target.height : device.height;
            var x = Math.floor(rect.x * pixelWidth);
            var y = Math.floor(rect.y * pixelHeight);
            var w = Math.floor(rect.width * pixelWidth);
            var h = Math.floor(rect.height * pixelHeight);
            device.setViewport(x, y, w, h);
            device.setScissor(x, y, w, h);

            device.clear(options ? options : camera._clearOptions); // clear full RT
        },

        setSceneConstants: function () {
            var i;
            var device = this.device;
            var scene = this.scene;

            // Set up ambient/exposure
            this.dispatchGlobalLights(scene);

            // Set up the fog
            if (scene.fog !== FOG_NONE) {
                this.fogColor[0] = scene.fogColor.r;
                this.fogColor[1] = scene.fogColor.g;
                this.fogColor[2] = scene.fogColor.b;
                if (scene.gammaCorrection) {
                    for (i = 0; i < 3; i++) {
                        this.fogColor[i] = Math.pow(this.fogColor[i], 2.2);
                    }
                }
                this.fogColorId.setValue(this.fogColor);
                if (scene.fog === FOG_LINEAR) {
                    this.fogStartId.setValue(scene.fogStart);
                    this.fogEndId.setValue(scene.fogEnd);
                } else {
                    this.fogDensityId.setValue(scene.fogDensity);
                }
            }

            // Set up screen size // should be RT size?
            this._screenSize[0] = device.width;
            this._screenSize[1] = device.height;
            this._screenSize[2] = 1 / device.width;
            this._screenSize[3] = 1 / device.height;
            this.screenSizeId.setValue(this._screenSize);
        },

        renderComposition: function (comp) {
            var device = this.device;
            var camera;
            var renderedRt = comp._renderedRt;
            var renderedByCam = comp._renderedByCam;
            var renderedLayer = comp._renderedLayer;
            var i, layer, transparent, cameras, j, rt, k, processedThisCamera, processedThisCameraAndLayer, processedThisCameraAndRt;

            // update the skybox, since this might change _meshInstances
            if (this.scene.updateSkybox) {
                this.scene._updateSkybox(device);
                this.scene.updateSkybox = false;
            }

            this.beginLayers(comp);

            // Update static layer data, if something's changed
            var updated = comp._update();
            if (updated & COMPUPDATED_LIGHTS) {
                this.scene.updateLitShaders = true;
            }


            // Single per-frame calculations
            this.beginFrame(comp);
            this.setSceneConstants();

            // Camera culling (once for each camera + layer)
            // Also applies meshInstance.visible and camera.cullingMask
            var renderedLength = 0;
            var objects, drawCalls, visible;
            for (i = 0; i < comp.layerList.length; i++) {
                layer = comp.layerList[i];
                if (!layer.enabled || !comp.subLayerEnabled[i]) continue;
                transparent = comp.subLayerList[i];
                objects = layer.instances;

                cameras = layer.cameras;
                for (j = 0; j < cameras.length; j++) {
                    camera = cameras[j];
                    if (!camera) continue;
                    camera.frameBegin(layer.renderTarget);
                    drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;

                    processedThisCamera = false;
                    processedThisCameraAndLayer = false;
                    for (k = 0; k < renderedLength; k++) {
                        if (renderedByCam[k] === camera) {
                            processedThisCamera = true;
                            if (renderedLayer[k] === layer) {
                                processedThisCameraAndLayer = true;
                                break;
                            }
                        }
                    }
                    if (!processedThisCamera) {
                        this.updateCameraFrustum(camera.camera); // update camera frustum once
                        this._camerasRendered++;
                    }
                    if (!processedThisCameraAndLayer) {
                        // cull each layer's lights once with each camera
                        // lights aren't collected anywhere, but marked as visible
                        this.cullLights(camera.camera, layer._lights);
                    }
                    if (!processedThisCamera || !processedThisCameraAndLayer) {
                        renderedByCam[renderedLength] = camera;
                        renderedLayer[renderedLength] = layer;
                        renderedLength++;
                    }

                    // cull mesh instances
                    // collected into layer arrays
                    // shared objects are only culled once
                    visible = transparent ? objects.visibleTransparent[j] : objects.visibleOpaque[j];
                    if (!visible.done) {
                        if (layer.onPreCull) {
                            layer.onPreCull(j);
                        }

                        visible.length = this.cull(camera.camera, drawCalls, visible.list);
                        visible.done = true;

                        if (layer.onPostCull) {
                            layer.onPostCull(j);
                        }

                    }

                    camera.frameEnd();
                }
            }

            // Shadowmap culling for directional and visible local lights
            // collected into light._visibleList
            // objects are also globally marked as visible
            // Also sets up local shadow camera matrices
            var light, casters;

            // Local lights
            // culled once for the whole frame


            for (i = 0; i < comp._lights.length; i++) {
                light = comp._lights[i];
                if (!light.visibleThisFrame) continue;
                if (light._type === LIGHTTYPE_DIRECTIONAL) continue;
                if (!light.castShadows || !light.enabled || light.shadowUpdateMode === SHADOWUPDATE_NONE) continue;
                casters = comp._lightShadowCasters[i];
                this.cullLocalShadowmap(light, casters);
            }

            // Directional lights
            // culled once for each camera
            renderedLength = 0;
            var globalLightCounter = -1;
            for (i = 0; i < comp._lights.length; i++) {
                light = comp._lights[i];
                if (light._type !== LIGHTTYPE_DIRECTIONAL) continue;
                globalLightCounter++;
                if (!light.castShadows || !light.enabled || light.shadowUpdateMode === SHADOWUPDATE_NONE) continue;
                casters = comp._lightShadowCasters[i];
                cameras = comp._globalLightCameras[globalLightCounter];
                for (j = 0; j < cameras.length; j++) {
                    this.cullDirectionalShadowmap(light, casters, cameras[j].camera, comp._globalLightCameraIds[globalLightCounter][j]);
                }
            }


            // Can call script callbacks here and tell which objects are visible

            // GPU update for all visible objects
            this.gpuUpdate(comp._meshInstances);

            // Shadow render for all local visible culled lights
            this.renderShadows(comp._sortedLights[LIGHTTYPE_SPOT]);
            this.renderShadows(comp._sortedLights[LIGHTTYPE_POINT]);

            // Rendering
            renderedLength = 0;
            var cameraPass;
            for (i = 0; i < comp._renderList.length; i++) {
                layer = comp.layerList[comp._renderList[i]];
                if (!layer.enabled || !comp.subLayerEnabled[comp._renderList[i]]) continue;
                objects = layer.instances;
                transparent = comp.subLayerList[comp._renderList[i]];
                cameraPass = comp._renderListCamera[i];
                camera = layer.cameras[cameraPass];



                if (camera) camera.frameBegin(layer.renderTarget);

                // Call prerender callback if there's one
                if (!transparent && layer.onPreRenderOpaque) {
                    layer.onPreRenderOpaque(cameraPass);
                } else if (transparent && layer.onPreRenderTransparent) {
                    layer.onPreRenderTransparent(cameraPass);
                }

                // Called for the first sublayer and for every camera
                if (!(layer._preRenderCalledForCameras & (1 << cameraPass))) {
                    if (layer.onPreRender) layer.onPreRender(cameraPass);
                    layer._preRenderCalledForCameras |= 1 << cameraPass;
                    if (layer.overrideClear) {
                        this.clearView(camera, layer.renderTarget, layer._clearOptions);
                    }
                }

                if (camera) {
                    // Each camera must only clear each render target once
                    rt = layer.renderTarget;
                    processedThisCameraAndRt = false;
                    for (k = 0; k < renderedLength; k++) {
                        if (renderedRt[k] === rt && renderedByCam[k] === camera) {
                            processedThisCameraAndRt = true;
                            break;
                        }
                    }

                    if (!processedThisCameraAndRt) {
                        // clear once per camera + RT
                        if (!layer.overrideClear) this.clearView(camera, layer.renderTarget); // TODO: deprecate camera.renderTarget?
                        renderedRt[renderedLength] = rt;
                        renderedByCam[renderedLength] = camera;
                        renderedLength++;
                    }

                    // Render directional shadows once for each camera (will reject more than 1 attempt in this function)

                    this.renderShadows(layer._sortedLights[LIGHTTYPE_DIRECTIONAL], cameraPass);


                    layer._sortVisible(transparent, camera.node, cameraPass);


                    visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];

                    // Set the not very clever global variable which is only useful when there's just one camera
                    this.scene._activeCamera = camera.camera;

                    // Set camera shader constants, viewport, scissor, render target
                    this.setCamera(camera.camera, layer.renderTarget);

                    this.renderForward(camera.camera,
                                       visible.list,
                                       visible.length,
                                       layer._sortedLights,
                                       layer.shaderPass,
                                       layer.cullingMask,
                                       layer.onDrawCall,
                                       layer);

                    // Revert temp frame stuff
                    device.setColorWrite(true, true, true, true);
                    device.setStencilTest(false); // don't leak stencil state
                    device.setAlphaToCoverage(false); // don't leak a2c state
                    device.setDepthBias(false);

                    camera.frameEnd();
                }

                // Call postrender callback if there's one
                if (!transparent && layer.onPostRenderOpaque) {
                    layer.onPostRenderOpaque(cameraPass);
                } else if (transparent && layer.onPostRenderTransparent) {
                    layer.onPostRenderTransparent(cameraPass);
                }
                if (layer.onPostRender && !(layer._postRenderCalledForCameras & (1 << cameraPass))) {
                    layer._postRenderCounter &= ~(transparent ? 2 : 1);
                    if (layer._postRenderCounter === 0) {
                        layer.onPostRender(cameraPass);
                        layer._postRenderCalledForCameras |= 1 << cameraPass;
                        layer._postRenderCounter = layer._postRenderCounterMax;
                    }
                }


            }
        }
    });

    /**
     * @class
     * @name pc.BasicMaterial
     * @augments pc.Material
     * @classdesc A Basic material is for rendering unlit geometry, either using a constant color or a
     * color map modulated with a color.
     * @property {pc.Color} color The flat color of the material (RGBA, where each component is 0 to 1).
     * @property {pc.Texture|null} colorMap The color map of the material (default is null). If specified, the color map is
     * modulated by the color property.
     * @example
     * // Create a new Basic material
     * var material = new pc.BasicMaterial();
     *
     * // Set the material to have a texture map that is multiplied by a red color
     * material.color.set(1, 0, 0);
     * material.colorMap = diffuseMap;
     *
     * // Notify the material that it has been modified
     * material.update();
     */
    function BasicMaterial() {
        Material.call(this);

        this.color = new Color(1, 1, 1, 1);
        this.colorUniform = new Float32Array(4);

        this.colorMap = null;
        this.vertexColors = false;
    }
    BasicMaterial.prototype = Object.create(Material.prototype);
    BasicMaterial.prototype.constructor = BasicMaterial;

    Object.assign(BasicMaterial.prototype, {
        /**
         * @function
         * @name pc.BasicMaterial#clone
         * @description Duplicates a Basic material. All properties are duplicated except textures
         * where only the references are copied.
         * @returns {pc.BasicMaterial} A cloned Basic material.
         */
        clone: function () {
            var clone = new BasicMaterial();

            Material.prototype._cloneInternal.call(this, clone);

            clone.color.copy(this.color);
            clone.colorMap = this.colorMap;
            clone.vertexColors = this.vertexColors;

            return clone;
        },

        updateUniforms: function () {
            this.clearParameters();

            this.colorUniform[0] = this.color.r;
            this.colorUniform[1] = this.color.g;
            this.colorUniform[2] = this.color.b;
            this.colorUniform[3] = this.color.a;
            this.setParameter('uColor', this.colorUniform);
            if (this.colorMap) {
                this.setParameter('texture_diffuseMap', this.colorMap);
            }
        },

        updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {
            var options = {
                skin: !!this.meshInstances[0].skinInstance,
                vertexColors: this.vertexColors,
                diffuseMap: this.colorMap,
                pass: pass
            };
            var library = device.getProgramLibrary();
            this.shader = library.getProgram('basic', options);
        }
    });

    var identityGraphNode = new GraphNode();

    function ImmediateData(device) {
        this.lineVertexFormat = new VertexFormat(device, [
            { semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 },
            { semantic: SEMANTIC_COLOR, components: 4, type: TYPE_UINT8, normalize: true }
        ]);
        this.lineBatches = [];
        this.layers = [];
        this.layerToBatch = {};
        this.quadMesh = null;
        this.cubeLocalPos = null;
        this.cubeWorldPos = null;
        this.identityGraphNode = new GraphNode();
    }

    ImmediateData.prototype.addLayer = function (layer) {
        if (this.layers.indexOf(layer) < 0) {
            this.layers.push(layer);
        }
    };

    ImmediateData.prototype.getLayerIdx = function (layer) {
        return this.layerToBatch[layer.id];
    };

    ImmediateData.prototype.addLayerIdx = function (idx, layer) {
        this.layerToBatch[layer.id] = idx;
    };

    function LineBatch() {
        // Sensible default value; buffers will be doubled and reallocated when it's not enough
        this.numLinesAllocated = 128;

        this.vb = null;
        this.vbRam = null;
        this.mesh = null;
        this.linesUsed = 0;
        this.material = null;
        this.meshInstance = null;

        this.layer = null;
    }

    Object.assign(LineBatch.prototype, {
        init: function (device, vertexFormat, layer, linesToAdd) {
            // Allocate basic stuff once per batch
            if (!this.mesh) {
                this.mesh = new Mesh(device);
                this.mesh.primitive[0].type = PRIMITIVE_LINES;
                this.mesh.primitive[0].base = 0;
                this.mesh.primitive[0].indexed = false;

                this.material = new BasicMaterial();
                this.material.vertexColors = true;
                this.material.blend = true;
                this.material.blendType = BLEND_NORMAL;
                this.material.update();
            }

            this.layer = layer;

            // Increase buffer size, if it's not enough
            while ((this.linesUsed + linesToAdd) > this.numLinesAllocated) {
                if (this.vb) {
                    this.vb.destroy();
                    this.vb = null;
                }
                this.numLinesAllocated *= 2;
            }

            this.vertexFormat = vertexFormat;

            // (Re)allocate line buffer
            if (!this.vb) {
                this.vb = new VertexBuffer(device, vertexFormat, this.numLinesAllocated * 2, BUFFER_DYNAMIC);
                this.mesh.vertexBuffer = this.vb;
                this.vbRam = new DataView(this.vb.lock());

                if (!this.meshInstance) {
                    identityGraphNode.worldTransform = Mat4.IDENTITY;
                    identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
                    this.meshInstance = new MeshInstance(identityGraphNode, this.mesh, this.material);
                    this.meshInstance.cull = false;
                }
            }
        },

        addLines: function (position, color) {
            // Append lines to buffer
            var multiColor = !!color.length;
            var offset = this.linesUsed * 2 * this.vertexFormat.size;
            var clr;
            for (var i = 0; i < position.length; i++) {
                this.vbRam.setFloat32(offset, position[i].x, true); offset += 4;
                this.vbRam.setFloat32(offset, position[i].y, true); offset += 4;
                this.vbRam.setFloat32(offset, position[i].z, true); offset += 4;
                clr = multiColor ? color[i] : color;
                this.vbRam.setUint8(offset, clr.r * 255); offset += 1;
                this.vbRam.setUint8(offset, clr.g * 255); offset += 1;
                this.vbRam.setUint8(offset, clr.b * 255); offset += 1;
                this.vbRam.setUint8(offset, clr.a * 255); offset += 1;
            }
            this.linesUsed += position.length / 2;
        },

        finalize: function (meshInstanceArray) {
            // Update batch vertex buffer/issue drawcall if there are any lines
            if (this.linesUsed > 0) {
                this.vb.setData(this.vbRam.buffer);
                this.mesh.primitive[0].count = this.linesUsed * 2;
                meshInstanceArray[0] = this.meshInstance;
                this.layer.addMeshInstances(meshInstanceArray, true);
                this.linesUsed = 0;
            }
        }
    });

    /**
     * @class
     * @name pc.LayerComposition
     * @augments pc.EventHandler
     * @classdesc Layer Composition is a collection of {@link pc.Layer} that is fed to {@link pc.Scene#layers} to define rendering order.
     * @description Create a new layer composition.
     * @property {pc.Layer[]} layerList A read-only array of {@link pc.Layer} sorted in the order they will be rendered.
     * @property {boolean[]} subLayerList A read-only array of boolean values, matching {@link pc.Layer#layerList}.
     * True means only semi-transparent objects are rendered, and false means opaque.
     * @property {boolean[]} subLayerEnabled A read-only array of boolean values, matching {@link pc.Layer#layerList}.
     * True means the layer is rendered, false means it's skipped.
     * @property {pc.CameraComponent[]} cameras A read-only array of {@link pc.CameraComponent} that can be used during rendering, e.g. Inside
     * {@link pc.Layer#onPreCull}, {@link pc.Layer#onPostCull}, {@link pc.Layer#onPreRender}, {@link pc.Layer#onPostRender}.
     */
    // Composition can hold only 2 sublayers of each layer
    function LayerComposition() {
        EventHandler.call(this);

        this.layerList = [];
        this.subLayerList = [];
        this.subLayerEnabled = []; // more granular control on top of layer.enabled (ANDed)
        this._opaqueOrder = {};
        this._transparentOrder = {};

        this._dirty = false;
        this._dirtyBlend = false;
        this._dirtyLights = false;
        this._dirtyCameras = false;
        this._meshInstances = [];
        this._lights = [];
        this.cameras = [];
        this._sortedLights = [[], [], []];
        this._lightShadowCasters = []; // array of arrays for every light; identical arrays must not be duplicated, just referenced
        this._globalLightCameras = []; // array mapping _globalLights to cameras
        this._globalLightCameraIds = []; // array mapping _globalLights to camera ids in composition
        this._renderedRt = [];
        this._renderedByCam = [];
        this._renderedLayer = [];

        // generated automatically - actual rendering sequence
        // can differ from layerList/subLayer list in case of multiple cameras on one layer
        // identical otherwise
        this._renderList = []; // index to layerList/subLayerList
        this._renderListCamera = []; // index to layer.cameras
    }
    LayerComposition.prototype = Object.create(EventHandler.prototype);
    LayerComposition.prototype.constructor = LayerComposition;

    LayerComposition.prototype._sortLights = function (target) {
        var light;
        var lights = target._lights;
        target._sortedLights[LIGHTTYPE_DIRECTIONAL].length = 0;
        target._sortedLights[LIGHTTYPE_POINT].length = 0;
        target._sortedLights[LIGHTTYPE_SPOT].length = 0;
        for (var i = 0; i < lights.length; i++) {
            light = lights[i];
            if (light.enabled) {
                target._sortedLights[light._type].push(light);
            }
        }
    };

    LayerComposition.prototype._update = function () {
        var i, j, k, l;
        var layer;
        var len = this.layerList.length;
        var result = 0;

        if (!this._dirty || !this._dirtyLights || !this._dirtyCameras) { // if dirty flags on comp are clean, check if they are not in layers
            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                if (layer._dirty) {
                    this._dirty = true;
                }
                if (layer._dirtyLights) {
                    this._dirtyLights = true;
                }
                if (layer._dirtyCameras) {
                    this._dirtyCameras = true;
                }
            }
        }

        var arr;
        if (this._dirty) {
            result |= COMPUPDATED_INSTANCES;
            this._meshInstances.length = 0;
            var mi;
            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                if (layer.passThrough) continue;
                arr = layer.opaqueMeshInstances;
                for (j = 0; j < arr.length; j++) {
                    mi = arr[j];
                    if (this._meshInstances.indexOf(mi) < 0) {
                        this._meshInstances.push(mi);
                        if (mi.material && mi.material._dirtyBlend) {
                            this._dirtyBlend = true;
                            mi.material._dirtyBlend = false;
                        }
                    }
                }
                arr = layer.transparentMeshInstances;
                for (j = 0; j < arr.length; j++) {
                    mi = arr[j];
                    if (this._meshInstances.indexOf(mi) < 0) {
                        this._meshInstances.push(mi);
                        if (mi.material && mi.material._dirtyBlend) {
                            this._dirtyBlend = true;
                            mi.material._dirtyBlend = false;
                        }
                    }
                }
            }

            for (i = 0; i < len; i++) {
                this.layerList[i]._dirty = false;
                this.layerList[i]._version++;
            }
            this._dirty = false;
        }

        if (this._dirtyBlend) {
            // TODO: make it fast
            result |= COMPUPDATED_BLEND;
            var opaqueOld, transparentOld, opaqueNew, transparentNew;
            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                if (layer.passThrough) continue;
                opaqueOld = layer.opaqueMeshInstances;
                transparentOld = layer.transparentMeshInstances;
                opaqueNew = [];
                transparentNew = [];
                for (j = 0; j < opaqueOld.length; j++) {
                    if (opaqueOld[j].material && opaqueOld[j].material.blendType !== BLEND_NONE) {
                        transparentNew.push(opaqueOld[j]);
                    } else {
                        opaqueNew.push(opaqueOld[j]);
                    }
                }
                for (j = 0; j < transparentOld.length; j++) {
                    if (transparentOld[j].material && transparentOld[j].material.blendType !== BLEND_NONE) {
                        transparentNew.push(transparentOld[j]);
                    } else {
                        opaqueNew.push(transparentOld[j]);
                    }
                }
                layer.opaqueMeshInstances.length = opaqueNew.length;
                for (j = 0; j < opaqueNew.length; j++) {
                    layer.opaqueMeshInstances[j] = opaqueNew[j];
                }
                layer.transparentMeshInstances.length = transparentNew.length;
                for (j = 0; j < transparentNew.length; j++) {
                    layer.transparentMeshInstances[j] = transparentNew[j];
                }
            }
            this._dirtyBlend = false;
        }

        var casters, lid, light;
        if (this._dirtyLights) {
            result |= COMPUPDATED_LIGHTS;
            this._lights.length = 0;
            this._lightShadowCasters.length = 0;
            // TODO: don't create new arrays, reference
            // updates when _dirty as well to fix shadow casters

            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                arr = layer._lights;
                for (j = 0; j < arr.length; j++) {
                    light = arr[j];
                    lid = this._lights.indexOf(light);
                    if (lid < 0) {
                        this._lights.push(light);
                        lid = this._lights.length - 1;
                    }

                    casters = this._lightShadowCasters[lid];
                    if (!casters) {
                        this._lightShadowCasters[lid] = casters = [];
                    }
                }
            }

            this._sortLights(this);
            this._dirtyLights = false;

            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                this._sortLights(layer);
                layer._dirtyLights = false;
            }
        }

        if (result) { // meshes OR lights changed
            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                arr = layer._lights;
                for (j = 0; j < arr.length; j++) {
                    light = arr[j];
                    lid = this._lights.indexOf(light);
                    casters = this._lightShadowCasters[lid];
                    var meshInstances = layer.shadowCasters;
                    for (k = 0; k < casters.length;) {
                        if (this._meshInstances.indexOf(casters[k]) < 0) {
                            casters[k] = casters[casters.length - 1];
                            casters.length -= 1;
                        } else {
                            k++;
                        }
                    }
                    for (k = 0; k < meshInstances.length; k++) {
                        if (casters.indexOf(meshInstances[k]) < 0) casters.push(meshInstances[k]);
                    }
                }
            }
        }

        if ((result & COMPUPDATED_LIGHTS) || this._dirtyCameras) {
            // TODO: make dirty when changing layer.enabled on/off
            this._globalLightCameras.length = 0;
            var globalLights = this._sortedLights[LIGHTTYPE_DIRECTIONAL];
            for (l = 0; l < globalLights.length; l++) {
                light = globalLights[l];
                this._globalLightCameras[l] = [];
                for (i = 0; i < len; i++) {
                    layer = this.layerList[i];
                    if (layer._sortedLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) < 0) continue;
                    for (k = 0; k < layer.cameras.length; k++) {
                        if (this._globalLightCameras[l].indexOf(layer.cameras[k]) >= 0) continue;
                        this._globalLightCameras[l].push(layer.cameras[k]);
                    }
                }
            }
        }

        var camera, index;
        if (this._dirtyCameras) {
            result |= COMPUPDATED_CAMERAS;

            this.cameras.length = 0;
            for (i = 0; i < len; i++) {
                layer = this.layerList[i];
                for (j = 0; j < layer.cameras.length; j++) {
                    camera = layer.cameras[j];
                    index = this.cameras.indexOf(camera);
                    if (index < 0) {
                        index = this.cameras.length;
                        this.cameras.push(camera);
                    }
                }
            }

            this._renderList.length = 0;
            this._renderListCamera.length = 0;
            var hash, hash2, groupLength, cam;
            var skipCount = 0;

            for (i = 0; i < len; i++) {
                if (skipCount) {
                    skipCount--;
                    continue;
                }

                layer = this.layerList[i];
                if (layer.cameras.length === 0 && !layer.isPostEffect) continue;
                hash = layer._cameraHash;
                if (hash === 0) { // single camera in layer
                    this._renderList.push(i);
                    this._renderListCamera.push(0);

                } else { // multiple cameras in a layer
                    groupLength = 1; // check if there is a sequence of sublayers with same cameras
                    for (j = i + 1; j < len; j++) {
                        hash2 = this.layerList[j]._cameraHash;
                        if (hash !== hash2) {
                            groupLength = (j - i) - 1;
                            break;
                        } else if (j === len - 1) {
                            groupLength = j - i;
                        }
                    }
                    if (groupLength === 1) { // not a sequence, but multiple cameras
                        for (cam = 0; cam < layer.cameras.length; cam++) {
                            this._renderList.push(i);
                            this._renderListCamera.push(cam);
                        }

                    } else { // sequence of groupLength
                        // add a whole sequence for each camera
                        cam = 0;
                        for (cam = 0; cam < layer.cameras.length; cam++) {
                            for (j = 0; j <= groupLength; j++) {
                                this._renderList.push(i + j);
                                this._renderListCamera.push(cam);
                            }
                        }
                        // skip the sequence sublayers (can't just modify i in JS)
                        skipCount = groupLength;
                    }
                }
            }

            this._dirtyCameras = false;
            for (i = 0; i < len; i++) {
                this.layerList[i]._dirtyCameras = false;
            }
        }

        if ((result & COMPUPDATED_LIGHTS) || (result & COMPUPDATED_CAMERAS)) {
            // cameras/lights changed
            this._globalLightCameraIds.length = 0;
            for (l = 0; l < this._globalLightCameras.length; l++) {
                arr = [];
                for (i = 0; i < this._globalLightCameras[l].length; i++) {
                    index = this.cameras.indexOf( this._globalLightCameras[l][i] );
                    if (index < 0) {
                        continue;
                    }
                    arr.push(index);
                }
                this._globalLightCameraIds.push(arr);
            }
        }

        return result;
    };

    LayerComposition.prototype._isLayerAdded = function (layer) {
        if (this.layerList.indexOf(layer) >= 0) {
            return true;
        }
        return false;
    };

    LayerComposition.prototype._isSublayerAdded = function (layer, transparent) {
        for (var i = 0; i < this.layerList.length; i++) {
            if (this.layerList[i] === layer && this.subLayerList[i] === transparent) {
                return true;
            }
        }
        return false;
    };

    // Whole layer API

    /**
     * @function
     * @name pc.LayerComposition#push
     * @description Adds a layer (both opaque and semi-transparent parts) to the end of the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     */
    LayerComposition.prototype.push = function (layer) {
        // add both opaque and transparent to the end of the array
        if (this._isLayerAdded(layer)) return;
        this.layerList.push(layer);
        this.layerList.push(layer);
        this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
        this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
        this.subLayerEnabled.push(true);
        this.subLayerEnabled.push(true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#insert
     * @description Inserts a layer (both opaque and semi-transparent parts) at the chosen index in the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     * @param {number} index - Insertion position.
     */
    LayerComposition.prototype.insert = function (layer, index) {
        // insert both opaque and transparent at the index
        if (this._isLayerAdded(layer)) return;
        this.layerList.splice(index, 0,    layer,  layer);
        this.subLayerList.splice(index, 0, false,  true);

        var count = this.layerList.length;
        this._updateOpaqueOrder(index, count - 1);
        this._updateTransparentOrder(index, count - 1);
        this.subLayerEnabled.splice(index, 0, true,  true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#remove
     * @description Removes a layer (both opaque and semi-transparent parts) from {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to remove.
     */
    LayerComposition.prototype.remove = function (layer) {
        // remove all occurences of a layer
        var id = this.layerList.indexOf(layer);

        delete this._opaqueOrder[id];
        delete this._transparentOrder[id];

        while (id >= 0) {
            this.layerList.splice(id, 1);
            this.subLayerList.splice(id, 1);
            this.subLayerEnabled.splice(id, 1);
            id = this.layerList.indexOf(layer);
            this._dirty = true;
            this._dirtyLights = true;
            this._dirtyCameras = true;
            this.fire("remove", layer);
        }

        // update both orders
        var count = this.layerList.length;
        this._updateOpaqueOrder(0, count - 1);
        this._updateTransparentOrder(0, count - 1);
    };

    // Sublayer API

    /**
     * @function
     * @name pc.LayerComposition#pushOpaque
     * @description Adds part of the layer with opaque (non semi-transparent) objects to the end of the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     */
    LayerComposition.prototype.pushOpaque = function (layer) {
        // add opaque to the end of the array
        if (this._isSublayerAdded(layer, false)) return;
        this.layerList.push(layer);
        this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
        this.subLayerEnabled.push(true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#insertOpaque
     * @description Inserts an opaque part of the layer (non semi-transparent mesh instances) at the chosen index in the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     * @param {number} index - Insertion position.
     */
    LayerComposition.prototype.insertOpaque = function (layer, index) {
        // insert opaque at index
        if (this._isSublayerAdded(layer, false)) return;
        this.layerList.splice(index, 0,    layer);
        this.subLayerList.splice(index, 0, false);

        var count = this.subLayerList.length;
        this._updateOpaqueOrder(index, count - 1);

        this.subLayerEnabled.splice(index, 0, true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#removeOpaque
     * @description Removes an opaque part of the layer (non semi-transparent mesh instances) from {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to remove.
     */
    LayerComposition.prototype.removeOpaque = function (layer) {
        // remove opaque occurences of a layer
        for (var i = 0, len = this.layerList.length; i < len; i++) {
            if (this.layerList[i] === layer && !this.subLayerList[i]) {
                this.layerList.splice(i, 1);
                this.subLayerList.splice(i, 1);

                len--;
                this._updateOpaqueOrder(i, len - 1);

                this.subLayerEnabled.splice(i, 1);
                this._dirty = true;
                this._dirtyLights = true;
                this._dirtyCameras = true;
                if (this.layerList.indexOf(layer) < 0) {
                    this.fire("remove", layer); // no sublayers left
                }
                return;
            }
        }
    };

    /**
     * @function
     * @name pc.LayerComposition#pushTransparent
     * @description Adds part of the layer with semi-transparent objects to the end of the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     */
    LayerComposition.prototype.pushTransparent = function (layer) {
        // add transparent to the end of the array
        if (this._isSublayerAdded(layer, true)) return;
        this.layerList.push(layer);
        this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
        this.subLayerEnabled.push(true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#insertTransparent
     * @description Inserts a semi-transparent part of the layer at the chosen index in the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to add.
     * @param {number} index - Insertion position.
     */
    LayerComposition.prototype.insertTransparent = function (layer, index) {
        // insert transparent at index
        if (this._isSublayerAdded(layer, true)) return;
        this.layerList.splice(index, 0,    layer);
        this.subLayerList.splice(index, 0, true);

        var count = this.subLayerList.length;
        this._updateTransparentOrder(index, count - 1);

        this.subLayerEnabled.splice(index, 0, true);
        this._dirty = true;
        this._dirtyLights = true;
        this._dirtyCameras = true;
        this.fire("add", layer);
    };

    /**
     * @function
     * @name pc.LayerComposition#removeTransparent
     * @description Removes a transparent part of the layer from {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to remove.
     */
    LayerComposition.prototype.removeTransparent = function (layer) {
        // remove transparent occurences of a layer
        for (var i = 0, len = this.layerList.length; i < len; i++) {
            if (this.layerList[i] === layer && this.subLayerList[i]) {
                this.layerList.splice(i, 1);
                this.subLayerList.splice(i, 1);

                len--;
                this._updateTransparentOrder(i, len - 1);

                this.subLayerEnabled.splice(i, 1);
                this._dirty = true;
                this._dirtyLights = true;
                this._dirtyCameras = true;
                if (this.layerList.indexOf(layer) < 0) {
                    this.fire("remove", layer); // no sublayers left
                }
                return;
            }
        }
    };

    LayerComposition.prototype._getSublayerIndex = function (layer, transparent) {
        // find sublayer index in the composition array
        var id = this.layerList.indexOf(layer);
        if (id < 0) return -1;

        if (this.subLayerList[id] !== transparent) {
            id = this.layerList.indexOf(layer, id + 1);
            if (id < 0) return -1;
            if (this.subLayerList[id] !== transparent) {
                return -1;
            }
        }
        return id;
    };

    /**
     * @function
     * @name pc.LayerComposition#getOpaqueIndex
     * @description Gets index of the opaque part of the supplied layer in the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to find index of.
     * @returns {number} The index of the opaque part of the specified layer.
     */
    LayerComposition.prototype.getOpaqueIndex = function (layer) {
        return this._getSublayerIndex(layer, false);
    };

    /**
     * @function
     * @name pc.LayerComposition#getTransparentIndex
     * @description Gets index of the semi-transparent part of the supplied layer in the {@link pc.Layer#layerList}.
     * @param {pc.Layer} layer - A {@link pc.Layer} to find index of.
     * @returns {number} The index of the semi-transparent part of the specified layer.
     */
    LayerComposition.prototype.getTransparentIndex = function (layer) {
        return this._getSublayerIndex(layer, true);
    };

    /**
     * @function
     * @name pc.LayerComposition#getLayerById
     * @description Finds a layer inside this composition by its ID. Null is returned, if nothing is found.
     * @param {number} id - An ID of the layer to find.
     * @returns {pc.Layer} The layer corresponding to the specified ID. Returns null if layer is not found.
     */
    LayerComposition.prototype.getLayerById = function (id) {
        for (var i = 0; i < this.layerList.length; i++) {
            if (this.layerList[i].id === id) return this.layerList[i];
        }
        return null;
    };

    /**
     * @function
     * @name pc.LayerComposition#getLayerByName
     * @description Finds a layer inside this composition by its name. Null is returned, if nothing is found.
     * @param {string} name - The name of the layer to find.
     * @returns {pc.Layer} The layer corresponding to the specified name. Returns null if layer is not found.
     */
    LayerComposition.prototype.getLayerByName = function (name) {
        for (var i = 0; i < this.layerList.length; i++) {
            if (this.layerList[i].name === name) return this.layerList[i];
        }
        return null;
    };

    LayerComposition.prototype._updateOpaqueOrder = function (startIndex, endIndex) {
        for (var i = startIndex; i <= endIndex; i++) {
            if (this.subLayerList[i] === false) {
                this._opaqueOrder[this.layerList[i].id] = i;
            }
        }
    };

    LayerComposition.prototype._updateTransparentOrder = function (startIndex, endIndex) {
        for (var i = startIndex; i <= endIndex; i++) {
            if (this.subLayerList[i] === true) {
                this._transparentOrder[this.layerList[i].id] = i;
            }
        }
    };

    // Used to determine which array of layers has any sublayer that is
    // on top of all the sublayers in the other array. The order is a dictionary
    // of <layerId, index>.
    LayerComposition.prototype._sortLayersDescending = function (layersA, layersB, order) {
        var i = 0;
        var len = 0;
        var id = 0;
        var topLayerA = -1;
        var topLayerB = -1;

        // search for which layer is on top in layersA
        for (i = 0, len = layersA.length; i < len; i++) {
            id = layersA[i];
            if (order.hasOwnProperty(id)) {
                topLayerA = Math.max(topLayerA, order[id]);
            }
        }

        // search for which layer is on top in layersB
        for (i = 0, len = layersB.length; i < len; i++) {
            id = layersB[i];
            if (order.hasOwnProperty(id)) {
                topLayerB = Math.max(topLayerB, order[id]);
            }
        }

        // if the layers of layersA or layersB do not exist at all
        // in the composition then return early with the other.
        if (topLayerA === -1 && topLayerB !== -1) {
            return 1;
        } else if (topLayerB === -1 && topLayerA !== -1) {
            return -1;
        }

        // sort in descending order since we want
        // the higher order to be first
        return topLayerB - topLayerA;
    };

    /**
     * @function
     * @name pc.LayerComposition#sortTransparentLayers
     * @description Used to determine which array of layers has any transparent sublayer that is on top of all the transparent sublayers in the other array.
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the transparent sublayers in layersA is on top of all the transparent sublayers in layersB,
     * or a positive number if any of the transparent sublayers in layersB is on top of all the transparent sublayers in layersA, or 0 otherwise.
     */
    LayerComposition.prototype.sortTransparentLayers = function (layersA, layersB) {
        return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
    };

    /**
     * @function
     * @name pc.LayerComposition#sortOpaqueLayers
     * @description Used to determine which array of layers has any opaque sublayer that is on top of all the opaque sublayers in the other array.
     * @param {number[]} layersA - IDs of layers.
     * @param {number[]} layersB - IDs of layers.
     * @returns {number} Returns a negative number if any of the opaque sublayers in layersA is on top of all the opaque sublayers in layersB,
     * or a positive number if any of the opaque sublayers in layersB is on top of all the opaque sublayers in layersA, or 0 otherwise.
     */
    LayerComposition.prototype.sortOpaqueLayers = function (layersA, layersB) {
        return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
    };

    var maxSize = 2048;
    var maskBaked = 2;
    var maskLightmap = 4;

    var sceneLightmaps = [];
    var sceneLightmapsNode = [];
    var lmCamera;
    var tempVec = new Vec3();
    var bounds = new BoundingBox();
    var lightBounds = new BoundingBox();
    var tempSphere$1 = {};

    var PASS_COLOR = 0;
    var PASS_DIR = 1;

    var passTexName = ["texture_lightMap", "texture_dirLightMap"];
    var passMaterial = [];

    function collectModels(node, nodes, nodesMeshInstances, allNodes) {
        if (!node.enabled) return;

        var i;
        if (node.model && node.model.model && node.model.enabled) {
            if (allNodes) allNodes.push(node);
            if (node.model.lightmapped) {
                if (nodes) {
                    var hasUv1 = true;
                    var meshInstances = node.model.model.meshInstances;
                    for (i = 0; i < meshInstances.length; i++) {
                        if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
                            hasUv1 = false;
                            break;
                        }
                    }
                    if (hasUv1) {

                        var j;
                        var isInstance;
                        var notInstancedMeshInstances = [];
                        for (i = 0; i < meshInstances.length; i++) {
                            isInstance = false;
                            for (j = 0; j < meshInstances.length; j++) {
                                if (i !== j) {
                                    if (meshInstances[i].mesh === meshInstances[j].mesh) {
                                        isInstance = true;
                                    }
                                }
                            }
                            // collect each instance (object with shared VB) as separate "node"
                            if (isInstance) {
                                nodes.push(node);
                                nodesMeshInstances.push([meshInstances[i]]);
                            } else {
                                notInstancedMeshInstances.push(meshInstances[i]);
                            }
                        }

                        // collect all non-shared objects as one "node"
                        if (notInstancedMeshInstances.length > 0) {
                            nodes.push(node);
                            nodesMeshInstances.push(notInstancedMeshInstances);
                        }
                    }
                }
            }
        }
        for (i = 0; i < node._children.length; i++) {
            collectModels(node._children[i], nodes, nodesMeshInstances, allNodes);
        }
    }

    /**
     * @class
     * @name pc.Lightmapper
     * @classdesc The lightmapper is used to bake scene lights into textures.
     * @param {pc.GraphicsDevice} device - The grahpics device used by the lightmapper.
     * @param {pc.Entity} root - The root entity of the scene.
     * @param {pc.Scene} scene - The scene to lightmap.
     * @param {pc.ForwardRenderer} renderer - The renderer.
     * @param {pc.AssetRegistry} assets - Registry of assets to lightmap.
     */
    function Lightmapper(device, root, scene, renderer, assets) {
        this.device = device;
        this.root = root;
        this.scene = scene;
        this.renderer = renderer;
        this.assets = assets;

    }

    Object.assign(Lightmapper.prototype, {
        destroy: function () {
            this.device = null;
            this.root = null;
            this.scene = null;
            this.renderer = null;
            this.assets = null;
        },

        calculateLightmapSize: function (node) {
            var data, parent;
            var sizeMult = this.scene.lightmapSizeMultiplier || 16;
            var scale = tempVec;
            var area = { x: 1, y: 1, z: 1, uv: 1 };

            if (node.model.asset) {
                data = this.assets.get(node.model.asset).data;
                if (data.area) {
                    area.x = data.area.x;
                    area.y = data.area.y;
                    area.z = data.area.z;
                    area.uv = data.area.uv;
                }
            } else if (node.model._area) {
                data = node.model;
                if (data._area) {
                    area.x = data._area.x;
                    area.y = data._area.y;
                    area.z = data._area.z;
                    area.uv = data._area.uv;
                }
            }
            var areaMult = node.model.lightmapSizeMultiplier || 1;
            area.x *= areaMult;
            area.y *= areaMult;
            area.z *= areaMult;

            scale.copy(node.localScale);
            parent = node._parent;
            while (parent) {
                scale.mul(parent.localScale);
                parent = parent._parent;
            }

            // Negatively scaled nodes still need full size lightmaps.
            scale.x = Math.abs(scale.x);
            scale.y = Math.abs(scale.y);
            scale.z = Math.abs(scale.z);

            var totalArea = area.x * scale.y * scale.z +
                            area.y * scale.x * scale.z +
                            area.z * scale.x * scale.y;
            totalArea /= area.uv;
            totalArea = Math.sqrt(totalArea);

            return Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || maxSize);
        },

        /**
         * @function
         * @name pc.Lightmapper#bake
         * @description Generates and applies the lightmaps.
         * @param {pc.Entity[]} nodes - An array of entities (with model components) to render
         * lightmaps for. If not supplied, the entire scene will be baked.
         * @param {number} [mode] - Baking mode. Can be:
         *
         * * {@link pc.BAKE_COLOR}: single color lightmap
         * * {@link pc.BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump/specular)
         *
         * Only lights with bakeDir=true will be used for generating the dominant light direction.
         */
        bake: function (nodes, mode) {


            var i, j;
            var device = this.device;
            var scene = this.scene;

            var passCount = 1;
            if (mode === undefined) mode = BAKE_COLORDIR;
            if (mode === BAKE_COLORDIR) passCount = 2;
            var pass;


            var allNodes = [];
            var nodesMeshInstances = [];
            if (!nodes) {
                // ///// Full bake /////

                // delete old lightmaps, if present
                for (i = 0; i < sceneLightmaps.length; i++) {
                    for (j = 0; j < sceneLightmaps[i].length; j++) {
                        sceneLightmaps[i][j].destroy();
                    }
                }
                sceneLightmaps = [];
                sceneLightmapsNode = [];

                // collect
                nodes = [];
                collectModels(this.root, nodes, nodesMeshInstances, allNodes);
            } else {
                // ///// Selected bake /////

                // delete old lightmaps, if present
                var k;
                for (i = sceneLightmapsNode.length - 1; i >= 0; i--) {
                    for (j = 0; j < nodes.length; j++) {
                        if (sceneLightmapsNode[i] === nodes[j]) {
                            for (k = 0; k < sceneLightmaps[i].length; k++) {
                                sceneLightmaps[i][k].destroy();
                            }
                            sceneLightmaps.splice(i, 1);
                            sceneLightmapsNode.splice(i, 1);
                        }
                    }
                }

                // collect
                var _nodes = [];
                for (i = 0; i < nodes.length; i++) {
                    collectModels(nodes[i], _nodes, nodesMeshInstances);
                }
                nodes = _nodes;

                collectModels(this.root, null, null, allNodes);
            }

            if (nodes.length === 0) {
                device.fire('lightmapper:end', {
                    timestamp: now(),
                    target: this
                });

                return;
            }


            // Disable static preprocessing (lightmapper needs original model draw calls)
            var revertStatic = false;
            if (scene._needsStaticPrepare) {
                scene._needsStaticPrepare = false;
                revertStatic = true;
            }
            var lmaps = [[], []];
            var texPool = {};
            var size;
            var tex;
            var blackTex = new Texture(this.device, {
                width: 4,
                height: 4,
                format: PIXELFORMAT_R8_G8_B8_A8,
                type: TEXTURETYPE_RGBM
            });
            blackTex.name = 'lightmap';
            for (i = 0; i < nodes.length; i++) {
                size = this.calculateLightmapSize(nodes[i]);
                for (pass = 0; pass < passCount; pass++) {
                    tex = new Texture(device, {
                        width: size,
                        height: size,
                        format: PIXELFORMAT_R8_G8_B8_A8,
                        mipmaps: false,
                        type: (pass === PASS_COLOR) ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,
                        minFilter: FILTER_NEAREST,
                        magFilter: FILTER_NEAREST
                    });
                    tex.name = 'lightmap';

                    lmaps[pass].push(tex);
                }

                if (!texPool[size]) {
                    var tex2 = new Texture(device, {
                        width: size,
                        height: size,
                        format: PIXELFORMAT_R8_G8_B8_A8,
                        mipmaps: false,
                        type: TEXTURETYPE_RGBM,
                        minFilter: FILTER_NEAREST,
                        magFilter: FILTER_NEAREST
                    });
                    tex2.name = 'lightmap';

                    var targ2 = new RenderTarget(device, tex2, {
                        depth: false
                    });
                    texPool[size] = targ2;
                }
            }

            var activeComp = scene.layers;
            activeComp._update();

            // Collect bakeable lights
            var lights = [];
            var origMask = [];
            var origShadowMode = [];
            var origEnabled = [];
            var sceneLights = activeComp._lights;
            var mask;
            for (i = 0; i < sceneLights.length; i++) {
                if (sceneLights[i].enabled) {
                    mask = sceneLights[i].mask;
                    if ((mask & maskLightmap) !== 0) {
                        origMask.push(mask);
                        origShadowMode.push(sceneLights[i].shadowUpdateMode);
                        sceneLights[i].mask = 0xFFFFFFFF;
                        sceneLights[i].shadowUpdateMode =
                            sceneLights[i]._type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
                        lights.push(sceneLights[i]);
                        sceneLights[i].isStatic = false; // if baked, can't be used as static
                    }
                }
                origEnabled.push(sceneLights[i].enabled);
                sceneLights[i].enabled = false;
            }


            // Init shaders
            var chunks = shaderChunks;
            var xformUv1 = "#define UV1LAYOUT\n" + chunks.transformVS;
            var bakeLmEnd = chunks.bakeLmEndPS;
            var dilate = chunks.dilatePS;

            var dilateShader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, dilate, "lmDilate");
            var constantTexSource = device.scope.resolve("source");
            var constantPixelOffset = device.scope.resolve("pixelOffset");
            var constantBakeDir = device.scope.resolve("bakeDir");

            var pixelOffset = new Float32Array(2);

            var drawCalls = activeComp._meshInstances;

            // update scene matrices
            for (i = 0; i < drawCalls.length; i++) {
                if (drawCalls[i].node) drawCalls[i].node.getWorldTransform();
            }

            // Store scene values
            var origFog = scene.fog;
            var origAmbientR = scene.ambientLight.r;
            var origAmbientG = scene.ambientLight.g;
            var origAmbientB = scene.ambientLight.b;

            scene.fog = FOG_NONE;
            scene.ambientLight.set(0, 0, 0);

            // Create pseudo-camera
            if (!lmCamera) {
                lmCamera = new Camera();
                lmCamera._node = new GraphNode();
                lmCamera.clearColor[0] = 0;
                lmCamera.clearColor[1] = 0;
                lmCamera.clearColor[2] = 0;
                lmCamera.clearColor[3] = 0;
                lmCamera.clearDepth = 1;
                lmCamera.clearFlags = CLEARFLAG_COLOR;
                lmCamera.clearStencil = null;
                lmCamera.frustumCulling = false;
            }

            var node;
            var lm, rcv, m;

            // Disable existing scene lightmaps
            var origShaderDefs = [];
            origShaderDefs.length = sceneLightmapsNode.length;
            var shaderDefs;
            for (node = 0; node < allNodes.length; node++) {
                rcv = allNodes[node].model.model.meshInstances;
                shaderDefs = [];
                for (i = 0; i < rcv.length; i++) {
                    shaderDefs.push(rcv[i]._shaderDefs);
                    rcv[i]._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM);
                }
                for (i = 0; i < sceneLightmapsNode.length; i++) {
                    if (sceneLightmapsNode[i] === allNodes[node]) {
                        origShaderDefs[i] = shaderDefs;
                        break;
                    }
                }
            }

            // Change shadow casting
            var origCastShadows = [];
            var casters = [];
            var meshes;
            for (node = 0; node < allNodes.length; node++) {
                origCastShadows[node] = allNodes[node].model.castShadows;
                allNodes[node].model.castShadows = allNodes[node].model.castShadowsLightmap;
                if (allNodes[node].model.castShadowsLightmap) {
                    meshes = allNodes[node].model.meshInstances;
                    for (i = 0; i < meshes.length; i++) {
                        meshes[i].visibleThisFrame = true;
                        casters.push(meshes[i]);
                    }
                }
            }

            this.renderer.updateCpuSkinMatrices(casters);
            this.renderer.gpuUpdate(casters);

            var origMat = [];

            // Prepare models
            var nodeBounds = [];
            var nodeTarg = [[], []];
            var targ, targTmp, texTmp;
            var light, shadowCam;
            var nodeLightCount = [];
            nodeLightCount.length = nodes.length;

            var lmMaterial;
            for (pass = 0; pass < passCount; pass++) {
                if (!passMaterial[pass]) {
                    lmMaterial = new StandardMaterial();
                    lmMaterial.chunks.transformVS = xformUv1; // draw UV1

                    if (pass === PASS_COLOR) {
                        lmMaterial.chunks.endPS = bakeLmEnd; // encode to RGBM
                        // don't bake ambient
                        lmMaterial.ambient = new Color(0, 0, 0);
                        lmMaterial.ambientTint = true;
                        lmMaterial.lightMap = blackTex;
                    } else {
                        lmMaterial.chunks.basePS = chunks.basePS + "\nuniform sampler2D texture_dirLightMap;\nuniform float bakeDir;\n";
                        lmMaterial.chunks.endPS = chunks.bakeDirLmEndPS;
                    }

                    // avoid writing unrelated things to alpha
                    lmMaterial.chunks.outputAlphaPS = "\n";
                    lmMaterial.chunks.outputAlphaOpaquePS = "\n";
                    lmMaterial.chunks.outputAlphaPremulPS = "\n";
                    lmMaterial.cull = CULLFACE_NONE;
                    lmMaterial.forceUv1 = true; // provide data to xformUv1
                    lmMaterial.update();
                    lmMaterial.updateShader(device, scene);
                    lmMaterial.name = "lmMaterial" + pass;

                    passMaterial[pass] = lmMaterial;
                }
            }

            for (node = 0; node < nodes.length; node++) {
                rcv = nodesMeshInstances[node];
                nodeLightCount[node] = 0;

                // Calculate model AABB
                if (rcv.length > 0) {
                    bounds.copy(rcv[0].aabb);
                    for (i = 0; i < rcv.length; i++) {
                        rcv[i].node.getWorldTransform();
                        bounds.add(rcv[i].aabb);
                    }
                }
                var nbounds = new BoundingBox();
                nbounds.copy(bounds);
                nodeBounds.push(nbounds);

                for (i = 0; i < rcv.length; i++) {
                    // patch meshInstance
                    m = rcv[i];
                    m._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM); // disable LM define, if set, to get bare ambient on first pass
                    m.mask = maskLightmap; // only affected by LM lights
                    m.deleteParameter("texture_lightMap");
                    m.deleteParameter("texture_dirLightMap");

                    // patch material
                    m.setParameter("texture_lightMap", m.material.lightMap ? m.material.lightMap : blackTex);
                    m.setParameter("texture_dirLightMap", blackTex);
                }

                for (pass = 0; pass < passCount; pass++) {
                    lm = lmaps[pass][node];
                    targ = new RenderTarget(device, lm, {
                        depth: false
                    });
                    nodeTarg[pass].push(targ);
                }
            }

            // Disable all bakeable lights
            for (j = 0; j < lights.length; j++)
                lights[j].enabled = false;

            var lightArray = [[], [], []];

            // Accumulate lights into RGBM textures
            var shadersUpdatedOn1stPass = false;
            var shadowMapRendered;
            for (i = 0; i < lights.length; i++) {

                lights[i].enabled = true; // enable next light
                shadowMapRendered = false;

                lights[i]._cacheShadowMap = true;
                if (lights[i]._type !== LIGHTTYPE_DIRECTIONAL) {
                    lights[i]._node.getWorldTransform();
                    lights[i].getBoundingSphere(tempSphere$1);
                    lightBounds.center = tempSphere$1.center;
                    lightBounds.halfExtents.x = tempSphere$1.radius;
                    lightBounds.halfExtents.y = tempSphere$1.radius;
                    lightBounds.halfExtents.z = tempSphere$1.radius;
                }
                if (lights[i]._type === LIGHTTYPE_SPOT) {
                    light = lights[i];
                    shadowCam = this.renderer.getShadowCamera(device, light);

                    shadowCam._node.setPosition(light._node.getPosition());
                    shadowCam._node.setRotation(light._node.getRotation());
                    shadowCam._node.rotateLocal(-90, 0, 0);

                    shadowCam.projection = PROJECTION_PERSPECTIVE;
                    shadowCam.nearClip = light.attenuationEnd / 1000;
                    shadowCam.farClip = light.attenuationEnd;
                    shadowCam.aspectRatio = 1;
                    shadowCam.fov = light._outerConeAngle * 2;

                    this.renderer.updateCameraFrustum(shadowCam);
                }

                if (nodesMeshInstances.length > 0) {
                    this.renderer.updateShaders(nodesMeshInstances[0]);
                }

                for (node = 0; node < nodes.length; node++) {

                    rcv = nodesMeshInstances[node];
                    bounds = nodeBounds[node];

                    // Tweak camera to fully see the model, so directional light frustum will also see it
                    if (lights[i]._type === LIGHTTYPE_DIRECTIONAL) {
                        tempVec.copy(bounds.center);
                        tempVec.y += bounds.halfExtents.y;

                        lmCamera._node.setPosition(tempVec);
                        lmCamera._node.setEulerAngles(-90, 0, 0);

                        var frustumSize = Math.max(bounds.halfExtents.x, bounds.halfExtents.z);

                        lmCamera.projection = PROJECTION_ORTHOGRAPHIC;
                        lmCamera.nearClip = 0;
                        lmCamera.farClip = bounds.halfExtents.y * 2;
                        lmCamera.aspectRatio = 1;
                        lmCamera.orthoHeight = frustumSize;
                    } else {
                        if (!lightBounds.intersects(bounds)) {
                            continue;
                        }
                    }

                    if (lights[i]._type === LIGHTTYPE_SPOT) {
                        var nodeVisible = false;
                        for (j = 0; j < rcv.length; j++) {
                            if (this.renderer._isVisible(shadowCam, rcv[j])) {
                                nodeVisible = true;
                                break;
                            }
                        }
                        if (!nodeVisible) {
                            continue;
                        }
                    }

                    if (lights[i]._type === LIGHTTYPE_DIRECTIONAL) {
                        lightArray[LIGHTTYPE_DIRECTIONAL][0] = lights[i];
                        lightArray[LIGHTTYPE_POINT].length = 0;
                        lightArray[LIGHTTYPE_SPOT].length = 0;
                        if (!shadowMapRendered && lights[i].castShadows) {
                            this.renderer.cullDirectionalShadowmap(lights[i], casters, lmCamera, 0);
                            this.renderer.renderShadows(lightArray[LIGHTTYPE_DIRECTIONAL], 0);
                            shadowMapRendered = true;
                        }
                    } else {
                        lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
                        if (lights[i]._type === LIGHTTYPE_POINT) {
                            lightArray[LIGHTTYPE_POINT][0] = lights[i];
                            lightArray[LIGHTTYPE_SPOT].length = 0;
                            if (!shadowMapRendered && lights[i].castShadows) {
                                this.renderer.cullLocalShadowmap(lights[i], casters);
                                this.renderer.renderShadows(lightArray[LIGHTTYPE_POINT]);
                                shadowMapRendered = true;
                            }
                        } else {
                            lightArray[LIGHTTYPE_POINT].length = 0;
                            lightArray[LIGHTTYPE_SPOT][0] = lights[i];
                            if (!shadowMapRendered && lights[i].castShadows) {
                                this.renderer.cullLocalShadowmap(lights[i], casters);
                                this.renderer.renderShadows(lightArray[LIGHTTYPE_SPOT]);
                                shadowMapRendered = true;
                            }
                        }
                    }

                    // Store original materials
                    for (j = 0; j < rcv.length; j++) {
                        origMat[j] = rcv[j].material;
                    }

                    for (pass = 0; pass < passCount; pass++) {
                        lm = lmaps[pass][node];
                        targ = nodeTarg[pass][node];
                        targTmp = texPool[lm.width];
                        texTmp = targTmp.colorBuffer;

                        if (pass === 0) {
                            shadersUpdatedOn1stPass = scene.updateShaders;
                        } else if (shadersUpdatedOn1stPass) {
                            scene.updateShaders = true;
                        }

                        for (j = 0; j < rcv.length; j++) {
                            rcv[j].material = passMaterial[pass];
                        }
                        if (passCount > 1) {
                            this.renderer.updateShaders(rcv); // update between passes
                        }

                        // ping-ponging output
                        this.renderer.setCamera(lmCamera, targTmp, true);

                        if (pass === PASS_DIR) {
                            constantBakeDir.setValue(lights[i].bakeDir ? 1 : 0);
                        }

                        // console.log("Baking light "+lights[i]._node.name + " on model " + nodes[node].name);

                        this.renderer._forwardTime = 0;
                        this.renderer._shadowMapTime = 0;

                        this.renderer.renderForward(lmCamera,
                                                    rcv, rcv.length,
                                                    lightArray,
                                                    SHADER_FORWARDHDR);


                        lmaps[pass][node] = texTmp;
                        nodeTarg[pass][node] = targTmp;
                        texPool[lm.width] = targ;

                        for (j = 0; j < rcv.length; j++) {
                            m = rcv[j];
                            m.setParameter(passTexName[pass], texTmp); // ping-ponging input
                            m._shaderDefs |= SHADERDEF_LM; // force using LM even if material doesn't have it
                        }
                    }

                    nodeLightCount[node]++;

                    // Revert original materials
                    for (j = 0; j < rcv.length; j++) {
                        rcv[j].material = origMat[j];
                    }
                }

                lights[i].enabled = false; // disable that light
                lights[i]._cacheShadowMap = false;
                if (lights[i]._isCachedShadowMap) {
                    lights[i]._destroyShadowMap();
                }
            }


            var sceneLmaps;
            for (node = 0; node < nodes.length; node++) {
                rcv = nodesMeshInstances[node];
                sceneLmaps = [];

                for (pass = 0; pass < passCount; pass++) {
                    lm = lmaps[pass][node];
                    targ = nodeTarg[pass][node];
                    targTmp = texPool[lm.width];
                    texTmp = targTmp.colorBuffer;

                    // Dilate
                    var numDilates2x = 4; // 8 dilates
                    pixelOffset[0] = 1 / lm.width;
                    pixelOffset[1] = 1 / lm.height;
                    constantPixelOffset.setValue(pixelOffset);
                    for (i = 0; i < numDilates2x; i++) {
                        constantTexSource.setValue(lm);
                        drawQuadWithShader(device, targTmp, dilateShader);

                        constantTexSource.setValue(texTmp);
                        drawQuadWithShader(device, targ, dilateShader);
                    }


                    for (i = 0; i < rcv.length; i++) {
                        m = rcv[i];
                        m.mask = maskBaked;

                        // Set lightmap
                        rcv[i].setParameter(passTexName[pass], lm);
                        if (pass === PASS_DIR) rcv[i]._shaderDefs |= SHADERDEF_DIRLM;
                    }
                    sceneLmaps[pass] = lm;

                    // Clean up
                    if (pass === passCount - 1) targ.destroy();
                }

                sceneLightmaps.push(sceneLmaps);
                sceneLightmapsNode.push(nodes[node]);
            }

            for (var key in texPool) {
                if (texPool.hasOwnProperty(key)) {
                    texPool[key].colorBuffer.destroy();
                    texPool[key].destroy();
                }
            }

            // Set up linear filtering
            for (i = 0; i < sceneLightmaps.length; i++) {
                for (j = 0; j < sceneLightmaps[i].length; j++) {
                    tex = sceneLightmaps[i][j];
                    tex.minFilter = FILTER_LINEAR;
                    tex.magFilter = FILTER_LINEAR;
                }
            }

            // Revert shadow casting
            for (node = 0; node < allNodes.length; node++) {
                allNodes[node].model.castShadows = origCastShadows[node];
            }

            // Enable existing scene lightmaps
            for (i = 0; i < origShaderDefs.length; i++) {
                if (origShaderDefs[i]) {
                    rcv = sceneLightmapsNode[i].model.model.meshInstances;
                    for (j = 0; j < rcv.length; j++) {
                        rcv[j]._shaderDefs |= origShaderDefs[i][j] & (SHADERDEF_LM | SHADERDEF_DIRLM);
                    }
                }
            }

            // Enable all lights back
            for (i = 0; i < lights.length; i++) {
                lights[i].mask = origMask[i];
                lights[i].shadowUpdateMode = origShadowMode[i];
            }

            for (i = 0; i < sceneLights.length; i++) {
                sceneLights[i].enabled = origEnabled[i];
            }

            // Roll back scene stuff
            scene.fog = origFog;
            scene.ambientLight.set(origAmbientR, origAmbientG, origAmbientB);

            // Revert static preprocessing
            if (revertStatic) {
                scene._needsStaticPrepare = true;
            }

        }
    });

    var nonUniformScale;
    var uniformScale = 1;
    var particleTexChannels = 4; // there is a duplicate in particle-emitter
    var rotMat = new Mat4();
    var rotMatInv = new Mat4();
    var randomPosTformed = new Vec3();
    var randomPos = new Vec3();
    var rndFactor3Vec = new Vec3();
    var particlePosPrev = new Vec3();
    var velocityVec = new Vec3();
    var localVelocityVec = new Vec3();
    var velocityVec2 = new Vec3();
    var localVelocityVec2 = new Vec3();
    var radialVelocityVec = new Vec3();
    var particlePos = new Vec3();
    var particleFinalPos = new Vec3();
    var moveDirVec = new Vec3();
    var tmpVec3$1 = new Vec3();

    function frac(f) {
        return f - Math.floor(f);
    }

    function saturate(x) {
        return Math.max(Math.min(x, 1), 0);
    }

    function glMod(x, y) {
        return x - y * Math.floor(x / y);
    }

    function encodeFloatRGBA( v ) {
        var encX = frac(v);
        var encY = frac(255.0 * v);
        var encZ = frac(65025.0 * v);
        var encW = frac(160581375.0 * v);

        encX -= encY / 255.0;
        encY -= encZ / 255.0;
        encZ -= encW / 255.0;
        encW -= encW / 255.0;

        return [encX, encY, encZ, encW];
    }

    function encodeFloatRG( v ) {
        var encX = frac(v);
        var encY = frac(255.0 * v);

        encX -= encY / 255.0;
        encY -= encY / 255.0;

        return [encX, encY];
    }

    // Wraps CPU update computations from ParticleEmitter
    function ParticleCPUUpdater(emitter) {
        this._emitter = emitter;
    }

    ParticleCPUUpdater.prototype.calcSpawnPosition = function (particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
        var emitter = this._emitter;

        var rX = Math.random();
        var rY = Math.random();
        var rZ = Math.random();
        var rW = Math.random();
        if (emitter.useCpu) {
            particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels] = rX;
            particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels] = rY;
            particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels] = rZ;
            // particleTex[i * 4 + 3 + emitter.numParticlesPot * 2 * 4] = 1; // hide/show
        }

        randomPos.x = rX - 0.5;
        randomPos.y = rY - 0.5;
        randomPos.z = rZ - 0.5;

        if (emitter.emitterShape === EMITTERSHAPE_BOX) {
            var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));

            // let's find a contour sourface level coresponding to max random component
            // and translate 2 other random components to that surface
            // edge = (1.0 - extentsInnerRatioUniform) * max + 0.5 * extentsInnerRatioUniform;
            var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
            var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
            var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
            randomPos.x = edgeX * (max == Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
            randomPos.y = edgeY * (max == Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
            randomPos.z = edgeZ * (max == Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);

            if (!emitter.localSpace)
                randomPosTformed.copy(emitterPos).add( spawnMatrix.transformPoint(randomPos) );
            else
                randomPosTformed.copy( spawnMatrix.transformPoint(randomPos) );
        } else {
            randomPos.normalize();
            var spawnBoundsSphereInnerRatio = (emitter.emitterRadius === 0) ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
            var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
            if (!emitter.localSpace)
                randomPosTformed.copy(emitterPos).add( randomPos.scale(r * emitter.emitterRadius) );
            else
                randomPosTformed.copy( randomPos.scale(r * emitter.emitterRadius) );
        }

        var particleRate, startSpawnTime;
        particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
        startSpawnTime = -particleRate * i;
        if (emitter.pack8) {
            var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
            var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
            var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;

            var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
            packA = (packA % (Math.PI * 2)) / (Math.PI * 2);

            var rg0 = encodeFloatRG(packX);
            particleTex[i * particleTexChannels] = rg0[0];
            particleTex[i * particleTexChannels + 1] = rg0[1];

            var ba0 = encodeFloatRG(packY);
            particleTex[i * particleTexChannels + 2] = ba0[0];
            particleTex[i * particleTexChannels + 3] = ba0[1];

            var rg1 = encodeFloatRG(packZ);
            particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels] = rg1[0];
            particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels] = rg1[1];

            var ba1 = encodeFloatRG(packA);
            particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels] = ba1[0];
            particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = ba1[1];

            var a2 = 1.0;
            particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 2] = a2;

            var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * (Math.max(emitter.rate, emitter.rate2)));
            var maxPosLife = emitter.lifetime + 1.0;
            startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
            var rgba3 = encodeFloatRGBA(startSpawnTime);
            particleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[0];
            particleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[1];
            particleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[2];
            particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[3];

        } else {
            particleTex[i * particleTexChannels] =     randomPosTformed.x;
            particleTex[i * particleTexChannels + 1] = randomPosTformed.y;
            particleTex[i * particleTexChannels + 2] = randomPosTformed.z;
            particleTex[i * particleTexChannels + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);

            particleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = startSpawnTime;
        }
    };

    // This should only change emitter state via in-params like data, vbToSort, etc.
    ParticleCPUUpdater.prototype.update = function (data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
        var a, b, c, i, j;
        var emitter = this._emitter;

        if (emitter.meshInstance.node) {
            var fullMat = emitter.meshInstance.node.worldTransform;
            for (j = 0; j < 12; j++) {
                rotMat.data[j] = fullMat.data[j];
            }
            rotMatInv.copy(rotMat);
            rotMatInv.invert();
            nonUniformScale = emitter.meshInstance.node.localScale;
            uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
        }

        // Particle updater emulation
        emitterPos = (emitter.meshInstance.node === null || emitter.localSpace) ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
        var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;

        var vertSize = !emitter.useMesh ? 15 : 17;
        var cf, cc;
        var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
        var precision1 = emitter.precision - 1;

        for (i = 0; i < emitter.numParticles; i++) {
            var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);

            var rndFactor = particleTex[id * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels];
            rndFactor3Vec.x = rndFactor;
            rndFactor3Vec.y = particleTex[id * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels];
            rndFactor3Vec.z = particleTex[id * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels];

            var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;// pc.math.lerp(emitter.rate, emitter.rate2, rndFactor);

            var particleLifetime = emitter.lifetime;

            var life = particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] + delta;
            var nlife = saturate(life / particleLifetime);

            var scale = 0;
            var alphaDiv = 0;
            var angle = 0;

            var respawn = (life - delta) <= 0.0 || life >= particleLifetime;
            if (respawn) {
                this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
            }

            var particleEnabled = life > 0.0 && life < particleLifetime;
            if (particleEnabled) {
                c = nlife * precision1;
                cf = Math.floor(c);
                cc = Math.ceil(c);
                c %= 1;

                // var rotSpeed =           tex1D(emitter.qRotSpeed, nlife);
                a = emitter.qRotSpeed[cf];
                b = emitter.qRotSpeed[cc];
                rotSpeed = a + (b - a) * c;

                // var rotSpeed2 =          tex1D(emitter.qRotSpeed2, nlife);
                a = emitter.qRotSpeed2[cf];
                b = emitter.qRotSpeed2[cc];
                rotSpeed2 = a + (b - a) * c;

                // scale =                  tex1D(emitter.qScale, nlife);
                a = emitter.qScale[cf];
                b = emitter.qScale[cc];
                scale = a + (b - a) * c;

                // var scale2 =             tex1D(emitter.qScale2, nlife);
                a = emitter.qScale2[cf];
                b = emitter.qScale2[cc];
                scale2 = a + (b - a) * c;

                // var alpha =              tex1D(emitter.qAlpha, nlife);
                a = emitter.qAlpha[cf];
                b = emitter.qAlpha[cc];
                alpha = a + (b - a) * c;

                // var alpha2 =             tex1D(emitter.qAlpha2, nlife);
                a = emitter.qAlpha2[cf];
                b = emitter.qAlpha2[cc];
                alpha2 = a + (b - a) * c;

                // var radialSpeed =        tex1D(emitter.qRadialSpeed, nlife);
                a = emitter.qRadialSpeed[cf];
                b = emitter.qRadialSpeed[cc];
                radialSpeed = a + (b - a) * c;
                // var radialSpeed2 =       tex1D(emitter.qRadialSpeed2, nlife);
                a = emitter.qRadialSpeed2[cf];
                b = emitter.qRadialSpeed2[cc];
                radialSpeed2 = a + (b - a) * c;
                radialSpeed += (radialSpeed2 - radialSpeed) * ((rndFactor * 100.0) % 1.0);

                particlePosPrev.x = particleTex[id * particleTexChannels];
                particlePosPrev.y = particleTex[id * particleTexChannels + 1];
                particlePosPrev.z = particleTex[id * particleTexChannels + 2];

                if (!emitter.localSpace)
                    radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
                else
                    radialVelocityVec.copy(particlePosPrev);
                radialVelocityVec.normalize().scale(radialSpeed);

                cf *= 3;
                cc *= 3;

                // localVelocityVec.data =  tex1D(emitter.qLocalVelocity, nlife, 3, localVelocityVec.data);
                a = emitter.qLocalVelocity[cf];
                b = emitter.qLocalVelocity[cc];
                localVelocityVec.x = a + (b - a) * c;
                a = emitter.qLocalVelocity[cf + 1];
                b = emitter.qLocalVelocity[cc + 1];
                localVelocityVec.y = a + (b - a) * c;
                a = emitter.qLocalVelocity[cf + 2];
                b = emitter.qLocalVelocity[cc + 2];
                localVelocityVec.z = a + (b - a) * c;

                // localVelocityVec2.data = tex1D(emitter.qLocalVelocity2, nlife, 3, localVelocityVec2.data);
                a = emitter.qLocalVelocity2[cf];
                b = emitter.qLocalVelocity2[cc];
                localVelocityVec2.x = a + (b - a) * c;
                a = emitter.qLocalVelocity2[cf + 1];
                b = emitter.qLocalVelocity2[cc + 1];
                localVelocityVec2.y = a + (b - a) * c;
                a = emitter.qLocalVelocity2[cf + 2];
                b = emitter.qLocalVelocity2[cc + 2];
                localVelocityVec2.z = a + (b - a) * c;

                // velocityVec.data =       tex1D(emitter.qVelocity, nlife, 3, velocityVec.data);
                a = emitter.qVelocity[cf];
                b = emitter.qVelocity[cc];
                velocityVec.x = a + (b - a) * c;
                a = emitter.qVelocity[cf + 1];
                b = emitter.qVelocity[cc + 1];
                velocityVec.y = a + (b - a) * c;
                a = emitter.qVelocity[cf + 2];
                b = emitter.qVelocity[cc + 2];
                velocityVec.z = a + (b - a) * c;

                // velocityVec2.data =      tex1D(emitter.qVelocity2, nlife, 3, velocityVec2.data);
                a = emitter.qVelocity2[cf];
                b = emitter.qVelocity2[cc];
                velocityVec2.x = a + (b - a) * c;
                a = emitter.qVelocity2[cf + 1];
                b = emitter.qVelocity2[cc + 1];
                velocityVec2.y = a + (b - a) * c;
                a = emitter.qVelocity2[cf + 2];
                b = emitter.qVelocity2[cc + 2];
                velocityVec2.z = a + (b - a) * c;

                localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
                localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
                localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;

                if (emitter.initialVelocity > 0) {
                    if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
                        randomPos.copy(rndFactor3Vec).scale(2).sub(Vec3.ONE).normalize();
                        localVelocityVec.add(randomPos.scale(emitter.initialVelocity));
                    } else {
                        localVelocityVec.add(Vec3.FORWARD.scale(emitter.initialVelocity));
                    }
                }

                velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
                velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
                velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;

                rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
                scale = (scale + (scale2 - scale) * ((rndFactor * 10000.0) % 1.0)) * uniformScale;
                alphaDiv = (alpha2 - alpha) * ((rndFactor * 1000.0) % 1.0);

                if (emitter.meshInstance.node) {
                    if (!emitter.localSpace) {
                        rotMat.transformPoint(localVelocityVec, localVelocityVec);
                    } else {
                        localVelocityVec.x /= nonUniformScale.x;
                        localVelocityVec.y /= nonUniformScale.y;
                        localVelocityVec.z /= nonUniformScale.z;
                    }

                }
                if (!emitter.localSpace) {
                    localVelocityVec.add(velocityVec.mul(nonUniformScale));
                    localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
                } else {
                    rotMatInv.transformPoint(velocityVec, velocityVec);
                    localVelocityVec.add(velocityVec).add(radialVelocityVec);
                }

                moveDirVec.copy(localVelocityVec);

                particlePos.copy(particlePosPrev).add(localVelocityVec.scale(delta));
                particleFinalPos.copy(particlePos);

                particleTex[id * particleTexChannels] =      particleFinalPos.x;
                particleTex[id * particleTexChannels + 1] =  particleFinalPos.y;
                particleTex[id * particleTexChannels + 2] =  particleFinalPos.z;
                particleTex[id * particleTexChannels + 3] += rotSpeed * delta;

                if (emitter.wrap && emitter.wrapBounds) {
                    if (!emitter.localSpace)
                        particleFinalPos.sub(emitterPos);
                    particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
                    particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
                    particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
                    if (!emitter.localSpace)
                        particleFinalPos.add(emitterPos);
                }

                if (emitter.sort > 0) {
                    if (emitter.sort === 1) {
                        tmpVec3$1.copy(particleFinalPos).sub(posCam);
                        emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
                    } else if (emitter.sort === 2) {
                        emitter.particleDistance[id] = life;
                    } else if (emitter.sort === 3) {
                        emitter.particleDistance[id] = -life;
                    }
                }
            }

            if (isOnStop) {
                if (life < 0) {
                    particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = -1;
                }
            } else {
                if (life >= particleLifetime) {
                    // respawn particle by moving it's life back to zero.
                    // OR below zero, if there are still unspawned particles to be emitted before this one.
                    // such thing happens when you have an enormous amount of particles with short lifetime.
                    life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);

                    // dead particles in a single-shot system continue their paths, but marked as invisible.
                    // it is necessary for keeping correct separation between particles, based on emission rate.
                    // dying again in a looped system they will become visible on next respawn.
                    particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = emitter.loop ? 1 : -1;
                }
                if (life < 0 && emitter.loop) {
                    particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = 1;
                }
            }
            if (particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] < 0)
                particleEnabled = false;
            particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = life;

            for (var v = 0; v < emitter.numParticleVerts; v++) {
                var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
                var quadX = emitter.vbCPU[vbOffset];
                var quadY = emitter.vbCPU[vbOffset + 1];
                var quadZ = emitter.vbCPU[vbOffset + 2];
                if (!particleEnabled) {
                    quadX = quadY = quadZ = 0;
                }

                var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
                data[w] = particleFinalPos.x;
                data[w + 1] = particleFinalPos.y;
                data[w + 2] = particleFinalPos.z;
                data[w + 3] = nlife;
                data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels + 3];
                data[w + 5] = scale;
                data[w + 6] = alphaDiv;
                data[w + 7] = moveDirVec.x;
                data[w + 8] = quadX;
                data[w + 9] = quadY;
                data[w + 10] = quadZ;
                data[w + 11] = moveDirVec.y;
                data[w + 12] = id;
                data[w + 13] = moveDirVec.z;
                data[w + 14] = emitter.vbCPU[vbOffset + 3];
                if (emitter.useMesh) {
                    data[w + 15] = emitter.vbCPU[vbOffset + 4];
                    data[w + 16] = emitter.vbCPU[vbOffset + 5];
                }
            }
        }

        // Particle sorting
        if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
            var vbStride = emitter.useMesh ? 6 : 4;
            var particleDistance = emitter.particleDistance;
            for (i = 0; i < emitter.numParticles; i++) {
                vbToSort[i][0] = i;
                vbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])]; // particle id
            }

            emitter.vbOld.set(emitter.vbCPU);

            vbToSort.sort(function (p1, p2) {
                return p1[1] - p2[1];
            });

            for (i = 0; i < emitter.numParticles; i++) {
                var src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;
                var dest = i * emitter.numParticleVerts * vbStride;
                for (j = 0; j < emitter.numParticleVerts * vbStride; j++) {
                    emitter.vbCPU[dest + j] = emitter.vbOld[src + j];
                }
            }
        }
    };

    var spawnMatrix3 = new Mat3();
    var emitterMatrix3 = new Mat3();
    var emitterMatrix3Inv = new Mat3();

    function mat4ToMat3(mat4, mat3) {
        mat3.data[0] = mat4.data[0];
        mat3.data[1] = mat4.data[1];
        mat3.data[2] = mat4.data[2];

        mat3.data[3] = mat4.data[4];
        mat3.data[4] = mat4.data[5];
        mat3.data[5] = mat4.data[6];

        mat3.data[6] = mat4.data[8];
        mat3.data[7] = mat4.data[9];
        mat3.data[8] = mat4.data[10];
    }

    // Wraps GPU particles render state and setup from ParticleEmitter
    function ParticleGPUUpdater(emitter, gd) {
        this._emitter = emitter;

        this.frameRandomUniform = new Float32Array(3);
        this.emitterPosUniform = new Float32Array(3);
        this.emitterScaleUniform = new Float32Array([1, 1, 1]);
        this.worldBoundsMulUniform = new Float32Array(3);
        this.worldBoundsAddUniform = new Float32Array(3);
        this.inBoundsSizeUniform = new Float32Array(3);
        this.inBoundsCenterUniform = new Float32Array(3);

        this.constantParticleTexIN = gd.scope.resolve("particleTexIN");
        this.constantParticleTexOUT = gd.scope.resolve("particleTexOUT");
        this.constantEmitterPos = gd.scope.resolve("emitterPos");
        this.constantEmitterScale = gd.scope.resolve("emitterScale");
        this.constantSpawnBounds = gd.scope.resolve("spawnBounds");
        this.constantSpawnPosInnerRatio = gd.scope.resolve("spawnPosInnerRatio");
        this.constantSpawnBoundsSphere = gd.scope.resolve("spawnBoundsSphere");
        this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve("spawnBoundsSphereInnerRatio");
        this.constantInitialVelocity = gd.scope.resolve("initialVelocity");
        this.constantFrameRandom = gd.scope.resolve("frameRandom");
        this.constantDelta = gd.scope.resolve("delta");
        this.constantRate = gd.scope.resolve("rate");
        this.constantRateDiv = gd.scope.resolve("rateDiv");
        this.constantLifetime = gd.scope.resolve("lifetime");
        this.constantGraphSampleSize = gd.scope.resolve("graphSampleSize");
        this.constantGraphNumSamples = gd.scope.resolve("graphNumSamples");
        this.constantInternalTex0 = gd.scope.resolve("internalTex0");
        this.constantInternalTex1 = gd.scope.resolve("internalTex1");
        this.constantInternalTex2 = gd.scope.resolve("internalTex2");
        this.constantInternalTex3 = gd.scope.resolve("internalTex3");
        this.constantEmitterMatrix = gd.scope.resolve("emitterMatrix");
        this.constantEmitterMatrixInv = gd.scope.resolve("emitterMatrixInv");
        this.constantNumParticles = gd.scope.resolve("numParticles");
        this.constantNumParticlesPot = gd.scope.resolve("numParticlesPot");
        this.constantLocalVelocityDivMult = gd.scope.resolve("localVelocityDivMult");
        this.constantVelocityDivMult = gd.scope.resolve("velocityDivMult");
        this.constantRotSpeedDivMult = gd.scope.resolve("rotSpeedDivMult");
        this.constantSeed = gd.scope.resolve("seed");
        this.constantStartAngle = gd.scope.resolve("startAngle");
        this.constantStartAngle2 = gd.scope.resolve("startAngle2");
        this.constantOutBoundsMul = gd.scope.resolve("outBoundsMul");
        this.constantOutBoundsAdd = gd.scope.resolve("outBoundsAdd");
        this.constantInBoundsSize = gd.scope.resolve("inBoundsSize");
        this.constantInBoundsCenter = gd.scope.resolve("inBoundsCenter");
        this.constantMaxVel = gd.scope.resolve("maxVel");
        this.constantFaceTangent = gd.scope.resolve("faceTangent");
        this.constantFaceBinorm = gd.scope.resolve("faceBinorm");
    }

    ParticleGPUUpdater.prototype._setInputBounds = function () {
        this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
        this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
        this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
        this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
        this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
        this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
        this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
        this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
    };

    ParticleGPUUpdater.prototype.randomize = function () {
        this.frameRandomUniform[0] = Math.random();
        this.frameRandomUniform[1] = Math.random();
        this.frameRandomUniform[2] = Math.random();
    };

    // This shouldn't change emitter state, only read from it
    ParticleGPUUpdater.prototype.update = function (device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {


        var emitter = this._emitter;

        device.setBlending(false);
        device.setColorWrite(true, true, true, true);
        device.setCullMode(CULLFACE_NONE);
        device.setDepthTest(false);
        device.setDepthWrite(false);

        this.randomize();

        this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
        this.constantGraphNumSamples.setValue(emitter.precision);
        this.constantNumParticles.setValue(emitter.numParticles);
        this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
        this.constantInternalTex0.setValue(emitter.internalTex0);
        this.constantInternalTex1.setValue(emitter.internalTex1);
        this.constantInternalTex2.setValue(emitter.internalTex2);
        this.constantInternalTex3.setValue(emitter.internalTex3);

        var node = emitter.meshInstance.node;
        var emitterScale = node === null ? Vec3.ONE : node.localScale;

        if (emitter.pack8) {
            this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
            this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
            this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
            this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
            this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
            this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
            this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
            this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);

            this._setInputBounds();

            var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
            maxVel = Math.max(maxVel, 1);
            this.constantMaxVel.setValue(maxVel);
        }

        var emitterPos = (node === null || emitter.localSpace) ? Vec3.ZERO : node.getPosition();
        var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
        if (emitter.emitterShape === EMITTERSHAPE_BOX) {
            mat4ToMat3(spawnMatrix, spawnMatrix3);
            this.constantSpawnBounds.setValue(spawnMatrix3.data);
            this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
        } else {
            this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
            this.constantSpawnBoundsSphereInnerRatio.setValue((emitter.emitterRadius === 0) ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
        }
        this.constantInitialVelocity.setValue(emitter.initialVelocity);

        mat4ToMat3(emitterMatrix, emitterMatrix3);
        emitterMatrix.invertTo3x3(emitterMatrix3Inv);
        this.emitterPosUniform[0] = emitterPos.x;
        this.emitterPosUniform[1] = emitterPos.y;
        this.emitterPosUniform[2] = emitterPos.z;
        this.constantEmitterPos.setValue(this.emitterPosUniform);
        this.constantFrameRandom.setValue(this.frameRandomUniform);
        this.constantDelta.setValue(delta);
        this.constantRate.setValue(emitter.rate);
        this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
        this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
        this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);

        this.constantSeed.setValue(emitter.seed);
        this.constantLifetime.setValue(emitter.lifetime);
        this.emitterScaleUniform[0] = emitterScale.x;
        this.emitterScaleUniform[1] = emitterScale.y;
        this.emitterScaleUniform[2] = emitterScale.z;
        this.constantEmitterScale.setValue(this.emitterScaleUniform);
        this.constantEmitterMatrix.setValue(emitterMatrix3.data);
        this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);

        this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
        this.constantVelocityDivMult.setValue(emitter.velocityUMax);
        this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);

        var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
        texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
        var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
        this.constantParticleTexIN.setValue(texIN);
        drawQuadWithShader(
            device,
            emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT,
            !isOnStop ?
                (emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn) :
                emitter.shaderParticleUpdateOnStop);

        // this.constantParticleTexOUT.setValue(texOUT);

        emitter.material.setParameter("particleTexOUT", texIN);// OUT);
        emitter.material.setParameter("particleTexIN", texOUT);// IN);
        emitter.beenReset = false;

        emitter.swapTex = !emitter.swapTex;

        device.setDepthTest(true);
        device.setDepthWrite(true);

        emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
        emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
        if (emitter.pack8)
            this._setInputBounds();

    };

    var particleVerts = [
        [-1, -1],
        [1, -1],
        [1, 1],
        [-1, 1]
    ];

    var _createTexture = function (device, width, height, pixelData, format, mult8Bit, filter) {
        if (!format) format = PIXELFORMAT_RGBA32F;

        var mipFilter = FILTER_NEAREST;
        if (filter && format === PIXELFORMAT_R8_G8_B8_A8)
            mipFilter = FILTER_LINEAR;

        var texture = new Texture(device, {
            width: width,
            height: height,
            format: format,
            cubemap: false,
            mipmaps: false,
            minFilter: mipFilter,
            magFilter: mipFilter,
            addressU: ADDRESS_CLAMP_TO_EDGE,
            addressV: ADDRESS_CLAMP_TO_EDGE
        });
        texture.name = "PSTexture";

        var pixels = texture.lock();

        if (format === PIXELFORMAT_R8_G8_B8_A8) {
            var temp = new Uint8Array(pixelData.length);
            for (var i = 0; i < pixelData.length; i++) {
                temp[i] = pixelData[i] * mult8Bit * 255;
            }
            pixelData = temp;
        }

        pixels.set(pixelData);

        texture.unlock();

        return texture;
    };

    function saturate$1(x) {
        return Math.max(Math.min(x, 1), 0);
    }

    var default0Curve = new Curve([0, 0, 1, 0]);
    var default1Curve = new Curve([0, 1, 1, 1]);
    var default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);
    var default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);

    var particleTexHeight = 2;
    var particleTexChannels$1 = 4; // there is a duplicate in cpu updater

    var extentsInnerRatioUniform = new Float32Array(3);
    var spawnMatrix = new Mat4();

    var tmpVec3$2 = new Vec3();
    var bMin = new Vec3();
    var bMax = new Vec3();

    var setPropertyTarget;
    var setPropertyOptions;

    function setProperty(pName, defaultVal) {
        if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
            setPropertyTarget[pName] = setPropertyOptions[pName];
        } else {
            setPropertyTarget[pName] = defaultVal;
        }
    }

    function pack3NFloats(a, b, c) {
        var packed = ((a * 255) << 16) | ((b * 255) << 8) | (c * 255);
        return (packed) / (1 << 24);
    }

    function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
        var num = qXYZ.length / 3;
        var colors = new Array(num * 4);
        for (var i = 0; i < num; i++) {
            colors[i * 4] = qXYZ[i * 3];
            colors[i * 4 + 1] = qXYZ[i * 3 + 1];
            colors[i * 4 + 2] = qXYZ[i * 3 + 2];

            colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
        }
        return colors;
    }

    function packTextureRGBA(qRGB, qA) {
        var colors = new Array(qA.length * 4);
        for (var i = 0; i < qA.length; i++) {
            colors[i * 4] = qRGB[i * 3];
            colors[i * 4 + 1] = qRGB[i * 3 + 1];
            colors[i * 4 + 2] = qRGB[i * 3 + 2];

            colors[i * 4 + 3] = qA[i];
        }
        return colors;
    }

    function packTexture5Floats(qA, qB, qC, qD, qE) {
        var colors = new Array(qA.length * 4);
        for (var i = 0; i < qA.length; i++) {
            colors[i * 4] = qA[i];
            colors[i * 4 + 1] = qB[i];
            colors[i * 4 + 2] = 0;

            colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
        }
        return colors;
    }

    function packTexture2Floats(qA, qB) {
        var colors = new Array(qA.length * 4);
        for (var i = 0; i < qA.length; i++) {
            colors[i * 4] = qA[i];
            colors[i * 4 + 1] = qB[i];
            colors[i * 4 + 2] = 0;
            colors[i * 4 + 3] = 0;
        }
        return colors;
    }

    var ParticleEmitter = function (graphicsDevice, options) {
        this.graphicsDevice = graphicsDevice;
        var gd = graphicsDevice;
        var precision = 32;
        this.precision = precision;

        this._addTimeTime = 0;


        if (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {
            // White radial gradient
            var resolution = 16;
            var centerPoint = resolution * 0.5 + 0.5;
            var dtex = new Float32Array(resolution * resolution * 4);
            var x, y, xgrad, ygrad, p, c;
            for (y = 0; y < resolution; y++) {
                for (x = 0; x < resolution; x++) {
                    xgrad = (x + 1) - centerPoint;
                    ygrad = (y + 1) - centerPoint;
                    c = saturate$1((1 - saturate$1(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution)) - 0.5);
                    p = y * resolution + x;
                    dtex[p * 4] =     1;
                    dtex[p * 4 + 1] = 1;
                    dtex[p * 4 + 2] = 1;
                    dtex[p * 4 + 3] = c;
                }
            }
            ParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(gd, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
            ParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = FILTER_LINEAR;
            ParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = FILTER_LINEAR;
        }

        // Global system parameters
        setPropertyTarget = this;
        setPropertyOptions = options;
        setProperty("numParticles", 1);                          // Amount of particles allocated (max particles = max GL texture width at this moment)

        if (this.numParticles > graphicsDevice.maxTextureSize) {
            console.warn("WARNING: can't create more than " + graphicsDevice.maxTextureSize + " particles on this device.");
            this.numParticles = graphicsDevice.maxTextureSize;
        }

        setProperty("rate", 1);                                  // Emission rate
        setProperty("rate2", this.rate);
        setProperty("lifetime", 50);                             // Particle lifetime
        setProperty("emitterExtents", new Vec3(0, 0, 0));        // Spawn point divergence
        setProperty("emitterExtentsInner", new Vec3(0, 0, 0));   // Volume inside emitterExtents to exclude from reneration
        setProperty("emitterRadius", 0);
        setProperty("emitterRadiusInner", 0);                       // Same as ExtentsInner but for spherical volume
        setProperty("emitterShape", EMITTERSHAPE_BOX);
        setProperty("initialVelocity", 1);
        setProperty("wrap", false);
        setProperty("localSpace", false);
        setProperty("wrapBounds", null);
        setProperty("colorMap", ParticleEmitter.DEFAULT_PARAM_TEXTURE);
        setProperty("normalMap", null);
        setProperty("loop", true);
        setProperty("preWarm", false);
        setProperty("sort", PARTICLESORT_NONE); // Sorting mode: 0 = none, 1 = by distance, 2 = by life, 3 = by -life;  Forces CPU mode if not 0
        setProperty("mode", PARTICLEMODE_GPU);
        setProperty("scene", null);
        setProperty("lighting", false);
        setProperty("halfLambert", false);
        setProperty("intensity", 1.0);
        setProperty("stretch", 0.0);
        setProperty("alignToMotion", false);
        setProperty("depthSoftening", 0);
        setProperty("mesh", null);                              // Mesh to be used as particle. Vertex buffer is supposed to hold vertex position in first 3 floats of each vertex
                                                                // Leave undefined to use simple quads
        setProperty("particleNormal", new Vec3(0, 1, 0));
        setProperty("orientation", PARTICLEORIENTATION_SCREEN);

        setProperty("depthWrite", false);
        setProperty("noFog", false);
        setProperty("blendType", BLEND_NORMAL);
        setProperty("node", null);
        setProperty("startAngle", 0);
        setProperty("startAngle2", this.startAngle);

        setProperty("animTilesX", 1);
        setProperty("animTilesY", 1);
        setProperty("animStartFrame", 0);
        setProperty("animNumFrames", 1);
        setProperty("animNumAnimations", 1);
        setProperty("animIndex", 0);
        setProperty("randomizeAnimIndex", false);
        setProperty("animSpeed", 1);
        setProperty("animLoop", true);

        this._gpuUpdater = new ParticleGPUUpdater(this, gd);
        this._cpuUpdater = new ParticleCPUUpdater(this);

        this.constantLightCube = gd.scope.resolve("lightCube[0]");
        this.emitterPosUniform = new Float32Array(3);
        this.wrapBoundsUniform = new Float32Array(3);
        this.emitterScaleUniform = new Float32Array([1, 1, 1]);

        // Time-dependent parameters
        setProperty("colorGraph", default1Curve3);
        setProperty("colorGraph2", this.colorGraph);

        setProperty("scaleGraph", default1Curve);
        setProperty("scaleGraph2", this.scaleGraph);

        setProperty("alphaGraph", default1Curve);
        setProperty("alphaGraph2", this.alphaGraph);

        setProperty("localVelocityGraph", default0Curve3);
        setProperty("localVelocityGraph2", this.localVelocityGraph);

        setProperty("velocityGraph", default0Curve3);
        setProperty("velocityGraph2", this.velocityGraph);

        setProperty("rotationSpeedGraph", default0Curve);
        setProperty("rotationSpeedGraph2", this.rotationSpeedGraph);

        setProperty("radialSpeedGraph", default0Curve);
        setProperty("radialSpeedGraph2", this.radialSpeedGraph);

        this.lightCube = new Float32Array(6 * 3);
        this.lightCubeDir = new Array(6);
        this.lightCubeDir[0] = new Vec3(-1, 0, 0);
        this.lightCubeDir[1] = new Vec3(1, 0, 0);
        this.lightCubeDir[2] = new Vec3(0, -1, 0);
        this.lightCubeDir[3] = new Vec3(0, 1, 0);
        this.lightCubeDir[4] = new Vec3(0, 0, -1);
        this.lightCubeDir[5] = new Vec3(0, 0, 1);

        this.animTilesParams = new Float32Array(2);
        this.animParams = new Float32Array(4);
        this.animIndexParams = new Float32Array(2);

        this.internalTex0 = null;
        this.internalTex1 = null;
        this.internalTex2 = null;
        this.colorParam = null;

        this.vbToSort = null;
        this.vbOld = null;
        this.particleDistance = null;

        this.camera = null;

        this.swapTex = false;
        this.useMesh = true;
        this.useCpu = false;

        this.pack8 = true;
        this.localBounds = new BoundingBox();
        this.worldBoundsNoTrail = new BoundingBox();
        this.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];
        this.worldBounds = new BoundingBox();

        this.worldBoundsSize = new Vec3();

        this.prevWorldBoundsSize = new Vec3();
        this.prevWorldBoundsCenter = new Vec3();
        this.prevEmitterExtents = this.emitterExtents;
        this.prevEmitterRadius = this.emitterRadius;
        this.worldBoundsMul = new Vec3();
        this.worldBoundsAdd = new Vec3();
        this.timeToSwitchBounds = 0;
        // this.prevPos = new Vec3();

        this.shaderParticleUpdateRespawn = null;
        this.shaderParticleUpdateNoRespawn = null;
        this.shaderParticleUpdateOnStop = null;

        this.numParticleVerts = 0;
        this.numParticleIndices = 0;

        this.material = null;
        this.meshInstance = null;

        this.seed = Math.random();

        this.fixedTimeStep = 1.0 / 60;
        this.maxSubSteps = 10;
        this.simTime = 0;
        this.simTimeTotal = 0;

        this.beenReset = false;

        this._layer = null;

        this.rebuild();
    };

    function calcEndTime(emitter) {
        var interval = (Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime);
        return Date.now() + interval * 1000;
    }

    function subGraph(A, B) {
        var r = new Float32Array(A.length);
        for (var i = 0; i < A.length; i++) {
            r[i] = A[i] - B[i];
        }
        return r;
    }

    function maxUnsignedGraphValue(A, outUMax) {
        var i, j;
        var chans = outUMax.length;
        var values = A.length / chans;
        for (i = 0; i < values; i++) {
            for (j = 0; j < chans; j++) {
                var a = Math.abs(A[i * chans + j]);
                outUMax[j] = Math.max(outUMax[j], a);
            }
        }
    }

    function normalizeGraph(A, uMax) {
        var chans = uMax.length;
        var i, j;
        var values = A.length / chans;
        for (i = 0; i < values; i++) {
            for (j = 0; j < chans; j++) {
                A[i * chans + j] /= (uMax[j] === 0 ? 1 : uMax[j]);
                A[i * chans + j] *= 0.5;
                A[i * chans + j] += 0.5;
            }
        }
    }

    function divGraphFrom2Curves(curve1, curve2, outUMax) {
        var sub = subGraph(curve2, curve1);
        maxUnsignedGraphValue(sub, outUMax);
        normalizeGraph(sub, outUMax);
        return sub;
    }

    Object.assign(ParticleEmitter.prototype, {

        onChangeCamera: function () {
            this.regenShader();
            this.resetMaterial();
        },

        calculateBoundsMad: function () {
            this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
            this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
            this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;

            this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).scale(-1);
            this.worldBoundsAdd.x += 0.5;
            this.worldBoundsAdd.y += 0.5;
            this.worldBoundsAdd.z += 0.5;
        },

        calculateWorldBounds: function () {
            if (!this.node) return;

            this.prevWorldBoundsSize.copy(this.worldBoundsSize);
            this.prevWorldBoundsCenter.copy(this.worldBounds.center);

            if (!this.useCpu) {
                var recalculateLocalBounds = false;
                if (this.emitterShape === EMITTERSHAPE_BOX) {
                    recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
                } else {
                    recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
                }
                if (recalculateLocalBounds) {
                    this.calculateLocalBounds();
                }
            }


            var nodeWT = this.node.getWorldTransform();
            if (this.localSpace) {
                this.worldBoundsNoTrail.copy(this.localBounds);
            } else {
                this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
            }

            this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
            this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);

            var now = this.simTimeTotal;
            if (now >= this.timeToSwitchBounds) {
                this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
                this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
                this.timeToSwitchBounds = now + this.lifetime;
            }

            this.worldBounds.copy(this.worldBoundsTrail[0]);

            this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);

            if (this.localSpace) {
                this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
                this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
            } else {
                this.meshInstance.aabb.copy(this.worldBounds);
                this.meshInstance.mesh.aabb.copy(this.worldBounds);
            }
            this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;

            if (this.pack8) this.calculateBoundsMad();
        },

        resetWorldBounds: function () {
            if (!this.node) return;

            this.worldBoundsNoTrail.setFromTransformedAabb(
                this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());

            this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
            this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);

            this.worldBounds.copy(this.worldBoundsTrail[0]);
            this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);

            this.prevWorldBoundsSize.copy(this.worldBoundsSize);
            this.prevWorldBoundsCenter.copy(this.worldBounds.center);

            this.simTimeTotal = 0;
            this.timeToSwitchBounds = 0;
        },

        calculateLocalBounds: function () {
            var minx = Number.MAX_VALUE;
            var miny = Number.MAX_VALUE;
            var minz = Number.MAX_VALUE;
            var maxx = -Number.MAX_VALUE;
            var maxy = -Number.MAX_VALUE;
            var maxz = -Number.MAX_VALUE;
            var maxR = 0;
            var maxScale = 0;
            var stepWeight = this.lifetime / this.precision;
            var wVels = [this.qVelocity, this.qVelocity2];
            var lVels = [this.qLocalVelocity, this.qLocalVelocity2];
            var accumX = [0, 0];
            var accumY = [0, 0];
            var accumZ = [0, 0];
            var accumR = [0, 0];
            var accumW = [0, 0];
            var i, j;
            var index;
            var x, y, z;
            for (i = 0; i < this.precision + 1; i++) { // take extra step to prevent position glitches
                index = Math.min(i, this.precision - 1);
                for (j = 0; j < 2; j++) {
                    x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
                    y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
                    z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];

                    minx = Math.min(x, minx);
                    miny = Math.min(y, miny);
                    minz = Math.min(z, minz);
                    maxx = Math.max(x, maxx);
                    maxy = Math.max(y, maxy);
                    maxz = Math.max(z, maxz);

                    accumX[j] = x;
                    accumY[j] = y;
                    accumZ[j] = z;
                }
                for (j = 0; j < 2; j++) {
                    accumW[j] += stepWeight * Math.sqrt(
                        wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] +
                        wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] +
                        wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);
                }

                accumR[0] += this.qRadialSpeed[index] * stepWeight;
                accumR[1] += this.qRadialSpeed2[index] * stepWeight;
                maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));

                maxScale = Math.max(maxScale, this.qScale[index]);
            }

            if (this.emitterShape === EMITTERSHAPE_BOX) {
                x = this.emitterExtents.x * 0.5;
                y = this.emitterExtents.y * 0.5;
                z = this.emitterExtents.z * 0.5;
            } else {
                x = this.emitterRadius;
                y = this.emitterRadius;
                z = this.emitterRadius;
            }

            var w = Math.max(accumW[0], accumW[1]);
            bMin.x = minx - maxScale - x - maxR - w;
            bMin.y = miny - maxScale - y - maxR - w;
            bMin.z = minz - maxScale - z - maxR - w;
            bMax.x = maxx + maxScale + x + maxR + w;
            bMax.y = maxy + maxScale + y + maxR + w;
            bMax.z = maxz + maxScale + z + maxR + w;
            this.localBounds.setMinMax(bMin, bMax);
        },

        rebuild: function () {
            var i;
            var gd = this.graphicsDevice;

            if (this.colorMap === null) this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;

            this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;

            this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE ||  // force CPU if desirable by user or sorting is enabled
            gd.maxVertexTextures <= 1 || // force CPU if can't use enough vertex textures
            gd.fragmentUniformsCount < 64 || // force CPU if can't use many uniforms; TODO: change to more realistic value (this one is iphone's)
            gd.forceCpuParticles ||
            !gd.extTextureFloat; // no float texture extension

            this._destroyResources();

            this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;

            particleTexHeight = (this.useCpu || this.pack8) ? 4 : 2;

            this.useMesh = false;
            if (this.mesh) {
                var totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;
                if (totalVertCount > 65535) {
                    console.warn("WARNING: particle system can't render mesh particles because numParticles * numVertices is more than 65k. Reverting to quad particles.");
                } else {
                    this.useMesh = true;
                }
            }

            this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
            this.rebuildGraphs();
            this.calculateLocalBounds();
            this.resetWorldBounds();

            if (this.node) {
                // this.prevPos.copy(this.node.getPosition());
                this.worldBounds.setFromTransformedAabb(
                    this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());

                this.worldBoundsTrail[0].copy(this.worldBounds);
                this.worldBoundsTrail[1].copy(this.worldBounds);

                this.worldBoundsSize.copy(this.worldBounds.halfExtents).scale(2);
                this.prevWorldBoundsSize.copy(this.worldBoundsSize);
                this.prevWorldBoundsCenter.copy(this.worldBounds.center);
                if (this.pack8) this.calculateBoundsMad();
            }

            // Dynamic simulation data
            this.vbToSort = new Array(this.numParticles);
            for (var iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];
            this.particleDistance = new Float32Array(this.numParticles);

            this._gpuUpdater.randomize();

            this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels$1);
            var emitterPos = (this.node === null || this.localSpace) ? Vec3.ZERO : this.node.getPosition();
            if (this.emitterShape === EMITTERSHAPE_BOX) {
                if (this.node === null || this.localSpace){
                    spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
                } else {
                    spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3$2.copy(this.spawnBounds).mul(this.node.localScale));
                }
                extentsInnerRatioUniform[0] = this.emitterExtents.x != 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
                extentsInnerRatioUniform[1] = this.emitterExtents.y != 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
                extentsInnerRatioUniform[2] = this.emitterExtents.z != 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
            }
            for (i = 0; i < this.numParticles; i++) {
                this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
                if (this.useCpu) this.particleTex[i * particleTexChannels$1 + 3 + this.numParticlesPot * 2 * particleTexChannels$1] = 1; // hide/show
            }

            this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels$1);
            for (i = 0; i < this.particleTexStart.length; i++) this.particleTexStart[i] = this.particleTex[i];

            if (!this.useCpu) {
                if (this.pack8) {
                    this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
                    this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);
                    this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);
                } else {
                    this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
                    this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
                    this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
                }

                this.rtParticleTexIN = new RenderTarget(gd, this.particleTexIN, {
                    depth: false
                });
                this.rtParticleTexOUT = new RenderTarget(gd, this.particleTexOUT, {
                    depth: false
                });
                this.swapTex = false;
            }

            var chunks = shaderChunks;
            var shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\n' : '') + chunks.particleUpdaterInitPS +
            (this.pack8 ? (chunks.particleInputRgba8PS + chunks.particleOutputRgba8PS) :
                (chunks.particleInputFloatPS + chunks.particleOutputFloatPS)) +
            (this.emitterShape === EMITTERSHAPE_BOX ? chunks.particleUpdaterAABBPS : chunks.particleUpdaterSpherePS) +
            chunks.particleUpdaterStartPS;
            var shaderCodeRespawn = shaderCodeStart + chunks.particleUpdaterRespawnPS + chunks.particleUpdaterEndPS;
            var shaderCodeNoRespawn = shaderCodeStart + chunks.particleUpdaterNoRespawnPS + chunks.particleUpdaterEndPS;
            var shaderCodeOnStop = shaderCodeStart + chunks.particleUpdaterOnStopPS + chunks.particleUpdaterEndPS;


            // Note: createShaderFromCode can return a shader from the cache (not a new shader) so we *should not* delete these shaders
            // when the particle emitter is destroyed
            var params = this.emitterShape + "" + this.pack8 + "" + this.localSpace;
            this.shaderParticleUpdateRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeRespawn, "fsQuad0" + params);
            this.shaderParticleUpdateNoRespawn = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeNoRespawn, "fsQuad1" + params);
            this.shaderParticleUpdateOnStop = chunks.createShaderFromCode(gd, chunks.fullscreenQuadVS, shaderCodeOnStop, "fsQuad2" + params);

            this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
            this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
            this._allocate(this.numParticles);

            var mesh = new Mesh(gd);
            mesh.vertexBuffer = this.vertexBuffer;
            mesh.indexBuffer[0] = this.indexBuffer;
            mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = (this.numParticles * this.numParticleIndices);
            mesh.primitive[0].indexed = true;

            this.material = new Material();
            this.material.name = this.node.name;
            this.material.cull = CULLFACE_NONE;
            this.material.alphaWrite = false;
            this.material.blend = true;
            this.material.blendType = this.blendType;

            this.material.depthWrite = this.depthWrite;
            this.material.emitter = this;

            this.regenShader();
            this.resetMaterial();

            var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
            this.meshInstance = new MeshInstance(this.node, mesh, this.material);
            this.meshInstance.pick = false;
            this.meshInstance.updateKey(); // shouldn't be here?
            this.meshInstance.cull = true;
            this.meshInstance._noDepthDrawGl1 = true;
            if (this.localSpace) {
                this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
            } else {
                this.meshInstance.aabb.copy(this.worldBounds);
            }
            this.meshInstance._updateAabb = false;
            this.meshInstance.visible = wasVisible;

            this._initializeTextures();

            this.resetTime();

            this.addTime(0, false); // fill dynamic textures and constants with initial data
            if (this.preWarm) this.prewarm(this.lifetime);
        },

        _isAnimated: function () {
            return this.animNumFrames >= 1 &&
                   (this.animTilesX > 1 || this.animTilesY > 1) &&
                   (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);
        },

        rebuildGraphs: function () {
            var precision = this.precision;
            var gd = this.graphicsDevice;
            var i;

            this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
            this.qVelocity = this.velocityGraph.quantize(precision);
            this.qColor =         this.colorGraph.quantizeClamped(precision, 0, 1);
            this.qRotSpeed =      this.rotationSpeedGraph.quantize(precision);
            this.qScale =         this.scaleGraph.quantize(precision);
            this.qAlpha =         this.alphaGraph.quantize(precision);
            this.qRadialSpeed =   this.radialSpeedGraph.quantize(precision);

            this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
            this.qVelocity2 =      this.velocityGraph2.quantize(precision);
            this.qColor2 =         this.colorGraph2.quantizeClamped(precision, 0, 1);
            this.qRotSpeed2 =      this.rotationSpeedGraph2.quantize(precision);
            this.qScale2 =         this.scaleGraph2.quantize(precision);
            this.qAlpha2 =         this.alphaGraph2.quantize(precision);
            this.qRadialSpeed2 =   this.radialSpeedGraph2.quantize(precision);

            for (i = 0; i < precision; i++) {
                this.qRotSpeed[i] *= math.DEG_TO_RAD;
                this.qRotSpeed2[i] *= math.DEG_TO_RAD;
            }

            this.localVelocityUMax = new Float32Array(3);
            this.velocityUMax = new Float32Array(3);
            this.colorUMax = new Float32Array(3);
            this.rotSpeedUMax = [0];
            this.scaleUMax =    [0];
            this.alphaUMax =    [0];
            this.radialSpeedUMax = [0];
            this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
            this.qVelocityDiv =      divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
            this.qColorDiv =         divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
            this.qRotSpeedDiv =      divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
            this.qScaleDiv =         divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
            this.qAlphaDiv =         divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
            this.qRadialSpeedDiv =   divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);

            if (this.pack8) {
                var umax = [0, 0, 0];
                maxUnsignedGraphValue(this.qVelocity, umax);
                var umax2 = [0, 0, 0];
                maxUnsignedGraphValue(this.qVelocity2, umax2);

                var lumax = [0, 0, 0];
                maxUnsignedGraphValue(this.qLocalVelocity, lumax);
                var lumax2 = [0, 0, 0];
                maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);

                var rumax = [0];
                maxUnsignedGraphValue(this.qRadialSpeed, rumax);
                var rumax2 = [0];
                maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);

                var maxVel = Math.max(umax[0], umax2[0]);
                maxVel = Math.max(maxVel, umax[1]);
                maxVel = Math.max(maxVel, umax2[1]);
                maxVel = Math.max(maxVel, umax[2]);
                maxVel = Math.max(maxVel, umax2[2]);

                var lmaxVel = Math.max(lumax[0], lumax2[0]);
                lmaxVel = Math.max(lmaxVel, lumax[1]);
                lmaxVel = Math.max(lmaxVel, lumax2[1]);
                lmaxVel = Math.max(lmaxVel, lumax[2]);
                lmaxVel = Math.max(lmaxVel, lumax2[2]);

                var maxRad = Math.max(rumax[0], rumax2[0]);

                this.maxVel = maxVel + lmaxVel + maxRad;
            }


            if (!this.useCpu) {
                this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
                this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
                this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
                this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
            }
            this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);
        },

        _initializeTextures: function () {
            if (this.colorMap) {
                this.material.setParameter('colorMap', this.colorMap);
                if (this.lighting && this.normalMap) {
                    this.material.setParameter('normalMap', this.normalMap);
                }
            }
        },

        regenShader: function () {
            var programLib = this.graphicsDevice.getProgramLibrary();
            var hasNormal = (this.normalMap !== null);
            this.normalOption = 0;
            if (this.lighting) {
                this.normalOption = hasNormal ? 2 : 1;
            }
            // updateShader is also called by pc.Scene when all shaders need to be updated
            this.material.updateShader = function () {

                // The app works like this:
                // 1. Emitter init
                // 2. Update. No camera is assigned to emitters
                // 3. Render; activeCamera = camera; shader init
                // 4. Update. activeCamera is set to emitters
                // -----
                // The problem with 1st frame render is that we init the shader without having any camera set to emitter -
                // so wrong shader is being compiled.
                // To fix it, we need to check activeCamera!=emitter.camera in shader init too
                if (this.emitter.scene) {
                    if (this.emitter.camera != this.emitter.scene._activeCamera) {
                        this.emitter.camera = this.emitter.scene._activeCamera;
                        this.emitter.onChangeCamera();
                    }
                }

                var shader = programLib.getProgram("particle", {
                    useCpu: this.emitter.useCpu,
                    normal: this.emitter.normalOption,
                    halflambert: this.emitter.halfLambert,
                    stretch: this.emitter.stretch,
                    alignToMotion: this.emitter.alignToMotion,
                    soft: this.emitter.depthSoftening,
                    mesh: this.emitter.useMesh,
                    gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
                    toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
                    fog: (this.emitter.scene && !this.emitter.noFog) ? this.emitter.scene.fog : "none",
                    wrap: this.emitter.wrap && this.emitter.wrapBounds,
                    localSpace: this.emitter.localSpace,
                    blend: this.blendType,
                    animTex: this.emitter._isAnimated(),
                    animTexLoop: this.emitter.animLoop,
                    pack8: this.emitter.pack8,
                    customFace: this.emitter.orientation != PARTICLEORIENTATION_SCREEN
                });
                this.shader = shader;
            };
            this.material.updateShader();
        },

        resetMaterial: function () {
            var material = this.material;

            material.setParameter('stretch', this.stretch);
            if (this._isAnimated()) {
                material.setParameter('animTexTilesParams', this.animTilesParams);
                material.setParameter('animTexParams', this.animParams);
                material.setParameter('animTexIndexParams', this.animIndexParams);
            }
            material.setParameter('colorMult', this.intensity);
            if (!this.useCpu) {
                material.setParameter('internalTex0', this.internalTex0);
                material.setParameter('internalTex1', this.internalTex1);
                material.setParameter('internalTex2', this.internalTex2);
                material.setParameter('internalTex3', this.internalTex3);
            }
            material.setParameter('colorParam', this.colorParam);

            material.setParameter('numParticles', this.numParticles);
            material.setParameter('numParticlesPot', this.numParticlesPot);
            material.setParameter('lifetime', this.lifetime);
            material.setParameter('rate', this.rate);
            material.setParameter('rateDiv', this.rate2 - this.rate);
            material.setParameter('seed', this.seed);
            material.setParameter('scaleDivMult', this.scaleUMax[0]);
            material.setParameter('alphaDivMult', this.alphaUMax[0]);
            material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
            material.setParameter("graphNumSamples", this.precision);
            material.setParameter("graphSampleSize", 1.0 / this.precision);
            material.setParameter("emitterScale", new Float32Array([1, 1, 1]));

            if (this.pack8) {
                this._gpuUpdater._setInputBounds();
                material.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform);
                material.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform);
                material.setParameter("maxVel", this.maxVel);
            }

            if (this.wrap && this.wrapBounds) {
                this.wrapBoundsUniform[0] = this.wrapBounds.x;
                this.wrapBoundsUniform[1] = this.wrapBounds.y;
                this.wrapBoundsUniform[2] = this.wrapBounds.z;
                material.setParameter('wrapBounds', this.wrapBoundsUniform);
            }

            if (this.colorMap) {
                material.setParameter('colorMap', this.colorMap);
            }

            if (this.lighting) {
                if (this.normalMap) {
                    material.setParameter('normalMap', this.normalMap);
                }
            }
            if (this.depthSoftening > 0) {
                material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100)); // remap to more perceptually linear
            }
            if (this.stretch > 0.0) material.cull = CULLFACE_NONE;

            this._compParticleFaceParams();
        },

        _compParticleFaceParams: function () {
            var tangent, binormal;
            if (this.orientation == PARTICLEORIENTATION_SCREEN) {
                tangent = new Float32Array([1, 0, 0]);
                binormal = new Float32Array([0, 0, 1]);
            } else {
                var n;
                if (this.orientation == PARTICLEORIENTATION_WORLD) {
                    n = this.particleNormal.normalize();
                } else {
                    var emitterMat = this.node === null ?
                        Mat4.IDENTITY : this.node.getWorldTransform();
                    n = emitterMat.transformVector(this.particleNormal).normalize();
                }
                var t = new Vec3(1, 0, 0);
                if (Math.abs(t.dot(n)) == 1)
                    t.set(0, 0, 1);
                var b = new Vec3().cross(n, t).normalize();
                t.cross(b, n).normalize();
                tangent = new Float32Array([t.x, t.y, t.z]);
                binormal = new Float32Array([b.x, b.y, b.z]);
            }
            this.material.setParameter("faceTangent", tangent);
            this.material.setParameter("faceBinorm", binormal);
        },


        // Declares vertex format, creates VB and IB
        _allocate: function (numParticles) {
            var psysVertCount = numParticles * this.numParticleVerts;
            var psysIndexCount = numParticles * this.numParticleIndices;
            var elements, particleFormat;
            var i;

            if ((this.vertexBuffer === undefined) || (this.vertexBuffer.getNumVertices() !== psysVertCount)) {
                // Create the particle vertex format
                if (!this.useCpu) {
                    // GPU: XYZ = quad vertex position; W = INT: particle ID, FRAC: random factor
                    elements = [{
                        semantic: SEMANTIC_ATTR0,
                        components: 4,
                        type: TYPE_FLOAT32
                    }];
                    if (this.useMesh) {
                        elements.push({
                            semantic: SEMANTIC_ATTR1,
                            components: 2,
                            type: TYPE_FLOAT32
                        });
                    }
                    particleFormat = new VertexFormat(this.graphicsDevice, elements);

                    this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
                    this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
                } else {
                    elements = [{
                        semantic: SEMANTIC_ATTR0,
                        components: 4,
                        type: TYPE_FLOAT32
                    }, {
                        semantic: SEMANTIC_ATTR1,
                        components: 4,
                        type: TYPE_FLOAT32
                    }, {
                        semantic: SEMANTIC_ATTR2,
                        components: 4,
                        type: TYPE_FLOAT32
                    }, {
                        semantic: SEMANTIC_ATTR3,
                        components: 1,
                        type: TYPE_FLOAT32
                    }, {
                        semantic: SEMANTIC_ATTR4,
                        components: this.useMesh ? 4 : 2,
                        type: TYPE_FLOAT32
                    }];
                    particleFormat = new VertexFormat(this.graphicsDevice, elements);

                    this.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);
                    this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);
                }

                // Fill the vertex buffer
                var data = new Float32Array(this.vertexBuffer.lock());
                var meshData, stride, texCoordOffset;
                if (this.useMesh) {
                    meshData = new Float32Array(this.mesh.vertexBuffer.lock());
                    stride = meshData.length / this.mesh.vertexBuffer.numVertices;
                    for (var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {
                        if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
                            texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
                            break;
                        }
                    }
                }

                var id;
                for (i = 0; i < psysVertCount; i++) {
                    id = Math.floor(i / this.numParticleVerts);
                    if (!this.useMesh) {
                        var vertID = i % 4;
                        data[i * 4] = particleVerts[vertID][0];
                        data[i * 4 + 1] = particleVerts[vertID][1];
                        data[i * 4 + 2] = 0;
                        data[i * 4 + 3] = id;
                    } else {
                        var vert = i % this.numParticleVerts;
                        data[i * 6] = meshData[vert * stride];
                        data[i * 6 + 1] = meshData[vert * stride + 1];
                        data[i * 6 + 2] = meshData[vert * stride + 2];
                        data[i * 6 + 3] = id;
                        data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
                        data[i * 6 + 5] = meshData[vert * stride + texCoordOffset + 1];
                    }
                }

                if (this.useCpu) {
                    this.vbCPU = new Float32Array(data);
                    this.vbOld = new Float32Array(this.vbCPU.length);
                }
                this.vertexBuffer.unlock();
                if (this.useMesh) {
                    this.mesh.vertexBuffer.unlock();
                }


                // Fill the index buffer
                var dst = 0;
                var indices = new Uint16Array(this.indexBuffer.lock());
                if (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());
                for (i = 0; i < numParticles; i++) {
                    if (!this.useMesh) {
                        var baseIndex = i * 4;
                        indices[dst++] = baseIndex;
                        indices[dst++] = baseIndex + 1;
                        indices[dst++] = baseIndex + 2;
                        indices[dst++] = baseIndex;
                        indices[dst++] = baseIndex + 2;
                        indices[dst++] = baseIndex + 3;
                    } else {
                        for (var j = 0; j < this.numParticleIndices; j++) {
                            indices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;
                        }
                    }
                }
                this.indexBuffer.unlock();
                if (this.useMesh) this.mesh.indexBuffer[0].unlock();
            }
        },

        reset: function () {
            this.beenReset = true;
            this.seed = Math.random();
            this.material.setParameter('seed', this.seed);
            if (this.useCpu) {
                for (var i = 0; i < this.particleTexStart.length; i++) {
                    this.particleTex[i] = this.particleTexStart[i];
                }
            } else {
                this._initializeTextures();
            }
            this.resetWorldBounds();
            this.resetTime();
            var origLoop =  this.loop;
            this.loop = true;
            this.addTime(0, false);
            this.loop = origLoop;
            if (this.preWarm) {
                this.prewarm(this.lifetime);
            }
        },

        prewarm: function (time) {
            var lifetimeFraction = time / this.lifetime;
            var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
            var stepDelta = time / iterations;
            for (var i = 0; i < iterations; i++) {
                this.addTime(stepDelta, false);
            }
        },

        resetTime: function () {
            this.endTime = calcEndTime(this);
        },

        finishFrame: function () {
            if (this.useCpu) this.vertexBuffer.unlock();
        },

        addTime: function (delta, isOnStop) {
            var device = this.graphicsDevice;


            this.simTimeTotal += delta;

            this.calculateWorldBounds();

            if (this._isAnimated()) {
                var tilesParams = this.animTilesParams;
                tilesParams[0] = 1.0 / this.animTilesX; // animTexTilesParams.x
                tilesParams[1] = 1.0 / this.animTilesY; // animTexTilesParams.y

                var params = this.animParams;
                params[0] = this.animStartFrame; // animTexParams.x
                params[1] = this.animNumFrames * this.animSpeed; // animTexParams.y
                params[2] = this.animNumFrames - 1; // animTexParams.z
                params[3] = this.animNumAnimations - 1; // animTexParams.w

                var animIndexParams = this.animIndexParams;
                animIndexParams[0] = this.animIndex; // animTexIndexParams.x
                animIndexParams[1] = this.randomizeAnimIndex; // animTexIndexParams.y
            }

            if (this.scene) {
                if (this.camera != this.scene._activeCamera) {
                    this.camera = this.scene._activeCamera;
                    this.onChangeCamera();
                }
            }

            if (this.emitterShape === EMITTERSHAPE_BOX) {
                extentsInnerRatioUniform[0] = this.emitterExtents.x != 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
                extentsInnerRatioUniform[1] = this.emitterExtents.y != 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
                extentsInnerRatioUniform[2] = this.emitterExtents.z != 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
                if (this.meshInstance.node === null){
                    spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
                } else {
                    spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3$2.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
                }
            }

            var emitterPos;
            var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
            this.emitterScaleUniform[0] = emitterScale.x;
            this.emitterScaleUniform[1] = emitterScale.y;
            this.emitterScaleUniform[2] = emitterScale.z;
            this.material.setParameter("emitterScale", this.emitterScaleUniform);
            if (this.localSpace && this.meshInstance.node) {
                emitterPos = this.meshInstance.node.getPosition();
                this.emitterPosUniform[0] = emitterPos.x;
                this.emitterPosUniform[1] = emitterPos.y;
                this.emitterPosUniform[2] = emitterPos.z;
                this.material.setParameter("emitterPos", this.emitterPosUniform);
            }

            this._compParticleFaceParams();

            if (!this.useCpu) {
                this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
            } else {
                var data = new Float32Array(this.vertexBuffer.lock());
                this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
                // this.vertexBuffer.unlock();
            }

            if (!this.loop) {
                if (Date.now() > this.endTime) {
                    if (this.onFinished) this.onFinished();
                    this.meshInstance.visible = false;
                }
            }

        },

        _destroyResources: function () {
            if (this.particleTexIN) {
                this.particleTexIN.destroy();
                this.particleTexIN = null;
            }

            if (this.particleTexOUT) {
                this.particleTexOUT.destroy();
                this.particleTexOUT = null;
            }

            if (this.particleTexStart && this.particleTexStart.destroy) {
                this.particleTexStart.destroy();
                this.particleTexStart = null;
            }

            if (this.rtParticleTexIN) {
                this.rtParticleTexIN.destroy();
                this.rtParticleTexIN = null;
            }

            if (this.rtParticleTexOUT) {
                this.rtParticleTexOUT.destroy();
                this.rtParticleTexOUT = null;
            }

            if (this.internalTex0) {
                this.internalTex0.destroy();
                this.internalTex0 = null;
            }

            if (this.internalTex1) {
                this.internalTex1.destroy();
                this.internalTex1 = null;
            }

            if (this.internalTex2) {
                this.internalTex2.destroy();
                this.internalTex2 = null;
            }

            if (this.internalTex3) {
                this.internalTex3.destroy();
                this.internalTex3 = null;
            }

            if (this.colorParam) {
                this.colorParam.destroy();
                this.colorParam = null;
            }

            if (this.vertexBuffer) {
                this.vertexBuffer.destroy();
                this.vertexBuffer = undefined; // we are testing if vb is undefined in some code, no idea why
            }

            if (this.indexBuffer) {
                this.indexBuffer.destroy();
                this.indexBuffer = undefined;
            }

            if (this.material) {
                this.material.destroy();
                this.material = null;
            }

            // note: shaders should not be destroyed as they could be shared between emitters
        },

        destroy: function () {
            this.camera = null;

            this._destroyResources();
        }
    });

    /**
     * @function
     * @name pc.calculateNormals
     * @description Generates normal information from the specified positions and
     * triangle indices. See {@link pc.createMesh}.
     * @param {number[]} positions - An array of 3-dimensional vertex positions.
     * @param {number[]} indices - An array of triangle indices.
     * @returns {number[]} An array of 3-dimensional vertex normals.
     * @example
     * var normals = pc.calculateNormals(positions, indices);
     * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
     * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
     */

    var primitiveUv1Padding = 4.0 / 64;
    var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;

    function calculateNormals(positions, indices) {
        var triangleCount = indices.length / 3;
        var vertexCount   = positions.length / 3;
        var i1, i2, i3;
        var i; // Loop counter
        var p1 = new Vec3();
        var p2 = new Vec3();
        var p3 = new Vec3();
        var p1p2 = new Vec3();
        var p1p3 = new Vec3();
        var faceNormal = new Vec3();

        var normals = [];

        // Initialize the normal array to zero
        for (i = 0; i < positions.length; i++) {
            normals[i] = 0;
        }

        // Accumulate face normals for each vertex
        for (i = 0; i < triangleCount; i++) {
            i1 = indices[i * 3];
            i2 = indices[i * 3 + 1];
            i3 = indices[i * 3 + 2];

            p1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
            p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
            p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);

            p1p2.sub2(p2, p1);
            p1p3.sub2(p3, p1);
            faceNormal.cross(p1p2, p1p3).normalize();

            normals[i1 * 3]     += faceNormal.x;
            normals[i1 * 3 + 1] += faceNormal.y;
            normals[i1 * 3 + 2] += faceNormal.z;
            normals[i2 * 3]     += faceNormal.x;
            normals[i2 * 3 + 1] += faceNormal.y;
            normals[i2 * 3 + 2] += faceNormal.z;
            normals[i3 * 3]     += faceNormal.x;
            normals[i3 * 3 + 1] += faceNormal.y;
            normals[i3 * 3 + 2] += faceNormal.z;
        }

        // Normalize all normals
        for (i = 0; i < vertexCount; i++) {
            var nx = normals[i * 3];
            var ny = normals[i * 3 + 1];
            var nz = normals[i * 3 + 2];
            var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            normals[i * 3] *= invLen;
            normals[i * 3 + 1] *= invLen;
            normals[i * 3 + 2] *= invLen;
        }

        return normals;
    }

    /**
     * @function
     * @name pc.calculateTangents
     * @description Generates tangent information from the specified positions,
     * normals, texture coordinates and triangle indices. See {@link pc.createMesh}.
     * @param {number[]} positions - An array of 3-dimensional vertex positions.
     * @param {number[]} normals - An array of 3-dimensional vertex normals.
     * @param {number[]} uvs - An array of 2-dimensional vertex texture coordinates.
     * @param {number[]} indices - An array of triangle indices.
     * @returns {number[]} An array of 3-dimensional vertex tangents.
     * @example
     * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
     * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
     */
    function calculateTangents(positions, normals, uvs, indices) {
        var triangleCount = indices.length / 3;
        var vertexCount   = positions.length / 3;
        var i1, i2, i3;
        var x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r;
        var sdir = new Vec3();
        var tdir = new Vec3();
        var v1   = new Vec3();
        var v2   = new Vec3();
        var v3   = new Vec3();
        var w1   = new Vec2();
        var w2   = new Vec2();
        var w3   = new Vec2();
        var i; // Loop counter
        var tan1 = new Float32Array(vertexCount * 3);
        var tan2 = new Float32Array(vertexCount * 3);

        var tangents = [];
        var area = 0.0;

        for (i = 0; i < triangleCount; i++) {
            i1 = indices[i * 3];
            i2 = indices[i * 3 + 1];
            i3 = indices[i * 3 + 2];

            v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
            v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
            v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);

            w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
            w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
            w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);

            x1 = v2.x - v1.x;
            x2 = v3.x - v1.x;
            y1 = v2.y - v1.y;
            y2 = v3.y - v1.y;
            z1 = v2.z - v1.z;
            z2 = v3.z - v1.z;

            s1 = w2.x - w1.x;
            s2 = w3.x - w1.x;
            t1 = w2.y - w1.y;
            t2 = w3.y - w1.y;

            area = s1 * t2 - s2 * t1;

            // Area can 0.0 for degenerate triangles or bad uv coordinates
            if (area == 0.0) {
                // Fallback to default values
                sdir.set(0.0, 1.0, 0.0);
                tdir.set(1.0, 0.0, 0.0);
            } else {
                r = 1.0 / area;
                sdir.set((t2 * x1 - t1 * x2) * r,
                         (t2 * y1 - t1 * y2) * r,
                         (t2 * z1 - t1 * z2) * r);
                tdir.set((s1 * x2 - s2 * x1) * r,
                         (s1 * y2 - s2 * y1) * r,
                         (s1 * z2 - s2 * z1) * r);
            }

            tan1[i1 * 3 + 0] += sdir.x;
            tan1[i1 * 3 + 1] += sdir.y;
            tan1[i1 * 3 + 2] += sdir.z;
            tan1[i2 * 3 + 0] += sdir.x;
            tan1[i2 * 3 + 1] += sdir.y;
            tan1[i2 * 3 + 2] += sdir.z;
            tan1[i3 * 3 + 0] += sdir.x;
            tan1[i3 * 3 + 1] += sdir.y;
            tan1[i3 * 3 + 2] += sdir.z;

            tan2[i1 * 3 + 0] += tdir.x;
            tan2[i1 * 3 + 1] += tdir.y;
            tan2[i1 * 3 + 2] += tdir.z;
            tan2[i2 * 3 + 0] += tdir.x;
            tan2[i2 * 3 + 1] += tdir.y;
            tan2[i2 * 3 + 2] += tdir.z;
            tan2[i3 * 3 + 0] += tdir.x;
            tan2[i3 * 3 + 1] += tdir.y;
            tan2[i3 * 3 + 2] += tdir.z;
        }

        t1 = new Vec3();
        t2 = new Vec3();
        var n = new Vec3();
        var temp = new Vec3();

        for (i = 0; i < vertexCount; i++) {
            n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
            t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
            t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);

            // Gram-Schmidt orthogonalize
            var ndott = n.dot(t1);
            temp.copy(n).scale(ndott);
            temp.sub2(t1, temp).normalize();

            tangents[i * 4]     = temp.x;
            tangents[i * 4 + 1] = temp.y;
            tangents[i * 4 + 2] = temp.z;

            // Calculate handedness
            temp.cross(n, t1);
            tangents[i * 4 + 3] = (temp.dot(t2) < 0.0) ? -1.0 : 1.0;
        }

        return tangents;
    }

    /**
     * @function
     * @name pc.createMesh
     * @description Creates a new mesh object from the supplied vertex information and topology.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {number[]} positions - An array of 3-dimensional vertex positions.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number[]} [opts.normals] - An array of 3-dimensional vertex normals.
     * @param {number[]} [opts.tangents] - An array of 3-dimensional vertex tangents.
     * @param {number[]} [opts.colors] - An array of 4-dimensional vertex colors.
     * @param {number[]} [opts.uvs] - An array of 2-dimensional vertex texture coordinates.
     * @param {number[]} [opts.uvs1] - Same as opts.uvs, but for additional UV set
     * @param {number[]} [opts.indices] - An array of triangle indices.
     * @returns {pc.Mesh} A new Geometry constructed from the supplied vertex and triangle data.
     * @example
     * // Create a new mesh supplying optional parameters using object literal notation
     * var mesh = pc.createMesh(
     *     graphicsDevice,
     *     positions,
     *     {
     *         normals: treeNormals,
     *         uvs: treeUvs,
     *         indices: treeIndices
     *     });
     */
    function createMesh(device, positions, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var normals      = opts && opts.normals !== undefined ? opts.normals : null;
        var tangents     = opts && opts.tangents !== undefined ? opts.tangents : null;
        var colors       = opts && opts.colors !== undefined ? opts.colors : null;
        var uvs          = opts && opts.uvs !== undefined ? opts.uvs : null;
        var uvs1         = opts && opts.uvs1 !== undefined ? opts.uvs1 : null;
        var indices      = opts && opts.indices !== undefined ? opts.indices : null;
        var blendIndices = opts && opts.blendIndices !== undefined ? opts.blendIndices : null;
        var blendWeights = opts && opts.blendWeights !== undefined ? opts.blendWeights : null;

        var vertexDesc = [
            { semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 }
        ];
        if (normals !== null) {
            vertexDesc.push({ semantic: SEMANTIC_NORMAL, components: 3, type: TYPE_FLOAT32 });
        }
        if (tangents !== null) {
            vertexDesc.push({ semantic: SEMANTIC_TANGENT, components: 4, type: TYPE_FLOAT32 });
        }
        if (colors !== null) {
            vertexDesc.push({ semantic: SEMANTIC_COLOR, components: 4, type: TYPE_UINT8, normalize: true });
        }
        if (uvs !== null) {
            vertexDesc.push({ semantic: SEMANTIC_TEXCOORD0, components: 2, type: TYPE_FLOAT32 });
        }
        if (uvs1 !== null) {
            vertexDesc.push({ semantic: SEMANTIC_TEXCOORD1, components: 2, type: TYPE_FLOAT32 });
        }
        if (blendIndices !== null) {
            vertexDesc.push({ semantic: SEMANTIC_BLENDINDICES, components: 2, type: TYPE_UINT8 });
        }
        if (blendWeights !== null) {
            vertexDesc.push({ semantic: SEMANTIC_BLENDWEIGHT, components: 2, type: TYPE_FLOAT32 });
        }

        var vertexFormat = new VertexFormat(device, vertexDesc);

        // Create the vertex buffer
        var numVertices  = positions.length / 3;
        var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);

        // Write the vertex data into the vertex buffer
        var iterator = new VertexIterator(vertexBuffer);
        for (var i = 0; i < numVertices; i++) {
            iterator.element[SEMANTIC_POSITION].set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
            if (normals !== null) {
                iterator.element[SEMANTIC_NORMAL].set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
            }
            if (tangents !== null) {
                iterator.element[SEMANTIC_TANGENT].set(tangents[i * 4], tangents[i * 4 + 1], tangents[i * 4 + 2], tangents[i * 4 + 3]);
            }
            if (colors !== null) {
                iterator.element[SEMANTIC_COLOR].set(colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]);
            }
            if (uvs !== null) {
                iterator.element[SEMANTIC_TEXCOORD0].set(uvs[i * 2], uvs[i * 2 + 1]);
            }
            if (uvs1 !== null) {
                iterator.element[SEMANTIC_TEXCOORD1].set(uvs1[i * 2], uvs1[i * 2 + 1]);
            }
            if (blendIndices !== null) {
                iterator.element[SEMANTIC_BLENDINDICES].set(blendIndices[i * 2], blendIndices[i * 2 + 1]);
            }
            if (blendWeights !== null) {
                iterator.element[SEMANTIC_BLENDWEIGHT].set(blendWeights[i * 2], blendWeights[i * 2 + 1]);
            }
            iterator.next();
        }
        iterator.end();

        // Create the index buffer
        var indexBuffer = null;
        var indexed = (indices !== null);
        if (indexed) {
            indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, indices.length);

            // Read the indicies into the index buffer
            var dst = new Uint16Array(indexBuffer.lock());
            dst.set(indices);
            indexBuffer.unlock();
        }

        var aabb = new BoundingBox();
        aabb.compute(positions);

        var mesh = new Mesh(device);
        mesh.vertexBuffer = vertexBuffer;
        mesh.indexBuffer[0] = indexBuffer;
        mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
        mesh.primitive[0].base = 0;
        mesh.primitive[0].count = indexed ? indices.length : numVertices;
        mesh.primitive[0].indexed = indexed;
        mesh.aabb = aabb;
        return mesh;
    }

    /**
     * @function
     * @name pc.createTorus
     * @description Creates a procedural torus-shaped mesh.
     *
     * The size, shape and tesselation properties of the torus can be controlled via function parameters.
     * By default, the function will create a torus in the XZ-plane with a tube radius of 0.2, a ring radius
     * of 0.3, 20 segments and 30 sides.
     *
     * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent information
     * is generated into the vertex buffer of the torus's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.tubeRadius] - The radius of the tube forming the body of the torus (defaults to 0.2).
     * @param {number} [opts.ringRadius] - The radius from the centre of the torus to the centre of the tube (defaults to 0.3).
     * @param {number} [opts.segments] - The number of radial divisions forming cross-sections of the torus ring (defaults to 20).
     * @param {number} [opts.sides] - The number of divisions around the tubular body of the torus ring (defaults to 30).
     * @returns {pc.Mesh} A new torus-shaped mesh.
     */
    function createTorus(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;
        var rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;
        var segments = opts && opts.segments !== undefined ? opts.segments : 30;
        var sides = opts && opts.sides !== undefined ? opts.sides : 20;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        // Variable declarations
        var i, j;
        var x, y, z, nx, ny, nz, u, v;
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        for (i = 0; i <= sides; i++) {
            for (j = 0; j <= segments; j++) {
                x  = Math.cos(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));
                y  = Math.sin(2.0 * Math.PI * i / sides) * rc;
                z  = Math.sin(2.0 * Math.PI * j / segments) * (rt + rc * Math.cos(2.0 * Math.PI * i / sides));

                nx = Math.cos(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);
                ny = Math.sin(2.0 * Math.PI * i / sides);
                nz = Math.sin(2.0 * Math.PI * j / segments) * Math.cos(2.0 * Math.PI * i / sides);

                u = i / sides;
                v = 1.0 - j / segments;

                positions.push(x, y, z);
                normals.push(nx, ny, nz);
                uvs.push(u, v);

                if ((i < sides) && (j < segments)) {
                    var first, second, third, fourth;
                    first   = ((i))     * (segments + 1) + ((j));
                    second  = ((i + 1)) * (segments + 1) + ((j));
                    third   = ((i))     * (segments + 1) + ((j + 1));
                    fourth  = ((i + 1)) * (segments + 1) + ((j + 1));

                    indices.push(first, second, third);
                    indices.push(second, fourth, third);
                }
            }
        }

        var options = {
            normals: normals,
            uvs: uvs,
            indices: indices
        };

        if (calculateTangents) {
            options.tangents = calculateTangents(positions, normals, uvs, indices);
        }

        return createMesh(device, positions, options);
    }

    function _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
        // Variable declarations
        var i, j;
        var x, y, z, u, v;
        var pos = new Vec3();
        var bottomToTop = new Vec3();
        var norm = new Vec3();
        var top, bottom, tangent;
        var positions = [];
        var normals = [];
        var uvs = [];
        var uvs1 = [];
        var indices = [];
        var theta, cosTheta, sinTheta;
        var phi, sinPhi, cosPhi;
        var first, second, third, fourth;
        var offset;

        // Define the body of the cone/cylinder
        if (height > 0) {
            for (i = 0; i <= heightSegments; i++) {
                for (j = 0; j <= capSegments; j++) {
                    // Sweep the cone body from the positive Y axis to match a 3DS Max cone/cylinder
                    theta = (j / capSegments) * 2.0 * Math.PI - Math.PI;
                    sinTheta = Math.sin(theta);
                    cosTheta = Math.cos(theta);
                    bottom = new Vec3(sinTheta * baseRadius, -height / 2.0, cosTheta * baseRadius);
                    top    = new Vec3(sinTheta * peakRadius,  height / 2.0, cosTheta * peakRadius);
                    pos.lerp(bottom, top, i / heightSegments);
                    bottomToTop.sub2(top, bottom).normalize();
                    tangent = new Vec3(cosTheta, 0.0, -sinTheta);
                    norm.cross(tangent, bottomToTop).normalize();

                    positions.push(pos.x, pos.y, pos.z);
                    normals.push(norm.x, norm.y, norm.z);
                    u = j / capSegments;
                    v = i / heightSegments;
                    uvs.push(u, v);

                    // Pack UV1 to 1st third
                    var _v = v;
                    v = u;
                    u = _v;
                    u /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    uvs1.push(u, v);

                    if ((i < heightSegments) && (j < capSegments)) {
                        first   = ((i))     * (capSegments + 1) + ((j));
                        second  = ((i))     * (capSegments + 1) + ((j + 1));
                        third   = ((i + 1)) * (capSegments + 1) + ((j));
                        fourth  = ((i + 1)) * (capSegments + 1) + ((j + 1));

                        indices.push(first, second, third);
                        indices.push(second, fourth, third);
                    }
                }
            }
        }

        if (roundedCaps) {
            var lat, lon;
            var latitudeBands = Math.floor(capSegments / 2);
            var longitudeBands = capSegments;
            var capOffset = height / 2;

            // Generate top cap
            for (lat = 0; lat <= latitudeBands; lat++) {
                theta = (lat * Math.PI * 0.5) / latitudeBands;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (lon = 0; lon <= longitudeBands; lon++) {
                    // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                    phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = cosPhi * sinTheta;
                    y = cosTheta;
                    z = sinPhi * sinTheta;
                    u = 1.0 - lon / longitudeBands;
                    v = 1.0 - lat / latitudeBands;

                    positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    // Pack UV1 to 2nd third
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += 1.0 / 3;
                    uvs1.push(u, v);
                }
            }

            offset = (heightSegments + 1) * (capSegments + 1);
            for (lat = 0; lat < latitudeBands; ++lat) {
                for (lon = 0; lon < longitudeBands; ++lon) {
                    first  = (lat * (longitudeBands + 1)) + lon;
                    second = first + longitudeBands + 1;

                    indices.push(offset + first + 1, offset + second, offset + first);
                    indices.push(offset + first + 1, offset + second + 1, offset + second);
                }
            }

            // Generate bottom cap
            for (lat = 0; lat <= latitudeBands; lat++) {
                theta = Math.PI * 0.5 + (lat * Math.PI * 0.5) / latitudeBands;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (lon = 0; lon <= longitudeBands; lon++) {
                    // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                    phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = cosPhi * sinTheta;
                    y = cosTheta;
                    z = sinPhi * sinTheta;
                    u = 1.0 - lon / longitudeBands;
                    v = 1.0 - lat / latitudeBands;

                    positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    // Pack UV1 to 3rd third
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += 2.0 / 3;
                    uvs1.push(u, v);
                }
            }

            offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
            for (lat = 0; lat < latitudeBands; ++lat) {
                for (lon = 0; lon < longitudeBands; ++lon) {
                    first  = (lat * (longitudeBands + 1)) + lon;
                    second = first + longitudeBands + 1;

                    indices.push(offset + first + 1, offset + second, offset + first);
                    indices.push(offset + first + 1, offset + second + 1, offset + second);
                }
            }
        } else {
            // Generate bottom cap
            offset = (heightSegments + 1) * (capSegments + 1);
            if (baseRadius > 0.0) {
                for (i = 0; i < capSegments; i++) {
                    theta = (i / capSegments) * 2.0 * Math.PI;
                    x = Math.sin(theta);
                    y = -height / 2.0;
                    z = Math.cos(theta);
                    u = 1.0 - (x + 1.0) / 2.0;
                    v = (z + 1.0) / 2.0;

                    positions.push(x * baseRadius, y, z * baseRadius);
                    normals.push(0.0, -1.0, 0.0);
                    uvs.push(u, v);

                    // Pack UV1 to 2nd third
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += 1.0 / 3;
                    uvs1.push(u, v);

                    if (i > 1) {
                        indices.push(offset, offset + i, offset + i - 1);
                    }
                }
            }

            // Generate top cap
            offset += capSegments;
            if (peakRadius > 0.0) {
                for (i = 0; i < capSegments; i++) {
                    theta = (i / capSegments) * 2.0 * Math.PI;
                    x = Math.sin(theta);
                    y = height / 2.0;
                    z = Math.cos(theta);
                    u = 1.0 - (x + 1.0) / 2.0;
                    v = (z + 1.0) / 2.0;

                    positions.push(x * peakRadius, y, z * peakRadius);
                    normals.push(0.0, 1.0, 0.0);
                    uvs.push(u, v);

                    // Pack UV1 to 3rd third
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += 2.0 / 3;
                    uvs1.push(u, v);

                    if (i > 1) {
                        indices.push(offset, offset + i - 1, offset + i);
                    }
                }
            }
        }

        return {
            positions: positions,
            normals: normals,
            uvs: uvs,
            uvs1: uvs1,
            indices: indices
        };
    }

    /**
     * @function
     * @name pc.createCylinder
     * @description Creates a procedural cylinder-shaped mesh.
     *
     * The size, shape and tesselation properties of the cylinder can be controlled via function parameters.
     * By default, the function will create a cylinder standing vertically centred on the XZ-plane with a radius
     * of 0.5, a height of 1.0, 1 height segment and 20 cap segments.
     *
     * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent information
     * is generated into the vertex buffer of the cylinder's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).
     * @param {number} [opts.height] - The length of the body of the cylinder (defaults to 1.0).
     * @param {number} [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).
     * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).
     * @returns {pc.Mesh} A new cylinder-shaped mesh.
     */
    function createCylinder(device, opts) {

        // Check the supplied options and provide defaults for unspecified ones
        var radius = opts && (opts.radius || opts.baseRadius);
        radius = radius !== undefined ? radius : 0.5;
        var height = opts && opts.height !== undefined ? opts.height : 1.0;
        var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
        var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        // Create vertex data for a cone that has a base and peak radius that is the same (i.e. a cylinder)
        var options = _createConeData(radius, radius, height, heightSegments, capSegments, false);

        if (calculateTangents) {
            options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
        }

        return createMesh(device, options.positions, options);
    }

    /**
     * @function
     * @name pc.createCapsule
     * @description Creates a procedural capsule-shaped mesh.
     *
     * The size, shape and tesselation properties of the capsule can be controlled via function
     * parameters. By default, the function will create a capsule standing vertically centred
     * on the XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap
     * segments.
     *
     * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent information
     * is generated into the vertex buffer of the capsule's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.radius] - The radius of the tube forming the body of the capsule (defaults to 0.3).
     * @param {number} [opts.height] - The length of the body of the capsule from tip to tip (defaults to 1.0).
     * @param {number} [opts.heightSegments] - The number of divisions along the tubular length of the capsule (defaults to 1).
     * @param {number} [opts.sides] - The number of divisions around the tubular body of the capsule (defaults to 20).
     * @returns {pc.Mesh} A new cylinder-shaped mesh.
     */
    function createCapsule(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var radius = opts && opts.radius !== undefined ? opts.radius : 0.3;
        var height = opts && opts.height !== undefined ? opts.height : 1.0;
        var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
        var sides = opts && opts.sides !== undefined ? opts.sides : 20;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        // Create vertex data for a cone that has a base and peak radius that is the same (i.e. a cylinder)
        var options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);

        if (calculateTangents) {
            options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
        }

        return createMesh(device, options.positions, options);
    }

    /**
     * @function
     * @name pc.createCone
     * @description Creates a procedural cone-shaped mesh.
     *
     * The size, shape and tesselation properties of the cone can be controlled via function
     * parameters. By default, the function will create a cone standing vertically centred
     * on the XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20
     * cap segments.
     *
     * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent
     * information is generated into the vertex buffer of the cone's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.baseRadius] - The base radius of the cone (defaults to 0.5).
     * @param {number} [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).
     * @param {number} [opts.height] - The length of the body of the cone (defaults to 1.0).
     * @param {number} [opts.heightSegments] - The number of divisions along the length of the cone (defaults to 5).
     * @param {number} [opts.capSegments] - The number of divisions around the tubular body of the cone (defaults to 18).
     * @returns {pc.Mesh} A new cone-shaped mesh.
     */
    function createCone(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;
        var peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;
        var height = opts && opts.height !== undefined ? opts.height : 1.0;
        var heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;
        var capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        var options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);

        if (calculateTangents) {
            options.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);
        }

        return createMesh(device, options.positions, options);
    }

    /**
     * @function
     * @name pc.createSphere
     * @description Creates a procedural sphere-shaped mesh.
     *
     * The size and tesselation properties of the sphere can be controlled via function
     * parameters. By default, the function will create a sphere centred on the object
     * space origin with a radius of 0.5 and 16 segments in both longitude and latitude.
     *
     * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent
     * information is generated into the vertex buffer of the sphere's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {number} [opts.radius] - The radius of the sphere (defaults to 0.5).
     * @param {number} [opts.segments] - The number of divisions along the longitudinal
     * and latitudinal axes of the sphere (defaults to 16).
     * @returns {pc.Mesh} A new sphere-shaped mesh.
     */
    function createSphere(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var radius = opts && opts.radius !== undefined ? opts.radius : 0.5;
        var latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;
        var longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        // Variable declarations
        var lon, lat;
        var theta, sinTheta, cosTheta, phi, sinPhi, cosPhi;
        var first, second;
        var x, y, z, u, v;
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        for (lat = 0; lat <= latitudeBands; lat++) {
            theta = lat * Math.PI / latitudeBands;
            sinTheta = Math.sin(theta);
            cosTheta = Math.cos(theta);

            for (lon = 0; lon <= longitudeBands; lon++) {
                // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2.0;
                sinPhi = Math.sin(phi);
                cosPhi = Math.cos(phi);

                x = cosPhi * sinTheta;
                y = cosTheta;
                z = sinPhi * sinTheta;
                u = 1.0 - lon / longitudeBands;
                v = 1.0 - lat / latitudeBands;

                positions.push(x * radius, y * radius, z * radius);
                normals.push(x, y, z);
                uvs.push(u, v);
            }
        }

        for (lat = 0; lat < latitudeBands; ++lat) {
            for (lon = 0; lon < longitudeBands; ++lon) {
                first  = (lat * (longitudeBands + 1)) + lon;
                second = first + longitudeBands + 1;

                indices.push(first + 1, second, first);
                indices.push(first + 1, second + 1, second);
            }
        }

        var options = {
            normals: normals,
            uvs: uvs,
            uvs1: uvs, // UV1 = UV0 for sphere
            indices: indices
        };

        if (calculateTangents) {
            options.tangents = calculateTangents(positions, normals, uvs, indices);
        }

        return createMesh(device, positions, options);
    }

    /**
     * @function
     * @name pc.createPlane
     * @description Creates a procedural plane-shaped mesh.
     *
     * The size and tesselation properties of the plane can be controlled via function
     * parameters. By default, the function will create a plane centred on the object
     * space origin with a width and length of 1.0 and 5 segments in either axis (50
     * triangles). The normal vector of the plane is aligned along the positive Y axis.
     *
     * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent
     * information is generated into the vertex buffer of the plane's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {pc.Vec2} [opts.halfExtents] - The half dimensions of the plane in the X and Z axes (defaults to [0.5, 0.5]).
     * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the plane (defaults to 5).
     * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the plane (defaults to 5).
     * @returns {pc.Mesh} A new plane-shaped mesh.
     */
    function createPlane(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);
        var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;
        var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        // Variable declarations
        var i, j;
        var x, y, z, u, v;
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        // Generate plane as follows (assigned UVs denoted at corners):
        // (0,1)x---------x(1,1)
        //      |         |
        //      |         |
        //      |    O--X |length
        //      |    |    |
        //      |    Z    |
        // (0,0)x---------x(1,0)
        // width
        var vcounter = 0;

        for (i = 0; i <= ws; i++) {
            for (j = 0; j <= ls; j++) {
                x = -he.x + 2.0 * he.x * i / ws;
                y = 0.0;
                z = -(-he.y + 2.0 * he.y * j / ls);
                u = i / ws;
                v = j / ls;

                positions.push(x, y, z);
                normals.push(0.0, 1.0, 0.0);
                uvs.push(u, v);

                if ((i < ws) && (j < ls)) {
                    indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
                    indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
                }

                vcounter++;
            }
        }

        var options = {
            normals: normals,
            uvs: uvs,
            uvs1: uvs, // UV1 = UV0 for plane
            indices: indices
        };

        if (calculateTangents) {
            options.tangents = calculateTangents(positions, normals, uvs, indices);
        }

        return createMesh(device, positions, options);
    }

    /**
     * @function
     * @name pc.createBox
     * @description Creates a procedural box-shaped mesh.
     *
     * The size, shape and tesselation properties of the box can be controlled via function parameters. By
     * default, the function will create a box centred on the object space origin with a width, length and
     * height of 1.0 unit and 10 segments in either axis (50 triangles per face).
     *
     * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent
     * information is generated into the vertex buffer of the box's mesh.
     * @param {pc.GraphicsDevice} device - The graphics device used to manage the mesh.
     * @param {object} [opts] - An object that specifies optional inputs for the function as follows:
     * @param {pc.Vec3} [opts.halfExtents] - The half dimensions of the box in each axis (defaults to [0.5, 0.5, 0.5]).
     * @param {number} [opts.widthSegments] - The number of divisions along the X axis of the box (defaults to 1).
     * @param {number} [opts.lengthSegments] - The number of divisions along the Z axis of the box (defaults to 1).
     * @param {number} [opts.heightSegments] - The number of divisions along the Y axis of the box (defaults to 1).
     * @returns {pc.Mesh} A new box-shaped mesh.
     */
    function createBox(device, opts) {
        // Check the supplied options and provide defaults for unspecified ones
        var he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);
        var ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;
        var ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
        var hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;
        var calculateTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;

        var corners = [
            new Vec3(-he.x, -he.y,  he.z),
            new Vec3( he.x, -he.y,  he.z),
            new Vec3( he.x,  he.y,  he.z),
            new Vec3(-he.x,  he.y,  he.z),
            new Vec3( he.x, -he.y, -he.z),
            new Vec3(-he.x, -he.y, -he.z),
            new Vec3(-he.x,  he.y, -he.z),
            new Vec3( he.x,  he.y, -he.z)
        ];

        var faceAxes = [
            [0, 1, 3], // FRONT
            [4, 5, 7], // BACK
            [3, 2, 6], // TOP
            [1, 0, 4], // BOTTOM
            [1, 4, 2], // RIGHT
            [5, 0, 6]  // LEFT
        ];

        var faceNormals = [
            [0,  0,  1], // FRONT
            [0,  0, -1], // BACK
            [0,  1,  0], // TOP
            [0, -1,  0], // BOTTOM
            [1,  0,  0], // RIGHT
            [-1,  0,  0]  // LEFT
        ];

        var sides = {
            FRONT: 0,
            BACK: 1,
            TOP: 2,
            BOTTOM: 3,
            RIGHT: 4,
            LEFT: 5
        };

        var positions = [];
        var normals = [];
        var uvs = [];
        var uvs1 = [];
        var indices = [];
        var vcounter = 0;

        var generateFace = function (side, uSegments, vSegments) {
            var u, v;
            var i, j;

            for (i = 0; i <= uSegments; i++) {
                for (j = 0; j <= vSegments; j++) {
                    var temp1 = new Vec3();
                    var temp2 = new Vec3();
                    var temp3 = new Vec3();
                    var r = new Vec3();
                    temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
                    temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
                    temp3.sub2(temp2, corners[faceAxes[side][0]]);
                    r.add2(temp1, temp3);
                    u = i / uSegments;
                    v = j / vSegments;

                    positions.push(r.x, r.y, r.z);
                    normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
                    uvs.push(u, v);
                    // pack as 3x2
                    // 1/3 will be empty, but it's either that or stretched pixels
                    // TODO: generate non-rectangular lightMaps, so we could use space without stretching
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += (side % 3) / 3;
                    v += Math.floor(side / 3) / 3;
                    uvs1.push(u, v);

                    if ((i < uSegments) && (j < vSegments)) {
                        indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
                        indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
                    }

                    vcounter++;
                }
            }
        };

        generateFace(sides.FRONT, ws, hs);
        generateFace(sides.BACK, ws, hs);
        generateFace(sides.TOP, ws, ls);
        generateFace(sides.BOTTOM, ws, ls);
        generateFace(sides.RIGHT, ls, hs);
        generateFace(sides.LEFT, ls, hs);

        var options = {
            normals: normals,
            uvs: uvs,
            uvs1: uvs1,
            indices: indices
        };

        if (calculateTangents) {
            options.tangents = calculateTangents(positions, normals, uvs, indices);
        }

        return createMesh(device, positions, options);
    }

    /**
     * @class
     * @name pc.Scene
     * @augments pc.EventHandler
     * @classdesc A scene is graphical representation of an environment. It manages the
     * scene hierarchy, all graphical objects, lights, and scene-wide properties.
     * @description Creates a new Scene.
     * @property {pc.Color} ambientLight The color of the scene's ambient light. Defaults
     * to black (0, 0, 0).
     * @property {string} fog The type of fog used by the scene. Can be:
     *
     * * {@link pc.FOG_NONE}
     * * {@link pc.FOG_LINEAR}
     * * {@link pc.FOG_EXP}
     * * {@link pc.FOG_EXP2}
     *
     * Defaults to pc.FOG_NONE.
     * @property {pc.Color} fogColor The color of the fog (if enabled). Defaults to black
     * (0, 0, 0).
     * @property {number} fogDensity The density of the fog (if enabled). This property
     * is only valid if the fog property is set to pc.FOG_EXP or pc.FOG_EXP2. Defaults to 0.
     * @property {number} fogEnd The distance from the viewpoint where linear fog reaches
     * its maximum. This property is only valid if the fog property is set to pc.FOG_LINEAR.
     * Defaults to 1000.
     * @property {number} fogStart The distance from the viewpoint where linear fog begins.
     * This property is only valid if the fog property is set to pc.FOG_LINEAR. Defaults to 1.
     * @property {number} gammaCorrection The gamma correction to apply when rendering the
     * scene. Can be:
     *
     * * {@link pc.GAMMA_NONE}
     * * {@link pc.GAMMA_SRGB}
     *
     * Defaults to pc.GAMMA_NONE.
     * @property {number} toneMapping The tonemapping transform to apply when writing
     * fragments to the frame buffer. Can be:
     *
     * * {@link pc.TONEMAP_LINEAR}
     * * {@link pc.TONEMAP_FILMIC}
     * * {@link pc.TONEMAP_HEJL}
     * * {@link pc.TONEMAP_ACES}
     *
     * Defaults to pc.TONEMAP_LINEAR.
     * @property {number} exposure The exposure value tweaks the overall brightness of
     * the scene. Defaults to 1.
     * @property {pc.Texture} skybox The base cubemap texture used as the scene's skybox, if mip level is 0. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered128 The prefiltered cubemap texture (size 128x128) used as the scene's skybox, if mip level 1. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered64 The prefiltered cubemap texture (size 64x64) used as the scene's skybox, if mip level 2. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered32 The prefiltered cubemap texture (size 32x32) used as the scene's skybox, if mip level 3. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered16 The prefiltered cubemap texture (size 16x16) used as the scene's skybox, if mip level 4. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered8 The prefiltered cubemap texture (size 8x8) used as the scene's skybox, if mip level 5. Defaults to null.
     * @property {pc.Texture} skyboxPrefiltered4 The prefiltered cubemap texture (size 4x4) used as the scene's skybox, if mip level 6. Defaults to null.
     * @property {number} skyboxIntensity Multiplier for skybox intensity. Defaults to 1.
     * @property {number} skyboxMip The mip level of the skybox to be displayed. Only valid
     * for prefiltered cubemap skyboxes. Defaults to 0 (base level).
     * @property {number} lightmapSizeMultiplier The lightmap resolution multiplier.
     * Defaults to 1.
     * @property {number} lightmapMaxResolution The maximum lightmap resolution. Defaults to
     * 2048.
     * @property {number} lightmapMode The lightmap baking mode. Can be:
     *
     * * {@link pc.BAKE_COLOR}: single color lightmap
     * * {@link pc.BAKE_COLORDIR}: single color lightmap + dominant light direction (used for
     * bump/specular). Only lights with bakeDir=true will be used for generating the dominant
     * light direction.
     *
     * Defaults to pc.BAKE_COLORDIR.
     * @property {pc.LayerComposition} layers A {@link pc.LayerComposition} that defines
     * rendering order of this scene.
     * @property {pc.StandardMaterial} defaultMaterial The default material used in case no
     * other material is available.
     * @property {pc.Entity} root The root entity of the scene, which is usually the only
     * child to the Application root entity.
     */
    function Scene() {
        EventHandler.call(this);

        this.root = null;

        this._gravity = new Vec3(0, -9.8, 0);

        this._layers = null;

        this._fog = FOG_NONE;
        this.fogColor = new Color(0, 0, 0);
        this.fogStart = 1;
        this.fogEnd = 1000;
        this.fogDensity = 0;

        this.ambientLight = new Color(0, 0, 0);

        this._gammaCorrection = GAMMA_NONE;
        this._toneMapping = 0;
        this.exposure = 1.0;

        this._skyboxPrefiltered = [null, null, null, null, null, null];

        this._firstUpdateSkybox = true;
        this._skyboxCubeMap = null;
        this.skyboxModel = null;

        this._skyboxIntensity = 1;
        this._skyboxMip = 0;

        this.lightmapSizeMultiplier = 1;
        this.lightmapMaxResolution = 2048;
        this.lightmapMode = BAKE_COLORDIR;

        this._stats = {
            meshInstances: 0,
            lights: 0,
            dynamicLights: 0,
            bakedLights: 0,
            lastStaticPrepareFullTime: 0,
            lastStaticPrepareSearchTime: 0,
            lastStaticPrepareWriteTime: 0,
            lastStaticPrepareTriAabbTime: 0,
            lastStaticPrepareCombineTime: 0,
            updateShadersTime: 0
        };

        this.updateShaders = true;
        this.updateSkybox = true;

        this._shaderVersion = 0;
        this._statsUpdated = false;

        // backwards compatibilty only
        this._models = [];

        // default material used in case no other material is available
        this.defaultMaterial = new StandardMaterial();
        this.defaultMaterial.name = "Default Material";
        this.defaultMaterial.shadingModel = SPECULAR_BLINN;
    }
    Scene.prototype = Object.create(EventHandler.prototype);
    Scene.prototype.constructor = Scene;

    Scene.prototype.destroy = function () {
        this.root = null;
        this.defaultMaterial.destroy();
        this.defaultMaterial = null;
        this.off();
    };

    Object.defineProperty(Scene.prototype, 'fog', {
        get: function () {
            return this._fog;
        },
        set: function (type) {
            if (type !== this._fog) {
                this._fog = type;
                this.updateShaders = true;
            }
        }
    });

    Object.defineProperty(Scene.prototype, 'gammaCorrection', {
        get: function () {
            return this._gammaCorrection;
        },
        set: function (value) {
            if (value !== this._gammaCorrection) {
                this._gammaCorrection = value;
                this.updateShaders = true;
            }
        }
    });

    Object.defineProperty(Scene.prototype, 'toneMapping', {
        get: function () {
            return this._toneMapping;
        },
        set: function (value) {
            if (value !== this._toneMapping) {
                this._toneMapping = value;
                this.updateShaders = true;
            }
        }
    });

    Object.defineProperty(Scene.prototype, 'skybox', {
        get: function () {
            return this._skyboxCubeMap;
        },
        set: function (value) {
            this._skyboxCubeMap = value;
            this._resetSkyboxModel();
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxIntensity', {
        get: function () {
            return this._skyboxIntensity;
        },
        set: function (value) {
            this._skyboxIntensity = value;
            this._resetSkyboxModel();
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxMip', {
        get: function () {
            return this._skyboxMip;
        },
        set: function (value) {
            this._skyboxMip = value;
            this._resetSkyboxModel();
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered128', {
        get: function () {
            return this._skyboxPrefiltered[0];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[0] === value)
                return;

            this._skyboxPrefiltered[0] = value;
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered64', {
        get: function () {
            return this._skyboxPrefiltered[1];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[1] === value)
                return;

            this._skyboxPrefiltered[1] = value;
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered32', {
        get: function () {
            return this._skyboxPrefiltered[2];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[2] === value)
                return;

            this._skyboxPrefiltered[2] = value;
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered16', {
        get: function () {
            return this._skyboxPrefiltered[3];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[3] === value)
                return;

            this._skyboxPrefiltered[3] = value;
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered8', {
        get: function () {
            return this._skyboxPrefiltered[4];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[4] === value)
                return;

            this._skyboxPrefiltered[4] = value;
            this.updateShaders = true;
        }
    });

    Object.defineProperty(Scene.prototype, 'skyboxPrefiltered4', {
        get: function () {
            return this._skyboxPrefiltered[5];
        },
        set: function (value) {
            if (this._skyboxPrefiltered[5] === value)
                return;

            this._skyboxPrefiltered[5] = value;
            this.updateShaders = true;
        }
    });

    // some backwards compatibility
    // drawCalls will now return list of all active composition mesh instances
    Object.defineProperty(Scene.prototype, 'drawCalls', {
        get: function () {
            var drawCalls = this.layers._meshInstances;
            if (!drawCalls.length) {
                this.layers._update();
                drawCalls = this.layers._meshInstances;
            }
            return drawCalls;
        },
        set: function (value) {

        }
    });

    Object.defineProperty(Scene.prototype, 'layers', {
        get: function () {
            return this._layers;
        },
        set: function (layers) {
            var prev = this._layers;
            this._layers = layers;
            this.fire("set:layers", prev, layers);
        }
    });

    Scene.prototype.applySettings = function (settings) {
        // settings
        this._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);
        this.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);
        this._fog = settings.render.fog;
        this.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);
        this.fogStart = settings.render.fog_start;
        this.fogEnd = settings.render.fog_end;
        this.fogDensity = settings.render.fog_density;
        this._gammaCorrection = settings.render.gamma_correction;
        this._toneMapping = settings.render.tonemapping;
        this.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;
        this.lightmapMaxResolution = settings.render.lightmapMaxResolution;
        this.lightmapMode = settings.render.lightmapMode;
        this.exposure = settings.render.exposure;
        this._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;
        this._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;

        this._resetSkyboxModel();
        this.updateShaders = true;
    };

    Scene.prototype._updateSkybox = function (device) {
        // Create skybox
        if (this._skyboxCubeMap && !this.skyboxModel) {
            var material = new Material();
            var scene = this;
            material.updateShader = function (dev, sc, defs, staticLightList, pass) {
                var library = device.getProgramLibrary();
                var shader = library.getProgram('skybox', {
                    rgbm: scene._skyboxCubeMap.type === TEXTURETYPE_RGBM,
                    hdr: (scene._skyboxCubeMap.type === TEXTURETYPE_RGBM || scene._skyboxCubeMap.format === PIXELFORMAT_RGBA32F),
                    useIntensity: scene.skyboxIntensity !== 1,
                    mip: scene._skyboxCubeMap.fixCubemapSeams ? scene.skyboxMip : 0,
                    fixSeams: scene._skyboxCubeMap.fixCubemapSeams,
                    gamma: (pass === SHADER_FORWARDHDR ? (scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE) : scene.gammaCorrection),
                    toneMapping: (pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping)
                });
                this.shader = shader;
            };

            material.updateShader();
            var usedTex;
            if (!this._skyboxCubeMap.fixCubemapSeams || !scene._skyboxMip) {
                usedTex = this._skyboxCubeMap;
            } else {
                var mip2tex = [null, "64", "16", "8", "4"];
                var mipTex = this["skyboxPrefiltered" + mip2tex[scene._skyboxMip]];
                if (mipTex)
                    usedTex = mipTex;
            }
            material.setParameter("texture_cubeMap", usedTex);
            material.cull = CULLFACE_FRONT;
            material.depthWrite = false;

            var skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);
            if (skyLayer) {
                var node = new GraphNode();
                var mesh = createBox(device);
                var meshInstance = new MeshInstance(node, mesh, material);
                meshInstance.cull = false;
                meshInstance._noDepthDrawGl1 = true;

                var model = new Model();
                model.graph = node;
                model.meshInstances = [meshInstance];
                this.skyboxModel = model;

                skyLayer.addMeshInstances(model.meshInstances);
                this.skyLayer = skyLayer;

                // enable the layer on first skybox update (the skybox layer is created disabled)
                if (this._firstUpdateSkybox) {
                    skyLayer.enabled = true;
                    this._firstUpdateSkybox = false;
                }

                this.fire("set:skybox", usedTex);
            }
        }
    };

    Scene.prototype._resetSkyboxModel = function () {
        if (this.skyboxModel) {
            this.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);
            this.skyboxModel.destroy();
        }
        this.skyboxModel = null;
        this.updateSkybox = true;
    };

    /**
     * @function
     * @name pc.Scene#setSkybox
     * @description Sets the cubemap for the scene skybox.
     * @param {pc.Texture[]} [cubemaps] - An array of cubemaps corresponding to the skybox at different mip levels. If undefined, scene will remove skybox.
     * Cubemap array should be of size 7, with the first element (index 0) corresponding to the base cubemap (mip level 0) with original resolution.
     * Each remaining element (index 1-6) corresponds to a fixed prefiltered resolution (128x128, 64x64, 32x32, 16x16, 8x8, 4x4).
     */
    Scene.prototype.setSkybox = function (cubemaps) {
        var i;
        if (!cubemaps)
            cubemaps = [null, null, null, null, null, null, null];

        // check if any values actually changed
        // to prevent unnecessary recompilations

        var different = false;

        if (this._skyboxCubeMap !== cubemaps[0])
            different = true;

        if (!different) {
            for (i = 0; i < 6 && !different; i++) {
                if (this._skyboxPrefiltered[i] !== cubemaps[i + 1])
                    different = true;
            }
        }

        if (!different)
            return;

        // set skybox

        for (i = 0; i < 6; i++)
            this._skyboxPrefiltered[i] = cubemaps[i + 1];

        this.skybox = cubemaps[0];
    };

    Scene.prototype.destroy = function () {
        this.skybox = null;
    };

    // Backwards compatibility
    Scene.prototype.addModel = function (model) {
        if (this.containsModel(model)) return;
        var layer = this.layers.getLayerById(LAYERID_WORLD);
        if (!layer) return;
        layer.addMeshInstances(model.meshInstances);
        this._models.push(model);
    };
    Scene.prototype.addShadowCaster = function (model) {
        var layer = this.layers.getLayerById(LAYERID_WORLD);
        if (!layer) return;
        layer.addShadowCasters(model.meshInstances);
    };
    Scene.prototype.removeModel = function (model) {
        var index = this._models.indexOf(model);
        if (index !== -1) {
            var layer = this.layers.getLayerById(LAYERID_WORLD);
            if (!layer) return;
            layer.removeMeshInstances(model.meshInstances);
            this._models.splice(index, 1);
        }
    };
    Scene.prototype.removeShadowCasters = function (model) {
        var layer = this.layers.getLayerById(LAYERID_WORLD);
        if (!layer) return;
        layer.removeShadowCasters(model.meshInstances);
    };
    Scene.prototype.containsModel = function (model) {
        return this._models.indexOf(model) >= 0;
    };
    Scene.prototype.getModels = function (model) {
        return this._models;
    };

    /**
     * @private
     * @function
     * @name pc.SoundManager.hasAudio
     * @description Reports whether this device supports the HTML5 Audio tag API.
     * @returns {boolean} True if HTML5 Audio tag API is supported and false otherwise.
     */
    function hasAudio() {
        return (typeof Audio !== 'undefined');
    }

    /**
     * @private
     * @function
     * @name pc.SoundManager.hasAudioContext
     * @description Reports whether this device supports the Web Audio API.
     * @returns {boolean} True if Web Audio is supported and false otherwise.
     */
    function hasAudioContext() {
        return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
    }

    var Channel;

    if (hasAudioContext()) {
        /**
         * @private
         * @class
         * @name pc.Channel
         * @classdesc A channel is created when the pc.SoundManager begins playback of a pc.Sound. Usually created internally by
         * pc.SoundManager#playSound or pc.SoundManager#playSound3d. Developers usually won't have to create Channels manually.
         * @param {pc.SoundManager} manager - The SoundManager instance.
         * @param {pc.Sound} sound - The sound to playback.
         * @param {object} [options] - Optional options object.
         * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
         * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
         * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the end or not.
         */
        Channel = function (manager, sound, options) {
            options = options || {};
            this.volume = (options.volume === undefined) ? 1 : options.volume;
            this.loop = (options.loop === undefined) ? false : options.loop;
            this.pitch = (options.pitch === undefined ? 1 : options.pitch);

            this.sound = sound;

            this.paused = false;
            this.suspended = false;

            this.startTime = 0;
            this.startOffset = 0;

            this.manager = manager;

            this.source = null;
            var context = manager.context;
            this.gain = context.createGain();
        };

        Object.assign(Channel.prototype, {
            /**
             * @private
             * @function
             * @name pc.Channel#play
             * @description Begin playback of sound.
             */
            play: function () {
                if (this.source) {
                    throw new Error('Call stop() before calling play()');
                }

                this._createSource();
                if (!this.source) {
                    return;
                }


                this.startTime = this.manager.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);

                // Initialize volume and loop - note moved to be after start() because of Chrome bug
                this.setVolume(this.volume);
                this.setLoop(this.loop);
                this.setPitch(this.pitch);

                this.manager.on('volumechange', this.onManagerVolumeChange, this);
                this.manager.on('suspend', this.onManagerSuspend, this);
                this.manager.on('resume', this.onManagerResume, this);

                // suspend immediately if manager is suspended
                if (this.manager.suspended)
                    this.onManagerSuspend();
            },

            /**
             * @private
             * @function
             * @name pc.Channel#pause
             * @description Pause playback of sound. Call unpause() to resume playback from the same position.
             */
            pause: function () {
                if (this.source) {
                    this.paused = true;

                    this.startOffset += this.manager.context.currentTime - this.startTime;
                    this.source.stop(0);
                    this.source = null;
                }
            },

            /**
             * @private
             * @function
             * @name pc.Channel#unpause
             * @description Resume playback of the sound. Playback resumes at the point that the audio was paused.
             */
            unpause: function () {
                if (this.source || !this.paused) {
                    console.warn('Call pause() before unpausing.');
                    return;
                }

                this._createSource();
                if (!this.source) {
                    return;
                }

                this.startTime = this.manager.context.currentTime;
                this.source.start(0, this.startOffset % this.source.buffer.duration);

                // Initialize parameters
                this.setVolume(this.volume);
                this.setLoop(this.loop);
                this.setPitch(this.pitch);

                this.paused = false;
            },

            /**
             * @private
             * @function
             * @name pc.Channel#stop
             * @description Stop playback of sound. Calling play() again will restart playback from the beginning of the sound.
             */
            stop: function () {
                if (this.source) {
                    this.source.stop(0);
                    this.source = null;
                }

                this.manager.off('volumechange', this.onManagerVolumeChange, this);
                this.manager.off('suspend', this.onManagerSuspend, this);
                this.manager.off('resume', this.onManagerResume, this);
            },

            /**
             * @private
             * @function
             * @name pc.Channel#setLoop
             * @description Enable/disable the loop property to make the sound restart from the beginning when it reaches the end.
             * @param {boolean} loop - True to loop the sound, false otherwise.
             */
            setLoop: function (loop) {
                this.loop = loop;
                if (this.source) {
                    this.source.loop = loop;
                }
            },

            /**
             * @private
             * @function
             * @name pc.Channel#setVolume
             * @description Set the volume of playback between 0 and 1.
             * @param {number} volume - The volume of the sound. Will be clamped between 0 and 1.
             */
            setVolume: function (volume) {
                volume = math.clamp(volume, 0, 1);
                this.volume = volume;
                if (this.gain) {
                    this.gain.gain.value = volume * this.manager.volume;
                }
            },

            setPitch: function (pitch) {
                this.pitch = pitch;
                if (this.source) {
                    this.source.playbackRate.value = pitch;
                }
            },

            isPlaying: function () {
                return (!this.paused && (this.source.playbackState === this.source.PLAYING_STATE));
            },

            getDuration: function () {
                return this.source ? this.source.buffer.duration : 0;
            },

            _createSource: function () {
                var context = this.manager.context;

                if (this.sound.buffer) {
                    this.source = context.createBufferSource();
                    this.source.buffer = this.sound.buffer;

                    // Connect up the nodes
                    this.source.connect(this.gain);
                    this.gain.connect(context.destination);

                    if (!this.loop) {
                        // mark source as paused when it ends
                        this.source.onended = this.pause.bind(this);
                    }
                }
            }
        });
    } else if (hasAudio()) {
        Channel = function (manager, sound, options) {
            this.volume = options.volume || 1;
            this.loop = options.loop || false;
            this.sound = sound;
            this.pitch = options.pitch !== undefined ? options.pitch : 1;

            this.paused = false;
            this.suspended = false;

            this.manager = manager;

            // handle the case where sound was
            if (sound.audio) {
                this.source = sound.audio.cloneNode(false);
                this.source.pause(); // not initially playing
            }
        };

        Object.assign(Channel.prototype, {
            play: function () {
                if (this.source) {
                    this.paused = false;
                    this.setVolume(this.volume);
                    this.setLoop(this.loop);
                    this.setPitch(this.pitch);
                    this.source.play();
                }

                this.manager.on('volumechange', this.onManagerVolumeChange, this);
                this.manager.on('suspend', this.onManagerSuspend, this);
                this.manager.on('resume', this.onManagerResume, this);

                // suspend immediately if manager is suspended
                if (this.manager.suspended)
                    this.onManagerSuspend();

            },

            pause: function () {
                if (this.source) {
                    this.paused = true;
                    this.source.pause();
                }
            },

            unpause: function () {
                if (this.source) {
                    this.paused = false;
                    this.source.play();
                }
            },

            stop: function () {
                if (this.source) {
                    this.source.pause();
                }

                this.manager.off('volumechange', this.onManagerVolumeChange, this);
                this.manager.off('suspend', this.onManagerSuspend, this);
                this.manager.off('resume', this.onManagerResume, this);
            },

            setVolume: function (volume) {
                volume = math.clamp(volume, 0, 1);
                this.volume = volume;
                if (this.source) {
                    this.source.volume = volume * this.manager.volume;
                }
            },

            setLoop: function (loop) {
                this.loop = loop;
                if (this.source) {
                    this.source.loop = loop;
                }
            },

            setPitch: function (pitch) {
                this.pitch = pitch;
                if (this.source) {
                    this.source.playbackRate = pitch;
                }
            },

            getDuration: function () {
                return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
            },

            isPlaying: function () {
                return !this.source.paused;
            }
        });
    } else {
        Channel = function () {
        };
    }

    // Add functions which don't depend on source type
    Object.assign(Channel.prototype, {
        /**
         * @private
         * @function
         * @name pc.Channel#getVolume
         * @description Get the current value for the volume. Between 0 and 1.
         * @returns {number} The volume of the channel.
         */
        getVolume: function () {
            return this.volume;
        },

        /**
         * @private
         * @function
         * @name pc.Channel#getLoop
         * @description Get the current looping state of the Channel.
         * @returns {boolean} The loop property for the channel.
         */
        getLoop: function () {
            return this.loop;
        },

        /**
         * @private
         * @function
         * @name pc.Channel#getPitch
         * @description Get the current pitch of the Channel.
         * @returns {number} The pitch of the channel.
         */
        getPitch: function () {
            return this.pitch;
        },

        /**
         * @private
         * @function
         * @name pc.Channel#onManagerVolumeChange
         * @description Handle the manager's 'volumechange' event.
         */
        onManagerVolumeChange: function () {
            this.setVolume(this.getVolume());
        },

        /**
         * @private
         * @function
         * @name pc.Channel#onManagerSuspend
         * @description Handle the manager's 'suspend' event.
         */
        onManagerSuspend: function () {
            if (this.isPlaying() && !this.suspended) {
                this.suspended = true;
                this.pause();
            }
        },

        /**
         * @private
         * @function
         * @name pc.Channel#onManagerResume
         * @description Handle the manager's 'resume' event.
         */
        onManagerResume: function () {
            if (this.suspended) {
                this.suspended = false;
                this.unpause();
            }
        }
    });

    /**
     * @constant
     * @type {string}
     * @name pc.DISTANCE_LINEAR
     * @description Linear distance model.
     */
    var DISTANCE_LINEAR = 'linear';

    /**
     * @constant
     * @type {string}
     * @name pc.DISTANCE_INVERSE
     * @description Inverse distance model.
     */
    var DISTANCE_INVERSE = 'inverse';

    /**
     * @constant
     * @type {string}
     * @name pc.DISTANCE_EXPONENTIAL
     * @description Exponential distance model.
     */
    var DISTANCE_EXPONENTIAL = 'exponential';

    // default maxDistance, same as Web Audio API
    var MAX_DISTANCE = 10000;

    var Channel3d;

    if (hasAudioContext()) {
        Channel3d = function (manager, sound, options) {
            Channel.call(this, manager, sound, options);

            this.position = new Vec3();
            this.velocity = new Vec3();

            var context = manager.context;
            this.panner = context.createPanner();
        };
        Channel3d.prototype = Object.create(Channel.prototype);
        Channel3d.prototype.constructor = Channel3d;

        Object.assign(Channel3d.prototype, {
            getPosition: function () {
                return this.position;
            },

            setPosition: function (position) {
                this.position.copy(position);
                this.panner.setPosition(position.x, position.y, position.z);
            },

            getVelocity: function () {
                return this.velocity;
            },

            setVelocity: function (velocity) {
                this.velocity.copy(velocity);
                this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
            },

            getMaxDistance: function () {
                return this.panner.maxDistance;
            },

            setMaxDistance: function (max) {
                this.panner.maxDistance = max;
            },

            getMinDistance: function () {
                return this.panner.refDistance;
            },

            setMinDistance: function (min) {
                this.panner.refDistance = min;
            },

            getRollOffFactor: function () {
                return this.panner.rolloffFactor;
            },

            setRollOffFactor: function (factor) {
                this.panner.rolloffFactor = factor;
            },

            getDistanceModel: function () {
                return this.pannel.distanceModel;
            },

            setDistanceModel: function (distanceModel) {
                this.panner.distanceModel = distanceModel;
            },

            /**
             * @private
             * @function
             * @name pc.Channel3d#_createSource
             * @description Create the buffer source and connect it up to the correct audio nodes.
             */
            _createSource: function () {
                var context = this.manager.context;

                this.source = context.createBufferSource();
                this.source.buffer = this.sound.buffer;

                // Connect up the nodes
                this.source.connect(this.panner);
                this.panner.connect(this.gain);
                this.gain.connect(context.destination);

                if (!this.loop) {
                    // mark source as paused when it ends
                    this.source.onended = this.pause.bind(this);
                }
            }
        });
    } else if (hasAudio()) {
        // temp vector storage
        var offset = new Vec3();


        // Fall off function which should be the same as the one in the Web Audio API
        // Taken from https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel
        var fallOff = function (posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
            offset = offset.sub2(posOne, posTwo);
            var distance = offset.length();

            if (distance < refDistance) {
                return 1;
            } else if (distance > maxDistance) {
                return 0;
            }

            var result = 0;
            if (distanceModel === DISTANCE_LINEAR) {
                result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
            } else if (distanceModel === DISTANCE_INVERSE) {
                result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
            } else if (distanceModel === DISTANCE_EXPONENTIAL) {
                result = Math.pow(distance / refDistance, -rolloffFactor);
            }
            return math.clamp(result, 0, 1);
        };

        Channel3d = function (manager, sound) {
            Channel.call(this, manager, sound);

            this.position = new Vec3();
            this.velocity = new Vec3();

            this.maxDistance = MAX_DISTANCE;
            this.minDistance = 1;
            this.rollOffFactor = 1;
            this.distanceModel = DISTANCE_INVERSE;
        };
        Channel3d.prototype = Object.create(Channel.prototype);
        Channel3d.prototype.constructor = Channel3d;

        Object.assign(Channel3d.prototype, {
            getPosition: function () {
                return this.position;
            },

            setPosition: function (position) {
                this.position.copy(position);

                if (this.source) {
                    var listener = this.manager.listener;

                    var lpos = listener.getPosition();

                    var factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);

                    var v = this.getVolume();
                    this.source.volume = v * factor;
                }
            },

            getVelocity: function () {
                return this.velocity;
            },

            setVelocity: function (velocity) {
                this.velocity.copy(velocity);
            },

            getMaxDistance: function () {
                return this.maxDistance;
            },

            setMaxDistance: function (max) {
                this.maxDistance = max;
            },

            getMinDistance: function () {
                return this.minDistance;
            },

            setMinDistance: function (min) {
                this.minDistance = min;
            },

            getRollOffFactor: function () {
                return this.rollOffFactor;
            },

            setRollOffFactor: function (factor) {
                this.rollOffFactor = factor;
            },

            getDistanceModel: function () {
                return this.distanceModel;
            },

            setDistanceModel: function (distanceModel) {
                this.distanceModel = distanceModel;
            }
        });
    } else {
        Channel3d = function () { };
    }

    /**
     * @private
     * @class
     * @name pc.Listener
     * @classdesc Represents an audio listener - used internally.
     * @param {pc.SoundManager} manager - The sound manager.
     */
    function Listener(manager) {
        this.position = new Vec3();
        this.velocity = new Vec3();
        this.orientation = new Mat4();

        if (hasAudioContext()) {
            this.listener = manager.context.listener;
        }
    }

    Object.assign(Listener.prototype, {
        getPosition: function () {
            return this.position;
        },

        setPosition: function (position) {
            this.position.copy(position);
            if (this.listener) {
                this.listener.setPosition(position.x, position.y, position.z);
            }
        },

        getVelocity: function () {
            return this.velocity;
        },

        setVelocity: function (velocity) {
            this.velocity.copy(velocity);
            if (this.listener) {
                this.listener.setPosition(velocity.x, velocity.y, velocity.z);
            }
        },

        setOrientation: function (orientation) {
            this.orientation.copy(orientation);
            if (this.listener) {
                this.listener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10],
                                             orientation.data[4], orientation.data[5], orientation.data[6]);
            }
        },

        getOrientation: function () {
            return this.orientation;
        }
    });

    /**
     * @class
     * @name pc.SoundManager
     * @augments pc.EventHandler
     * @classdesc The SoundManager is used to load and play audio. As well as apply system-wide settings
     * like global volume, suspend and resume.
     * @description Creates a new sound manager.
     * @param {object} [options] - Options options object.
     * @param {boolean} [options.forceWebAudioApi] - Always use the Web Audio API even check indicates that it if not available.
     * @property {number} volume Global volume for the manager. All {@link pc.SoundInstance}s will scale their volume with this volume. Valid between [0, 1].
     */
    function SoundManager(options) {
        EventHandler.call(this);

        if (hasAudioContext() || options.forceWebAudioApi) {
            if (typeof AudioContext !== 'undefined') {
                this.context = new AudioContext();
            } else if (typeof webkitAudioContext !== 'undefined') {
                this.context = new webkitAudioContext();
            }

            if (this.context) {
                var context = this.context;

                // resume AudioContext on user interaction because of new Chrome autoplay policy
                this.resumeContext = function () {
                    this.context.resume();
                    window.removeEventListener('mousedown', this.resumeContext);
                    window.removeEventListener('touchend', this.resumeContext);
                }.bind(this);

                window.addEventListener('mousedown', this.resumeContext);
                window.addEventListener('touchend', this.resumeContext);

                // iOS only starts sound as a response to user interaction
                if (platform.ios) {
                    // Play an inaudible sound when the user touches the screen
                    // This only happens once
                    var unlock = function () {
                        var buffer = context.createBuffer(1, 1, 44100);
                        var source = context.createBufferSource();
                        source.buffer = buffer;
                        source.connect(context.destination);
                        source.start(0);
                        source.disconnect();

                        // no further need for this so remove the listener
                        window.removeEventListener('touchend', unlock);
                    };

                    window.addEventListener('touchend', unlock);
                }
            }
        } else {
            console.warn('No support for 3D audio found');
        }

        if (!hasAudio())
            console.warn('No support for 2D audio found');

        this.listener = new Listener(this);

        this._volume = 1;
        this.suspended = false;
    }
    SoundManager.prototype = Object.create(EventHandler.prototype);
    SoundManager.prototype.constructor = SoundManager;

    Object.assign(SoundManager.prototype, {
        suspend: function  () {
            this.suspended = true;
            this.fire('suspend');
        },

        resume: function () {
            this.suspended = false;
            this.fire('resume');
        },

        destroy: function () {
            window.removeEventListener('mousedown', this.resumeContext);
            window.removeEventListener('touchend', this.resumeContext);

            this.fire('destroy');
            if (this.context && this.context.close) {
                this.context.close();
                this.context = null;
            }
        },

        /**
         * @private
         * @function
         * @name pc.SoundManager#playSound
         * @description Create a new pc.Channel and begin playback of the sound.
         * @param {pc.Sound} sound - The Sound object to play.
         * @param {object} options - Optional options object.
         * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
         * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
         * @returns {pc.Channel} The channel playing the sound.
         */
        playSound: function (sound, options) {
            options = options || {};
            var channel = null;
            if (Channel) {
                channel = new Channel(this, sound, options);
                channel.play();
            }
            return channel;
        },

        /**
         * @private
         * @function
         * @name pc.SoundManager#playSound3d
         * @description Create a new pc.Channel3d and begin playback of the sound at the position specified.
         * @param {pc.Sound} sound - The Sound object to play.
         * @param {pc.Vec3} position - The position of the sound in 3D space.
         * @param {object} options - Optional options object.
         * @param {number} [options.volume] - The volume to playback at, between 0 and 1.
         * @param {boolean} [options.loop] - Whether to loop the sound when it reaches the end.
         * @returns {pc.Channel3d} The 3D channel playing the sound.
         */
        playSound3d: function (sound, position, options) {
            options = options || {};
            var channel = null;
            if (Channel3d) {
                channel = new Channel3d(this, sound, options);
                channel.setPosition(position);
                if (options.volume) {
                    channel.setVolume(options.volume);
                }
                if (options.loop) {
                    channel.setLoop(options.loop);
                }
                if (options.maxDistance) {
                    channel.setMaxDistance(options.maxDistance);
                }
                if (options.minDistance) {
                    channel.setMinDistance(options.minDistance);
                }
                if (options.rollOffFactor) {
                    channel.setRollOffFactor(options.rollOffFactor);
                }
                if (options.distanceModel) {
                    channel.setDistanceModel(options.distanceModel);
                }

                channel.play();
            }

            return channel;
        }
    });

    Object.defineProperty(SoundManager.prototype, 'volume', {
        get: function () {
            return this._volume;
        },
        set: function (volume) {
            volume = math.clamp(volume, 0, 1);
            this._volume = volume;
            this.fire('volumechange', volume);
        }
    });

    function Key(time, position, rotation, scale) {
        this.time = time;
        this.position = position;
        this.rotation = rotation;
        this.scale = scale;
    }

    /**
     * @class
     * @name pc.Node
     * @classdesc A animation node has a name and contains an array of keyframes.
     * @description Create a new animation node.
     */
    function Node() {
        this._name = "";
        this._keys = [];
    }

    /**
     * @class
     * @name pc.Animation
     * @classdesc An animation is a sequence of keyframe arrays which map to the nodes of a skeletal hierarchy.
     * It controls how the nodes of the hierarchy are transformed over time.
     * @property {string} name Human-readable name of the animation.
     * @property {number} duration Duration of the animation in seconds.
     */
    function Animation() {
        this.name = '';
        this.duration = 0;
        this._nodes = [];
        this._nodeDict = {};
    }

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Animation#getDuration
     * @description Returns the duration of the animation in seconds.
     * @returns {number} The duration of the animation in seconds.
     */
    Animation.prototype.getDuration = function () {
        return this.duration;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Animation#getName
     * @description Returns the human-readable name of the animation.
     * @returns {string} The name of the animation.
     */
    Animation.prototype.getName = function () {
        return this.name;
    };

    /**
     * @function
     * @name pc.Animation#getNode
     * @description Gets a {@link pc.Node} by name.
     * @param {string} name - The name of the pc.Node.
     * @returns {pc.Node} The pc.Node with the specified name.
     */
    Animation.prototype.getNode = function (name) {
        return this._nodeDict[name];
    };

    /**
     * @readonly
     * @name pc.Animation#nodes
     * @type {pc.Node[]}
     * @description A read-only property to get array of animation nodes.
     */
    Object.defineProperty(Animation.prototype, 'nodes', {
        get: function () {
            return this._nodes;
        }
    });

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Animation#getNodes
     * @description Gets the {@link pc.Node}s of this {@link pc.Animation}.
     * @returns {pc.Node[]} An array of nodes.
     */
    Animation.prototype.getNodes = function () {
        return this._nodes;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Animation#setDuration
     * @description Sets the duration of the specified animation in seconds.
     * @param {number} duration - The duration of the animation in seconds.
     */
    Animation.prototype.setDuration = function (duration) {
        this.duration = duration;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Animation#setName
     * @description Sets the human-readable name of the specified animation.
     * @param {string} name - The new name for the animation.
     */
    Animation.prototype.setName = function (name) {
        this.name = name;
    };

    /**
     * @function
     * @name pc.Animation#addNode
     * @description Adds a node to the internal nodes array.
     * @param {pc.Node} node - The node to add.
     */
    Animation.prototype.addNode = function (node) {
        this._nodes.push(node);
        this._nodeDict[node._name] = node;
    };

    /**
     * @class
     * @name pc.Morph
     * @classdesc Contains a list of pc.MorphTarget, a combined delta AABB and some associated data.
     * @param {pc.MorphTarget[]} targets - A list of morph targets.
     */
    function Morph(targets) {

        this._targets = targets;

        this._updateMorphFlags();
        this._calculateAabb();
    }

    Object.defineProperties(Morph.prototype, {
        'morphPositions': {
            get: function () {
                return this._morphPositions;
            }
        },

        'morphNormals': {
            get: function () {
                return this._morphNormals;
            }
        },

        'maxActiveTargets': {
            get: function () {
                return (this._morphPositions && this._morphNormals) ? 4 : 8;
            }
        }
    });

    Object.assign(Morph.prototype, {

        /**
         * @function
         * @name pc.Morph#destroy
         * @description Frees video memory allocated by this object.
         */
        destroy: function () {
            for (var i = 0; i < this._targets.length; i++) {
                this._targets[i].destroy();
            }
            this._targets.length = 0;
        },

        /**
         * @function
         * @name pc.Morph#getTarget
         * @description Gets the morph target by index.
         * @param {number} index - An index of morph target.
         * @returns {pc.MorphTarget} A morph target object.
         */
        getTarget: function (index) {
            return this._targets[index];
        },

        _updateMorphFlags: function () {

            // find out if this morph needs to morph positions and normals
            this._morphPositions = false;
            this._morphNormals = false;
            var target;
            for (var i = 0; i < this._targets.length; i++) {
                target = this._targets[i];
                if (target.morphPositions) {
                    this._morphPositions = true;
                }
                if (target.morphNormals) {
                    this._morphNormals = true;
                }
            }
        },

        _calculateAabb: function () {

            this.aabb = new BoundingBox(new Vec3(0, 0, 0), new Vec3(0, 0, 0));
            var target;

            // calc bounding box of the relative change this morph can add
            for (var i = 0; i < this._targets.length; i++) {
                target = this._targets[i];
                this.aabb._expand(target.aabb.getMin(), target.aabb.getMax());
            }
        }
    });

    /**
     * @class
     * @name pc.MorphTarget
     * @classdesc A Morph Target (also known as Blend Shape) contains deformation data to apply to existing mesh.
     * Multiple morph targets can be blended together on a mesh. This is useful for effects that are hard to achieve with conventional animation and skinning.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used to manage this morph target. If it is not provided, a device is obtained
     * from the {@link pc.Application}.
     * @param {object} options - Object for passing optional arguments.
     * @param {ArrayBuffer} options.deltaPositions - An array of 3-dimensional vertex position offsets.
     * @param {number} options.deltaPositionsType - A format to store position offsets inside {@link pc.VertexBuffer}. Defaults to {@link pc.TYPE_FLOAT32} if not provided.
     * @param {ArrayBuffer} [options.deltaNormals] - An array of 3-dimensional vertex normal offsets.
     * @param {number} options.deltaNormalsType - A format to store normal offsets inside {@link pc.VertexBuffer}. Defaults to {@link pc.TYPE_FLOAT32} if not provided.
     * @param {string} [options.name] - Name.
     * @param {pc.BoundingBox} [options.aabb] - Bounding box. Will be automatically generated, if undefined.
     * @param {number} [options.defaultWeight] - Default blend weight to use for this morph target.
     */
    function MorphTarget(graphicsDevice, options) {

        this.name = options.name;
        this.defaultWeight = options.defaultWeight || 0;

        this._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);
        this._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);

        // access to positions stored inside vertex buffer
        if (this._vertexBufferPositions) {
            this.deltaPositions = this._vertexBufferPositions.lock();
        }

        // bounds
        this.aabb = options.aabb;
        if (!this.aabb) {
            this.aabb = new BoundingBox();
            if (this.deltaPositions)
                this.aabb.compute(this.deltaPositions);
        }
    }

    Object.defineProperties(MorphTarget.prototype, {
        'morphPositions': {
            get: function () {
                return !!this._vertexBufferPositions;
            }
        },

        'morphNormals': {
            get: function () {
                return !!this._vertexBufferNormals;
            }
        }
    });

    Object.assign(MorphTarget.prototype, {

        _createVertexBuffer: function (device, data, dataType) {

            if (data) {

                // create vertex buffer with specified type (or float32), and semantic of ATTR0 which gets replaced at runtime with actual semantic
                var formatDesc = [{ semantic: SEMANTIC_ATTR0, components: 3, type: dataType || TYPE_FLOAT32 }];
                return new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);
            }

            return null;
        },

        destroy: function () {

            if (this._vertexBufferPositions) {
                this._vertexBufferPositions.destroy();
                this._vertexBufferPositions = null;
            }

            if (this._vertexBufferNormals) {
                this._vertexBufferNormals.destroy();
                this._vertexBufferNormals = null;
            }
        }
    });

    /**
     * @private
     * @constant
     * @type {number}
     * @name pc.INTERPOLATION_STEP
     * @description A stepped interpolation scheme.
     */
    var INTERPOLATION_STEP = 0;

    /**
     * @private
     * @constant
     * @type {number}
     * @name pc.INTERPOLATION_LINEAR
     * @description A linear interpolation scheme.
     */
    var INTERPOLATION_LINEAR = 1;

    /**
     * @private
     * @constant
     * @type {number}
     * @name pc.INTERPOLATION_CUBIC
     * @description A cubic spline interpolation scheme.
     */
    var INTERPOLATION_CUBIC = 2;

    /**
     * @private
     * @class
     * @name pc.AnimPropertyLocator
     * @classdesc The AnimProperyLocator encodes and decodes paths to properties in the scene hierarchy.
     * @description Create a new AnimPropertyLocator.
     */
    function AnimPropertyLocator() {}

    Object.assign(AnimPropertyLocator.prototype, {
        /**
         * @private
         * @function
         * @name pc.AnimPropertyLocator#encode
         * @description Converts a locator array into its string version
         * @param {Array} locator - The property location in the scene defined as an array
         * @returns {string} The locator encoded as a string
         * @example
         * // returns 'spotLight/light/color.r'
         * encode([['spotLight'], 'light', ['color', 'r']]);
         */
        encode: function (locator) {
            return AnimBinder.joinPath([
                AnimBinder.joinPath(locator[0]),
                locator[1],
                AnimBinder.joinPath(locator[2])
            ], '/');
        },
        /**
         * @private
         * @function
         * @name pc.AnimPropertyLocator#decode
         * @description Converts a locator string into its array version
         * @param {Array} locator - The property location in the scene defined as a string
         * @returns {Array} - The locator decoded into an array
         * @example
         * // returns [['spotLight'], 'light', ['color','r']]
         * encode('spotLight/light/color.r');
         */
        decode: function (locator) {
            var locatorSections = AnimBinder.splitPath(locator, '/');
            return [
                AnimBinder.splitPath(locatorSections[0]),
                locatorSections[1],
                AnimBinder.splitPath(locatorSections[2])
            ];
        }
    });

    /**
     * @class
     * @name pc.Entity
     * @augments pc.GraphNode
     * @classdesc The Entity is the core primitive of a PlayCanvas game. Generally speaking an object in your game will consist of an {@link pc.Entity},
     * and a set of {@link pc.Component}s which are managed by their respective {@link pc.ComponentSystem}s. One of those components maybe a
     * {@link pc.ScriptComponent} which allows you to write custom code to attach to your Entity.
     * <p>
     * The Entity uniquely identifies the object and also provides a transform for position and orientation
     * which it inherits from {@link pc.GraphNode} so can be added into the scene graph.
     * The Component and ComponentSystem provide the logic to give an Entity a specific type of behavior. e.g. the ability to
     * render a model or play a sound. Components are specific to an instance of an Entity and are attached (e.g. `this.entity.model`)
     * ComponentSystems allow access to all Entities and Components and are attached to the {@link pc.Application}.
     * @param {string} [name] - The non-unique name of the entity, default is "Untitled".
     * @param {pc.Application} [app] - The application the entity belongs to, default is the current application.
     * @property {pc.AnimationComponent} [animation] Gets the {@link pc.AnimationComponent} attached to this entity. [read only]
     * @property {pc.AudioListenerComponent} [audiolistener] Gets the {@link pc.AudioSourceComponent} attached to this entity. [read only]
     * @property {pc.ButtonComponent} [button] Gets the {@link pc.ButtonComponent} attached to this entity. [read only]
     * @property {pc.CameraComponent} [camera] Gets the {@link pc.CameraComponent} attached to this entity. [read only]
     * @property {pc.CollisionComponent} [collision] Gets the {@link pc.CollisionComponent} attached to this entity. [read only]
     * @property {pc.ElementComponent} [element] Gets the {@link pc.ElementComponent} attached to this entity. [read only]
     * @property {pc.LayoutChildComponent} [layoutchild] Gets the {@link pc.LayoutChildComponent} attached to this entity. [read only]
     * @property {pc.LayoutGroupComponent} [layoutgroup] Gets the {@link pc.LayoutGroupComponent} attached to this entity. [read only]
     * @property {pc.LightComponent} [light] Gets the {@link pc.LightComponent} attached to this entity. [read only]
     * @property {pc.ModelComponent} [model] Gets the {@link pc.ModelComponent} attached to this entity. [read only]
     * @property {pc.ParticleSystemComponent} [particlesystem] Gets the {@link pc.ParticleSystemComponent} attached to this entity. [read only]
     * @property {pc.RigidBodyComponent} [rigidbody] Gets the {@link pc.RigidBodyComponent} attached to this entity. [read only]
     * @property {pc.ScreenComponent} [screen] Gets the {@link pc.ScreenComponent} attached to this entity. [read only]
     * @property {pc.ScriptComponent} [script] Gets the {@link pc.ScriptComponent} attached to this entity. [read only]
     * @property {pc.ScrollViewComponent} [scrollview] Gets the {@link pc.ScrollViewComponent} attached to this entity. [read only]
     * @property {pc.SoundComponent} [sound] Gets the {@link pc.SoundComponent} attached to this entity. [read only]
     * @property {pc.SpriteComponent} [sprite] Gets the {@link pc.SpriteComponent} attached to this entity. [read only]
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a Component to the Entity
     * entity.addComponent("camera", {
     *     fov: 45,
     *     nearClip: 1,
     *     farClip: 10000
     * });
     *
     * // Add the Entity into the scene graph
     * app.root.addChild(entity);
     *
     * // Move the entity
     * entity.translate(10, 0, 0);
     *
     * // Or translate it by setting it's position directly
     * var p = entity.getPosition();
     * entity.setPosition(p.x + 10, p.y, p.z);
     *
     * // Change the entity's rotation in local space
     * var e = entity.getLocalEulerAngles();
     * entity.setLocalEulerAngles(e.x, e.y + 90, e.z);
     *
     * // Or use rotateLocal
     * entity.rotateLocal(0, 90, 0);
     */
    function Entity(name, app) {
        GraphNode.call(this, name);

        if (name instanceof Application) app = name;
        this._batchHandle = null; // The handle for a RequestBatch, set this if you want to Component's to load their resources using a pre-existing RequestBatch.
        this.c = {}; // Component storage

        this._app = app; // store app
        if (!app) {
            this._app = Application.getApplication(); // get the current application
            if (!this._app) {
                throw new Error("Couldn't find current application");
            }
        }

        this._guid = null;

        // used by component systems to speed up destruction
        this._destroying = false;
    }
    Entity.prototype = Object.create(GraphNode.prototype);
    Entity.prototype.constructor = Entity;

    /**
     * @function
     * @name pc.Entity#addComponent
     * @description Create a new component and add it to the entity.
     * Use this to add functionality to the entity like rendering a model, playing sounds and so on.
     * @param {string} type - The name of the component to add. Valid strings are:
     *
     * * "animation" - see {@link pc.AnimationComponent}
     * * "audiolistener" - see {@link pc.AudioListenerComponent}
     * * "button" - see {@link pc.ButtonComponent}
     * * "camera" - see {@link pc.CameraComponent}
     * * "collision" - see {@link pc.CollisionComponent}
     * * "element" - see {@link pc.ElementComponent}
     * * "layoutchild" - see {@link pc.LayoutChildComponent}
     * * "layoutgroup" - see {@link pc.LayoutGroupComponent}
     * * "light" - see {@link pc.LightComponent}
     * * "model" - see {@link pc.ModelComponent}
     * * "particlesystem" - see {@link pc.ParticleSystemComponent}
     * * "rigidbody" - see {@link pc.RigidBodyComponent}
     * * "screen" - see {@link pc.ScreenComponent}
     * * "script" - see {@link pc.ScriptComponent}
     * * "scrollbar" - see {@link pc.ScrollbarComponent}
     * * "scrollview" - see {@link pc.ScrollViewComponent}
     * * "sound" - see {@link pc.SoundComponent}
     * * "sprite" - see {@link pc.SpriteComponent}
     *
     * @param {object} [data] - The initialization data for the specific component type. Refer to each
     * specific component's API reference page for details on valid values for this parameter.
     * @returns {pc.Component} The new Component that was attached to the entity or null if there
     * was an error.
     * @example
     * var entity = new pc.Entity();
     *
     * // Add a light component with default properties
     * entity.addComponent("light");
     *
     * // Add a camera component with some specified properties
     * entity.addComponent("camera", {
     *     fov: 45,
     *     clearColor: new pc.Color(1, 0, 0)
     * });
     */
    Entity.prototype.addComponent = function (type, data) {
        var system = this._app.systems[type];
        if (!system) {
            return null;
        }
        if (this.c[type]) {
            return null;
        }
        return system.addComponent(this, data);
    };

    /**
     * @function
     * @name pc.Entity#removeComponent
     * @description Remove a component from the Entity.
     * @param {string} type - The name of the Component type.
     * @example
     * var entity = new pc.Entity();
     * entity.addComponent("light"); // add new light component
     *
     * entity.removeComponent("light"); // remove light component
     */
    Entity.prototype.removeComponent = function (type) {
        var system = this._app.systems[type];
        if (!system) {
            return;
        }
        if (!this.c[type]) {
            return;
        }
        system.removeComponent(this);
    };

    /**
     * @function
     * @name pc.Entity#findComponent
     * @description Search the entity and all of its descendants for the first component of specified type.
     * @param {string} type - The name of the component type to retrieve.
     * @returns {pc.Component} A component of specified type, if the entity or any of its descendants has
     * one. Returns undefined otherwise.
     * @example
     * // Get the first found light component in the hierarchy tree that starts with this entity
     * var light = entity.findComponent("light");
     */
    Entity.prototype.findComponent = function (type) {
        var entity = this.findOne(function (node) {
            return node.c && node.c[type];
        });
        return entity && entity.c[type];
    };

    /**
     * @function
     * @name pc.Entity#findComponents
     * @description Search the entity and all of its descendants for all components of specified type.
     * @param {string} type - The name of the component type to retrieve.
     * @returns {pc.Component} All components of specified type in the entity or any of its descendants.
     * Returns empty array if none found.
     * @example
     * // Get all light components in the hierarchy tree that starts with this entity
     * var lights = entity.findComponents("light");
     */
    Entity.prototype.findComponents = function (type) {
        var entities = this.find(function (node) {
            return node.c && node.c[type];
        });
        return entities.map(function (entity) {
            return entity.c[type];
        });
    };

    /**
     * @private
     * @function
     * @name pc.Entity#getGuid
     * @description Get the GUID value for this Entity.
     * @returns {string} The GUID of the Entity.
     */
    Entity.prototype.getGuid = function () {
        // if the guid hasn't been set yet then set it now
        // before returning it
        if (! this._guid) {
            this.setGuid(guid.create());
        }

        return this._guid;
    };

    /**
     * @private
     * @function
     * @name pc.Entity#setGuid
     * @description Set the GUID value for this Entity.
     *
     * N.B. It is unlikely that you should need to change the GUID value of an Entity at run-time. Doing so will corrupt the graph this Entity is in.
     * @param {string} guid - The GUID to assign to the Entity.
     */
    Entity.prototype.setGuid = function (guid) {
        // remove current guid from entityIndex
        var index = this._app._entityIndex;
        if (this._guid) {
            delete index[this._guid];
        }

        // add new guid to entityIndex
        this._guid = guid;
        index[this._guid] = this;
    };

    Entity.prototype._notifyHierarchyStateChanged = function (node, enabled) {
        var enableFirst = false;
        if (node === this && this._app._enableList.length === 0)
            enableFirst = true;

        node._beingEnabled = true;

        node._onHierarchyStateChanged(enabled);

        if (node._onHierarchyStatePostChanged)
            this._app._enableList.push(node);

        var i, len;
        var c = node._children;
        for (i = 0, len = c.length; i < len; i++) {
            if (c[i]._enabled)
                this._notifyHierarchyStateChanged(c[i], enabled);
        }

        node._beingEnabled = false;

        if (enableFirst) {
            // do not cache the length here, as enableList may be added to during loop
            for (i = 0; i < this._app._enableList.length; i++) {
                this._app._enableList[i]._onHierarchyStatePostChanged();
            }

            this._app._enableList.length = 0;
        }
    };

    Entity.prototype._onHierarchyStateChanged = function (enabled) {
        GraphNode.prototype._onHierarchyStateChanged.call(this, enabled);

        // enable / disable all the components
        var component;
        var components = this.c;
        for (var type in components) {
            if (components.hasOwnProperty(type)) {
                component = components[type];
                if (component.enabled) {
                    if (enabled) {
                        component.onEnable();
                    } else {
                        component.onDisable();
                    }
                }
            }
        }
    };

    Entity.prototype._onHierarchyStatePostChanged = function () {
        // post enable all the components
        var components = this.c;
        for (var type in components) {
            if (components.hasOwnProperty(type))
                components[type].onPostStateChange();
        }
    };

    /**
     * @function
     * @name pc.Entity#findByGuid
     * @description Find a descendant of this Entity with the GUID.
     * @param {string} guid - The GUID to search for.
     * @returns {pc.Entity} The Entity with the GUID or null.
     */
    Entity.prototype.findByGuid = function (guid) {
        if (this._guid === guid) return this;

        var e = this._app._entityIndex[guid];
        if (e && (e === this || e.isDescendantOf(this))) {
            return e;
        }

        return null;
    };

    /**
     * @function
     * @name pc.Entity#destroy
     * @description Remove all components from the Entity and detach it from the Entity hierarchy. Then recursively destroy all ancestor Entities.
     * @example
     * var firstChild = this.entity.children[0];
     * firstChild.destroy(); // delete child, all components and remove from hierarchy
     */
    Entity.prototype.destroy = function () {
        var name;

        this._destroying = true;

        // Disable all enabled components first
        for (name in this.c) {
            this.c[name].enabled = false;
        }

        // Remove all components
        for (name in this.c) {
            this.c[name].system.removeComponent(this);
        }

        // Detach from parent
        if (this._parent)
            this._parent.removeChild(this);

        var children = this._children;
        var child = children.shift();
        while (child) {
            if (child instanceof Entity) {
                child.destroy();
            }

            // make sure child._parent is null because
            // we have removed it from the children array before calling
            // destroy on it
            child._parent = null;

            child = children.shift();
        }

        // fire destroy event
        this.fire('destroy', this);

        // clear all events
        this.off();

        // remove from entity index
        if (this._guid) {
            delete this._app._entityIndex[this._guid];
        }

        this._destroying = false;
    };

    /**
     * @function
     * @name pc.Entity#clone
     * @description Create a deep copy of the Entity. Duplicate the full Entity hierarchy, with all Components and all descendants.
     * Note, this Entity is not in the hierarchy and must be added manually.
     * @returns {pc.Entity} A new Entity which is a deep copy of the original.
     * @example
     * var e = this.entity.clone();
     *
     * // Add clone as a sibling to the original
     * this.entity.parent.addChild(e);
     */
    Entity.prototype.clone = function () {
        var duplicatedIdsMap = {};
        var clone = this._cloneRecursively(duplicatedIdsMap);
        duplicatedIdsMap[this.getGuid()] = clone;

        resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);

        return clone;
    };

    Entity.prototype._cloneRecursively = function (duplicatedIdsMap) {
        var clone = new Entity(this._app);
        GraphNode.prototype._cloneInternal.call(this, clone);

        for (var type in this.c) {
            var component = this.c[type];
            component.system.cloneComponent(this, clone);
        }

        var i;
        for (i = 0; i < this._children.length; i++) {
            var oldChild = this._children[i];
            if (oldChild instanceof Entity) {
                var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
                clone.addChild(newChild);
                duplicatedIdsMap[oldChild.getGuid()] = newChild;
            }
        }

        return clone;
    };

    // When an entity that has properties that contain references to other
    // entities within its subtree is duplicated, the expectation of the
    // user is likely that those properties will be updated to point to
    // the corresponding entities within the newly-created duplicate subtree.
    //
    // To handle this, we need to search for properties that refer to entities
    // within the old duplicated structure, find their newly-cloned partners
    // within the new structure, and update the references accordingly. This
    // function implements that requirement.
    function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
        var i, len;

        if (oldEntity instanceof Entity) {
            var components = oldEntity.c;

            // Handle component properties
            for (var componentName in components) {
                var component = components[componentName];
                var entityProperties = component.system.getPropertiesOfType('entity');

                for (i = 0, len = entityProperties.length; i < len; i++) {
                    var propertyDescriptor = entityProperties[i];
                    var propertyName = propertyDescriptor.name;
                    var oldEntityReferenceId = component[propertyName];
                    var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);

                    if (entityIsWithinOldSubtree) {
                        var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();

                        if (newEntityReferenceId) {
                            newEntity.c[componentName][propertyName] = newEntityReferenceId;
                        } else {
                            console.warn('Could not find corresponding entity id when resolving duplicated entity references');
                        }
                    }
                }
            }

            // Handle entity script attributes
            if (components.script && ! newEntity._app.useLegacyScriptAttributeCloning) {
                newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
            }

            // Recurse into children. Note that we continue to pass in the same `oldSubtreeRoot`,
            // in order to correctly handle cases where a child has an entity reference
            // field that points to a parent or other ancestor that is still within the
            // duplicated subtree.
            var _old = oldEntity.children.filter(function (e) {
                return (e instanceof Entity);
            });
            var _new = newEntity.children.filter(function (e) {
                return (e instanceof Entity);
            });

            for (i = 0, len = _old.length; i < len; i++) {
                resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);
            }
        }
    }

    /**
     * @private
     * @class
     * @name pc.AnimData
     * @classdesc Wraps a set of data used in animation.
     * @description Create a new animation data container.
     * @param {number} components - Specifies how many components make up an element of data.
     * For example, specify 3 for a set of 3-dimensional vectors. The number of elements in
     * data array must be a multiple of components.
     * @param {Float32Array|number[]} data - The set of data
     * @property {number} components - The number of components that make up and element
     * @property {Float32Array|number[]} data - The data
     */
    function AnimData(components, data) {
        this._components = components;
        this._data = data;
    }

    Object.defineProperties(AnimData.prototype, {
        components: {
            get: function () {
                return this._components;
            }
        },
        data: {
            get: function () {
                return this._data;
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimCache
     * @classdesc Internal cache data for the evaluation of a single curve timeline.
     * @description Create a new animation cache.
     */
    function AnimCache() {
        // these members are calculated per-segment
        this._left = Infinity;      // time of left knot
        this._right = -Infinity;    // time of right knot
        this._len = 0;              // distance between current knots
        this._recip = 0;            // reciprocal len
        this._p0 = 0;               // index of the left knot
        this._p1 = 0;               // index of the right knot

        // these members are calculated per-time evaluation
        this._t = 0;                // normalized time
        this._hermite = {           // hermite weights, calculated on demand
            valid: false,
            p0: 0,
            m0: 0,
            p1: 0,
            m1: 0
        };
    }

    Object.assign(AnimCache.prototype, {
        update: function (time, input) {
            if (time < this._left || time >= this._right) {
                // recalculate knots
                var len = input.length;
                if (!len) {
                    // curve is empty
                    this._left = -Infinity;
                    this._right = Infinity;
                    this._len = 0;
                    this._recip = 0;
                    this._p0 = this._p1 = 0;
                } else {
                    if (time < input[0]) {
                        // time falls before the first key
                        this._left = -Infinity;
                        this._right = input[0];
                        this._len = 0;
                        this._recip = 0;
                        this._p0 = this._p1 = 0;
                    } else if (time >= input[len - 1]) {
                        // time falls after the last key
                        this._left = input[len - 1];
                        this._right = Infinity;
                        this._len = 0;
                        this._recip = 0;
                        this._p0 = this._p1 = len - 1;
                    } else {
                        // time falls within the bounds of the curve
                        var index = this._findKey(time, input);
                        this._left = input[index];
                        this._right = input[index + 1];
                        this._len = this._right - this._left;
                        var diff = 1.0 / this._len;
                        this._recip = (isFinite(diff) ? diff : 0);
                        this._p0 = index;
                        this._p1 = index + 1;
                    }
                }
            }

            // calculate normalized time
            this._t = (this._recip === 0) ? 0 : ((time - this._left) * this._recip);
            this._hermite.valid = false;
        },

        _findKey: function (time, input) {
            // TODO: start the search around the currently selected knots
            var index = 0;
            while (time >= input[index + 1]) {
                index++;
            }
            return index;
        },

        // evaluate the output anim data at the current time
        eval: function (result, interpolation, output) {
            var data = output._data;
            var comp = output._components;
            var idx0 = this._p0 * comp;
            var i;

            if (interpolation === INTERPOLATION_STEP) {
                for (i = 0; i < comp; ++i) {
                    result[i] = data[idx0 + i];
                }
            } else {
                var t = this._t;
                var idx1 = this._p1 * comp;

                switch (interpolation) {
                    case INTERPOLATION_LINEAR:
                        for (i = 0; i < comp; ++i) {
                            result[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);
                        }
                        break;

                    case INTERPOLATION_CUBIC:
                        var hermite = this._hermite;

                        if (!hermite.valid) {
                            // cache hermite weights
                            var t2 = t * t;
                            var twot = t + t;
                            var omt = 1 - t;
                            var omt2 = omt * omt;

                            hermite.valid = true;
                            hermite.p0 = (1 + twot) * omt2;
                            hermite.m0 = t * omt2;
                            hermite.p1 = t2 * (3 - twot);
                            hermite.m1 = t2 * (t - 1);
                        }

                        var p0 = (this._p0 * 3 + 1) * comp;     // point at k
                        var m0 = (this._p0 * 3 + 2) * comp;     // out-tangent at k
                        var p1 = (this._p1 * 3 + 1) * comp;     // point at k + 1
                        var m1 = (this._p1 * 3 + 0) * comp;     // in-tangent at k + 1

                        for (i = 0; i < comp; ++i) {
                            result[i] = hermite.p0 * data[p0 + i] +
                                        hermite.m0 * data[m0 + i] * this._len +
                                        hermite.p1 * data[p1 + i] +
                                        hermite.m1 * data[m1 + i] * this._len;
                        }
                        break;
                }
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimCurve
     * @classdesc Animation curve links an input data set to an output data set
     * and defines the interpolation method to use.
     * @description Create a new animation curve
     * @param {string[]} paths - array of path strings identifying the targets of this curve, for example "rootNode.translation".
     * @param {number} input - index of the curve which specifies the key data.
     * @param {number} output - index of the curve which specifies the value data.
     * @param {number} interpolation - the interpolation method to use. One of the following:
     *
     * * {@link pc.INTERPOLATION_STEP}
     * * {@link pc.INTERPOLATION_LINEAR}
     * * {@link pc.INTERPOLATION_CUBIC}
     */
    function AnimCurve(paths, input, output, interpolation) {
        this._paths = paths;
        this._input = input;
        this._output = output;
        this._interpolation = interpolation;
    }

    Object.defineProperties(AnimCurve.prototype, {
        paths: {
            get: function () {
                return this._paths;
            }
        },
        input: {
            get: function () {
                return this._input;
            }
        },
        output: {
            get: function () {
                return this._output;
            }
        },
        interpolation: {
            get: function () {
                return this._interpolation;
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimTrack
     * @classdesc AnimTrack contains a set of curve data which can be used to animate a set of target nodes.
     * @description Create a new animation track.
     * @param {string} name - the track name
     * @param {number} duration - the duration of the track in seconds.
     * @param {pc.AnimData[]} inputs - list of curve key data.
     * @param {pc.AnimData[]} outputs - list of curve value data.
     * @param {pc.AnimCurve[]} curves - the list of curves.
     */
    function AnimTrack(name, duration, inputs, outputs, curves) {
        this._name = name;
        this._duration = duration;
        this._inputs = inputs;
        this._outputs = outputs;
        this._curves = curves;
    }

    Object.defineProperties(AnimTrack.prototype, {
        name: {
            get: function () {
                return this._name;
            }
        },
        duration: {
            get: function () {
                return this._duration;
            }
        },
        inputs: {
            get: function () {
                return this._inputs;
            }
        },
        outputs: {
            get: function () {
                return this._outputs;
            }
        },
        curves: {
            get: function () {
                return this._curves;
            }
        }
    });

    Object.assign(AnimTrack.prototype, {
        // evaluate all track curves at the specified time and store results
        // in the provided snapshot.
        eval: function (time, snapshot) {
            snapshot._time = time;

            var inputs = this._inputs;
            var outputs = this._outputs;
            var curves = this._curves;
            var cache = snapshot._cache;
            var results = snapshot._results;

            var i;

            // evaluate inputs
            for (i = 0; i < inputs.length; ++i) {
                cache[i].update(time, inputs[i]._data);
            }

            // evalute outputs
            for (i = 0; i < curves.length; ++i) {
                var curve = curves[i];
                var output = outputs[curve._output];
                var result = results[i];
                cache[curve._input].eval(result, curve._interpolation, output);
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimSnapshot
     * @classdesc AnimSnapshot stores the state of an animation track at a particular time.
     * @description Create a new animation snapshot.
     * @param {pc.AnimTrack} animTrack - the source track.
     */
    function AnimSnapshot(animTrack) {
        this._name = animTrack.name + 'Snapshot';
        this._time = -1;

        // per-curve input cache
        this._cache = [];

        // per-curve evaluation results
        this._results = [];

        var i;

        // pre-allocate input caches
        for (i = 0; i < animTrack._inputs.length; ++i) {
            this._cache[i] = new AnimCache();
        }

        // pre-allocate storage for evaluation results
        var curves = animTrack._curves;
        var outputs = animTrack._outputs;
        for (i = 0; i < curves.length; ++i) {
            var curve = curves[i];
            var output = outputs[curve._output];
            var storage = [];
            for (var j = 0; j < output._components; ++j) {
                storage[j] = 0;
            }
            this._results[i] = storage;
        }
    }

    /**
     * @private
     * @class
     * @name pc.AnimClip
     * @classdesc AnimClip wraps the running state of an animation track. It contains and update
     * the animation 'cursor' and performs looping logic.
     * @description Create a new animation clip.
     * @param {pc.AnimTrack} track - the animation data.
     * @param {number} time - the initial time of the clip.
     * @param {number} speed - speed of the animation playback.
     * @param {boolean} playing - true if the clip is playing and false otherwise.
     * @param {boolean} loop - whether the clip should loop.
     */
    // TODO: add configurable looping start/end times?
    function AnimClip(track, time, speed, playing, loop) {
        this._name = track.name;        // default to track name
        this._track = track;
        this._snapshot = new AnimSnapshot(track);
        this._playing = playing;
        this._time = time;              // play cursor
        this._speed = speed;            // playback speed, may be negative
        this._loop = loop;              // whether to loop
        this._blendWeight = 1.0;        // blend weight 0..1
        this._blendOrder = 0.0;         // blend order relative to other clips
    }

    Object.defineProperties(AnimClip.prototype, {
        name: {
            get: function () {
                return this._name;
            },
            set: function (name) {
                this._name = name;
            }
        },
        track: {
            get: function () {
                return this._track;
            }
        },
        snapshot: {
            get: function () {
                return this._snapshot;
            }
        },
        time: {
            get: function () {
                return this._time;
            },
            set: function (time) {
                this._time = time;
            }
        },
        speed: {
            get: function () {
                return this._speed;
            },
            set: function (speed) {
                this._speed = speed;
            }
        },
        loop: {
            get: function () {
                return this._loop;
            },
            set: function (loop) {
                this._loop = loop;
            }
        },
        blendWeight: {
            get: function () {
                return this._blendWeight;
            },
            set: function (blendWeight) {
                this._blendWeight = blendWeight;
            }
        },
        blendOrder: {
            get: function () {
                return this._blendOrder;
            },
            set: function (blendOrder) {
                this._blendOrder = blendOrder;
            }
        }
    });

    Object.assign(AnimClip.prototype, {
        _update: function (deltaTime) {
            if (this._playing) {
                var time = this._time;
                var duration = this._track.duration;
                var speed = this._speed;
                var loop = this._loop;

                // update time
                time += speed * deltaTime;

                // perform looping
                if (speed >= 0) {
                    // playing forwards
                    if (time > duration) {
                        if (loop) {
                            time = (time % duration) || 0;  // if duration is 0, % is NaN
                        } else {
                            time = this._track.duration;
                            this.pause();
                        }
                    }
                } else {
                    // playing backwards
                    if (time < 0) {
                        if (loop) {
                            time = duration + ((time % duration) || 0);
                        } else {
                            time = 0;
                            this.pause();
                        }
                    }
                }
                this._time = time;
            }

            // update snapshot if time has changed
            if (this._time != this._snapshot._time) {
                this._track.eval(this._time, this._snapshot);
            }
        },

        play: function () {
            this._playing = true;
            this._time = 0;
        },

        stop: function () {
            this._playing = false;
            this._time = 0;
        },

        pause: function () {
            this._playing = false;
        },

        resume: function () {
            this._playing = true;
        },

        reset: function () {
            this._time = 0;
        }
    });

    /**
     * @private
     * @callback pc.AnimSetter
     * @description Callback function that the {@link pc.AnimEvaluator} uses to set final animation values.
     * These callbacks are stored in {@link pc.AnimTarget} instances which are constructed by an
     * {@link pc.AnimBinder}.
     * @param {number[]} value - updated animation value.
     */

    /**
     * @private
     * @class
     * @name pc.AnimTarget
     * @classdesc Stores the information required by {@link pc.AnimEvaluator} for updating a target value.
     * @param {pc.AnimSetter} func - this function will be called when a new animation value is output by
     * the {@link pc.AnimEvaluator}.
     * @param {'vector'|'quaternion'} type - the type of animation data this target expects.
     * @param {number} components - the number of components on this target (this should ideally match the number
     * of components found on all attached animation curves).
     */
    function AnimTarget(func, type, components) {
        this._func = func;
        this._type = type;
        this._components = components;
    }

    Object.defineProperties(AnimTarget.prototype, {
        func: {
            get: function () {
                return this._func;
            }
        },
        type: {
            get: function () {
                return this._type;
            }
        },
        components: {
            get: function () {
                return this._components;
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimBinder
     * @classdesc This interface is used by {@link pc.AnimEvaluator} to resolve unique animation target path strings
     * into instances of {@link pc.AnimTarget}.
     */
    function AnimBinder() {}

    // join a list of path segments into a path string using the full stop character. If another character is supplied,
    // it will join using that character instead
    AnimBinder.joinPath = function (pathSegments, character) {
        character = character || '.';
        var escape = function (string) {
            return string.replace(/\\/g, '\\\\').replace(new RegExp('\\' + character, 'g'), '\\' + character);
        };
        return pathSegments.map(escape).join(character);
    };

    // split a path string into its segments and resolve character escaping
    AnimBinder.splitPath = function (path, character) {
        character = character || '.';
        var result = [];
        var curr = "";
        var i = 0;
        while (i < path.length) {
            var c = path[i++];

            if (c === '\\' && i < path.length) {
                c = path[i++];
                if (c === '\\' || c === character) {
                    curr += c;
                } else {
                    curr += '\\' + c;
                }
            } else if (c === character) {
                result.push(curr);
                curr = '';
            } else {
                curr += c;
            }
        }
        if (curr.length > 0) {
            result.push(curr);
        }
        return result;
    };

    Object.assign(AnimBinder.prototype, {
        /**
         * @private
         * @function
         * @name pc.AnimBinder#resolve
         * @description Resolve the provided target path and return an instance of {@link pc.AnimTarget} which
         * will handle setting the value, or return null if no such target exists.
         * @param {string} path - the animation curve path to resolve.
         * @returns {pc.AnimTarget|null} - returns the target instance on success and null otherwise.
         */
        resolve: function (path) {
            return null;
        },

        /**
         * @private
         * @function
         * @name pc.AnimBinder#unresolve
         * @description Called when the {@link AnimEvaluator} no longer has a curve driving the given key.
         * @param {string} path - the animation curve path which is no longer driven.
         */
        unresolve: function (path) {

        },

        /**
         * @private
         * @function
         * @name pc.AnimBinder#update
         * @description Called by {@link pc.AnimEvaluator} once a frame after animation updates are done.
         * @param {number} deltaTime - amount of time that passed in the current update.
         */
        update: function (deltaTime) {

        }
    });

    /**
     * @private
     * @class
     * @name pc.DefaultAnimBinder
     * @implements {pc.AnimBinder}
     * @classdesc Implementation of {@link pc.AnimBinder} for animating a skeleton in the graph-node
     * hierarchy.
     */
    function DefaultAnimBinder(graph) {
        var nodes = { };

        // cache node names so we can quickly resolve animation paths
        var flatten = function (node) {
            nodes[node.name] = {
                node: node,
                count: 0
            };
            for (var i = 0; i < node.children.length; ++i) {
                flatten(node.children[i]);
            }
        };
        flatten(graph);

        this.nodes = nodes;                 // map of node name -> { node, count }
        this.activeNodes = [];              // list of active nodes
        this.handlers = {
            'localPosition': function (node) {
                var object = node.localPosition;
                var func = function (value) {
                    object.set.apply(object, value);
                };
                return new AnimTarget(func, 'vector', 3);
            },

            'localRotation': function (node) {
                var object = node.localRotation;
                var func = function (value) {
                    object.set.apply(object, value);
                };
                return new AnimTarget(func, 'quaternion', 4);
            },

            'localScale': function (node) {
                var object = node.localScale;
                var func = function (value) {
                    object.set.apply(object, value);
                };
                return new AnimTarget(func, 'vector', 3);
            },

            'weights': function (node) {
                var object = node;
                while (object && object.constructor !== Entity) {
                    object = object.parent;
                }
                if (!object ||
                    !object.model ||
                    !object.model.model ||
                    !object.model.model.morphInstances) {
                    return null;
                }
                var meshInstances = object.model.meshInstances;
                var morphInstance;
                for (var i = 0; i < meshInstances.length; ++i) {
                    if (meshInstances[i].node.name === node.name) {
                        morphInstance = meshInstances[i].morphInstance;
                        break;
                    }
                }
                if (!morphInstance) {
                    return null;
                }
                var func = function (value) {
                    for (var i = 0; i < value.length; ++i) {
                        morphInstance.setWeight(i, value[i]);
                    }
                };
                return new AnimTarget(func, 'vector', morphInstance.morph._targets.length);
            }
        };

        this.propertyLocator = new AnimPropertyLocator();
    }

    Object.assign(DefaultAnimBinder.prototype, {
        resolve: function (path) {
            var pathSections = this.propertyLocator.decode(path);

            var node = this.nodes[pathSections[0][0]];
            if (!node) {
                return null;
            }

            var handler = this.handlers[pathSections[2][0]];
            if (!handler) {
                return null;
            }

            var target = handler(node.node);
            if (!target) {
                return null;
            }

            if (node.count === 0) {
                this.activeNodes.push(node.node);
            }
            node.count++;

            return target;
        },

        unresolve: function (path) {
            var pathSections = this.propertyLocator.decode(path);
            if (pathSections[1] !== 'graph')
                return;

            var node = this.nodes[pathSections[0][0]];

            node.count--;
            if (node.count === 0) {
                var activeNodes = this.activeNodes;
                var i = activeNodes.indexOf(node.node);  // :(
                var len = activeNodes.length;
                if (i < len - 1) {
                    activeNodes[i] = activeNodes[len - 1];
                }
                activeNodes.pop();
            }
        },

        // flag animating nodes as dirty
        update: function (deltaTime) {
            var activeNodes = this.activeNodes;
            for (var i = 0; i < activeNodes.length; ++i) {
                activeNodes[i]._dirtifyLocal();
            }
        },

        // get the path parts. we expect parts to have structure nodeName.[translation|rotation|scale|weights]
        _getParts: function (path) {
            var parts = AnimBinder.splitPath(path);
            if (parts.length !== 2 ||
                !this.nodes.hasOwnProperty(parts[0]) ||
                !this.handlers.hasOwnProperty(parts[1])) {
                return null;
            }
            return parts;
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimEvaluator
     * @classdesc AnimEvaluator blends multiple sets of animation clips together.
     * @description Create a new animation evaluator.
     * @param {pc.AnimBinder} binder - interface resolves curve paths to instances of {@link pc.AnimTarget}.
     * @property {pc.AnimClip[]} clips - the list of animation clips
     */
    function AnimEvaluator(binder) {
        this._binder = binder;
        this._clips = [];
        this._inputs = [];
        this._outputs = [];
        this._targets = {};
    }

    /**
     * @private
     * @name pc.AnimEvaluator
     * @type {number}
     * @description The number of clips.
     */
    Object.defineProperties(AnimEvaluator.prototype, {
        'clips': {
            get: function () {
                return this._clips;
            }
        }
    });

    AnimEvaluator._dot = function (a, b) {
        var len  = a.length;
        var result = 0;
        for (var i = 0; i < len; ++i) {
            result += a[i] * b[i];
        }
        return result;
    };

    AnimEvaluator._normalize = function (a) {
        var l = AnimEvaluator._dot(a, a);
        if (l > 0) {
            l = 1.0 / Math.sqrt(l);
            var len = a.length;
            for (var i = 0; i < len; ++i) {
                a[i] *= l;
            }
        }
    };

    AnimEvaluator._set = function (a, b, type) {
        var len  = a.length;
        var i;

        if (type === 'quaternion') {
            var l = AnimEvaluator._dot(b, b);
            if (l > 0) {
                l = 1.0 / Math.sqrt(l);
            }
            for (i = 0; i < len; ++i) {
                a[i] = b[i] * l;
            }
        } else {
            for (i = 0; i < len; ++i) {
                a[i] = b[i];
            }
        }
    };

    AnimEvaluator._blendVec = function (a, b, t) {
        var it = 1.0 - t;
        var len = a.length;
        for (var i = 0; i < len; ++i) {
            a[i] = a[i] * it + b[i] * t;
        }
    };

    AnimEvaluator._blendQuat = function (a, b, t) {
        var len = a.length;
        var it = 1.0 - t;

        // negate b if a and b don't lie in the same winding (due to
        // double cover). if we don't do this then often rotations from
        // one orientation to another go the long way around.
        if (AnimEvaluator._dot(a, b) < 0) {
            t = -t;
        }

        for (var i = 0; i < len; ++i) {
            a[i] = a[i] * it + b[i] * t;
        }

        AnimEvaluator._normalize(a);
    };

    AnimEvaluator._blend = function (a, b, t, type) {
        if (type === 'quaternion') {
            AnimEvaluator._blendQuat(a, b, t);
        } else {
            AnimEvaluator._blendVec(a, b, t);
        }
    };

    AnimEvaluator._stableSort = function (a, lessFunc) {
        var len = a.length;
        for (var i = 0; i < len - 1; ++i) {
            for (var j = i + 1; j < len; ++j) {
                if (lessFunc(a[j], a[i])) {
                    var tmp = a[i];
                    a[i] = a[j];
                    a[j] = tmp;
                }
            }
        }
    };

    Object.assign(AnimEvaluator.prototype, {
        /**
         * @private
         * @function
         * @name pc.AnimEvaluator#addClip
         * @description Add a clip to the evaluator.
         * @param {pc.AnimClip} clip - the clip to add to the evaluator.
         */
        addClip: function (clip) {
            var targets = this._targets;

            // store list of input/output arrays
            var curves = clip.track.curves;
            var snapshot = clip.snapshot;
            var inputs = [];
            var outputs = [];
            for (var i = 0; i < curves.length; ++i) {
                var curve = curves[i];
                var paths = curve.paths;
                for (var j = 0; j < paths.length; ++j) {
                    var path = paths[j];
                    var target = targets[path];

                    // create new target if it doesn't exist yet
                    if (!target) {
                        var resolved = this._binder.resolve(path);
                        if (resolved) {
                            target = {
                                target: resolved,           // resolved target instance
                                value: [],                  // storage for calculated value
                                curves: 0,                  // number of curves driving this target
                                blendCounter: 0             // per-frame number of blends (used to identify first blend)
                            };

                            for (var k = 0; k < target.target.components; ++k) {
                                target.value.push(0);
                            }

                            targets[path] = target;
                        }
                    }

                    // binding may have failed
                    // TODO: it may be worth storing quaternions and vector targets in seperate
                    // lists. this way the update code won't be foreced to check target type before
                    // setting/blending each target.
                    if (target) {
                        target.curves++;
                        inputs.push(snapshot._results[i]);
                        outputs.push(target);
                    }
                }
            }

            this._clips.push(clip);
            this._inputs.push(inputs);
            this._outputs.push(outputs);
        },

        /**
         * @private
         * @function
         * @name pc.AnimEvaluator#removeClip
         * @description Remove a clip from the evaluator.
         * @param {number} index - index of the clip to remove.
         */
        removeClip: function (index) {
            var targets = this._targets;

            var clips = this._clips;
            var clip = clips[index];
            var curves = clip.track.curves;

            for (var i = 0; i < curves.length; ++i) {
                var curve = curves[i];
                var paths = curve.paths;
                for (var j = 0; j < paths.length; ++j) {
                    var path = paths[j];

                    var target = targets[path];

                    if (target) {
                        target.curves--;
                        if (target.curves === 0) {
                            this._binder.unresolve(path);
                            delete targets[path];
                        }
                    }
                }
            }

            clips.splice(index, 1);
            this._inputs.splice(index, 1);
            this._outputs.splice(index, 1);
        },

        /**
         * @private
         * @function
         * @name pc.AnimEvaluator#removeClips
         * @description Remove all clips from the evaluator.
         */
        removeClips: function () {
            while (this._clips.length > 0) {
                this.removeClip(0);
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimEvaluator#findClip
         * @description Returns the first clip which matches the given name, or null if no such clip was found.
         * @param {string} name - name of the clip to find.
         * @returns {pc.AnimClip|null} - the clip with the given name or null if no such clip was found.
         */
        findClip: function (name) {
            var clips = this._clips;
            for (var i = 0; i < clips.length; ++i) {
                var clip = clips[i];
                if (clip.name === name) {
                    return clip;
                }
            }
            return null;
        },

        /**
         * @private
         * @function
         * @name pc.AnimEvaluator#update
         * @description Evaluator frame update function. All the attached {@link pc.AnimClip}s are evaluated,
         * blended and the results set on the {@link pc.AnimTarget}.
         * @param {number} deltaTime - the amount of time that has passed since the last update, in seconds.
         */
        update: function (deltaTime) {
            // copy clips
            var clips = this._clips;

            // stable sort order
            var order = clips.map(function (c, i) {
                return i;
            });
            AnimEvaluator._stableSort(order, function (a, b) {
                return clips[a].blendOrder < clips[b].blendOrder;
            });

            var i, j;

            for (i = 0; i < clips.length; ++i) {
                var index = order[i];
                var clip = clips[index];
                var inputs = this._inputs[index];
                var outputs = this._outputs[index];
                var blendWeight = clip.blendWeight;

                // update clip
                if (blendWeight > 0.0) {
                    clip._update(deltaTime);
                }

                var input;
                var output;
                var value;

                if (blendWeight >= 1.0) {
                    for (j = 0; j < inputs.length; ++j) {
                        input = inputs[j];
                        output = outputs[j];
                        value = output.value;

                        AnimEvaluator._set(value, input, output.target.type);

                        output.blendCounter++;
                    }
                } else if (blendWeight > 0.0) {
                    for (j = 0; j < inputs.length; ++j) {
                        input = inputs[j];
                        output = outputs[j];
                        value = output.value;

                        if (output.blendCounter === 0) {
                            AnimEvaluator._set(value, input, output.target.type);
                        } else {
                            AnimEvaluator._blend(value, input, blendWeight, output.target.type);
                        }

                        output.blendCounter++;
                    }
                }
            }

            // apply result to anim targets
            var targets = this._targets;
            for (var path in targets) {
                if (targets.hasOwnProperty(path)) {
                    var target = targets[path];
                    target.target.func(target.value);
                    target.blendCounter = 0;
                }
            }

            // give the binder an opportunity to update itself
            // TODO: is this even necessary? binder could know when to update
            // itself without our help.
            this._binder.update(deltaTime);
        }
    });

    function I18nParser() {}

    I18nParser.prototype._validate = function (data) {
        if (!data.header) {
            throw new Error('pc.I18n#addData: Missing "header" field');
        }
        if (!data.header.version) {
            throw new Error('pc.I18n#addData: Missing "header.version" field');
        }
        if (data.header.version !== 1) {
            throw new Error('pc.I18n#addData: Invalid "header.version" field');
        }

        if (!data.data) {
            throw new Error('pc.I18n#addData: Missing "data" field');
        } else if (!Array.isArray(data.data)) {
            throw new Error('pc.I18n#addData: "data" field must be an array');
        }

        for (var i = 0, len = data.data.length; i < len; i++) {
            var entry = data.data[i];
            if (!entry.info) {
                throw new Error('pc.I18n#addData: missing "data[' + i + '].info" field');
            }

            if (!entry.info.locale) {
                throw new Error('pc.I18n#addData: missing "data[' + i + '].info.locale" field');
            }
            if (typeof entry.info.locale !== 'string') {
                throw new Error('pc.I18n#addData: "data[' + i + '].info.locale" must be a string');
            }

            if (!entry.messages) {
                throw new Error('pc.I18n#addData: missing "data[' + i + '].messages" field');
            }
        }
    };

    I18nParser.prototype.parse = function (data) {

        return data.data;
    };

    // Maps locale to function that returns the plural index
    // based on the CLDR rules. See here for reference
    // https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
    // and http://unicode.org/reports/tr35/tr35-numbers.html#Operands .
    // An initial set of locales is supported and we can keep adding more as we go.
    var PLURALS = {};

    // Helper function to define the plural function for an array of locales
    var definePluralFn = function (locales, fn) {
        for (var i = 0, len = locales.length; i < len; i++) {
            PLURALS[locales[i]] = fn;
        }
    };

    // Gets the language portion form a locale
    var getLang = function (locale) {
        var idx = locale.indexOf('-');
        if (idx !== -1) {
            return locale.substring(0, idx);
        }

        return locale;
    };

    // Replaces the language in the specified locale and returns the result
    var replaceLang = function (locale, desiredLang) {
        var idx = locale.indexOf('-');
        if (idx !== -1) {
            return desiredLang + locale.substring(idx);
        }

        return desiredLang;
    };

    var DEFAULT_LOCALE = 'en-US';

    // default locale fallbacks if a specific locale
    // was not found. E.g. if the desired locale is en-AS but we
    // have en-US and en-GB then pick en-US. If a fallback does not exist either
    // then pick the first that satisfies the language.
    var DEFAULT_LOCALE_FALLBACKS = {
        'en': 'en-US',
        'es': 'en-ES',
        'zh': 'zh-CN',
        'zh-HK': 'zh-TW',
        'zh-TW': 'zh-HK',
        'fr': 'fr-FR',
        'de': 'de-DE',
        'it': 'it-IT',
        'ru': 'ru-RU',
        'ja': 'ja-JP'
    };

    // Only OTHER
    definePluralFn([
        'ja',
        'ko',
        'th',
        'vi',
        'zh',
        'id'
    ], function (n) {
        return 0;
    });

    // ONE, OTHER
    definePluralFn([
        'fa',
        'hi'
    ], function (n) {
        if (n >= 0 && n <= 1) {
            return 0; // one
        }

        return 1; // other
    });

    // from Unicode rules: i = 0..1
    definePluralFn([
        'fr',
        'pt'
    ], function (n) {
        if (n >= 0 && n < 2) {
            return 0; // one
        }

        return 1; // other
    });

    // danish
    definePluralFn([
        'da'
    ], function (n) {
        if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
            return 0; // one
        }

        return 1; // other
    });

    definePluralFn([
        'de',
        'en',
        'it',
        'el',
        'es',
        'tr',
        'fi',
        'sv',
        'nb',
        'no',
        'ur'
    ], function (n) {
        if (n === 1)  {
            return 0; // one
        }

        return 1; // other
    });

    // ONE, FEW, MANY, OTHER
    definePluralFn([
        'ru',
        'uk'
    ], function (n) {
        if (Number.isInteger(n)) {
            var mod10 = n % 10;
            var mod100 = n % 100;

            if (mod10 === 1 && mod100 !== 11) {
                return 0; // one
            } else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
                return 1; // few
            } else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
                return 2; // many
            }
        }

        return 3; // other
    });

    // polish
    definePluralFn([
        'pl'
    ], function (n) {
        if (Number.isInteger(n)) {
            if (n === 1) {
                return 0; // one
            }
            var mod10 = n % 10;
            var mod100 = n % 100;

            if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
                return 1; // few
            } else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
                return 2; // many
            }
        }

        return 3; // other
    });

    // ZERO, ONE, TWO, FEW, MANY, OTHER
    definePluralFn([
        'ar'
    ], function (n) {
        if (n === 0)  {
            return 0; // zero
        } else if (n === 1) {
            return 1; // one
        } else if (n === 2) {
            return 2; // two
        }

        if (Number.isInteger(n)) {
            var mod100 = n % 100;
            if (mod100 >= 3 && mod100 <= 10) {
                return 3; // few
            } else if (mod100 >= 11 && mod100 <= 99) {
                return 4; // many
            }
        }

        return 5; // other
    });

    var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];

    // Gets the function that converts to plural for a language
    var getPluralFn = function (lang) {
        return PLURALS[lang] || DEFAULT_PLURAL_FN;
    };

    /**
     * @class
     * @name pc.I18n
     * @augments pc.EventHandler
     * @classdesc Handles localization. Responsible for loading localization assets
     * and returning translations for a certain key. Can also handle plural forms. To override
     * its default behaviour define a different implementation for {@link pc.I18n#getText} and {@link pc.I18n#getPluralText}.
     * @param {pc.Application} app - The application.
     * @property {string} locale The current locale for example "en-US". Changing the locale will raise an event which will cause localized Text Elements to
     * change language to the new locale.
     * @property {number[]|pc.Asset[]} assets An array of asset ids or assets that contain localization data in the expected format. I18n will automatically load
     * translations from these assets as the assets are loaded and it will also automatically unload translations if the assets get removed or unloaded at runtime.
     */
    function I18n(app) {
        EventHandler.call(this);

        this.locale = DEFAULT_LOCALE;
        this._translations = {};
        this._availableLangs = {};
        this._app = app;
        this._assets = [];
        this._parser = new I18nParser();
    }
    I18n.prototype = Object.create(EventHandler.prototype);
    I18n.prototype.constructor = I18n;

    /**
     * @function
     * @name pc.I18n#findAvailableLocale
     * @description Returns the first available locale based on the desired locale specified. First
     * tries to find the desired locale and then tries to find an alternative locale based on the language.
     * @param {string} desiredLocale - The desired locale e.g. En-US.
     * @param {object} availableLocales - A dictionary where each key is an available locale.
     * @returns {string} The locale found or if no locale is available returns the default en-US locale.
     */
    I18n.findAvailableLocale = function (desiredLocale, availableLocales) {
        if (availableLocales[desiredLocale]) {
            return desiredLocale;
        }

        var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
        if (fallback && availableLocales[fallback]) {
            return fallback;
        }

        var lang = getLang(desiredLocale);

        fallback = DEFAULT_LOCALE_FALLBACKS[lang];
        if (availableLocales[fallback]) {
            return fallback;
        }

        if (availableLocales[lang]) {
            return lang;
        }

        return DEFAULT_LOCALE;
    };

    /**
     * @function
     * @name pc.I18n#getText
     * @description Returns the translation for the specified key and locale. If the locale is not specified
     * it will use the current locale.
     * @param {string} key - The localization key.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale then it will return
     * the en-US translation. If no translation exists for that key then it will return the localization key.
     * @example
     * var localized = this.app.i18n.getText('localization-key');
     * var localizedFrench = this.app.i18n.getText('localization-key', 'fr-FR');
     */
    I18n.prototype.getText = function (key, locale) {
        // default translation is the key
        var result = key;

        var lang;
        if (!locale) {
            locale = this._locale;
            lang = this._lang;
        }

        var translations = this._translations[locale];
        if (!translations) {
            if (!lang) {
                lang = getLang(locale);
            }

            locale = this._findFallbackLocale(locale, lang);
            translations = this._translations[locale];
        }

        if (translations && translations.hasOwnProperty(key)) {
            result = translations[key];

            // if this is a plural key then return the first entry in the array
            if (Array.isArray(result)) {
                result = result[0];
            }

            // if null or undefined switch back to the key (empty string is allowed)
            if (result === null || result === undefined) {
                result = key;
            }
        }

        return result;
    };

    /**
     * @function
     * @name pc.I18n#getPluralText
     * @description Returns the pluralized translation for the specified key, number n and locale. If the locale is not specified
     * it will use the current locale.
     * @param {string} key - The localization key.
     * @param {number} n - The number used to determine which plural form to use. E.g. For the phrase "5 Apples" n equals 5.
     * @param {string} [locale] - The desired locale.
     * @returns {string} The translated text. If no translations are found at all for the locale then it will return
     * the en-US translation. If no translation exists for that key then it will return the localization key.
     * @example
     * // manually replace {number} in the resulting translation with our number
     * var localized = this.app.i18n.getPluralText('{number} apples', number).replace("{number}", number);
     */
    I18n.prototype.getPluralText = function (key, n, locale) {
        // default translation is the key
        var result = key;

        var pluralFn;
        var lang;

        if (!locale) {
            locale = this._locale;
            lang = this._lang;
            pluralFn = this._pluralFn;
        } else {
            lang = getLang(locale);
            pluralFn = getPluralFn(lang);
        }

        var translations = this._translations[locale];
        if (!translations) {
            locale = this._findFallbackLocale(locale, lang);
            lang = getLang(locale);
            pluralFn = getPluralFn(lang);
            translations = this._translations[locale];
        }

        if (translations && translations[key] && pluralFn) {
            var index = pluralFn(n);
            result = translations[key][index];

            // if null or undefined switch back to the key (empty string is allowed)
            if (result === null || result === undefined) {
                result = key;
            }
        }

        return result;
    };

    /**
     * @function
     * @name pc.I18n#addData
     * @description Adds localization data. If the locale and key for a translation already exists it will be overwritten.
     * @param {object} data - The localization data. See example for the expected format of the data.
     * @example
     * this.app.i18n.addData({
     *     header: {
     *         version: 1
     *     },
     *     data: [{
     *         info: {
     *             locale: 'en-US'
     *         },
     *         messages: {
     *             "key": "translation",
     *             // The number of plural forms depends on the locale. See the manual for more information.
     *             "plural_key": ["one item", "more than one items"]
     *         }
     *     }, {
     *         info: {
     *             locale: 'fr-FR'
     *         },
     *         messages: {
     *             // ...
     *         }
     *     }]
     * });
     */
    I18n.prototype.addData = function (data) {
        var parsed;
        try {
            parsed = this._parser.parse(data);
        } catch (err) {
            console.error(err);
            return;
        }

        for (var i = 0, len = parsed.length; i < len; i++) {
            var entry = parsed[i];
            var locale = entry.info.locale;
            var messages = entry.messages;
            if (!this._translations[locale]) {
                this._translations[locale] = {};
                var lang = getLang(locale);

                // remember the first locale we've found for that language
                // in case we need to fall back to it
                if (!this._availableLangs[lang]) {
                    this._availableLangs[lang] = locale;
                }
            }

            Object.assign(this._translations[locale], messages);

            this.fire('data:add', locale, messages);
        }
    };

    /**
     * @function
     * @name pc.I18n#removeData
     * @description Removes localization data.
     * @param {object} data - The localization data. The data is expected to be in the same format as {@link pc.I18n#addData}.
     */
    I18n.prototype.removeData = function (data) {
        var parsed;
        var key;
        try {
            parsed = this._parser.parse(data);
        } catch (err) {
            console.error(err);
            return;
        }

        for (var i = 0, len = parsed.length; i < len; i++) {
            var entry = parsed[i];
            var locale = entry.info.locale;
            var translations = this._translations[locale];
            if (!translations) continue;

            var messages = entry.messages;
            for (key in messages) {
                delete translations[key];
            }

            // if no more entries for that locale then
            // delete the locale
            var hasAny = false;
            for (key in translations) {
                hasAny = true;
                break;
            }

            if (!hasAny) {
                delete this._translations[locale];
                delete this._availableLangs[getLang(locale)];
            }

            this.fire('data:remove', locale, messages);
        }
    };

    /**
     * @function
     * @name pc.I18n#destroy
     * @description Frees up memory.
     */
    I18n.prototype.destroy = function () {
        this._translations = null;
        this._availableLangs = null;
        this._assets = null;
        this._parser = null;
        this.off();
    };

    Object.defineProperty(I18n.prototype, 'locale', {
        get: function () {
            return this._locale;
        },
        set: function (value) {
            if (this._locale === value) {
                return;
            }

            // replace 'in' language with 'id'
            // for Indonesian because both codes are valid
            // so that users only need to use the 'id' code
            var lang = getLang(value);
            if (lang === 'in') {
                lang = 'id';
                value = replaceLang(value, lang);
                if (this._locale === value) {
                    return;
                }
            }

            var old = this._locale;
            // cache locale, lang and plural function
            this._locale = value;
            this._lang = lang;
            this._pluralFn = getPluralFn(this._lang);

            // raise event
            this.fire('set:locale', value, old);
        }
    });

    Object.defineProperty(I18n.prototype, 'assets', {
        get: function () {
            return this._assets;
        },
        set: function (value) {
            var i;
            var len;
            var id;
            var asset;

            var index = {};

            // convert array to dict
            for (i = 0, len = value.length; i < len; i++) {
                id = value[i] instanceof Asset ? value[i].id : value[i];
                index[id] = true;
            }

            // remove assets not in value
            i = this._assets.length;
            while (i--) {
                id = this._assets[i];
                if (!index[id]) {
                    this._app.assets.off('add:' + id, this._onAssetAdd, this);
                    asset = this._app.assets.get(id);
                    if (asset) {
                        this._onAssetRemove(asset);
                    }
                    this._assets.splice(i, 1);
                }
            }

            // add assets in value that do not already exist here
            for (id in index) {
                id = parseInt(id, 10);
                if (this._assets.indexOf(id) !== -1) continue;

                this._assets.push(id);
                asset = this._app.assets.get(id);
                if (!asset) {
                    this._app.assets.once('add:' + id, this._onAssetAdd, this);
                } else {
                    this._onAssetAdd(asset);
                }
            }
        }
    });

    // Finds a fallback locale for the specified locale and language.
    // 1) First tries DEFAULT_LOCALE_FALLBACKS
    // 2) If no translation exists for that locale return the first locale available for that language.
    // 3) If no translation exists for that either then return the DEFAULT_LOCALE
    I18n.prototype._findFallbackLocale = function (locale, lang) {
        var result = DEFAULT_LOCALE_FALLBACKS[locale];
        if (result && this._translations[result]) {
            return result;
        }

        result = DEFAULT_LOCALE_FALLBACKS[lang];
        if (result && this._translations[result]) {
            return result;
        }

        result = this._availableLangs[lang];
        if (result && this._translations[result]) {
            return result;
        }

        return DEFAULT_LOCALE;
    };

    I18n.prototype._onAssetAdd = function (asset) {
        asset.on('load', this._onAssetLoad, this);
        asset.on('change', this._onAssetChange, this);
        asset.on('remove', this._onAssetRemove, this);
        asset.on('unload', this._onAssetUnload, this);

        if (asset.resource) {
            this._onAssetLoad(asset);
        }
    };

    I18n.prototype._onAssetLoad = function (asset) {
        this.addData(asset.resource);
    };

    I18n.prototype._onAssetChange = function (asset) {
        if (asset.resource) {
            this.addData(asset.resource);
        }
    };

    I18n.prototype._onAssetRemove = function (asset) {
        asset.off('load', this._onAssetLoad, this);
        asset.off('change', this._onAssetChange, this);
        asset.off('remove', this._onAssetRemove, this);
        asset.off('unload', this._onAssetUnload, this);

        if (asset.resource) {
            this.removeData(asset.resource);
        }

        this._app.assets.once('add:' + asset.id, this._onAssetAdd, this);
    };

    I18n.prototype._onAssetUnload = function (asset) {
        if (asset.resource) {
            this.removeData(asset.resource);
        }
    };

    var ABSOLUTE_URL = new RegExp(
        '^' + // beginning of the url
        '\\s*' +  // ignore leading spaces (some browsers trim the url automatically, but we can't assume that)
        '(?:' +  // beginning of a non-captured regex group
            // `{protocol}://`
            '(?:' +  // beginning of protocol scheme (non-captured regex group)
                '[a-z]+[a-z0-9\\-\\+\\.]*' + // protocol scheme must (RFC 3986) consist of "a letter and followed by any combination of letters, digits, plus ("+"), period ("."), or hyphen ("-")."
                ':' + // protocol scheme must end with colon character
            ')?' + // end of optional scheme group, the group is optional since the string may be a protocol-relative absolute URL
            '//' + // an absolute url must always begin with two forward slash characters (ignoring any leading spaces and protocol scheme)

            '|' + // or another option(s):

            // Data URL (RFC 2397), simplified
            'data:' +

            // Blob data
            '|blob:' +
        ')',
        'i' // non case-sensitive flag
    );

    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_ANIMATION
     * @description Asset type name for animation.
     */
    var ASSET_ANIMATION = 'animation';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_AUDIO
     * @description Asset type name for audio.
     */
    var ASSET_AUDIO = 'audio';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_IMAGE
     * @description Asset type name for image.
     */
    var ASSET_IMAGE = 'image';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_JSON
     * @description Asset type name for json.
     */
    var ASSET_JSON = 'json';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_MODEL
     * @description Asset type name for model.
     */
    var ASSET_MODEL = 'model';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_MATERIAL
     * @description Asset type name for material.
     */
    var ASSET_MATERIAL = 'material';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_TEXT
     * @description Asset type name for text.
     */
    var ASSET_TEXT = 'text';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_TEXTURE
     * @description Asset type name for texture.
     */
    var ASSET_TEXTURE = 'texture';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_CUBEMAP
     * @description Asset type name for cubemap.
     */
    var ASSET_CUBEMAP = 'cubemap';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_SHADER
     * @description Asset type name for shader.
     */
    var ASSET_SHADER = 'shader';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_CSS
     * @description Asset type name for CSS.
     */
    var ASSET_CSS = 'css';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_HTML
     * @description Asset type name for HTML.
     */
    var ASSET_HTML = 'html';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_SCRIPT
     * @description Asset type name for script.
     */
    var ASSET_SCRIPT = 'script';
    /**
     * @constant
     * @type {string}
     * @name pc.ASSET_CONTAINER
     * @description Asset type name for a container.
     */
    var ASSET_CONTAINER = 'container';

    var properties = [];

    function AssetVariants(asset) {
        this.asset = asset;
    }

    var defineVariantProperty = function (name) {
        var field = '_' + name;
        properties.push(field);

        Object.defineProperty(AssetVariants.prototype, name, {
            get: function () {
                return this[field] || null;
            },
            set: function (value) {
                var fieldAsBool = !!this[field];
                var valueAsBool = !!value;
                if (fieldAsBool !== valueAsBool || (this[field] && value && this[field].hash !== value.hash)) {
                    if (value) {
                        this[field] = {
                            url: value.url,
                            filename: value.filename,
                            size: value.size,
                            hash: value.hash,
                            opt: value.opt || 0
                        };
                    } else {
                        this[field] = null;
                    }

                    if (this.asset.file) {
                        this.asset.fire('change', this.asset, 'file', this.asset._file, this.asset._file);
                        this.asset.reload();
                    }
                }
            }
        });
    };


    // texture
    defineVariantProperty('dxt');
    defineVariantProperty('pvr');
    defineVariantProperty('etc1');
    defineVariantProperty('etc2');
    defineVariantProperty('basis');

    AssetVariants.prototype.clear = function () {
        for (var i = 0; i < properties.length; i++)
            this[properties[i]] = null;
    };

    // auto incrementing number for asset ids
    var assetIdCounter = -1;

    var VARIANT_SUPPORT = {
        pvr: 'extCompressedTexturePVRTC',
        dxt: 'extCompressedTextureS3TC',
        etc2: 'extCompressedTextureETC',
        etc1: 'extCompressedTextureETC1',
        basis: 'canvas' // dummy, basis is always supported
    };

    var VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];

    /**
     * @class
     * @name pc.Asset
     * @augments pc.EventHandler
     * @classdesc An asset record of a file or data resource that can be loaded by the engine.
     * The asset contains three important fields:
     *
     * * `file`: contains the details of a file (filename, url) which contains the resource data, e.g. an image file for a texture asset.
     * * `data`: contains a JSON blob which contains either the resource data for the asset (e.g. material data) or additional data for the file (e.g. material mappings for a model).
     * * `resource`: contains the final resource when it is loaded. (e.g. a {@link pc.StandardMaterial} or a {@link pc.Texture}).
     *
     * See the {@link pc.AssetRegistry} for details on loading resources from assets.
     * @description Create a new Asset record. Generally, Assets are created in the loading process and you won't need to create them by hand.
     * @param {string} name - A non-unique but human-readable name which can be later used to retrieve the asset.
     * @param {string} type - Type of asset. One of ["animation", "audio", "binary", "cubemap", "css", "font", "json", "html", "material", "model", "script", "shader", "text", "texture"]
     * @param {object} [file] - Details about the file the asset is made from. At the least must contain the 'url' field. For assets that don't contain file data use null.
     * @example
     * var file = {
     *     filename: "filename.txt",
     *     url: "/example/filename.txt"
     * };
     * @param {object} [data] - JSON object with additional data about the asset (e.g. for texture and model assets) or contains the asset data itself (e.g. in the case of materials)
     * @example
     * var asset = new pc.Asset("a texture", "texture", {
     *     url: "http://example.com/my/assets/here/texture.png"
     * });
     * @param {object} [options] - a JSON object containing load-time options specific to the asset.
     * @property {string} name The name of the asset
     * @property {number} id The asset id
     * @property {string} type The type of the asset. One of ["animation", "audio", "binary", "cubemap", "css", "font", "json", "html", "material", "model", "script", "shader", "text", "texture"]
     * @property {pc.Tags} tags Interface for tagging. Allows to find assets by tags using {@link pc.AssetRegistry#findByTag} method.
     * @property {object} file The file details or null if no file
     * @property {string} [file.url] The URL of the resource file that contains the asset data
     * @property {string} [file.filename] The filename of the resource file
     * @property {number} [file.size] The size of the resource file
     * @property {string} [file.hash] The MD5 hash of the resource file data and the Asset data field
     * @property {object} [data] Optional JSON data that contains either the complete resource data (e.g. in the case of a material) or additional data (e.g. in the case of a model it contains mappings from mesh to material)
     * @property {object} resource A reference to the resource when the asset is loaded. e.g. a {@link pc.Texture} or a {@link pc.Model}
     * @property {Array} resources A reference to the resources of the asset when it's loaded. An asset can hold more runtime resources than one e.g. cubemaps
     * @property {boolean} preload If true the asset will be loaded during the preload phase of application set up.
     * @property {boolean} loaded True if the resource is loaded. e.g. if asset.resource is not null
     * @property {boolean} loading True if the resource is currently being loaded
     * @property {pc.AssetRegistry} registry The asset registry that this Asset belongs to
     */
    function Asset(name, type, file, data, options) {
        EventHandler.call(this);

        this._id = assetIdCounter--;

        this.name = name || '';
        this.type = type;
        this.tags = new Tags(this);
        this._preload = false;

        this.variants = new AssetVariants(this);

        this._file = null;
        this._data = data || { };
        this.options = options || { };

        // This is where the loaded resource(s) will be
        this._resources = [];

        // a string-assetId dictionary that maps
        // locale to asset id
        this._i18n = {};

        // Is resource loaded
        this.loaded = false;
        this.loading = false;

        this.registry = null;

        if (file) this.file = file;
    }
    Asset.prototype = Object.create(EventHandler.prototype);
    Asset.prototype.constructor = Asset;

    /**
     * @event
     * @name pc.Asset#load
     * @description Fired when the asset has completed loading.
     * @param {pc.Asset} asset - The asset that was loaded.
     */

    /**
     * @event
     * @name pc.Asset#remove
     * @description Fired when the asset is removed from the asset registry.
     * @param {pc.Asset} asset - The asset that was removed.
     */

    /**
     * @event
     * @name pc.Asset#error
     * @description Fired if the asset encounters an error while loading.
     * @param {string} err - The error message.
     * @param {pc.Asset} asset - The asset that generated the error.
     */

    /**
     * @event
     * @name pc.Asset#change
     * @description Fired when one of the asset properties `file`, `data`, `resource` or `resources` is changed.
     * @param {pc.Asset} asset - The asset that was loaded.
     * @param {string} property - The name of the property that changed.
     * @param {*} value - The new property value.
     * @param {*} oldValue - The old property value.
     */

    /**
     * @event
     * @name pc.Asset#add:localized
     * @description Fired when we add a new localized asset id to the asset.
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we added.
     */

    /**
     * @event
     * @name pc.Asset#remove:localized
     * @description Fired when we remove a localized asset id from the asset.
     * @param {string} locale - The locale.
     * @param {number} assetId - The asset id we removed.
     */

    Object.assign(Asset.prototype, {
        /**
         * @name pc.Asset#getFileUrl
         * @function
         * @description Return the URL required to fetch the file for this asset.
         * @returns {string} The URL.
         * @example
         * var assets = app.assets.find("My Image", "texture");
         * var img = "&lt;img src='" + assets[0].getFileUrl() + "'&gt;";
         */
        getFileUrl: function () {
            var file = this.getPreferredFile();

            if (!file || !file.url)
                return null;

            var url = file.url;

            if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url))
                url = this.registry.prefix + url;

            // add file hash to avoid hard-caching problems
            if (this.type !== 'script' && file.hash) {
                var separator = url.indexOf('?') !== -1 ? '&' : '?';
                url += separator + 't=' + file.hash;
            }

            return url;
        },

        getPreferredFile: function () {
            if (!this.file)
                return null;

            if (this.type === 'texture' || this.type === 'textureatlas' || this.type === 'bundle') {
                var app = this.registry._loader._app;
                var device = app.graphicsDevice;

                for (var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {
                    var variant = VARIANT_DEFAULT_PRIORITY[i];
                    // if the device supports the variant
                    if (! device[VARIANT_SUPPORT[variant]]) continue;

                    // if the variant exists in the asset then just return it
                    if (this.file.variants[variant]) {
                        return this.file.variants[variant];
                    }

                    // if the variant does not exist but the asset is in a bundle
                    // and the bundle contain assets with this variant then return the default
                    // file for the asset
                    if (app.enableBundles) {
                        var bundles = app.bundles.listBundlesForAsset(this);
                        if (! bundles) continue;

                        for (var j = 0, len2 = bundles.length; j < len2; j++) {
                            if (bundles[j].file && bundles[j].file.variants && bundles[j].file.variants[variant]) {
                                return this.file;
                            }
                        }
                    }
                }
            }

            return this.file;
        },

        /**
         * @private
         * @function
         * @name pcAsset#getAbsoluteUrl
         * @description Construct an asset URL from this asset's location and a relative path
         * @param {string} relativePath - The relative path to be concatenated to this asset's base url
         * @returns {string} Resulting URL of the asset
         */
        getAbsoluteUrl: function (relativePath) {
            var base = path.getDirectory(this.file.url);
            return path.join(base, relativePath);
        },

        /**
         * @private
         * @function
         * @name pc.Asset#getLocalizedAssetId
         * @param {string} locale - The desired locale e.g. Ar-AR.
         * @description Returns the asset id of the asset that corresponds to the specified locale.
         * @returns {number} An asset id or null if there is no asset specified for the desired locale.
         */
        getLocalizedAssetId: function (locale) {
            // tries to find either the desired locale or a fallback locale
            locale = I18n.findAvailableLocale(locale, this._i18n);
            return this._i18n[locale] || null;
        },

        /**
         * @private
         * @function
         * @name pc.Asset#addLocalizedAssetId
         * @param {string} locale - The locale e.g. Ar-AR.
         * @param {number} assetId - The asset id.
         * @description Adds a replacement asset id for the specified locale. When the locale in {@link pc.Application#i18n} changes then
         * references to this asset will be replaced with the specified asset id. (Currently only supported by the {@link pc.ElementComponent}).
         */
        addLocalizedAssetId: function (locale, assetId) {
            this._i18n[locale] = assetId;
            this.fire('add:localized', locale, assetId);
        },

        /**
         * @private
         * @function
         * @name pc.Asset#removeLocalizedAssetId
         * @param {string} locale - The locale e.g. Ar-AR.
         * @description Removes a localized asset.
         */
        removeLocalizedAssetId: function (locale) {
            var assetId = this._i18n[locale];
            if (assetId) {
                delete this._i18n[locale];
                this.fire('remove:localized', locale, assetId);
            }
        },

        /**
         * @function
         * @name pc.Asset#ready
         * @description Take a callback which is called as soon as the asset is loaded. If the asset is already loaded the callback is called straight away.
         * @param {pc.callbacks.AssetReady} callback - The function called when the asset is ready. Passed the (asset) arguments.
         * @param {object} [scope] - Scope object to use when calling the callback.
         * @example
         * var asset = app.assets.find("My Asset");
         * asset.ready(function (asset) {
         *   // asset loaded
         * });
         * app.assets.load(asset);
         */
        ready: function (callback, scope) {
            scope = scope || this;

            if (this.resource) {
                callback.call(scope, this);
            } else {
                this.once("load", function (asset) {
                    callback.call(scope, asset);
                });
            }
        },

        reload: function () {
            // no need to be reloaded
            if (!this.loaded)
                return;

            if (this.type === 'cubemap') {
                this.registry._loader.patch(this, this.registry);
            } else {
                this.loaded = false;
                this.registry.load(this);
            }
        },

        /**
         * @function
         * @name pc.Asset#unload
         * @description Destroys the associated resource and marks asset as unloaded.
         * @example
         * var asset = app.assets.find("My Asset");
         * asset.unload();
         * // asset.resource is null
         */
        unload: function () {
            if (!this.loaded && this._resources.length === 0)
                return;

            this.fire('unload', this);
            this.registry.fire('unload:' + this.id, this);

            for (var i = 0; i < this._resources.length; ++i) {
                var resource = this._resources[i];
                if (resource && resource.destroy) {
                    resource.destroy();
                }
            }

            this.resources = [];
            this.loaded = false;

            if (this.file) {
                // remove resource from loader cache
                this.registry._loader.clearCache(this.getFileUrl(), this.type);
            }
        }
    });

    Object.defineProperty(Asset.prototype, 'id', {
        get: function () {
            return this._id;
        },

        set: function (value) {
            this._id = value;
        }
    });

    Object.defineProperty(Asset.prototype, 'file', {
        get: function () {
            return this._file;
        },

        set: function (value) {
            // fire change event when the file changes
            // so that we reload it if necessary
            // set/unset file property of file hash been changed
            var key;
            var valueAsBool = !!value;
            var fileAsBool = !!this._file;
            if (valueAsBool !== fileAsBool || (value && this._file && value.hash !== this._file)) {
                if (value) {
                    if (!this._file)
                        this._file = { };

                    this._file.url = value.url;
                    this._file.filename = value.filename;
                    this._file.hash = value.hash;
                    this._file.size = value.size;
                    this._file.variants = this.variants;

                    if (value.hasOwnProperty('variants')) {
                        this.variants.clear();

                        if (value.variants) {
                            for (key in value.variants) {
                                if (!value.variants[key])
                                    continue;

                                this.variants[key] = value.variants[key];
                            }
                        }
                    }

                    this.fire('change', this, 'file', this._file, this._file);
                    this.reload();
                } else {
                    this._file = null;
                    this.variants.clear();
                }
            } else if (value && this._file && value.hasOwnProperty('variants')) {
                this.variants.clear();

                if (value.variants) {
                    for (key in value.variants) {
                        if (!value.variants[key])
                            continue;

                        this.variants[key] = value.variants[key];
                    }
                }
            }
        }
    });

    Object.defineProperty(Asset.prototype, 'data', {
        get: function () {
            return this._data;
        },

        set: function (value) {
            // fire change event when data changes
            // because the asset might need reloading if that happens
            var old = this._data;
            this._data = value;
            if (value !== old) {
                this.fire('change', this, 'data', value, old);

                if (this.loaded)
                    this.registry._loader.patch(this, this.registry);
            }
        }
    });

    Object.defineProperty(Asset.prototype, 'resource', {
        get: function () {
            return this._resources[0];
        },

        set: function (value) {
            var _old = this._resources[0];
            this._resources[0] = value;
            this.fire('change', this, 'resource', value, _old);
        }
    });

    Object.defineProperty(Asset.prototype, 'resources', {
        get: function () {
            return this._resources;
        },

        set: function (value) {
            var _old = this._resources;
            this._resources = value;
            this.fire('change', this, 'resources', value, _old);
        }
    });

    Object.defineProperty(Asset.prototype, 'preload', {
        get: function () {
            return this._preload;
        },
        set: function (value) {
            value = !!value;
            if (this._preload === value)
                return;

            this._preload = value;
            if (this._preload && !this.loaded && !this.loading && this.registry)
                this.registry.load(this);
        }
    });

    var isDataURI = function (uri) {
        return /^data:.*,.*$/i.test(uri);
    };

    var getDataURIMimeType = function (uri) {
        return uri.substring(uri.indexOf(":") + 1, uri.indexOf(";"));
    };

    var getNumComponents = function (accessorType) {
        switch (accessorType) {
            case 'SCALAR': return 1;
            case 'VEC2': return 2;
            case 'VEC3': return 3;
            case 'VEC4': return 4;
            case 'MAT2': return 4;
            case 'MAT3': return 9;
            case 'MAT4': return 16;
            default: return 3;
        }
    };

    var getComponentType = function (componentType) {
        switch (componentType) {
            case 5120: return TYPE_INT8;
            case 5121: return TYPE_UINT8;
            case 5122: return TYPE_INT16;
            case 5123: return TYPE_UINT16;
            case 5124: return TYPE_INT32;
            case 5125: return TYPE_UINT32;
            case 5126: return TYPE_FLOAT32;
            default: return 0;
        }
    };

    var getComponentSizeInBytes = function (componentType) {
        switch (componentType) {
            case 5120: return 1;    // int8
            case 5121: return 1;    // uint8
            case 5122: return 2;    // int16
            case 5123: return 2;    // uint16
            case 5124: return 4;    // int32
            case 5125: return 4;    // uint32
            case 5126: return 4;    // float32
            default: return 0;
        }
    };

    var getAccessorDataType = function (accessor) {
        switch (accessor.componentType) {
            case 5120: return Int8Array;
            case 5121: return Uint8Array;
            case 5122: return Int16Array;
            case 5123: return Uint16Array;
            case 5124: return Int32Array;
            case 5125: return Uint32Array;
            case 5126: return Float32Array;
            default: return null;
        }
    };

    var getAccessorData = function (accessor, bufferViews, buffers) {
        var bufferViewIdx;
        var count;
        if (accessor.hasOwnProperty("sparse")) {
            bufferViewIdx = accessor.sparse.values.bufferView;
            count = accessor.sparse.count;
        } else {
            bufferViewIdx = accessor.bufferView;
            count = accessor.count;
        }

        var bufferView = bufferViews[bufferViewIdx];
        var typedArray = buffers[bufferView.buffer];
        var accessorByteOffset = accessor.hasOwnProperty('byteOffset') ? accessor.byteOffset : 0;
        var bufferViewByteOffset = bufferView.hasOwnProperty('byteOffset') ? bufferView.byteOffset : 0;
        var byteOffset = typedArray.byteOffset + accessorByteOffset + bufferViewByteOffset;
        var length = count * getNumComponents(accessor.type);

        var dataType = getAccessorDataType(accessor);
        return dataType ? new dataType(typedArray.buffer, byteOffset, length) : null;
    };

    var getSparseAccessorIndices = function (accessor, bufferViews, buffers) {
        var bufferView = bufferViews[accessor.sparse.indices.bufferView];
        var typedArray = buffers[bufferView.buffer];
        var bufferViewByteOffset = bufferView.hasOwnProperty('byteOffset') ? bufferView.byteOffset : 0;
        var byteOffset = typedArray.byteOffset + bufferViewByteOffset;
        var length = accessor.sparse.count;

        switch (accessor.sparse.indices.componentType) {
            case 5120: return new Int8Array(typedArray.buffer, byteOffset, length);
            case 5121: return new Uint8Array(typedArray.buffer, byteOffset, length);
            case 5122: return new Int16Array(typedArray.buffer, byteOffset, length);
            case 5123: return new Uint16Array(typedArray.buffer, byteOffset, length);
            case 5124: return new Int32Array(typedArray.buffer, byteOffset, length);
            case 5125: return new Uint32Array(typedArray.buffer, byteOffset, length);
            case 5126: return new Float32Array(typedArray.buffer, byteOffset, length);
            default: return null;
        }
    };

    var getPrimitiveType = function (primitive) {
        if (!primitive.hasOwnProperty('mode')) {
            return PRIMITIVE_TRIANGLES;
        }

        switch (primitive.mode) {
            case 0: return PRIMITIVE_POINTS;
            case 1: return PRIMITIVE_LINES;
            case 2: return PRIMITIVE_LINELOOP;
            case 3: return PRIMITIVE_LINESTRIP;
            case 4: return PRIMITIVE_TRIANGLES;
            case 5: return PRIMITIVE_TRISTRIP;
            case 6: return PRIMITIVE_TRIFAN;
            default: return PRIMITIVE_TRIANGLES;
        }
    };

    var generateIndices = function (numVertices) {
        var dummyIndices = new Uint16Array(numVertices);
        for (var i = 0; i < numVertices; i++) {
            dummyIndices[i] = i;
        }
        return dummyIndices;
    };

    var generateNormals = function (sourceDesc, vertexDesc, positions, numVertices, indices) {

        if (!indices) {
            indices = generateIndices(numVertices);
        }

        // generate normals
        var normalsTemp = calculateNormals(positions, indices);
        var normals = new Float32Array(normalsTemp.length);
        normals.set(normalsTemp);

        vertexDesc.push({
            semantic: SEMANTIC_NORMAL,
            components: 3,
            type: TYPE_FLOAT32
        });

        sourceDesc[SEMANTIC_NORMAL] = {
            buffer: normals.buffer,
            size: 12,
            offset: 0,
            stride: 12,
            count: numVertices
        };
    };

    var createVertexBufferInternal = function (device, numVertices, vertexDesc, positionDesc, sourceDesc) {

        // order vertexDesc to match the rest of the engine
        var elementOrder = [
            SEMANTIC_POSITION,
            SEMANTIC_NORMAL,
            SEMANTIC_TANGENT,
            SEMANTIC_COLOR,
            SEMANTIC_BLENDINDICES,
            SEMANTIC_BLENDWEIGHT,
            SEMANTIC_TEXCOORD0,
            SEMANTIC_TEXCOORD1
        ];

        // sort vertex elements by engine-ideal order
        vertexDesc.sort(function (lhs, rhs) {
            var lhsOrder = elementOrder.indexOf(lhs.semantic);
            var rhsOrder = elementOrder.indexOf(rhs.semantic);
            return (lhsOrder < rhsOrder) ? -1 : (rhsOrder < lhsOrder ? 1 : 0);
        });

        // create vertex buffer
        var vertexBuffer = new VertexBuffer(device,
                                            new VertexFormat(device, vertexDesc),
                                            numVertices,
                                            BUFFER_STATIC);

        var i, j, k;
        var source, target, sourceOffset;

        // check whether source data is correctly interleaved
        var isCorrectlyInterleaved = true;
        for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
            target = vertexBuffer.format.elements[i];
            source = sourceDesc[target.name];
            sourceOffset = source.offset - positionDesc.offset;
            if ((source.buffer !== positionDesc.buffer) ||
                (source.stride !== target.stride) ||
                (source.size !== target.size) ||
                (sourceOffset !== target.offset)) {
                isCorrectlyInterleaved = false;
                break;
            }
        }

        var vertexData = vertexBuffer.lock();
        var targetArray = new Uint32Array(vertexData);
        var sourceArray;

        if (isCorrectlyInterleaved) {
            // copy data
            sourceArray = new Uint32Array(positionDesc.buffer,
                                          positionDesc.offset,
                                          numVertices * vertexBuffer.format.size / 4);
            targetArray.set(sourceArray);
        } else {
            var targetStride, sourceStride;
            // copy data and interleave
            for (i = 0; i < vertexBuffer.format.elements.length; ++i) {
                target = vertexBuffer.format.elements[i];
                targetStride = target.stride / 4;

                source = sourceDesc[target.name];
                sourceArray = new Uint32Array(source.buffer, source.offset, source.count * source.stride / 4);
                sourceStride = source.stride / 4;

                var src = 0;
                var dst = target.offset / 4;
                for (j = 0; j < numVertices; ++j) {
                    for (k = 0; k < source.size / 4; ++k) {
                        targetArray[dst + k] = sourceArray[src + k];
                    }
                    src += sourceStride;
                    dst += targetStride;
                }
            }
        }
        vertexBuffer.unlock();

        return vertexBuffer;
    };

    var createVertexBuffer = function (device, attributes, indices, accessors, bufferViews, buffers, semanticMap) {

        // build vertex buffer format desc and source
        var vertexDesc = [];
        var sourceDesc = {};
        for (var attrib in attributes) {
            if (attributes.hasOwnProperty(attrib)) {
                var accessor = accessors[attributes[attrib]];
                var bufferView = bufferViews[accessor.bufferView];

                if (semanticMap.hasOwnProperty(attrib)) {
                    var semantic = semanticMap[attrib].semantic;
                    vertexDesc.push({
                        semantic: semantic,
                        components: getNumComponents(accessor.type),
                        type: getComponentType(accessor.componentType),
                        normalize: accessor.normalized
                    });
                    // store the info we'll need to copy this data into the vertex buffer
                    var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
                    var buffer = buffers[bufferView.buffer];
                    sourceDesc[semantic] = {
                        buffer: buffer.buffer,
                        size: size,
                        offset: (accessor.hasOwnProperty('byteOffset') ? accessor.byteOffset : 0) +
                                (bufferView.hasOwnProperty('byteOffset') ? bufferView.byteOffset : 0) +
                                (buffer.byteOffset),
                        stride: bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size,
                        count: accessor.count
                    };
                }
            }
        }

        // get position attribute
        var positionDesc = sourceDesc[SEMANTIC_POSITION];
        var numVertices = positionDesc.count;

        // generate normals if they're missing (this should probably be a user option)
        if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
            var positions = getAccessorData(accessors[attributes.POSITION], bufferViews, buffers);
            generateNormals(sourceDesc, vertexDesc, positions, numVertices, indices);
        }

        return createVertexBufferInternal(device, numVertices, vertexDesc, positionDesc, sourceDesc);
    };

    var createVertexBufferDraco = function (device, outputGeometry, extDraco, decoder, decoderModule, semanticMap, indices) {

        var numPoints = outputGeometry.num_points();

        // helper function to decode data stream with id to TypedArray of appropriate type
        var extractDracoAttributeInfo = function (uniqueId) {
            var attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);
            var numValues = numPoints * attribute.num_components();
            var dracoFormat = attribute.data_type();
            var ptr, values, componentSizeInBytes, storageType;

            // storage format is based on draco attribute data type
            switch (dracoFormat) {

                case decoderModule.DT_UINT8:
                    storageType = TYPE_UINT8;
                    componentSizeInBytes = 1;
                    ptr = decoderModule._malloc(numValues * componentSizeInBytes);
                    decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);
                    values = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();
                    break;

                case decoderModule.DT_UINT16:
                    storageType = TYPE_UINT16;
                    componentSizeInBytes = 2;
                    ptr = decoderModule._malloc(numValues * componentSizeInBytes);
                    decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);
                    values = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();
                    break;

                case decoderModule.DT_FLOAT32:
                default:
                    storageType = TYPE_FLOAT32;
                    componentSizeInBytes = 4;
                    ptr = decoderModule._malloc(numValues * componentSizeInBytes);
                    decoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);
                    values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
                    break;
            }

            decoderModule._free(ptr);

            return {
                values: values,
                numComponents: attribute.num_components(),
                componentSizeInBytes: componentSizeInBytes,
                storageType: storageType,
                normalized: attribute.normalized()
            };
        };

        // build vertex buffer format desc and source
        var vertexDesc = [];
        var sourceDesc = {};
        var attributes = extDraco.attributes;
        for (var attrib in attributes) {
            if (attributes.hasOwnProperty(attrib) && semanticMap.hasOwnProperty(attrib)) {
                var semanticInfo = semanticMap[attrib];
                var semantic = semanticInfo.semantic;
                var attributeInfo = extractDracoAttributeInfo(attributes[attrib]);

                vertexDesc.push({
                    semantic: semantic,
                    components: attributeInfo.numComponents,
                    type: attributeInfo.storageType,
                    normalize: attributeInfo.normalized
                });

                // store the info we'll need to copy this data into the vertex buffer
                var size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;
                sourceDesc[semantic] = {
                    values: attributeInfo.values,
                    buffer: attributeInfo.values.buffer,
                    size: size,
                    offset: 0,
                    stride: size,
                    count: numPoints
                };
            }
        }

        // get position attribute
        var positionDesc = sourceDesc[SEMANTIC_POSITION];
        var numVertices = positionDesc.count;

        // generate normals if they're missing (this should probably be a user option)
        if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
            generateNormals(sourceDesc, vertexDesc, positionDesc.values, numVertices, indices);
        }

        return createVertexBufferInternal(device, numVertices, vertexDesc, positionDesc, sourceDesc);
    };

    var createSkin = function (device, skinData, accessors, bufferViews, nodes, buffers) {
        var i, j, bindMatrix;
        var joints = skinData.joints;
        var numJoints = joints.length;
        var ibp = [];
        if (skinData.hasOwnProperty('inverseBindMatrices')) {
            var inverseBindMatrices = skinData.inverseBindMatrices;
            var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, buffers);
            var ibmValues = [];

            for (i = 0; i < numJoints; i++) {
                for (j = 0; j < 16; j++) {
                    ibmValues[j] = ibmData[i * 16 + j];
                }
                bindMatrix = new Mat4();
                bindMatrix.set(ibmValues);
                ibp.push(bindMatrix);
            }
        } else {
            for (i = 0; i < numJoints; i++) {
                bindMatrix = new Mat4();
                ibp.push(bindMatrix);
            }
        }

        var boneNames = [];
        for (i = 0; i < numJoints; i++) {
            boneNames[i] = nodes[joints[i]].name;
        }

        var skeleton = skinData.skeleton;

        var skin = new Skin(device, ibp, boneNames);
        skin.skeleton = nodes[skeleton];

        skin.bones = [];
        for (i = 0; i < joints.length; i++) {
            skin.bones[i] = nodes[joints[i]];
        }

        return skin;
    };

    var tempMat = new Mat4();
    var tempVec$1 = new Vec3();

    var createMesh$1 = function (device, meshData, accessors, bufferViews, buffers, callback) {
        var meshes = [];

        var semanticMap = {
            'POSITION': { semantic: SEMANTIC_POSITION },
            'NORMAL': { semantic: SEMANTIC_NORMAL },
            'TANGENT': { semantic: SEMANTIC_TANGENT },
            'COLOR_0': { semantic: SEMANTIC_COLOR },
            'JOINTS_0': { semantic: SEMANTIC_BLENDINDICES },
            'WEIGHTS_0': { semantic: SEMANTIC_BLENDWEIGHT },
            'TEXCOORD_0': { semantic: SEMANTIC_TEXCOORD0 },
            'TEXCOORD_1': { semantic: SEMANTIC_TEXCOORD1 }
        };

        meshData.primitives.forEach(function (primitive) {

            var primitiveType, vertexBuffer, numIndices;
            var indices = null;
            var mesh = new Mesh(device);
            var canUseMorph = true;

            // try and get draco compressed data first
            if (primitive.hasOwnProperty('extensions')) {
                var extensions = primitive.extensions;
                if (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {

                    // access DracoDecoderModule
                    var decoderModule = window.DracoDecoderModule;
                    if (decoderModule) {
                        var extDraco = extensions.KHR_draco_mesh_compression;
                        if (extDraco.hasOwnProperty('attributes')) {
                            var bufferView = bufferViews[extDraco.bufferView];
                            var arrayBuffer = buffers[bufferView.buffer];
                            var uint8Buffer = new Uint8Array(arrayBuffer.buffer, arrayBuffer.byteOffset + bufferView.byteOffset, bufferView.byteLength);
                            var buffer = new decoderModule.DecoderBuffer();
                            buffer.Init(uint8Buffer, uint8Buffer.length);

                            var decoder = new decoderModule.Decoder();
                            var geometryType = decoder.GetEncodedGeometryType(buffer);

                            var outputGeometry, status;
                            switch (geometryType) {
                                case decoderModule.POINT_CLOUD:
                                    primitiveType = PRIMITIVE_POINTS;
                                    outputGeometry = new decoderModule.PointCloud();
                                    status = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);
                                    break;
                                case decoderModule.TRIANGULAR_MESH:
                                    primitiveType = PRIMITIVE_TRIANGLES;
                                    outputGeometry = new decoderModule.Mesh();
                                    status = decoder.DecodeBufferToMesh(buffer, outputGeometry);
                                    break;
                                case decoderModule.INVALID_GEOMETRY_TYPE:
                            }

                            if (!status || !status.ok() || outputGeometry.ptr == 0) {
                                callback("Failed to decode draco compressed asset: " +
                                (status ? status.error_msg() : ('Mesh asset - invalid draco compressed geometry type: ' + geometryType) ));
                                return;
                            }

                            // indices
                            var numFaces = outputGeometry.num_faces();
                            if (geometryType == decoderModule.TRIANGULAR_MESH) {
                                var bit32 = outputGeometry.num_points() > 65535;
                                numIndices = numFaces * 3;
                                var dataSize = numIndices * (bit32 ? 4 : 2);
                                var ptr = decoderModule._malloc(dataSize);

                                if (bit32) {
                                    decoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);
                                    indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
                                } else {
                                    decoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);
                                    indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
                                }

                                decoderModule._free( ptr );
                            }

                            // vertices
                            vertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, semanticMap, indices);

                            // clean up
                            decoderModule.destroy(outputGeometry);
                            decoderModule.destroy(decoder);
                            decoderModule.destroy(buffer);

                            // morph streams are not compatible with draco compression, disable morphing
                            canUseMorph = false;
                        }
                    }
                }
            }

            // if mesh was not constructed from draco data, use uncompressed
            if (!vertexBuffer) {
                indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, buffers) : null;
                vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, buffers, semanticMap);
                primitiveType = getPrimitiveType(primitive);
            }

            // build the mesh
            mesh.vertexBuffer = vertexBuffer;
            mesh.primitive[0].type = primitiveType;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].indexed = (indices !== null);

            // index buffer
            if (indices !== null) {
                var indexFormat;
                if (indices instanceof Uint8Array) {
                    indexFormat = INDEXFORMAT_UINT8;
                } else if (indices instanceof Uint16Array) {
                    indexFormat = INDEXFORMAT_UINT16;
                } else {
                    // TODO: these indices may need conversion since some old WebGL 1.0 devices
                    // don't support 32bit index data
                    indexFormat = INDEXFORMAT_UINT32;
                }
                var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
                mesh.indexBuffer[0] = indexBuffer;
                mesh.primitive[0].count = indices.length;
            } else {
                mesh.primitive[0].count = vertexBuffer.numVertices;
            }

            mesh.materialIndex = primitive.material;

            var accessor = accessors[primitive.attributes.POSITION];
            var min = accessor.min;
            var max = accessor.max;
            var aabb = new BoundingBox(
                new Vec3((max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2),
                new Vec3((max[0] - min[0]) / 2, (max[1] - min[1]) / 2, (max[2] - min[2]) / 2)
            );
            mesh.aabb = aabb;

            // convert sparse morph target vertex data to full format
            var sparseToFull = function (data, indices, dataType, totalCount) {
                var full = new dataType(totalCount * 3);
                for (var s = 0; s < indices.length; s++) {
                    var dstIndex = indices[s] * 3;
                    full[dstIndex] = data[s * 3];
                    full[dstIndex + 1] = data[s * 3 + 1];
                    full[dstIndex + 2] = data[s * 3 + 2];
                }
                return full;
            };

            // morph targets
            if (canUseMorph && primitive.hasOwnProperty('targets')) {
                var targets = [];
                var dataType;

                primitive.targets.forEach(function (target, index) {
                    var options = {};

                    if (target.hasOwnProperty('POSITION')) {

                        accessor = accessors[target.POSITION];
                        dataType = getAccessorDataType(accessor);

                        options.deltaPositions = getAccessorData(accessor, bufferViews, buffers);
                        options.deltaPositionsType = typedArrayToType[dataType.name];

                        if (accessor.sparse) {
                            options.deltaPositions = sparseToFull(options.deltaPositions, getSparseAccessorIndices(accessor, bufferViews, buffers),
                                                                  dataType, mesh.vertexBuffer.numVertices);

                        }

                        if (accessor.hasOwnProperty('min') && accessor.hasOwnProperty('max')) {
                            options.aabb = new BoundingBox();
                            options.aabb.setMinMax(new Vec3(accessor.min), new Vec3(accessor.max));
                        }
                    }

                    if (target.hasOwnProperty('NORMAL')) {

                        accessor = accessors[target.NORMAL];
                        dataType = getAccessorDataType(accessor);

                        options.deltaNormals = getAccessorData(accessor, bufferViews, buffers);
                        options.deltaNormalsType = typedArrayToType[dataType.name];

                        if (accessor.sparse) {
                            options.deltaNormals = sparseToFull(options.deltaNormals, getSparseAccessorIndices(accessor, bufferViews, buffers),
                                                                dataType, mesh.vertexBuffer.numVertices);
                        }
                    }

                    if (meshData.hasOwnProperty('extras') &&
                        meshData.extras.hasOwnProperty('targetNames')) {
                        options.name = meshData.extras.targetNames[index];
                    } else {
                        options.name = targets.length.toString(10);
                    }

                    targets.push(new MorphTarget(device, options));
                });

                mesh.morph = new Morph(targets);

                // set default morph target weights if they're specified
                if (meshData.hasOwnProperty('weights')) {
                    for (var i = 0; i < meshData.weights.length; ++i) {
                        targets[i].defaultWeight = meshData.weights[i];
                    }
                }
            }

            meshes.push(mesh);
        });

        return meshes;
    };

    var createMaterial = function (materialData, textures) {
        // TODO: integrate these shader chunks into the native engine
        var glossChunk = [
            "#ifdef MAPFLOAT",
            "uniform float material_shininess;",
            "#endif",
            "",
            "#ifdef MAPTEXTURE",
            "uniform sampler2D texture_glossMap;",
            "#endif",
            "",
            "void getGlossiness() {",
            "    dGlossiness = 1.0;",
            "",
            "#ifdef MAPFLOAT",
            "    dGlossiness *= material_shininess;",
            "#endif",
            "",
            "#ifdef MAPTEXTURE",
            "    dGlossiness *= texture2D(texture_glossMap, $UV).$CH;",
            "#endif",
            "",
            "#ifdef MAPVERTEX",
            "    dGlossiness *= saturate(vVertexColor.$VC);",
            "#endif",
            "",
            "    dGlossiness = 1.0 - dGlossiness;",
            "",
            "    dGlossiness += 0.0000001;",
            "}"
        ].join('\n');

        var specularChunk = [
            "#ifdef MAPCOLOR",
            "uniform vec3 material_specular;",
            "#endif",
            "",
            "#ifdef MAPTEXTURE",
            "uniform sampler2D texture_specularMap;",
            "#endif",
            "",
            "void getSpecularity() {",
            "    dSpecularity = vec3(1.0);",
            "",
            "    #ifdef MAPCOLOR",
            "        dSpecularity *= material_specular;",
            "    #endif",
            "",
            "    #ifdef MAPTEXTURE",
            "        vec3 srgb = texture2D(texture_specularMap, $UV).$CH;",
            "        dSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));",
            "    #endif",
            "",
            "    #ifdef MAPVERTEX",
            "        dSpecularity *= saturate(vVertexColor.$VC);",
            "    #endif",
            "}"
        ].join('\n');

        var extractTextureTransform = function (source, material, maps) {
            var map;

            var texCoord = source.texCoord;
            if (texCoord) {
                for (map = 0; map < maps.length; ++map) {
                    material[maps[map] + 'MapUv'] = texCoord;
                }
            }

            var extensions = source.extensions;
            if (extensions) {
                var textureTransformData = extensions.KHR_texture_transform;
                if (textureTransformData) {
                    var scale = textureTransformData.scale;
                    if (scale) {
                        for (map = 0; map < maps.length; ++map) {
                            material[maps[map] + 'MapTiling'] = new Vec2(scale[0], scale[1]);
                        }
                    }

                    var offset = textureTransformData.offset;
                    if (offset) {
                        for (map = 0; map < maps.length; ++map) {
                            material[maps[map] + 'MapOffset'] = new Vec2(offset[0], offset[1]);
                        }
                    }
                }
            }
        };

        var material = new StandardMaterial();

        // glTF dooesn't define how to occlude specular
        material.occludeSpecular = true;

        material.diffuseTint = true;
        material.diffuseVertexColor = true;

        material.specularTint = true;
        material.specularVertexColor = true;

        if (materialData.hasOwnProperty('name')) {
            material.name = materialData.name;
        }

        var color, texture;
        if (materialData.hasOwnProperty('extensions') &&
            materialData.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {
            var specData = materialData.extensions.KHR_materials_pbrSpecularGlossiness;

            if (specData.hasOwnProperty('diffuseFactor')) {
                color = specData.diffuseFactor;
                // Convert from linear space to sRGB space
                material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
                material.opacity = (color[3] != null) ? color[3] : 1;
            } else {
                material.diffuse.set(1, 1, 1);
                material.opacity = 1;
            }
            if (specData.hasOwnProperty('diffuseTexture')) {
                var diffuseTexture = specData.diffuseTexture;
                texture = textures[diffuseTexture.index];

                material.diffuseMap = texture;
                material.diffuseMapChannel = 'rgb';
                material.opacityMap = texture;
                material.opacityMapChannel = 'a';

                extractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);
            }
            material.useMetalness = false;
            if (specData.hasOwnProperty('specularFactor')) {
                color = specData.specularFactor;
                // Convert from linear space to sRGB space
                material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            } else {
                material.specular.set(1, 1, 1);
            }
            if (specData.hasOwnProperty('glossinessFactor')) {
                material.shininess = 100 * specData.glossinessFactor;
            } else {
                material.shininess = 100;
            }
            if (specData.hasOwnProperty('specularGlossinessTexture')) {
                var specularGlossinessTexture = specData.specularGlossinessTexture;
                material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
                material.specularMapChannel = 'rgb';
                material.glossMapChannel = 'a';

                extractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);
            }

            material.chunks.specularPS = specularChunk;

        } else if (materialData.hasOwnProperty('pbrMetallicRoughness')) {
            var pbrData = materialData.pbrMetallicRoughness;

            if (pbrData.hasOwnProperty('baseColorFactor')) {
                color = pbrData.baseColorFactor;
                // Convert from linear space to sRGB space
                material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
                material.opacity = color[3];
            } else {
                material.diffuse.set(1, 1, 1);
                material.opacity = 1;
            }
            if (pbrData.hasOwnProperty('baseColorTexture')) {
                var baseColorTexture = pbrData.baseColorTexture;
                texture = textures[baseColorTexture.index];

                material.diffuseMap = texture;
                material.diffuseMapChannel = 'rgb';
                material.opacityMap = texture;
                material.opacityMapChannel = 'a';

                extractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);
            }
            material.useMetalness = true;
            if (pbrData.hasOwnProperty('metallicFactor')) {
                material.metalness = pbrData.metallicFactor;
            } else {
                material.metalness = 1;
            }
            if (pbrData.hasOwnProperty('roughnessFactor')) {
                material.shininess = 100 * pbrData.roughnessFactor;
            } else {
                material.shininess = 100;
            }
            if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
                var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
                material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
                material.metalnessMapChannel = 'b';
                material.glossMapChannel = 'g';

                extractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);
            }

            material.chunks.glossPS = glossChunk;
        }

        if (materialData.hasOwnProperty('normalTexture')) {
            var normalTexture = materialData.normalTexture;
            material.normalMap = textures[normalTexture.index];

            extractTextureTransform(normalTexture, material, ['normal']);

            if (normalTexture.hasOwnProperty('scale')) {
                material.bumpiness = normalTexture.scale;
            }
        }
        if (materialData.hasOwnProperty('occlusionTexture')) {
            var occlusionTexture = materialData.occlusionTexture;
            material.aoMap = textures[occlusionTexture.index];
            material.aoMapChannel = 'r';

            extractTextureTransform(occlusionTexture, material, ['ao']);
            // TODO: support 'strength'
        }
        if (materialData.hasOwnProperty('emissiveFactor')) {
            color = materialData.emissiveFactor;
            // Convert from linear space to sRGB space
            material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            material.emissiveTint = true;
        } else {
            material.emissive.set(0, 0, 0);
            material.emissiveTint = false;
        }
        if (materialData.hasOwnProperty('emissiveTexture')) {
            var emissiveTexture = materialData.emissiveTexture;
            material.emissiveMap = textures[emissiveTexture.index];

            extractTextureTransform(emissiveTexture, material, ['emissive']);
        }
        if (materialData.hasOwnProperty('alphaMode')) {
            switch (materialData.alphaMode) {
                case 'MASK':
                    material.blendType = BLEND_NONE;
                    if (materialData.hasOwnProperty('alphaCutoff')) {
                        material.alphaTest = materialData.alphaCutoff;
                    } else {
                        material.alphaTest = 0.5;
                    }
                    break;
                case 'BLEND':
                    material.blendType = BLEND_NORMAL;
                    break;
                default:
                case 'OPAQUE':
                    material.blendType = BLEND_NONE;
                    break;
            }
        } else {
            material.blendType = BLEND_NONE;
        }
        if (materialData.hasOwnProperty('doubleSided')) {
            material.twoSidedLighting = materialData.doubleSided;
            material.cull = materialData.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
        } else {
            material.twoSidedLighting = false;
            material.cull = CULLFACE_BACK;
        }

        // handle unlit material by disabling lighting and copying diffuse colours
        // into emissive.
        if (materialData.hasOwnProperty('extensions') &&
            materialData.extensions.hasOwnProperty('KHR_materials_unlit')) {
            material.useLighting = false;

            // copy diffuse into emissive
            material.emissive.copy(material.diffuse);
            material.emissiveTint = material.diffuseTint;
            material.emissiveMap = material.diffuseMap;
            material.emissiveMapUv = material.diffuseMapUv;
            material.emissiveMapTiling.copy(material.diffuseMapTiling);
            material.emissiveMapOffset.copy(material.diffuseMapOffset);
            material.emissiveMapChannel = material.diffuseMapChannel;
            material.emissiveVertexColor = material.diffuseVertexColor;
            material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;

            // blank diffuse
            material.diffuse.set(0, 0, 0);
            material.diffuseTint = false;
            material.diffuseMap = null;
            material.diffuseVertexColor = false;
        }

        material.update();

        return material;
    };

    // create the anim structure
    var createAnimation = function (animationData, animationIndex, accessors, bufferViews, nodes, buffers) {

        // create animation data block for the accessor
        var createAnimData = function (accessor) {
            var data = getAccessorData(accessor, bufferViews, buffers);
            // TODO: this assumes data is tightly packed, handle the case data is interleaved
            return new AnimData(getNumComponents(accessor.type), new data.constructor(data));
        };

        var interpMap = {
            "STEP": pc.INTERPOLATION_STEP,
            "LINEAR": pc.INTERPOLATION_LINEAR,
            "CUBICSPLINE": pc.INTERPOLATION_CUBIC
        };

        var inputMap = { };
        var inputs = [];

        var outputMap = { };
        var outputs = [];

        var curves = [];

        var i;

        // convert samplers
        for (i = 0; i < animationData.samplers.length; ++i) {
            var sampler = animationData.samplers[i];

            // get input data
            if (!inputMap.hasOwnProperty(sampler.input)) {
                inputMap[sampler.input] = inputs.length;
                inputs.push(createAnimData(accessors[sampler.input]));
            }

            // get output data
            if (!outputMap.hasOwnProperty(sampler.output)) {
                outputMap[sampler.output] = outputs.length;
                outputs.push(createAnimData(accessors[sampler.output]));
            }

            var interpolation =
                sampler.hasOwnProperty('interpolation') &&
                interpMap.hasOwnProperty(sampler.interpolation) ?
                    interpMap[sampler.interpolation] : pc.INTERPOLATION_LINEAR;

            // create curve
            curves.push(new AnimCurve(
                [],
                inputMap[sampler.input],
                outputMap[sampler.output],
                interpolation));
        }

        var quatArrays = [];

        var propertyLocator = new pc.AnimPropertyLocator();
        var transformSchema = {
            'translation': 'localPosition',
            'rotation': 'localRotation',
            'scale': 'localScale',
            'weights': 'weights'
        };

        // convert anim channels
        for (i = 0; i < animationData.channels.length; ++i) {
            var channel = animationData.channels[i];
            var target = channel.target;
            var curve = curves[channel.sampler];
            curve._paths.push(propertyLocator.encode([[nodes[target.node].name], 'graph', [transformSchema[target.path]]]));

            // if this target is a set of quaternion keys, make note of its index so we can perform
            // quaternion-specific processing on it.
            if (target.path.startsWith('rotation') && curve.interpolation !== pc.INTERPOLATION_CUBIC) {
                quatArrays.push(curve.output);
            } else if (target.path.startsWith('weights')) {
                // it's a bit strange, but morph target animations implicitly assume there are n output
                // values when there are n morph targets. here we set the number of components explicitly
                // on the output curve data.
                outputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;
            }
        }

        // sort the list of array indexes so we can skip dups
        quatArrays.sort();

        // run through the quaternion data arrays flipping quaternion keys
        // that don't fall in the same winding order.
        var prevIndex = null;
        for (i = 0; i < quatArrays.length; ++i) {
            var index = quatArrays[i];
            // skip over duplicate array indices
            if (i === 0 || index !== prevIndex) {
                var data = outputs[index];
                if (data.components === 4) {
                    var d = data.data;
                    var len = d.length - 4;
                    for (var j = 0; j < len; j += 4) {
                        var dp = d[j + 0] * d[j + 4] +
                                 d[j + 1] * d[j + 5] +
                                 d[j + 2] * d[j + 6] +
                                 d[j + 3] * d[j + 7];

                        if (dp < 0) {
                            d[j + 4] *= -1;
                            d[j + 5] *= -1;
                            d[j + 6] *= -1;
                            d[j + 7] *= -1;
                        }
                    }
                }
                prevIndex = index;
            }
        }

        // calculate duration of the animation as maximum time value
        var duration = inputs.reduce(function (value, input) {
            var data  = input._data;
            return Math.max(value, data.length === 0 ? 0 : data[data.length - 1]);
        }, 0);

        return new AnimTrack(
            animationData.hasOwnProperty('name') ? animationData.name : ("animation_" + animationIndex),
            duration,
            inputs,
            outputs,
            curves);
    };

    var createNode = function (nodeData, nodeIndex) {
        var entity = new GraphNode();

        if (nodeData.hasOwnProperty('name')) {
            entity.name = nodeData.name;
        } else {
            entity.name = "node_" + nodeIndex;
        }

        // Parse transformation properties
        if (nodeData.hasOwnProperty('matrix')) {
            tempMat.data.set(nodeData.matrix);
            tempMat.getTranslation(tempVec$1);
            entity.setLocalPosition(tempVec$1);
            tempMat.getEulerAngles(tempVec$1);
            entity.setLocalEulerAngles(tempVec$1);
            tempMat.getScale(tempVec$1);
            entity.setLocalScale(tempVec$1);
        }

        if (nodeData.hasOwnProperty('rotation')) {
            var r = nodeData.rotation;
            entity.setLocalRotation(r[0], r[1], r[2], r[3]);
        }

        if (nodeData.hasOwnProperty('translation')) {
            var t = nodeData.translation;
            entity.setLocalPosition(t[0], t[1], t[2]);
        }

        if (nodeData.hasOwnProperty('scale')) {
            var s = nodeData.scale;
            entity.setLocalScale(s[0], s[1], s[2]);
        }

        return entity;
    };

    var createSkins = function (device, gltf, nodes, buffers) {
        if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
            return [];
        }
        return gltf.skins.map(function (skinData) {
            return createSkin(device, skinData, gltf.accessors, gltf.bufferViews, nodes, buffers);
        });

    };

    var createMeshes = function (device, gltf, buffers, callback) {
        if (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 ||
            !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 ||
            !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {
            return [];
        }
        return gltf.meshes.map(function (meshData) {
            return createMesh$1(device, meshData, gltf.accessors, gltf.bufferViews, buffers, callback);
        });

    };

    var createMaterials = function (gltf, textures) {
        if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
            return [];
        }
        return gltf.materials.map(function (materialData) {
            return createMaterial(materialData, textures);
        });

    };

    var createAnimations = function (gltf, nodes, buffers) {
        if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
            return [];
        }
        return gltf.animations.map(function (animationData, animationIndex) {
            return createAnimation(animationData, animationIndex, gltf.accessors, gltf.bufferViews, nodes, buffers);
        });

    };

    var createNodes = function (gltf) {
        if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
            return [];
        }
        var nodes = gltf.nodes.map(createNode);

        // build node hierarchy
        for (var i = 0; i < gltf.nodes.length; ++i) {
            var nodeData = gltf.nodes[i];
            if (nodeData.hasOwnProperty('children')) {
                for (var j = 0; j < nodeData.children.length; ++j) {
                    var parent = nodes[i];
                    var child = nodes[nodeData.children[j]];
                    if (!child.parent) {
                        parent.addChild(child);
                    }
                }
            }
        }

        return nodes;
    };

    // create engine resources from the downloaded GLB data
    var createResources = function (device, gltf, buffers, textures, callback) {
        var nodes = createNodes(gltf);
        var animations = createAnimations(gltf, nodes, buffers);
        var materials = createMaterials(gltf, gltf.textures ? gltf.textures.map(function (t) {
            return textures[t.source].resource;
        }) : []);
        var meshes = createMeshes(device, gltf, buffers, callback);
        var skins = createSkins(device, gltf, nodes, buffers);

        callback(null, {
            'gltf': gltf,
            'nodes': nodes,
            'animations': animations,
            'textures': textures,
            'materials': materials,
            'meshes': meshes,
            'skins': skins
        });
    };

    var applySampler = function (texture, samplerData) {
        var defaultSampler = {
            magFilter: 9729,
            minFilter: 9987,
            wrapS: 10497,
            wrapT: 10497
        };

        var getFilter = function (filter) {
            switch (filter) {
                case 9728: return FILTER_NEAREST;
                case 9729: return FILTER_LINEAR;
                case 9984: return FILTER_NEAREST_MIPMAP_NEAREST;
                case 9985: return FILTER_LINEAR_MIPMAP_NEAREST;
                case 9986: return FILTER_NEAREST_MIPMAP_LINEAR;
                case 9987: return FILTER_LINEAR_MIPMAP_LINEAR;
                default:   return FILTER_LINEAR;
            }
        };

        var getWrap = function (wrap) {
            switch (wrap) {
                case 33071: return ADDRESS_CLAMP_TO_EDGE;
                case 33648: return ADDRESS_MIRRORED_REPEAT;
                case 10497: return ADDRESS_REPEAT;
                default:    return ADDRESS_REPEAT;
            }
        };

        samplerData = samplerData || defaultSampler;
        texture.minFilter = getFilter(samplerData.minFilter);
        texture.magFilter = getFilter(samplerData.magFilter);
        texture.addressU = getWrap(samplerData.wrapS);
        texture.addressV = getWrap(samplerData.wrapT);
    };

    // load textures using the asset system
    var loadTexturesAsync = function (device, gltf, buffers, urlBase, registry, callback) {
        var result = [];

        if (!gltf.hasOwnProperty('images') || gltf.images.length === 0 ||
            !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {
            callback(null, result);
            return;
        }

        var remaining = gltf.images.length;
        var onLoad = function (idx, img) {
            result[idx] = img;
            if (--remaining === 0) {
                // apply samplers
                for (var t = 0; t < gltf.textures.length; ++t) {
                    var texture = gltf.textures[t];
                    applySampler(result[texture.source], (gltf.samplers || [])[texture.sampler]);
                }

                callback(null, result);
            }
        };

        for (var i = 0; i < gltf.images.length; ++i) {
            var imgData = gltf.images[i];

            var url;
            var mimeType;
            var options = {};
            if (imgData.hasOwnProperty('uri')) {
                // uri specified
                if (isDataURI(imgData.uri)) {
                    url = imgData.uri;
                    mimeType = getDataURIMimeType(imgData.uri);
                } else {
                    url = path.join(urlBase, imgData.uri);
                    options.crossOrigin = "anonymous";
                }
            } else if (imgData.hasOwnProperty('bufferView') && imgData.hasOwnProperty('mimeType')) {
                // bufferview
                var bufferView = gltf.bufferViews[imgData.bufferView];
                var byteOffset = bufferView.hasOwnProperty('byteOffset') ? bufferView.byteOffset : 0;
                var byteLength = bufferView.byteLength;

                var buffer = buffers[bufferView.buffer];
                var imageBuffer = new Uint8Array(buffer.buffer, buffer.byteOffset + byteOffset, byteLength);
                var blob = new Blob([imageBuffer], { type: imgData.mimeType });
                url = URL.createObjectURL(blob);
                mimeType = imgData.mimeType;
            } else {
                // fail
                callback("Invalid image found in gltf (neither uri or bufferView found). index=" + i);
                return;
            }

            var mimeTypeFileExtensions = {
                'image/png': 'png',
                'image/jpeg': 'jpg',
                'image/basis': 'basis',
                'image/ktx': 'ktx',
                'image/vnd-ms.dds': 'dds'
            };

            // construct the asset file
            var file = { url: url };
            if (mimeType) {
                var extension = mimeTypeFileExtensions[mimeType];
                if (extension) {
                    file.filename = 'glb-texture-' + i + '.' + extension;
                }
            }

            // create and load the asset
            var asset = new Asset('texture_' + i, 'texture',  file, { flipY: false }, options);
            asset.on('load', onLoad.bind(null, i));
            registry.add(asset);
            registry.load(asset);
        }
    };

    // load gltf buffers asynchronously, returning them in the callback
    var loadBuffersAsync = function (gltf, binaryChunk, urlBase, callback) {
        var result = [];

        if (gltf.buffers === null || gltf.buffers.length === 0) {
            callback(null, result);
            return;
        }

        var remaining = gltf.buffers.length;
        var onLoad = function (buffer, idx) {
            result[idx] = buffer;
            if (--remaining === 0) {
                callback(null, result);
            }
        };

        var createCallback = function (index) {
            return function (err, result) {
                if (err) {
                    callback(err);
                } else {
                    onLoad(new Uint8Array(result), index);
                }
            };
        };

        for (var i = 0; i < gltf.buffers.length; ++i) {
            var buffer = gltf.buffers[i];
            if (buffer.hasOwnProperty('uri')) {
                if (isDataURI(buffer.uri)) {
                    // convert base64 to raw binary data held in a string
                    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
                    var byteString = atob(buffer.uri.split(',')[1]);

                    // write the bytes of the string to an ArrayBuffer
                    var arrayBuffer = new ArrayBuffer(byteString.length);

                    // create a view into the buffer
                    var binaryArray = new Uint8Array(arrayBuffer);

                    // set the bytes of the buffer to the correct values
                    for (var j = 0; j < byteString.length; j++) {
                        binaryArray[j] = byteString.charCodeAt(j);
                    }

                    onLoad(binaryArray, i);
                } else {
                    http.get(
                        path.join(urlBase, buffer.uri),
                        { cache: true, responseType: 'arraybuffer', retry: false },
                        createCallback(i));
                }
            } else {
                // glb buffer reference
                onLoad(binaryChunk, i);
            }
        }
    };

    // parse the gltf chunk, returns the gltf json
    var parseGltf = function (gltfChunk, callback) {
        var decodeBinaryUtf8 = function (array) {
            if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(array);
            }
            var str = array.reduce( function (accum, value) {
                accum += String.fromCharCode(value);
                return accum;
            }, "");
            return decodeURIComponent(escape(str));

        };

        var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));

        // check gltf version
        if (gltf.asset && gltf.asset.version && Number.parseFloat(gltf.asset.version) < 2) {
            callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
            return;
        }

        callback(null, gltf);
    };

    // parse glb data, returns the gltf and binary chunk
    var parseGlb = function (glbData, callback) {
        var data = new DataView(glbData);

        // read header
        var magic = data.getUint32(0, true);
        var version = data.getUint32(4, true);
        var length = data.getUint32(8, true);

        if (magic !== 0x46546C67) {
            callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
            return;
        }

        if (version !== 2) {
            callback("Invalid version number found in glb header. Expected 2, found " + version);
            return;
        }

        if (length <= 0 || length > glbData.byteLength) {
            callback("Invalid length found in glb header. Found " + length);
            return;
        }

        // read chunks
        var chunks = [];
        var offset = 12;
        while (offset < length) {
            var chunkLength = data.getUint32(offset, true);
            if (offset + chunkLength + 8 > glbData.byteLength) {
                throw new Error("Invalid chunk length found in glb. Found " + chunkLength);
            }
            var chunkType = data.getUint32(offset + 4, true);
            var chunkData = new Uint8Array(glbData, offset + 8, chunkLength);
            chunks.push( { length: chunkLength, type: chunkType, data: chunkData } );
            offset += chunkLength + 8;
        }

        if (chunks.length !== 1 && chunks.length !== 2) {
            callback("Invalid number of chunks found in glb file.");
            return;
        }

        if (chunks[0].type !== 0x4E4F534A) {
            callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
            return;
        }

        if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
            callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
            return;
        }

        callback(null, {
            gltfChunk: chunks[0].data,
            binaryChunk: chunks.length === 2 ? chunks[1].data : null
        });
    };

    // parse the chunk of data, which can be glb or gltf
    var parseChunk = function (filename, data, callback) {
        if (filename && filename.toLowerCase().endsWith('.glb')) {
            parseGlb(data, callback);
        } else {
            callback(null, {
                gltfChunk: data,
                binaryChunk: null
            });
        }
    };

    // -- GlbParser
    function GlbParser() {}

    // parse the gltf or glb data asynchronously, loading external resources
    GlbParser.parseAsync = function (filename, urlBase, data, device, registry, callback) {
        // parse the data
        parseChunk(filename, data, function (err, chunks) {
            if (err) {
                callback(err);
                return;
            }

            // parse gltf
            parseGltf(chunks.gltfChunk, function (err, gltf) {
                if (err) {
                    callback(err);
                    return;
                }

                // async load external buffers
                loadBuffersAsync(gltf, chunks.binaryChunk, urlBase, function (err, buffers) {
                    if (err) {
                        callback(err);
                        return;
                    }

                    // async load images
                    loadTexturesAsync(device, gltf, buffers, urlBase, registry, function (err, textures) {
                        if (err) {
                            callback(err);
                            return;
                        }

                        createResources(device, gltf, buffers, textures, callback);
                    });
                });
            });
        });
    };

    // parse the gltf or glb data synchronously. external resources (buffers and images) are ignored.
    GlbParser.parse = function (filename, data, device) {
        var result = null;

        // parse the data
        parseChunk(filename, data, function (err, chunks) {
            if (err) {
                console.error(err);
            } else {
                // parse gltf
                parseGltf(chunks.gltfChunk, function (err, gltf) {
                    if (err) {
                        console.error(err);
                    } else {
                        var buffers = [chunks.binaryChunk];
                        var textures = [];

                        // create resources
                        createResources(device, gltf, buffers, textures, function (err, result_) {
                            if (err) {
                                console.error(err);
                            } else {
                                result = result_;
                            }
                        });
                    }
                });
            }
        });

        return result;
    };

    // create a pc.Model from the parsed GLB data structures
    GlbParser.createModel = function (glb, defaultMaterial) {
        var createMeshInstance = function (model, mesh, skins, materials, node, nodeData) {
            var material = (mesh.materialIndex === undefined) ? defaultMaterial : materials[mesh.materialIndex];

            var meshInstance = new MeshInstance(node, mesh, material);

            if (mesh.morph) {
                var morphInstance = new MorphInstance(mesh.morph);
                if (mesh.weights) {
                    for (var wi = 0; wi < mesh.weights.length; wi++) {
                        morphInstance.setWeight(wi, mesh.weights[wi]);
                    }
                }

                meshInstance.morphInstance = morphInstance;
                model.morphInstances.push(morphInstance);
            }

            if (nodeData.hasOwnProperty('skin')) {
                var skin = skins[nodeData.skin];
                mesh.skin = skin;

                var skinInstance = new SkinInstance(skin);
                skinInstance.bones = skin.bones;

                meshInstance.skinInstance = skinInstance;
                model.skinInstances.push(skinInstance);
            }

            model.meshInstances.push(meshInstance);
        };

        var model = new Model();
        var i;

        var rootNodes = [];
        for (i = 0; i < glb.nodes.length; i++) {
            var node = glb.nodes[i];
            if (node.parent === null) {
                rootNodes.push(node);
            }

            var nodeData = glb.gltf.nodes[i];
            if (nodeData.hasOwnProperty('mesh')) {
                var meshGroup = glb.meshes[nodeData.mesh];
                for (var mi = 0; mi < meshGroup.length; mi++) {
                    createMeshInstance(model, meshGroup[mi], glb.skins, glb.materials, node, nodeData);
                }
            }
        }

        // set model root (create a group if there is more than one)
        if (rootNodes.length === 1) {
            model.graph = rootNodes[0];
        } else {
            model.graph = new GraphNode('SceneGroup');
            for (i = 0; i < rootNodes.length; ++i) {
                model.graph.addChild(rootNodes[i]);
            }
        }

        return model;
    };

    /**
     * @class
     * @name pc.AnimationHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Animation} resources.
     */
    function AnimationHandler() {
        this.retryRequests = false;
    }

    Object.assign(AnimationHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // we need to specify JSON for blob URLs
            var options = {
                retry: this.retryRequests
            };

            if (url.load.startsWith('blob:')) {
                if (path.getExtension(url.original).toLowerCase() === '.glb') {
                    options.responseType = Http.ResponseType.ARRAY_BUFFER;
                } else {
                    options.responseType = Http.ResponseType.JSON;
                }
            }

            http.get(url.load, options, function (err, response) {
                if (err) {
                    callback("Error loading animation resource: " + url.original + " [" + err + "]");
                } else {
                    callback(null, response);
                }
            });
        },

        open: function (url, data) {
            if (path.getExtension(url).toLowerCase() === '.glb') {
                var glb = GlbParser.parse("filename.glb", data, null);
                if (!glb) {
                    return null;
                }
                return glb.animations;
            }
            return this["_parseAnimationV" + data.animation.version](data);
        },

        _parseAnimationV3: function (data) {
            var animData = data.animation;

            var anim = new Animation();
            anim.setName(animData.name);
            anim.duration = animData.duration;

            for (var i = 0; i < animData.nodes.length; i++) {
                var node = new Node();

                var n = animData.nodes[i];
                node._name = n.name;

                for (var j = 0; j < n.keys.length; j++) {
                    var k = n.keys[j];

                    var t = k.time;
                    var p = k.pos;
                    var r = k.rot;
                    var s = k.scale;
                    var pos = new Vec3(p[0], p[1], p[2]);
                    var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
                    var scl = new Vec3(s[0], s[1], s[2]);

                    var key = new Key(t, pos, rot, scl);

                    node._keys.push(key);
                }

                anim.addNode(node);
            }

            return anim;
        },

        _parseAnimationV4: function (data) {
            var animData = data.animation;

            var anim = new Animation();
            anim.setName(animData.name);
            anim.duration = animData.duration;

            for (var i = 0; i < animData.nodes.length; i++) {
                var node = new Node();

                var n = animData.nodes[i];
                node._name = n.name;

                var defPos = n.defaults.p;
                var defRot = n.defaults.r;
                var defScl = n.defaults.s;

                for (var j = 0; j < n.keys.length; j++) {
                    var k = n.keys[j];

                    var t = k.t;
                    var p = defPos ? defPos : k.p;
                    var r = defRot ? defRot : k.r;
                    var s = defScl ? defScl : k.s;
                    var pos = new Vec3(p[0], p[1], p[2]);
                    var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
                    var scl = new Vec3(s[0], s[1], s[2]);

                    var key = new Key(t, pos, rot, scl);

                    node._keys.push(key);
                }

                anim.addNode(node);
            }

            return anim;
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimClipHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.AnimClip} resources.
     */
    function AnimClipHandler() {
        this.retryRequests = false;
    }

    Object.assign(AnimClipHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // we need to specify JSON for blob URLs
            var options = {
                retry: this.retryRequests
            };

            if (url.load.startsWith('blob:')) {
                options.responseType = Http.ResponseType.JSON;
            }

            http.get(url.load, options, function (err, response) {
                if (err) {
                    callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
                } else {
                    callback(null, response);
                }
            });
        },

        open: function (url, data) {
            var name = data.name;
            var duration = data.duration;
            var inputs = data.inputs.map(function (input) {
                return new AnimData(1, input);
            });
            var outputs = data.outputs.map(function (output) {
                return new AnimData(output.components, output.data);
            });
            var curves = data.curves.map(function (curve) {
                return new AnimCurve(
                    [curve.path],
                    curve.inputIndex,
                    curve.outputIndex,
                    curve.interpolation
                );
            });
            return new AnimTrack(
                name,
                duration,
                inputs,
                outputs,
                curves
            );
        }
    });

    function AnimStateGraph(data) {
        this._layers = [];
        this._parameters = {};
        if (data) {
            if (data.states) {
                this._layers = [];
                this._layers.push({
                    name: 'DEFAULT_LAYER',
                    states: data.states,
                    transitions: data.transitions
                });
            } else {
                this._layers = data.layers;
            }
            this._parameters = Object.assign({}, data.parameters);
        }
    }

    Object.defineProperties(AnimStateGraph.prototype, {
        parameters: {
            get: function () {
                return Object.assign({}, this._parameters);
            }
        },
        layers: {
            get: function () {
                return this._layers;
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimStateGraphHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.AnimStateGraph} resources.
     */
    function AnimStateGraphHandler() {
        this.retryRequests = false;
    }

    Object.assign(AnimStateGraphHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // we need to specify JSON for blob URLs
            var options = {
                retry: this.retryRequests
            };

            if (url.load.startsWith('blob:')) {
                options.responseType = Http.ResponseType.JSON;
            }

            http.get(url.load, options, function (err, response) {
                if (err) {
                    callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
                } else {
                    callback(null, response);
                }
            });
        },

        open: function (url, data) {
            return new AnimStateGraph(data);
        }
    });

    /**
     * @class
     * @name pc.Sound
     * @classdesc Represents the resource of an audio asset.
     * @param {HTMLAudioElement|AudioBuffer} resource - If the Web Audio API is supported, pass an AudioBuffer object, otherwise
     * an Audio object.
     * @property {AudioBuffer} buffer If the Web Audio API is supported this contains the audio data.
     * @property {HTMLAudioElement} audio If the Web Audio API is not supported this contains the audio data.
     * @property {number} duration Returns the duration of the sound. If the sound is not loaded it returns 0.
     */
    function Sound(resource) {
        if (resource instanceof Audio) {
            this.audio = resource;
        } else {
            this.buffer = resource;
        }
    }

    Object.defineProperty(Sound.prototype, 'duration', {
        get: function () {
            var duration = 0;
            if (this.buffer) {
                duration = this.buffer.duration;
            } else if (this.audio) {
                duration = this.audio.duration;
            }

            return duration || 0;
        }
    });

    // checks if user is running IE
    var ie = (function () {
        if (typeof window === 'undefined') {
            // Node.js => return false
            return false;
        }
        var ua = window.navigator.userAgent;

        var msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        return false;
    })();

    /**
     * @class
     * @name pc.AudioHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Sound} resources.
     * @param {pc.SoundManager} manager - The sound manager.
     */
    function AudioHandler(manager) {
        this.manager = manager;
        this.retryRequests = false;
    }

    Object.assign(AudioHandler.prototype, {
        _isSupported: function (url) {
            var toMIME = {
                '.ogg': 'audio/ogg',
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/x-wav',
                '.mp4a': 'audio/mp4',
                '.m4a': 'audio/mp4',
                '.mp4': 'audio/mp4',
                '.aac': 'audio/aac'
            };

            var ext = path.getExtension(url);

            if (toMIME[ext]) {
                return true;
            }
            return false;
        },

        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var success = function (resource) {
                callback(null, new Sound(resource));
            };

            var error = function (err) {
                var msg = 'Error loading audio url: ' + url.original;
                if (err) {
                    msg += ': ' + (err.message || err);
                }
                console.warn(msg);
                callback(msg);
            };

            if (this._createSound) {
                if (!this._isSupported(url.original)) {
                    error("Audio format for " + url.original + " not supported");
                    return;
                }

                this._createSound(url.load, success, error);
            } else {
                error(null);
            }
        },

        open: function (url, data) {
            return data;
        }
    });

    if (hasAudioContext()) {
        /**
         * @private
         * @function
         * @name pc.SoundHandler._createSound
         * @description Loads an audio asset using an AudioContext by URL and calls success or error with the created resource or error respectively.
         * @param {string} url - The url of the audio asset.
         * @param {Function} success - Function to be called if the audio asset was loaded or if we
         * just want to continue without errors even if the audio is not loaded.
         * @param {Function} error - Function to be called if there was an error while loading the audio asset.
         */
        AudioHandler.prototype._createSound = function (url, success, error) {
            var manager = this.manager;

            if (!manager.context) {
                error('Audio manager has no audio context');
                return;
            }

            // if this is a blob URL we need to set the response type to arraybuffer
            var options = {
                retry: this.retryRequests
            };

            if (url.startsWith('blob:')) {
                options.responseType = Http.ResponseType.ARRAY_BUFFER;
            }

            http.get(url, options, function (err, response) {
                if (err) {
                    error(err);
                    return;
                }

                manager.context.decodeAudioData(response, success, error);
            });
        };

    } else if (hasAudio()) {
        /**
         * @private
         * @function
         * @name pc.SoundHandler._createSound
         * @description Loads an audio asset using an Audio element by URL and calls success or error with the created resource or error respectively.
         * @param {string} url - The url of the audio asset.
         * @param {Function} success - Function to be called if the audio asset was loaded or if we
         * just want to continue without errors even if the audio is not loaded.
         * @param {Function} error - Function to be called if there was an error while loading the audio asset.
         */
        AudioHandler.prototype._createSound = function (url, success, error) {
            var audio = null;

            try {
                audio = new Audio();
            } catch (e) {
                // Some windows platforms will report Audio as available, then throw an exception when
                // the object is created.
                error("No support for Audio element");
                return;
            }

            // audio needs to be added to the DOM for IE
            if (ie) {
                document.body.appendChild(audio);
            }

            var onReady = function () {
                audio.removeEventListener('canplaythrough', onReady);

                // remove from DOM no longer necessary
                if (ie) {
                    document.body.removeChild(audio);
                }

                success(audio);
            };

            audio.onerror = function () {
                audio.onerror = null;

                // remove from DOM no longer necessary
                if (ie) {
                    document.body.removeChild(audio);
                }

                error();
            };

            audio.addEventListener('canplaythrough', onReady);
            audio.src = url;
        };
    }

    function BinaryHandler() {
        this.retryRequests = false;
    }

    Object.assign(BinaryHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                responseType: Http.ResponseType.ARRAY_BUFFER,
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading binary resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    /**
     * @private
     * @class
     * @name pc.Bundle
     * @param {object[]} files - An array of objects that have a name field and contain a getBlobUrl() function.
     * @classdesc Represents the resource of a Bundle Asset, which contains an index that maps URLs to blob URLs.
     */
    function Bundle(files) {
        this._blobUrls = {};

        for (var i = 0, len = files.length; i < len; i++) {
            if (files[i].url) {
                this._blobUrls[files[i].name] = files[i].url;
            }
        }
    }

    /**
     * @private
     * @function
     * @name pc.Bundle#hasBlobUrl
     * @description Returns true if the specified URL exists in the loaded bundle.
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on the URL first.
     * @returns {boolean} True of false.
     */
    Bundle.prototype.hasBlobUrl = function (url) {
        return !!this._blobUrls[url];
    };

    /**
     * @private
     * @function
     * @name pc.Bundle#getBlobUrl
     * @description Returns a blob URL for the specified URL.
     * @param {string} url - The original file URL. Make sure you have called decodeURIComponent on the URL first.
     * @returns {string} A blob URL.
     */
    Bundle.prototype.getBlobUrl = function (url) {
        return this._blobUrls[url];
    };


    /**
     * @private
     * @function
     * @name pc.Bundle#destroy
     * @description Destroys the bundle and frees up blob URLs.
     */
    Bundle.prototype.destroy = function () {
        for (var key in this._blobUrls) {
            URL.revokeObjectURL(this._blobUrls[key]);
        }
        this._blobUrls = null;
    };

    var Untar; // see below why we declare this here

    // The UntarScope function is going to be used
    // as the code that ends up in a Web Worker.
    // The Untar variable is declared outside the scope so that
    // we do not have to add a 'return' statement to the UntarScope function.
    // We also have to make sure that we do not mangle 'Untar' variable otherwise
    // the Worker will not work.
    function UntarScope(isWorker) {
        var utfDecoder;
        var asciiDecoder;

        if (typeof TextDecoder !== 'undefined') {
            utfDecoder = new TextDecoder('utf-8');
            asciiDecoder = new TextDecoder('windows-1252');
        } else {
            console.warn('TextDecoder not supported - pc.Untar module will not work');
        }

        function PaxHeader(fields) {
            this._fields = fields;
        }

        PaxHeader.parse = function (buffer, start, length) {
            var paxArray = new Uint8Array(buffer, start, length);
            var bytesRead = 0;
            var fields = [];

            while (bytesRead < length) {
                var spaceIndex;
                for (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {
                    if (paxArray[spaceIndex] == 0x20)
                        break;
                }

                if (spaceIndex >= length) {
                    throw new Error('Invalid PAX header data format.');
                }


                var fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);
                var fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));
                var field = fieldText.split('=');

                if (field.length !== 2) {
                    throw new Error('Invalid PAX header data format.');
                }

                if (field[1].length === 0) {
                    field[1] = null;
                }

                fields.push({
                    name: field[0],
                    value: field[1]
                });

                bytesRead += fieldLength;
            }

            return new PaxHeader(fields);
        };

        PaxHeader.prototype.applyHeader = function (file) {
            for (var i = 0; i < this._fields.length; i++) {
                var fieldName = this._fields[i].name;
                var fieldValue = this._fields[i].value;

                if (fieldName === 'path') {
                    fieldName = 'name';
                }

                if (fieldValue === null) {
                    delete file[fieldName];
                } else {
                    file[fieldName] = fieldValue;
                }
            }
        };

        /**
         * @private
         * @name pc.Untar
         * @classdesc Untars a tar archive in the form of an array buffer.
         * @param {ArrayBuffer} arrayBuffer - The array buffer that holds the tar archive.
         * @description Creates a new instance of pc.Untar.
         */
        function UntarInternal(arrayBuffer) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(0);
            this._bufferView = new DataView(this._arrayBuffer);
            this._globalPaxHeader = null;
            this._paxHeader = null;
            this._bytesRead = 0;
        }

        if (! isWorker) {
            Untar = UntarInternal;
        }

        /**
         * @private
         * @function
         * @name pc.Untar#_hasNext
         * @description Whether we have more files to untar.
         * @returns {boolean} Returns true or false.
         */
        UntarInternal.prototype._hasNext = function () {
            return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
        };

        /**
         * @private
         * @function
         * @name pc.Untar#_readNextFile
         * @description Untars the next file in the archive.
         * @returns {object} Returns a file descriptor in the following format:
         * {name, size, start, url}.
         */
        UntarInternal.prototype._readNextFile = function () {
            var headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);
            var headers = asciiDecoder.decode(headersDataView);
            this._bytesRead += 512;

            var name = headers.substr(0, 100).replace(/\0/g, '');
            var ustarFormat = headers.substr(257, 6);
            var size = parseInt(headers.substr(124, 12), 8);
            var type = headers.substr(156, 1);
            var start = this._bytesRead;
            var url = null;

            var normalFile = false;
            switch (type) {
                case "0": case "": // Normal file
                    // do not create blob URL if we are in a worker
                    // because if the worker is destroyed it will also destroy the blob URLs
                    normalFile = true;
                    if (!isWorker) {
                        var blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);
                        url = URL.createObjectURL(blob);
                    }
                    break;
                case "g": // Global PAX header
                    this._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
                    break;
                case "x": // PAX header
                    this._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);
                    break;
            }

            this._bytesRead += size;

            // File data is padded to reach a 512 byte boundary; skip the padded bytes too.
            var remainder = size % 512;
            if (remainder !== 0) {
                this._bytesRead += (512 - remainder);
            }

            if (! normalFile) {
                return null;
            }

            if (ustarFormat.indexOf("ustar") !== -1) {
                var namePrefix = headers.substr(345, 155).replace(/\0/g, '');

                if (namePrefix.length > 0) {
                    name = namePrefix.trim() + name.trim();
                }
            }

            var file = {
                name: name,
                start: start,
                size: size,
                url: url
            };

            if (this._globalPaxHeader) {
                this._globalPaxHeader.applyHeader(file);
            }

            if (this._paxHeader) {
                this._paxHeader.applyHeader(file);
                this._paxHeader = null;
            }

            return file;
        };

        /**
         * @private
         * @function
         * @name pc.Untar#untar
         * @description Untars the array buffer provided in the constructor.
         * @param {string} [filenamePrefix] - The prefix for each filename in the tar archive. This is usually the {@link pc.AssetRegistry} prefix.
         * @returns {object[]} An array of files in this format {name, start, size, url}.
         */
        UntarInternal.prototype.untar = function (filenamePrefix) {
            if (! utfDecoder) {
                console.error('Cannot untar because TextDecoder interface is not available for this platform.');
                return [];
            }

            var files = [];
            while (this._hasNext()) {
                var file = this._readNextFile();
                if (! file) continue;
                if (filenamePrefix && file.name) {
                    file.name = filenamePrefix + file.name;
                }
                files.push(file);
            }

            return files;
        };

        // if we are in a worker then create the onmessage handler using worker.self
        if (isWorker) {
            self.onmessage = function (e) {
                var id = e.data.id;

                try {
                    var archive = new UntarInternal(e.data.arrayBuffer);
                    var files = archive.untar(e.data.prefix);
                    // The worker is done so send a message to the main thread.
                    // Notice we are sending the array buffer back as a Transferrable object
                    // so that the main thread can re-assume control of the array buffer.
                    postMessage({
                        id: id,
                        files: files,
                        arrayBuffer: e.data.arrayBuffer
                    }, [e.data.arrayBuffer]);
                } catch (err) {
                    postMessage({
                        id: id,
                        error: err.toString()
                    });
                }
            };
        }
    }

    // this is the URL that is going to be used for workers
    var workerUrl = null;

    // Convert the UntarScope function to a string and add
    // the onmessage handler for the worker to untar archives
    var getWorkerUrl = function () {
        if (!workerUrl) {
            // execute UntarScope function in the worker
            var code = '(' + UntarScope.toString() + ')(true)\n\n';

            // create blob URL for the code above to be used for the worker
            var blob = new Blob([code], { type: 'application/javascript' });

            workerUrl = URL.createObjectURL(blob);
        }
        return workerUrl;
    };

    /**
     * @private
     * @name pc.UntarWorker
     * @classdesc Wraps untar'ing a tar archive with a Web Worker.
     * @description Creates new instance of a pc.UntarWorker.
     * @param {string} [filenamePrefix] - The prefix that should be added to each file name in the archive. This is usually the {@link pc.AssetRegistry} prefix.
     */
    function UntarWorker(filenamePrefix) {
        this._requestId = 0;
        this._pendingRequests = {};
        this._filenamePrefix = filenamePrefix;
        this._worker = new Worker(getWorkerUrl());
        this._worker.addEventListener('message', this._onMessage.bind(this));
    }

    UntarWorker.prototype._onMessage = function (e) {
        var id = e.data.id;
        if (! this._pendingRequests[id]) return;

        var callback = this._pendingRequests[id];

        delete this._pendingRequests[id];

        if (e.data.error) {
            callback(e.data.error);
        } else {
            var arrayBuffer = e.data.arrayBuffer;

            // create blob URLs for each file. We are creating the URLs
            // here - outside of the worker - so that the main thread owns them
            for (var i = 0, len = e.data.files.length; i < len; i++) {
                var file = e.data.files[i];
                var blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);
                file.url = URL.createObjectURL(blob);
            }

            callback(null, e.data.files);
        }
    };

    /**
     * @private
     * @function
     * @name pc.UntarWorker#untar
     * @description Untars the specified array buffer using a Web Worker and returns the result in the callback.
     * @param {ArrayBuffer} arrayBuffer - The array buffer that holds the tar archive.
     * @param {Function} callback - The callback function called when the worker is finished or if there is an error. The
     * callback has the following arguments: {error, files}, where error is a string if any, and files is an array of file descriptors.
     */
    UntarWorker.prototype.untar = function (arrayBuffer, callback) {
        var id = this._requestId++;
        this._pendingRequests[id] = callback;

        // send data to the worker - notice the last argument
        // converts the arrayBuffer to a Transferrable object
        // to avoid copying the array buffer which would cause a stall.
        // However this causes the worker to assume control of the array
        // buffer so we cannot access this buffer until the worker is done with it.
        this._worker.postMessage({
            id: id,
            prefix: this._filenamePrefix,
            arrayBuffer: arrayBuffer
        }, [arrayBuffer]);
    };

    /**
     * @private
     * @function
     * @name pc.UntarWorker#hasPendingRequests
     * @description Returns whether the worker has pending requests to untar array buffers.
     * @returns {boolean} Returns true of false.
     */
    UntarWorker.prototype.hasPendingRequests = function () {
        for (var key in this._pendingRequests) {
            return true;
        }

        return false;
    };

    /**
     * @private
     * @function
     * @name pc.UntarWorker#destroy
     * @description Destroys the internal Web Worker.
     */
    UntarWorker.prototype.destroy = function () {
        if (this._worker) {
            this._worker.terminate();
            this._worker = null;

            this._pendingRequests = null;
        }
    };

    // execute the UntarScope function in order to declare the Untar constructor
    UntarScope();

    /**
     * @private
     * @class
     * @name pc.BundleHandler
     * @implements {pc.ResourceHandler}
     * @param {pc.AssetRegistry} assets - The asset registry.
     * @classdesc Loads Bundle Assets.
     */
    function BundleHandler(assets) {
        this._assets = assets;
        this._worker = null;
        this.retryRequests = false;
    }

    Object.assign(BundleHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var self = this;

            http.get(url.load, {
                responseType: Http.ResponseType.ARRAY_BUFFER,
                retry: this.retryRequests
            }, function (err, response) {
                if (! err) {
                    try {
                        self._untar(response, callback);
                    } catch (ex) {
                        callback("Error loading bundle resource " + url.original + ": " + ex);
                    }
                } else {
                    callback("Error loading bundle resource " + url.original + ": " + err);
                }
            });
        },

        _untar: function (response, callback) {
            var self = this;

            // use web workers if available otherwise
            // fallback to untar'ing in the main thread
            if (platform.workers) {
                // create web worker if necessary
                if (!self._worker) {
                    self._worker = new UntarWorker(self._assets.prefix);
                }

                self._worker.untar(response, function (err, files) {
                    callback(err, files);

                    // if we have no more requests for this worker then
                    // destroy it
                    if (! self._worker.hasPendingRequests()) {
                        self._worker.destroy();
                        self._worker = null;
                    }
                });
            } else {
                var archive = new Untar(response);
                var files = archive.untar(self._assets.prefix);
                callback(null, files);
            }
        },

        open: function (url, data) {
            return new Bundle(data);
        },

        patch: function (asset, assets) {
        }
    });

    /**
     * @class
     * @name pc.ContainerResource
     * @classdesc Container for a list of animations, textures, materials and a model.
     * @param {object} data - The loaded GLB data.
     */
    function ContainerResource(data) {
        this.data = data;
        this.model = null;
        this.materials = [];
        this.textures = [];
        this.animations = [];
        this.registry = null;
    }

    Object.assign(ContainerResource.prototype, {
        destroy: function () {

            var registry = this.registry;

            var destroyAsset = function (asset) {
                registry.remove(asset);
                asset.unload();
            };

            var destroyAssets = function (assets) {
                assets.forEach(function (asset) {
                    destroyAsset(asset);
                });
            };

            // unload and destroy assets
            if (this.animations) {
                destroyAssets(this.animations);
                this.animations = null;
            }

            if (this.textures) {
                destroyAssets(this.textures);
                this.textures = null;
            }

            if (this.materials) {
                destroyAssets(this.materials);
                this.materials = null;
            }

            if (this.model) {
                destroyAsset(this.model);
                this.model = null;
            }

            this.data = null;
            this.assets = null;
        }
    });

    /**
     * @class
     * @name pc.ContainerHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Loads files that contain in them multiple resources. For example GLB files which can contain
     * textures, models and animations.
     * @param {pc.GraphicsDevice} device - The graphics device that will be rendering.
     * @param {pc.StandardMaterial} defaultMaterial - The shared default material that is used in any place that a material is not specified.
     */
    function ContainerHandler(device, defaultMaterial) {
        this._device = device;
        this._defaultMaterial = defaultMaterial;
    }

    Object.assign(ContainerHandler.prototype, {
        _getUrlWithoutParams: function (url) {
            return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
        },

        load: function (url, callback, asset) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var options = {
                responseType: Http.ResponseType.ARRAY_BUFFER,
                retry: false
            };

            var self = this;

            http.get(url.load, options, function (err, response) {
                if (!callback)
                    return;

                if (!err) {
                    GlbParser.parseAsync(self._getUrlWithoutParams(url.original),
                                         path.extractPath(url.load),
                                         response,
                                         self._device,
                                         asset.registry,
                                         function (err, result) {
                                             if (err) {
                                                 callback(err);
                                             } else {
                                                 // return everything
                                                 callback(null, new ContainerResource(result));
                                             }
                                         });
                } else {
                    callback("Error loading model: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data, asset) {
            return data;
        },

        // Create assets to wrap the loaded engine resources - model, materials, textures and animations.
        patch: function (asset, assets) {
            var createAsset = function (type, resource, index) {
                var subAsset = new Asset(asset.name + '/' + type + '/' + index, type, {
                    url: ''
                });
                subAsset.resource = resource;
                subAsset.loaded = true;
                assets.add(subAsset);
                return subAsset;
            };

            var container = asset.resource;
            var data = container.data;
            var i;

            // create model asset
            var model = createAsset('model', GlbParser.createModel(data, this._defaultMaterial), 0);

            // create material assets
            var materials = [];
            for (i = 0; i < data.materials.length; ++i) {
                materials.push(createAsset('material', data.materials[i], i));
            }

            // create animation assets
            var animations = [];
            for (i = 0; i < data.animations.length; ++i) {
                animations.push(createAsset('animation', data.animations[i], i));
            }

            container.data = null;              // since assets are created, release GLB data
            container.model = model;
            container.materials = materials;
            container.textures = data.textures; // texture assets are created directly
            container.animations = animations;
            container.registry = assets;
        }
    });

    function CssHandler() {
        this.retryRequests = false;
    }

    Object.assign(CssHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading css resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    /**
     * @function
     * @name pc.createStyle
     * @description Creates a &lt;style&gt; DOM element from a string that contains CSS.
     * @param {string} cssString - A string that contains valid CSS.
     * @example
     * var css = 'body {height: 100;}';
     * var style = pc.createStyle(css);
     * document.head.appendChild(style);
     * @returns {Element} The style DOM element.
     */
    function createStyle(cssString) {
        var result = document.createElement('style');
        result.type = 'text/css';
        if (result.styleSheet) {
            result.styleSheet.cssText = cssString;
        } else {
            result.appendChild(document.createTextNode(cssString));
        }

        return result;
    }

    /**
     * @class
     * @name pc.CubemapHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading cubemap {@link pc.Texture} resources.
     * @param {pc.GraphicsDevice} device - The graphics device.
     * @param {pc.AssetRegistry} assets - The asset registry.
     * @param {pc.ResourceLoader} loader - The resource loader.
     */
    function CubemapHandler(device, assets, loader) {
        this._device = device;
        this._assets = assets;
        this._loader = loader;
    }

    Object.assign(CubemapHandler.prototype, {
        load: function (url, callback) { },

        open: function (url, data) { },

        patch: function (assetCubeMap, assets) {
            var self = this;
            var loaded = false;

            if (!assetCubeMap.resources[0]) {
                assetCubeMap.resources[0] = new Texture(this._device, {
                    format: PIXELFORMAT_R8_G8_B8_A8,
                    cubemap: true,
                    mipmaps: true,
                    fixCubemapSeams: !!assetCubeMap._dds
                });
                assetCubeMap.resources[0].name = 'cubemap';

                loaded = true;
            }

            if (!assetCubeMap.file) {
                delete assetCubeMap._dds;
            } else if (assetCubeMap.file && !assetCubeMap._dds) {
                var url = assetCubeMap.getFileUrl();

                assets._loader.load(url + '?t=' + assetCubeMap.file.hash, 'texture', function (err, texture) {
                    if (!err) {
                        assets._loader.patch({
                            resource: texture,
                            type: 'texture',
                            data: assetCubeMap.data
                        }, assets);

                        assetCubeMap._dds = texture;
                        self.patch(assetCubeMap, assets);
                    } else {
                        assets.fire("error", err, assetCubeMap);
                        assets.fire("error:" + assetCubeMap.id, err, assetCubeMap);
                        assetCubeMap.fire("error", err, assetCubeMap);
                    }
                });
            }

            if ((!assetCubeMap.file || !assetCubeMap._dds) && assetCubeMap.resources[1]) {
                // unset prefiltered textures
                assetCubeMap.resources = [assetCubeMap.resources[0]];

                loaded = true;
            } else if (assetCubeMap._dds && !assetCubeMap.resources[1]) {
                assetCubeMap.resources = [assetCubeMap.resources[0]];

                // set prefiltered textures
                assetCubeMap._dds.fixCubemapSeams = true;
                assetCubeMap._dds.addressU = ADDRESS_CLAMP_TO_EDGE;
                assetCubeMap._dds.addressV = ADDRESS_CLAMP_TO_EDGE;

                var startIndex = 0;
                if (this._device.useTexCubeLod) {
                    // full PMREM mipchain is added for ios
                    assetCubeMap.resources.push(assetCubeMap._dds);
                    startIndex = 1;
                }

                for (var i = startIndex; i < 6; i++) {
                    // create a cubemap for each mip in the prefiltered cubemap
                    var mip = new Texture(this._device, {
                        cubemap: true,
                        fixCubemapSeams: true,
                        mipmaps: true,
                        format: assetCubeMap._dds.format,
                        type: assetCubeMap._dds.type,
                        width: Math.pow(2, 7 - i),
                        height: Math.pow(2, 7 - i)
                    });

                    mip.name = 'cubemap-mip';
                    mip._levels[0] = assetCubeMap._dds._levels[i];
                    mip.upload();
                    assetCubeMap.resources.push(mip);
                }

                loaded = true;
            }

            var cubemap = assetCubeMap.resource;

            if (cubemap.name !== assetCubeMap.name)
                cubemap.name = assetCubeMap.name;

            if (assetCubeMap.data.hasOwnProperty('rgbm')) {
                var type = assetCubeMap.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
                if (cubemap.type !== type) {
                    cubemap.type = type;
                }
            }

            cubemap.fixCubemapSeams = !!assetCubeMap._dds;

            if (assetCubeMap.data.hasOwnProperty('minFilter') && cubemap.minFilter !== assetCubeMap.data.minFilter)
                cubemap.minFilter = assetCubeMap.data.minFilter;

            if (assetCubeMap.data.hasOwnProperty('magFilter') && cubemap.magFilter !== assetCubeMap.data.magFilter)
                cubemap.magFilter = assetCubeMap.data.magFilter;

            if (assetCubeMap.data.hasOwnProperty('anisotropy') && cubemap.anisotropy !== assetCubeMap.data.anisotropy)
                cubemap.anisotropy = assetCubeMap.data.anisotropy;

            if (cubemap.addressU !== ADDRESS_CLAMP_TO_EDGE)
                cubemap.addressU = ADDRESS_CLAMP_TO_EDGE;

            if (cubemap.addressV !== ADDRESS_CLAMP_TO_EDGE)
                cubemap.addressV = ADDRESS_CLAMP_TO_EDGE;

            this._patchTextureFaces(assetCubeMap, assets);

            if (loaded) {
                // trigger load event as resource is changed
                assets.fire('load', assetCubeMap);
                assets.fire('load:' + assetCubeMap.id, assetCubeMap);
                assetCubeMap.fire('load', assetCubeMap);
            }
        },

        _patchTexture: function () {
            this.registry._loader._handlers.cubemap._patchTextureFaces(this, this.registry);
        },

        _patchTextureFaces: function (assetCubeMap, assets) {
            if (!assetCubeMap.loadFaces && assetCubeMap.file)
                return;

            var cubemap = assetCubeMap.resource;
            var sources = [];
            var count = 0;
            var levelsUpdated = false;
            var self = this;

            if (!assetCubeMap._levelsEvents)
                assetCubeMap._levelsEvents = [null, null, null, null, null, null];

            assetCubeMap.data.textures.forEach(function (id, index) {
                var assetReady = function (asset) {
                    count++;
                    sources[index] = asset && asset.resource.getSource() || null;

                    // events of texture loads
                    var evtAsset = assetCubeMap._levelsEvents[index];
                    if (evtAsset !== asset) {
                        if (evtAsset)
                            evtAsset.off('load', self._patchTexture, assetCubeMap);

                        if (asset)
                            asset.on('load', self._patchTexture, assetCubeMap);

                        assetCubeMap._levelsEvents[index] = asset || null;
                    }

                    // check if source is actually changed
                    if (sources[index] !== cubemap._levels[0][index])
                        levelsUpdated = true;

                    // when all faces checked
                    if (count === 6 && levelsUpdated) {
                        cubemap.setSource(sources);
                        // trigger load event (resource changed)
                        assets.fire('load', assetCubeMap);
                        assets.fire('load:' + assetCubeMap.id, assetCubeMap);
                        assetCubeMap.fire('load', assetCubeMap);
                    }
                };

                var assetAdded = function (asset) {
                    asset.ready(assetReady);
                    assets.load(asset);
                };

                if (id === null) {
                    assetReady(null);
                } else {
                    var asset;
                    if (parseInt(id, 10) === id) {
                        asset = assets.get(id);
                        if (asset) {
                            asset.ready(assetReady);
                            assets.load(asset);
                        } else if (id) {
                            assets.once("load:" + id, assetReady);
                            assets.once("add:" + id, assetAdded);
                        } else {
                            assetReady(null);
                        }
                    } else {
                        asset = new Asset(assetCubeMap.name + "_face_" + index, "texture", { url: id });
                        assets.add(asset);
                        assets.load(asset);
                        assets.once("load:" + asset.id, assetReady);
                        assets.once("add:" + asset.id, assetAdded);
                    }
                }
            });
        }
    });

    function FolderHandler() {}

    Object.assign(FolderHandler.prototype, {
        load: function (url, callback) {
            callback(null, null);
        },

        open: function (url, data) {
            return data;
        }
    });

    var FONT_MSDF = 'msdf';
    var FONT_BITMAP = 'bitmap';

    /**
     * @class
     * @name pc.Font
     * @classdesc Represents the resource of a font asset.
     * @param {pc.Texture[]} textures - The font textures.
     * @param {object} data - The font data.
     * @property {number} intensity The font intensity.
     * @property {pc.Texture[]} textures The font textures.
     */
    function Font(textures, data) {
        this.type = data ? data.type || FONT_MSDF : FONT_MSDF;

        this.em = 1;

        // atlas texture
        this.textures = textures;

        // intensity
        this.intensity = 0.0;

        // json data
        this._data = null;
        this.data = data;
    }

    Object.defineProperty(Font.prototype, "data", {
        get: function () {
            return this._data;
        },

        set: function (value){
            this._data = value;
            if (!value)
                return;

            if (this._data.intensity !== undefined) {
                this.intensity = this._data.intensity;
            }

            if (!this._data.info)
                this._data.info = {};

            // check if we need to migrate to version 2
            if (!this._data.version || this._data.version < 2) {
                this._data.info.maps = [{
                    width: this._data.info.width,
                    height: this._data.info.height
                }];

                if (this._data.chars) {
                    for (var key in this._data.chars) {
                        this._data.chars[key].map = 0;
                    }
                }
            }
        }
    });

    function upgradeDataSchema(data) {
        // convert v1 and v2 to v3 font data schema
        if (data.version < 3) {
            if (data.version < 2) {
                data.info.maps = data.info.maps || [{
                    width: data.info.width,
                    height: data.info.height
                }];
            }
            data.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {
                var existing = data.chars[key];
                // key by letter instead of char code
                var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
                if (data.version < 2) {
                    existing.map = existing.map || 0;
                }
                newChars[newKey] = existing;
                return newChars;
            }, {});
            data.version = 3;
        }
        return data;
    }

    /**
     * @class
     * @name pc.FontHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Font} resources.
     * @param {pc.ResourceLoader} loader - The resource loader.
     */
    function FontHandler(loader) {
        this._loader = loader;
        this.retryRequests = false;
    }

    Object.assign(FontHandler.prototype, {
        load: function (url, callback, asset) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var self = this;
            if (path.getExtension(url.original) === '.json') {
                // load json data then load texture of same name
                http.get(url.load, {
                    retry: this.retryRequests
                }, function (err, response) {
                    // update asset data
                    var data = upgradeDataSchema(response);
                    if (!err) {
                        self._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {
                            if (err) return callback(err);

                            callback(null, {
                                data: data,
                                textures: textures
                            });
                        });
                    } else {
                        callback("Error loading font resource: " + url.original + " [" + err + "]");
                    }
                });

            } else {
                // upgrade asset data
                if (asset && asset.data) {
                    asset.data = upgradeDataSchema(asset.data);
                }
                this._loadTextures(url.load, asset && asset.data, callback);
            }
        },

        _loadTextures: function (url, data, callback) {
            var numTextures = data.info.maps.length;
            var numLoaded = 0;
            var error = null;

            var textures = new Array(numTextures);
            var loader = this._loader;

            var loadTexture = function (index) {
                var onLoaded = function (err, texture) {
                    if (error) return;

                    if (err) {
                        error = err;
                        return callback(err);
                    }

                    texture.upload();
                    textures[index] = texture;
                    numLoaded++;
                    if (numLoaded === numTextures) {
                        callback(null, textures);
                    }
                };

                if (index === 0) {
                    loader.load(url, "texture", onLoaded);
                } else {
                    loader.load(url.replace('.png', index + '.png'), "texture", onLoaded);
                }
            };

            for (var i = 0; i < numTextures; i++)
                loadTexture(i);
        },

        open: function (url, data, asset) {
            var font;
            if (data.textures) {
                // both data and textures exist
                font = new Font(data.textures, data.data);
            } else {
                // only textures
                font = new Font(data, null);
            }
            return font;
        },

        patch: function (asset, assets) {
            // if not already set, get font data block from asset
            // and assign to font resource
            var font = asset.resource;
            if (!font.data && asset.data) {
                // font data present in asset but not in font
                font.data = asset.data;
            } else if (!asset.data && font.data) {
                // font data present in font but not in asset
                asset.data = font.data;
            }

            if (asset.data) {
                asset.data = upgradeDataSchema(asset.data);
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.AssetListLoader
     * @augments pc.EventHandler
     * @classdesc Used to load a group of assets and fires a callback when all assets are loaded.
     * @param {pc.Asset[]|number[]} assetList - An array of pc.Asset objects to load or an array of Asset IDs to load.
     * @param {pc.AssetRegistry} assetRegistry - The application's asset registry.
     */
    function AssetListLoader(assetList, assetRegistry) {
        EventHandler.call(this);

        this._assets = [];
        this._registry = assetRegistry;
        this._loaded = false;
        this._count = 0; // running count of successfully loaded assets
        this._total = 0; // total assets loader is expecting to load
        this._failed = []; // list of assets that failed to load

        this._waitingAssets = [];

        if (assetList.length && assetList[0] instanceof Asset) {
            // list of pc.Asset
            this._assets = assetList;
        } else {
            // list of Asset IDs
            for (var i = 0; i < assetList.length; i++) {
                var asset = assetRegistry.get(assetList[i]);
                if (asset) {
                    this._assets.push(asset);
                } else {
                    this._waitForAsset(assetList[i]);
                    this._total++;
                }

            }
        }
    }
    AssetListLoader.prototype = Object.create(EventHandler.prototype);
    AssetListLoader.prototype.constructor = AssetListLoader;

    AssetListLoader.prototype.destroy = function () {
        // remove any outstanding listeners

        var self = this;

        this._registry.off("load", this._onLoad);
        this._registry.off("error", this._onError);

        this._waitingAssets.forEach(function (id) {
            self._registry.off("add:" + id, this._onAddAsset);
        });

        this.off("progress");
        this.off("load");
    };

    /**
     * @private
     * @function
     * @name pc.AssetListLoader#load
     * @description Start loading asset list, call done() when all assets have loaded or failed to load.
     * @param {Function} done - Callback called when all assets in the list are loaded. Passed (err, failed) where err is the undefined if no errors are encountered and failed contains a list of assets that failed to load.
     * @param {object} [scope] - Scope to use when calling callback.
     *
     */
    AssetListLoader.prototype.load = function (done, scope) {
        var i = 0;
        var l = this._assets.length;
        var asset;

        // this._total = l;
        this._count = 0;
        this._failed = [];
        this._callback = done;
        this._scope = scope;

        this._registry.on("load", this._onLoad, this);
        this._registry.on("error", this._onError, this);

        for (i = 0; i < l; i++) {
            asset = this._assets[i];

            if (!asset.loading && !asset.loaded) {
                this._registry.load(asset);
                this._total++;
            }
        }
    };

    /**
     * @private
     * @function
     * @name pc.AssetListLoader#ready
     * @param {Function} done - Callback called when all assets in the list are loaded.
     * @param {object} [scope] - Scope to use when calling callback.
     */
    AssetListLoader.prototype.ready = function (done, scope) {
        scope = scope || this;

        if (this._loaded) {
            done.call(scope, this._assets);
        } else {
            this.once("load", function (assets) {
                done.call(scope, assets);
            });
        }
    };

    // called when all assets are loaded
    AssetListLoader.prototype._loadingComplete = function () {
        this._loaded = true;
        this._registry.off("load", this._onLoad, this);
        this._registry.off("error", this._onError, this);

        if (this._failed && this._failed.length) {
            if (this._callback) {
                this._callback.call(this._scope, "Failed to load some assets", this._failed);
            }
            this.fire("error", this._failed);
        } else {
            if (this._callback) {
                this._callback.call(this._scope);
            }
            this.fire("load", this._assets);
        }
    };

    // called when an (any) asset is loaded
    AssetListLoader.prototype._onLoad = function (asset) {
        var self = this;

        // check this is an asset we care about
        if (this._assets.indexOf(asset) >= 0) {
            this._count++;
            this.fire("progress", asset);
        }

        if (this._count === this._total) {
            // call next tick because we want
            // this to be fired after any other
            // asset load events
            setTimeout(function () {
                self._loadingComplete(self._failed);
            }, 0);
        }
    };

    // called when an asset fails to load
    AssetListLoader.prototype._onError = function (err, asset) {
        var self = this;

        // check this is an asset we care about
        if (this._assets.indexOf(asset) >= 0) {
            this._count++;
            this._failed.push(asset);
        }

        if (this._count === this._total) {
            // call next tick because we want
            // this to be fired after any other
            // asset load events
            setTimeout(function () {
                self._loadingComplete(self._failed);
            }, 0);
        }
    };

    // called when a expected asset is added to the asset registry
    AssetListLoader.prototype._onAddAsset = function (asset) {
        // remove from waiting list
        var index = this._waitingAssets.indexOf(asset);
        if (index >= 0) {
            this._waitingAssets.splice(index, 1);
        }

        this._assets.push(asset);
        var i;
        var l = this._assets.length;
        for (i = 0; i < l; i++) {
            asset = this._assets[i];

            if (!asset.loading && !asset.loaded) {
                this._registry.load(asset);
            }
        }
    };

    AssetListLoader.prototype._waitForAsset = function (assetId) {
        this._waitingAssets.push(assetId);
        this._registry.once('add:' + assetId, this._onAddAsset, this);
    };

    var TemplateUtils = {
        /**
         * @private
         * @function
         * @name pc.TemplateUtils#waitForTemplatesInScene
         * @description Delay execution of the callback until collapsedInstances
         * are expanded (if present). For expansion we need to wait for template assets
         * to load.
         * @param {object} data - Raw scene data from the database.
         * @param {pc.AssetRegistry} assets - The application's asset registry.
         * @param {Function} callback - The callback to execute after template assets are loaded.
         */
        waitForTemplatesInScene: function (data, assets, callback) {
            if (data.collapsedInstances) {
                var entities = TemplateUtils._getAllCollapsedEntities(data);

                TemplateUtils.waitForTemplateAssets(
                    entities,
                    assets,
                    callback,
                    data);
            } else {
                callback(null, data);
            }
        },

        /**
         * @private
         * @function
         * @name pc.TemplateUtils#waitForTemplateAssets
         * @description Delay execution of the callback until template assets
         * referenced by the provided entities are loaded.
         * @param {object[]} entities - Scene entity data from the database.
         * @param {pc.AssetRegistry} assets - The application's asset registry.
         * @param {Function} callback - The callback to execute after template assets are loaded.
         * @param {object} response - The response object to be passed to the callback.
         */
        waitForTemplateAssets: function (entities, assets, callback, response) {
            var templateIds = TemplateUtils._extractTemplateIds(entities);

            var loader = new AssetListLoader(templateIds, assets);

            loader.load(function (err) {
                callback(err, response);
            });
        },

        _getAllCollapsedEntities: function (data) {
            var entities = {};

            data.collapsedInstances.forEach(function (h) {
                Object.assign(entities, h.instanceEntities);
            });

            return entities;
        },

        _extractTemplateIds: function (entities) {
            var templateIds = [];

            for (var guid in entities) {
                var id = entities[guid].template_id;

                if (id) {
                    templateIds.push(id);
                }
            }

            return templateIds;
        },

        /**
         * @private
         * @function
         * @name pc.TemplateUtils#expandTemplateEntities
         * @description Expand entities marked with the collapsed_entity flag.
         * @param {pc.Application} app - The application.
         * @param {object} entities - Scene entity data from the database.
         * @returns {object} An entities map with those that needed expansion expanded.
         */
        expandTemplateEntities: function (app, entities) {
            var result = {};

            for (var guid in entities) {
                var h = entities[guid];

                result[guid] = h.collapsed_entity ?
                    TemplateUtils.expandEntity(app, h) : h;
            }

            return result;
        },

        expandEntity: function (app, data) {
            // todo implement this
        }
    };

    function SceneParser(app, isTemplate) {
        this._app = app;

        this._isTemplate = isTemplate;
    }

    Object.assign(SceneParser.prototype, {
        parse: function (data) {
            var entities = {};
            var id, i;
            var parent = null;

            if (data.collapsedInstances) {
                this._addCollapsedToEntities(this._app, data);
            }

            // instantiate entities
            for (id in data.entities) {
                entities[id] = this._createEntity(data.entities[id]);
                if (data.entities[id].parent === null) {
                    parent = entities[id];
                }
            }

            // put entities into hierarchy
            for (id in data.entities) {
                var l = data.entities[id].children.length;
                for (i = 0; i < l; i++) {
                    // pop resource id off the end of the array
                    var resource_id = data.entities[id].children[i];
                    if (entities[resource_id]) {
                        // push entity on the front of the array
                        entities[id].addChild(entities[resource_id]);
                    }
                }
            }

            this._openComponentData(parent, data.entities);

            return parent;
        },

        _createEntity: function (data) {
            var entity = new Entity();

            var p = data.position;
            var r = data.rotation;
            var s = data.scale;

            entity.name = data.name;
            entity.setGuid(data.resource_id);
            entity.setLocalPosition(p[0], p[1], p[2]);
            entity.setLocalEulerAngles(r[0], r[1], r[2]);
            entity.setLocalScale(s[0], s[1], s[2]);
            entity._enabled = data.enabled !== undefined ? data.enabled : true;

            if (!this._isTemplate) {
                entity._enabledInHierarchy = entity._enabled;
            }

            entity.template = data.template;

            if (data.tags) {
                for (var i = 0; i < data.tags.length; i++) {
                    entity.tags.add(data.tags[i]);
                }
            }

            if (data.labels) {
                data.labels.forEach(function (label) {
                    entity.addLabel(label);
                });
            }

            return entity;
        },

        _openComponentData: function (entity, entities) {
            // Create components in order
            var systemsList = this._app.systems.list;

            var i, len = systemsList.length;
            var entityData = entities[entity.getGuid()];
            for (i = 0; i < len; i++) {
                var system = systemsList[i];
                var componentData = entityData.components[system.id];
                if (componentData) {
                    system.addComponent(entity, componentData);
                }
            }

            // Open all children and add them to the node
            len = entityData.children.length;
            var children = entity._children;
            for (i = 0; i < len; i++) {
                children[i] = this._openComponentData(children[i], entities);
            }

            return entity;
        },

        _addCollapsedToEntities: function (app, data) {
            data.collapsedInstances.forEach(function (h) {
                var expanded = TemplateUtils.expandTemplateEntities(
                    app, h.instanceEntities);

                Object.assign(data.entities, expanded);
            });
        }
    });

    function HierarchyHandler(app) {
        this._app = app;
        this.retryRequests = false;
    }

    Object.assign(HierarchyHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var assets = this._app.assets;

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    TemplateUtils.waitForTemplatesInScene(
                        response,
                        assets,
                        callback);
                } else {
                    var errMsg = 'Error while loading scene ' + url.original;
                    if (err.message) {
                        errMsg += ': ' + err.message;
                        if (err.stack) {
                            errMsg += '\n' + err.stack;
                        }
                    } else {
                        errMsg += ': ' + err;
                    }

                    callback(errMsg);
                }
            });
        },

        open: function (url, data) {
            // prevent script initialization until entire scene is open
            this._app.systems.script.preloading = true;

            var parser = new SceneParser(this._app, false);
            var parent = parser.parse(data);

            // re-enable script initialization
            this._app.systems.script.preloading = false;

            return parent;
        }
    });

    function HtmlHandler() {
        this.retryRequests = false;
    }

    Object.assign(HtmlHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading html resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    function JsonHandler() {
        this.retryRequests = false;
    }

    Object.assign(JsonHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // if this a blob URL we need to set the response type as json
            var options = {
                retry: this.retryRequests
            };

            if (url.load.startsWith('blob:')) {
                options.responseType = Http.ResponseType.JSON;
            }

            http.get(url.load, options, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading JSON resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    var standardMaterialParameterTypes = {
        name: 'string',
        chunks: 'chunks',

        mappingFormat: 'string',
        _engine: 'boolean', // internal param for engine-only loading

        ambient: 'rgb',
        ambientTint: 'boolean',

        aoVertexColor: 'boolean',
        aoVertexColorChannel: 'string',
        aoMap: 'texture',
        aoMapChannel: 'string',
        aoMapUv: 'number',
        aoMapTiling: 'vec2',
        aoMapOffset: 'vec2',

        diffuse: 'rgb',
        diffuseTint: 'boolean',
        diffuseVertexColor: 'boolean',
        diffuseVertexColorChannel: 'string',
        diffuseMap: 'texture',
        diffuseMapChannel: 'string',
        diffuseMapUv: 'number',
        diffuseMapTiling: 'vec2',
        diffuseMapOffset: 'vec2',
        diffuseDetailMap: 'texture',
        diffuseDetailMapChannel: 'string',
        diffuseDetailMapUv: 'number',
        diffuseDetailMapTiling: 'vec2',
        diffuseDetailMapOffset: 'vec2',
        diffuseDetailMode: 'string',

        specular: 'rgb',
        specularTint: 'boolean',
        specularVertexColor: 'boolean',
        specularVertexColorChannel: 'string',
        specularMap: 'texture',
        specularMapChannel: 'string',
        specularMapUv: 'number',
        specularMapTiling: 'vec2',
        specularMapOffset: 'vec2',
        specularAntialias: 'boolean',
        occludeSpecular: 'enum:occludeSpecular',

        useMetalness: 'boolean',
        metalness: 'number',
        enableGGXSpecular: 'boolean',
        anisotropy: 'number',
        clearCoat: 'number',
        clearCoatGlossiness: 'number',
        metalnessTint: 'boolean',
        metalnessVertexColor: 'boolean',
        metalnessVertexColorChannel: 'string',
        metalnessMap: 'texture',
        metalnessMapChannel: 'string',
        metalnessMapUv: 'number',
        metalnessMapTiling: 'vec2',
        metalnessMapOffset: 'vec2',

        conserveEnergy: 'boolean',
        shininess: 'number',
        glossVertexColor: 'boolean',
        glossVertexColorChannel: 'string',
        glossMap: 'texture',
        glossMapChannel: 'string',
        glossMapUv: 'number',
        glossMapTiling: 'vec2',
        glossMapOffset: 'vec2',

        fresnelModel: 'number',

        emissive: 'rgb',
        emissiveTint: 'boolean',
        emissiveVertexColor: 'boolean',
        emissiveVertexColorChannel: 'string',
        emissiveMap: 'texture',
        emissiveMapChannel: 'string',
        emissiveMapUv: 'number',
        emissiveMapTiling: 'vec2',
        emissiveMapOffset: 'vec2',
        emissiveIntensity: 'number',

        normalMap: 'texture',
        normalMapTiling: 'vec2',
        normalMapOffset: 'vec2',
        normalMapUv: 'number',
        bumpiness: 'number',
        // normalMapFactor: 'number', // TODO rename bumpiness to normalMapFactor
        normalDetailMap: 'texture',
        normalDetailMapTiling: 'vec2',
        normalDetailMapOffset: 'vec2',
        normalDetailMapUv: 'number',
        normalDetailMapBumpiness: 'number',

        heightMap: 'texture',
        heightMapChannel: 'string',
        heightMapUv: 'number',
        heightMapTiling: 'vec2',
        heightMapOffset: 'vec2',
        heightMapFactor: 'number',

        alphaToCoverage: 'boolean',
        alphaTest: 'number',
        opacity: 'number',
        opacityVertexColor: 'boolean',
        opacityVertexColorChannel: 'string',
        opacityMap: 'texture',
        opacityMapChannel: 'string',
        opacityMapUv: 'number',
        opacityMapTiling: 'vec2',
        opacityMapOffset: 'vec2',

        reflectivity: 'number',
        refraction: 'number',
        refractionIndex: 'number',
        sphereMap: 'texture',
        cubeMap: 'cubemap',
        cubeMapProjection: 'number',
        cubeMapProjectionBox: 'boundingbox',

        lightVertexColor: 'boolean',
        lightVertexColorChannel: 'string',
        lightMap: 'texture',
        lightMapChannel: 'string',
        lightMapUv: 'number',
        lightMapTiling: 'vec2',
        lightMapOffset: 'vec2',

        depthTest: 'boolean',
        depthWrite: 'boolean',
        depthBias: 'number',
        slopeDepthBias: 'number',

        cull: 'enum:cull',
        blendType: 'enum:blendType',
        shadingModel: 'enum:shadingModel',

        useFog: 'boolean',
        useLighting: 'boolean',
        useSkybox: 'boolean',
        useGammaTonemap: 'boolean',

        prefilteredCubeMap128: 'texture',
        prefilteredCubeMap64: 'texture',
        prefilteredCubeMap32: 'texture',
        prefilteredCubeMap16: 'texture',
        prefilteredCubeMap8: 'texture',
        prefilteredCubeMap4: 'texture'

        // twoSidedLighting
        // nineSlicedMode
        // pixelSnap
        // forceUv1
        // occludeDirect
        // occludeSpecularIntensity
        // fastTbn
        // normalizeNormalMap

        // msdfMap
        // msdfMapChannel
        // msdfMapUv
        // msdfMapTiling
        // msdfMapOffset
        // msdfVertexColor
        // msdfVexterColorChannel
    };

    var key, type$1;
    var standardMaterialTextureParameters = [];
    for (key in standardMaterialParameterTypes) {
        type$1 = standardMaterialParameterTypes[key];
        if (type$1 === 'texture') {
            standardMaterialTextureParameters.push(key);
        }
    }

    var standardMaterialCubemapParameters = [];
    for (key in standardMaterialParameterTypes) {
        type$1 = standardMaterialParameterTypes[key];
        if (type$1 === 'cubemap') {
            standardMaterialCubemapParameters.push(key);
        }
    }

    /**
     * @class
     * @name pc.AssetReference
     * @description An object that manages the case where an object holds a reference to an asset and needs to be notified when
     * changes occur in the asset. e.g. notifications include load, add and remove events.
     * @param {string} propertyName - The name of the property that the asset is stored under, passed into callbacks to enable updating.
     * @param {pc.Asset|object} parent - The parent object that contains the asset reference, passed into callbacks to enable updating. Currently an asset, but could be component or other.
     * @param {pc.AssetRegistry} registry - The asset registry that stores all assets.
     * @param {object} callbacks - A set of functions called when the asset state changes: load, add, remove.
     * @param {object} [callbacks.load] - The function called when the asset loads load(propertyName, parent, asset).
     * @param {object} [callbacks.add] - The function called when the asset is added to the registry add(propertyName, parent, asset).
     * @param {object} [callbacks.remove] - The function called when the asset is remove from the registry remove(propertyName, parent, asset).
     * @param {object} [scope] - The scope to call the callbacks in
     * @property {number} id Get or set the asset id which this references. One of either id or url must be set to initialize an asset reference.
     * @property {string} url Get or set the asset url which this references. One of either id or url must be called to initialize an asset reference.
     * @example
     *
     * var reference = new pc.AssetReference('textureAsset', this, this.app.assets, {
     *     load: this.onTextureAssetLoad,
     *     add: this.onTextureAssetAdd,
     *     remove: this.onTextureAssetRemove
     * }, this);
     * reference.id = this.textureAsset.id;
     */
    function AssetReference(propertyName, parent, registry, callbacks, scope) {
        this.propertyName = propertyName;
        this.parent = parent;

        this._scope = scope;
        this._registry = registry;

        this.id = null;
        this.url = null;
        this.asset = null;

        this._onAssetLoad = callbacks.load;
        this._onAssetAdd = callbacks.add;
        this._onAssetRemove = callbacks.remove;
    }

    AssetReference.prototype._bind = function () {
        if (this.id) {
            if (this._onAssetLoad) this._registry.on("load:" + this.id, this._onLoad, this);
            if (this._onAssetAdd) this._registry.once("add:" + this.id, this._onAdd, this);
            if (this._onAssetRemove) this._registry.on("remove:" + this.id, this._onRemove, this);
        }

        if (this.url) {
            if (this._onAssetLoad) this._registry.on("load:url:" + this.url, this._onLoad, this);
            if (this._onAssetAdd) this._registry.once("add:url:" + this.url, this._onAdd, this);
            if (this._onAssetRemove) this._registry.on("remove:url:" + this.url, this._onRemove, this);
        }
    };

    AssetReference.prototype._unbind = function () {
        if (this.id) {
            if (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);
            if (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);
            if (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);
        }
        if (this.url) {
            if (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);
            if (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);
            if (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);
        }
    };

    AssetReference.prototype._onLoad = function (asset) {
        this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
    };

    AssetReference.prototype._onAdd = function (asset) {
        this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
    };

    AssetReference.prototype._onRemove = function (asset) {
        this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
    };

    Object.defineProperty(AssetReference.prototype, 'id', {
        get: function () {
            return this._id;
        },
        set: function (value) {
            if (this.url) throw Error("Can't set id and url");

            this._unbind();

            this._id = value;
            this.asset = this._registry.get(this._id);

            this._bind();
        }
    });

    Object.defineProperty(AssetReference.prototype, 'url', {
        get: function () {
            return this._url;
        },
        set: function (value) {
            if (this.id) throw Error("Can't set id and url");

            this._unbind();

            this._url = value;
            this.asset = this._registry.getByUrl(this._url);

            this._bind();
        }
    });

    function StandardMaterialValidator() {
        this.removeInvalid = true;

        this.valid = true; // start off valid

        this.enumValidators = {
            occludeSpecular: this._createEnumValidator([
                SPECOCC_NONE,
                SPECOCC_AO,
                SPECOCC_GLOSSDEPENDENT
            ]),
            cull: this._createEnumValidator([
                CULLFACE_NONE,
                CULLFACE_BACK,
                CULLFACE_FRONT,
                CULLFACE_FRONTANDBACK
            ]),
            blendType: this._createEnumValidator([
                BLEND_SUBTRACTIVE,
                BLEND_ADDITIVE,
                BLEND_NORMAL,
                BLEND_NONE,
                BLEND_PREMULTIPLIED,
                BLEND_MULTIPLICATIVE,
                BLEND_ADDITIVEALPHA,
                BLEND_MULTIPLICATIVE2X,
                BLEND_SCREEN,
                BLEND_MIN,
                BLEND_MAX
            ]),
            shadingModel: this._createEnumValidator([
                SPECULAR_PHONG,
                SPECULAR_BLINN
            ])
        };
    }

    StandardMaterialValidator.prototype.setInvalid = function (key, data) {
        this.valid = false;


        if (this.removeInvalid) {
            delete data[key];
        }
    };

    StandardMaterialValidator.prototype.validate = function (data) {
         // validate input data against defined standard-material properties and types\
         // if removeInvalid flag is set to true then remove invalid properties from data

        var TYPES = standardMaterialParameterTypes;
        var type;
        var i;

        var pathMapping = (data.mappingFormat === "path");

        for (var key in data) {
            type = TYPES[key];

            if (!type) {
                this.valid = false;
                continue;
            }

            if (type.startsWith("enum")) {
                var enumType = type.split(":")[1];
                if (this.enumValidators[enumType]) {
                    if (!this.enumValidators[enumType](data[key])) {
                        this.setInvalid(key, data);
                    }
                }

            } else if (type === 'number') {
                if (typeof(data[key]) !== 'number') {
                    this.setInvalid(key, data);
                }
            } else if (type === 'boolean') {
                if (typeof(data[key]) !== 'boolean') {
                    this.setInvalid(key, data);
                }
            } else if (type === 'string') {
                if (typeof(data[key]) !== 'string') {
                    this.setInvalid(key, data);
                }
            } else if (type === 'vec2') {
                if (!(data[key] instanceof Array && data[key].length === 2)) {
                    this.setInvalid(key, data);
                }
            } else if (type === 'rgb') {
                if (!(data[key] instanceof Array && data[key].length === 3)) {
                    this.setInvalid(key, data);
                }
            } else if (type === 'texture') {
                if (!pathMapping) {
                    if (typeof(data[key]) === 'number' || data[key] === null) ; else if (!(data[key] instanceof Texture)) {
                        this.setInvalid(key, data);
                    }
                } else {
                    if (typeof(data[key]) === 'string' || data[key === null]) ; else if (!(data[key] instanceof Texture)) {
                        this.setInvalid(key, data);
                    }
                }
            } else if (type === 'boundingbox') {
                if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
                    this.setInvalid(key, data);
                }
                if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
                    this.setInvalid(key, data);
                }
            } else if (type === 'cubemap') {
                if (typeof(data[key]) === 'number' || data[key] === null || data[key] === undefined) ; else if (!(data[key] instanceof Texture && data[key].cubemap)) {
                    this.setInvalid(key, data);
                }
            } else if (type === 'chunks') {
                var chunkNames = Object.keys(data[key]);
                for (i = 0; i < chunkNames.length; i++) {
                    if (typeof(data[key][chunkNames[i]]) !== 'string') {
                        this.setInvalid(chunkNames[i], data[key]);
                    }
                }

            } else {
                console.error("Unknown material type: " + type);
            }
        }

        // mark data as validated so we don't validate twice
        data.validated = true;

        return this.valid;
    };

    StandardMaterialValidator.prototype._createEnumValidator = function (values) {
        return function (value) {
            return (values.indexOf(value) >= 0);
        };
    };

    /**
     * @private
     * @name pc.JsonStandardMaterialParser
     * @description Convert incoming JSON data into a {@link pc.StandardMaterial}.
     */
    function JsonStandardMaterialParser() {
        this._validator = null;
    }

    JsonStandardMaterialParser.prototype.parse = function (input) {
        var migrated = this.migrate(input);
        var validated = this._validate(migrated);

        var material = new StandardMaterial();
        this.initialize(material, validated);

        return material;
    };

    /**
     * @private
     * @function
     * @name pc.JsonStandardMaterialParser#initialize
     * @description  Initialize material properties from the material data block e.g. Loading from server.
     * @param {pc.StandardMaterial} material - The material to be initialized.
     * @param {object} data - The data block that is used to initialize.
     */
    JsonStandardMaterialParser.prototype.initialize = function (material, data) {
        // usual flow is that data is validated in resource loader
        // but if not, validate here.
        if (!data.validated) {
            if (!this._validator) {
                this._validator = new StandardMaterialValidator();
            }
            this._validator.validate(data);
        }

        if (data.chunks) {
            material.chunks.copy(data.chunks);
        }

        // initialize material values from the input data
        for (var key in data) {
            var type = standardMaterialParameterTypes[key];
            var value = data[key];

            if (type === 'vec2') {
                material[key] = new Vec2(value[0], value[1]);
            } else if (type === 'rgb') {
                material[key] = new Color(value[0], value[1], value[2]);
            } else if (type === 'texture') {
                if (value instanceof Texture) {
                    material[key] = value;
                } else if (material[key] instanceof Texture && typeof(value) === 'number' && value > 0) ; else {
                    material[key] = null;
                }
            } else if (type === 'cubemap') {
                if (value instanceof Texture) {
                    material[key] = value;
                } else if (material[key] instanceof Texture && typeof(value) === 'number' && value > 0) ; else {
                    material[key] = null;
                }
            } else if (type === 'boundingbox') {
                var center = new Vec3(value.center[0], value.center[1], value.center[2]);
                var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
                material[key] = new BoundingBox(center, halfExtents);
            } else {
                // number, boolean and enum types don't require type creation
                material[key] = data[key];
            }
        }

        material.update();
    };

    // convert any properties that are out of date
    // or from old versions into current version
    JsonStandardMaterialParser.prototype.migrate = function (data) {
        // replace old shader property with new shadingModel property
        if (data.shadingModel === undefined) {
            if (data.shader === 'blinn') {
                data.shadingModel = SPECULAR_BLINN;
            } else {
                data.shadingModel = SPECULAR_PHONG;
            }
        }
        if (data.shader) delete data.shader;


        // make JS style
        if (data.mapping_format) {
            data.mappingFormat = data.mapping_format;
            delete data.mapping_format;
        }

        var i;
        // list of properties that have been renamed in StandardMaterial
        // but may still exists in data in old format
        var RENAMED_PROPERTIES = [
            ["bumpMapFactor", "bumpiness"],

            ["aoUvSet", "aoMapUv"],

            ["aoMapVertexColor", "aoVertexColor"],
            ["diffuseMapVertexColor", "diffuseVertexColor"],
            ["emissiveMapVertexColor", "emissiveVertexColor"],
            ["specularMapVertexColor", "specularVertexColor"],
            ["metalnessMapVertexColor", "metalnessVertexColor"],
            ["opacityMapVertexColor", "opacityVertexColor"],
            ["glossMapVertexColor", "glossVertexColor"],
            ["lightMapVertexColor", "lightVertexColor"],

            ["diffuseMapTint", "diffuseTint"],
            ["specularMapTint", "specularTint"],
            ["emissiveMapTint", "emissiveTint"],
            ["metalnessMapTint", "metalnessTint"]
        ];

        // if an old property name exists without a new one,
        // move property into new name and delete old one.
        for (i = 0; i < RENAMED_PROPERTIES.length; i++) {
            var _old = RENAMED_PROPERTIES[i][0];
            var _new = RENAMED_PROPERTIES[i][1];

            if (data[_old] !== undefined && !(data[_new] !== undefined)) {
                data[_new] = data[_old];
                delete data[_old];
            }
        }

        // Properties that may exist in input data, but are now ignored
        var DEPRECATED_PROPERTIES = [
            'fresnelFactor',
            'shadowSampleType'
        ];

        for (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {
            var name = DEPRECATED_PROPERTIES[i];
            if (data.hasOwnProperty(name)) {
                delete data[name];
            }
        }

        return data;
    };

    // check for invalid properties
    JsonStandardMaterialParser.prototype._validate = function (data) {
        if (!this._validator) {
            this._validator = new StandardMaterialValidator();
        }
        this._validator.validate(data);

        return data;
    };

    var PLACEHOLDER_MAP = {
        aoMap: 'white',
        diffuseMap: 'gray',
        specularMap: 'gray',
        metalnessMap: 'black',
        glossMap: 'gray',
        emissiveMap: 'gray',
        normalMap: 'normal',
        heightMap: 'gray',
        opacityMap: 'gray',
        sphereMap: 'gray',
        lightMap: 'white'
    };

    /**
     * @class
     * @name pc.MaterialHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Material} resources.
     * @param {pc.Application} app - The running {@link pc.Application}.
     */
    function MaterialHandler(app) {
        this._assets = app.assets;
        this._device = app.graphicsDevice;

        this._placeholderTextures = null;

        this._parser = new JsonStandardMaterialParser();
        this.retryRequests = false;
    }

    Object.assign(MaterialHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // Loading from URL (engine-only)
            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    if (callback) {
                        response._engine = true;
                        callback(null, response);
                    }
                } else {
                    if (callback) {
                        callback("Error loading material: " + url.original + " [" + err + "]");
                    }
                }
            });
        },

        open: function (url, data) {
            var material = this._parser.parse(data);

            // temp storage for engine-only as we need this during patching
            if (data._engine) {
                material._data = data;
                delete data._engine;
            }

            return material;
        },

        // creates placeholders for textures
        // that are used while texture is loading
        _createPlaceholders: function () {
            this._placeholderTextures = {};

            var textures = {
                white: [255, 255, 255, 255],
                gray: [128, 128, 128, 255],
                black: [0, 0, 0, 255],
                normal: [128, 128, 255, 255]
            };

            for (var key in textures) {
                if (!textures.hasOwnProperty(key))
                    continue;

                // create texture
                this._placeholderTextures[key] = new Texture(this._device, {
                    width: 2,
                    height: 2,
                    format: PIXELFORMAT_R8_G8_B8_A8
                });
                this._placeholderTextures[key].name = 'placeholder';

                // fill pixels with color
                var pixels = this._placeholderTextures[key].lock();
                for (var i = 0; i < 4; i++) {
                    for (var c = 0; c < 4; c++) {
                        pixels[i * 4 + c] = textures[key][c];
                    }
                }
                this._placeholderTextures[key].unlock();
            }
        },

        patch: function (asset, assets) {
            // in an engine-only environment we manually copy the source data into the asset
            if (asset.resource._data) {
                asset._data = asset.resource._data; // use _data to avoid firing events
                delete asset.resource._data; // remove from temp storage
            }

            // patch the name of the asset over the material name property
            asset.data.name = asset.name;
            asset.resource.name = asset.name;

            this._bindAndAssignAssets(asset, assets);

            asset.off('unload', this._onAssetUnload, this);
            asset.on('unload', this._onAssetUnload, this);
        },

        _onAssetUnload: function (asset) {
            // remove the parameter block we created which includes texture references
            delete asset.data.parameters;
            delete asset.data.chunks;
            delete asset.data.name;
        },

        _assignTexture: function (parameterName, materialAsset, texture) {
            materialAsset.data[parameterName] = texture;
            materialAsset.resource[parameterName] = texture;
        },

        // assign a placeholder texture while waiting for one to load
        // placeholder textures do not replace the data[parameterName] value
        // in the asset.data thus preserving the final asset id until it is loaded
        _assignPlaceholderTexture: function (parameterName, materialAsset) {
            // create placeholder textures on-demand
            if (!this._placeholderTextures) {
                this._createPlaceholders();
            }

            var placeholder = PLACEHOLDER_MAP[parameterName];
            var texture = this._placeholderTextures[placeholder];

            materialAsset.resource[parameterName] = texture;
        },

        _onTextureLoad: function (parameterName, materialAsset, textureAsset) {
            this._assignTexture(parameterName, materialAsset, textureAsset.resource);
            materialAsset.resource.update();
        },

        _onTextureAdd: function (parameterName, materialAsset, textureAsset) {
            this._assets.load(textureAsset);
        },

        _onTextureRemove: function (parameterName, materialAsset, textureAsset) {
            var material = materialAsset.resource;

            if (material[parameterName] === textureAsset.resource) {
                this._assignTexture(parameterName, materialAsset, null);
                material.update();
            }
        },

        _assignCubemap: function (parameterName, materialAsset, textures) {
            materialAsset.data[parameterName] = textures[0]; // the primary cubemap texture
            if (textures.length === 7) {
                // the prefiltered textures
                materialAsset.data.prefilteredCubeMap128 = textures[1];
                materialAsset.data.prefilteredCubeMap64 = textures[2];
                materialAsset.data.prefilteredCubeMap32 = textures[3];
                materialAsset.data.prefilteredCubeMap16 = textures[4];
                materialAsset.data.prefilteredCubeMap8 = textures[5];
                materialAsset.data.prefilteredCubeMap4 = textures[6];
            }
        },

        _onCubemapLoad: function (parameterName, materialAsset, cubemapAsset) {
            this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
            this._parser.initialize(materialAsset.resource, materialAsset.data);
        },

        _onCubemapAdd: function (parameterName, materialAsset, cubemapAsset) {
            // phong based - so ensure we load individual faces
            if (materialAsset.data.shadingModel === SPECULAR_PHONG) {
                materialAsset.loadFaces = true;
            }

            this._assets.load(cubemapAsset);
        },

        _onCubemapRemove: function (parameterName, materialAsset, cubemapAsset) {
            var material = materialAsset.resource;

            if (material[parameterName] === cubemapAsset.resource) {
                this._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);
                material.update();
            }
        },

        _bindAndAssignAssets: function (materialAsset, assets) {
            // always migrate before updating material from asset data
            var data = this._parser.migrate(materialAsset.data);

            var material = materialAsset.resource;

            var pathMapping = (data.mappingFormat === "path");

            var TEXTURES = standardMaterialTextureParameters;

            var i, name, assetReference;
            // iterate through all texture parameters
            for (i = 0; i < TEXTURES.length; i++) {
                name = TEXTURES[i];

                assetReference = material._assetReferences[name];

                // data[name] contains an asset id for a texture
                if (data[name] && !(data[name] instanceof Texture)) {
                    if (!assetReference) {
                        assetReference = new AssetReference(name, materialAsset, assets, {
                            load: this._onTextureLoad,
                            add: this._onTextureAdd,
                            remove: this._onTextureRemove
                        }, this);

                        material._assetReferences[name] = assetReference;
                    }

                    if (pathMapping) {
                        // texture paths are measured from the material directory
                        assetReference.url = materialAsset.getAbsoluteUrl(data[name]);
                    } else {
                        assetReference.id = data[name];
                    }

                    if (assetReference.asset) {
                        if (assetReference.asset.resource) {
                            // asset is already loaded
                            this._assignTexture(name, materialAsset, assetReference.asset.resource);
                        } else {
                            this._assignPlaceholderTexture(name, materialAsset);
                        }

                        assets.load(assetReference.asset);
                    }
                } else {
                    if (assetReference) {
                        // texture has been removed
                        if (pathMapping) {
                            assetReference.url = null;
                        } else {
                            assetReference.id = null;
                        }
                    }
                }
            }

            var CUBEMAPS = standardMaterialCubemapParameters;

            // iterate through all cubemap parameters
            for (i = 0; i < CUBEMAPS.length; i++) {
                name = CUBEMAPS[i];

                assetReference = material._assetReferences[name];

                // data[name] contains an asset id for a cubemap
                if (data[name] && !(data[name] instanceof Texture)) {
                    if (!assetReference) {
                        assetReference = new AssetReference(name, materialAsset, assets, {
                            load: this._onCubemapLoad,
                            add: this._onCubemapAdd,
                            remove: this._onCubemapRemove
                        }, this);

                        material._assetReferences[name] = assetReference;
                    }

                    if (pathMapping) {
                        assetReference.url = data[name];
                    } else {
                        assetReference.id = data[name];
                    }

                    if (assetReference.asset) {
                        if (assetReference.asset.resource) {
                            // asset loaded
                            this._assignCubemap(name, materialAsset, assetReference.asset.resources);
                        }

                        assets.load(assetReference.asset);
                    }
                }


            }

            // call to re-initialize material after all textures assigned
            this._parser.initialize(material, data);
        }
    });

    function GlbModelParser(device) {
        this._device = device;
        this._defaultMaterial = getDefaultMaterial();
    }

    Object.assign(GlbModelParser.prototype, {
        parse: function (data) {
            var glb = GlbParser.parse("filename.glb", data, this._device);
            if (!glb) {
                return null;
            }
            return GlbParser.createModel(glb, this._defaultMaterial);
        }
    });

    function PartitionedVertex() {
        this.index = 0;
        this.boneIndices = [0, 0, 0, 0];
    }

    function SkinPartition() {
        this.partition = 0;
        this.vertexStart = 0;
        this.vertexCount = 0;
        this.indexStart = 0;
        this.indexCount = 0;

        // Indices of bones in this partition. skin matrices will be uploaded to the vertex shader in this order.
        this.boneIndices = [];

        // Partitioned vertex attributes
        this.vertices = [];
        // Partitioned vertex indices
        this.indices = [];
        // Maps the index of an un-partitioned vertex to that same vertex if it has been added
        // to this particular partition. speeds up checking for duplicate vertices so we don't
        // add the same vertex more than once.
        this.indexMap = {};
    }

    Object.assign(SkinPartition.prototype, {
        addVertex: function (vertex, idx, vertexArray) {
            var remappedIndex = -1;
            if (this.indexMap[idx] !== undefined) {
                remappedIndex = this.indexMap[idx];
                this.indices.push(remappedIndex);
            } else {
                // Create new partitioned vertex
                for (var influence = 0; influence < 4; influence++ ) {
                    if (vertexArray.blendWeight.data[idx * 4 + influence] === 0)
                        continue;

                    var originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];
                    vertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);
                }
                remappedIndex = this.vertices.length;
                this.indices.push(remappedIndex);
                this.vertices.push(vertex);
                this.indexMap[idx] = remappedIndex;
            }
        },

        addPrimitive: function (vertices, vertexIndices, vertexArray, boneLimit) {
            // Build a list of all the bones used by the vertex that aren't currently in this partition
            var i, j;
            var bonesToAdd = [];
            var bonesToAddCount = 0;
            var vertexCount = vertices.length;
            for (i = 0; i < vertexCount; i++) {
                var vertex = vertices[i];
                var idx = vertex.index;
                for (var influence = 0; influence < 4; influence++) {
                    if (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {
                        var boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];
                        var needToAdd = true;
                        for (j = 0; j < bonesToAddCount; j++) {
                            if (bonesToAdd[j] == boneIndex) {
                                needToAdd = false;
                                break;
                            }
                        }
                        if (needToAdd) {
                            bonesToAdd[bonesToAddCount] = boneIndex;
                            var boneRemap = this.getBoneRemap(boneIndex);
                            bonesToAddCount += (boneRemap === -1 ? 1 : 0);
                        }
                    }
                }
            }

            // Check that we can fit more bones in this partition.
            if ((this.boneIndices.length + bonesToAddCount) > boneLimit) {
                return false;
            }

            // Add bones
            for (i = 0; i < bonesToAddCount; i++) {
                this.boneIndices.push(bonesToAdd[i]);
            }

            // Add vertices and indices
            for (i = 0; i < vertexCount; i++) {
                this.addVertex(vertices[i], vertexIndices[i], vertexArray);
            }

            return true;
        },

        getBoneRemap: function (boneIndex) {
            for (var i = 0; i < this.boneIndices.length; i++ ) {
                if (this.boneIndices[i] === boneIndex) {
                    return i;
                }
            }
            return -1;
        }
    });

    function indicesToReferences(model) {
        var i;
        var vertices = model.vertices;
        var skins = model.skins;
        var meshes = model.meshes;
        var meshInstances = model.meshInstances;

        for (i = 0; i < meshes.length; i++) {
            meshes[i].vertices = vertices[meshes[i].vertices];
            if (meshes[i].skin !== undefined) {
                meshes[i].skin = skins[meshes[i].skin];
            }
        }
        for (i = 0; i < meshInstances.length; i++) {
            meshInstances[i].mesh = meshes[meshInstances[i].mesh];
        }
    }

    function referencesToIndices(model) {
        var i;
        var vertices = model.vertices;
        var skins = model.skins;
        var meshes = model.meshes;
        var meshInstances = model.meshInstances;

        for (i = 0; i < meshes.length; i++) {
            meshes[i].vertices = vertices.indexOf(meshes[i].vertices);
            if (meshes[i].skin !== undefined) {
                meshes[i].skin = skins.indexOf(meshes[i].skin);
            }
        }
        for (i = 0; i < meshInstances.length; i++) {
            meshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);
        }
    }

    function partitionSkin(model, materialMappings, boneLimit) {
        var i, j, k, index;

        // Replace object indices with actual object references
        // This simplifies insertion/removal of array items
        indicesToReferences(model);

        var vertexArrays = model.vertices;
        var skins = model.skins;
        var mesh;
        var meshes = model.meshes;
        var meshInstances = model.meshInstances;

        var getVertex = function (idx) {
            var vert = new PartitionedVertex();
            vert.index = idx;
            return vert;
        };

        for (i = skins.length - 1; i >= 0; i--) {
            // This skin exceeds the bone limit. Split it!
            if (skins[i].boneNames.length > boneLimit) {
                var skin = skins.splice(i, 1)[0];

                // Build a list of meshes that use this skin
                var meshesToSplit = [];
                for (j = 0; j < meshes.length; j++) {
                    if (meshes[j].skin === skin) {
                        meshesToSplit.push(meshes[j]);
                    }
                }
                // Remove meshes from source array
                for (j = 0; j < meshesToSplit.length; j++) {
                    index = meshes.indexOf(meshesToSplit[j]);
                    if (index !== -1) {
                        meshes.splice(index, 1);
                    }
                }

                // Error handling
                if (meshesToSplit.length === 0) {
                    throw new Error('partitionSkin: There should be at least one mesh that references a skin');
                }

                var vertexArray = meshesToSplit[0].vertices;
                for (j = 1; j < meshesToSplit.length; j++) {
                    if (meshesToSplit[j].vertices !== vertexArray) {
                        throw new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');
                    }
                }

                var partition;
                var partitions = [];

                // Phase 1:
                // Build the skin partitions
                // Go through index list and extract primitives and add them to bone partitions
                // Since we are working with a single triangle list, everything is a triangle
                var primitiveVertices = [];
                var primitiveIndices = [];
                var basePartition = 0;

                for (j = 0; j < meshesToSplit.length; j++) {
                    mesh = meshesToSplit[j];
                    var indices = mesh.indices;
                    for (var iIndex = mesh.base; iIndex < mesh.base + mesh.count; ) {
                        // Extract primitive
                        // Convert vertices
                        // There is a little bit of wasted time here if the vertex was already added previously
                        index = indices[iIndex++];
                        primitiveVertices[0] = getVertex(index);
                        primitiveIndices[0] = index;

                        index = indices[iIndex++];
                        primitiveVertices[1] = getVertex(index);
                        primitiveIndices[1] = index;

                        index = indices[iIndex++];
                        primitiveVertices[2] = getVertex(index);
                        primitiveIndices[2] = index;

                        // Attempt to add the primitive to an existing bone partition
                        var added = false;
                        for (var iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {
                            partition = partitions[iBonePartition];
                            if (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {
                                added = true;
                                break;
                            }
                        }

                        // If the primitive was not added to an existing bone partition, we need to make a new bone partition and add the primitive to it
                        if (!added) {
                            partition = new SkinPartition();
                            partition.originalMesh = mesh;
                            partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);
                            partitions.push(partition);
                        }
                    }

                    basePartition = partitions.length;
                }

                // Phase 2:
                // Gather vertex and index lists from all the partitions, then upload to GPU
                var partitionedVertices = [];
                var partitionedIndices = [];

                for (j = 0; j < partitions.length; j++) {
                    partition = partitions[j];

                    if (partition.vertices.length && partition.indices.length) {
                        // this bone partition contains vertices and indices

                        // Find offsets
                        var vertexStart = partitionedVertices.length;
                        var vertexCount = partition.vertices.length;
                        var indexStart = partitionedIndices.length;
                        var indexCount = partition.indices.length;

                        // Make a new sub set
                        partition.partition = j;
                        partition.vertexStart = vertexStart;
                        partition.vertexCount = vertexCount;
                        partition.indexStart = indexStart;
                        partition.indexCount = indexCount;

                        // Copy buffers
                        var iSour;
                        var iDest;

                        // Copy vertices to final list
                        iSour = 0;
                        iDest = vertexStart;
                        while (iSour < vertexCount) {
                            partitionedVertices[iDest++] = partition.vertices[iSour++];
                        }

                        // Copy indices to final list
                        iSour = 0;
                        iDest = indexStart;
                        while (iSour < indexCount) {
                            partitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;    // adjust so they reference into flat vertex list
                        }
                    }
                }

                // Phase 3:
                // Create the split skins
                var splitSkins = [];
                for (j = 0; j < partitions.length; j++) {
                    partition = partitions[j];

                    var ibp = [];
                    var boneNames = [];
                    for (k = 0; k < partition.boneIndices.length; k++) {
                        ibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);
                        boneNames.push(skin.boneNames[partition.boneIndices[k]]);
                    }

                    var splitSkin = {
                        inverseBindMatrices: ibp,
                        boneNames: boneNames
                    };
                    splitSkins.push(splitSkin);
                    skins.push(splitSkin);
                }

                // Phase 4

                // Create a partitioned vertex array
                var attrib, attribName, data, components;
                var splitVertexArray = {};

                // Create a vertex array of the same format as the input to take partitioned vertex data
                for (attribName in vertexArray) {
                    splitVertexArray[attribName] = {
                        components: vertexArray[attribName].components,
                        data: [],
                        type: vertexArray[attribName].type
                    };
                }

                // Copy across the vertex data. Everything is the same as the source data except the remapped
                // bone indices
                for (attribName in vertexArray) {
                    if (attribName === 'blendIndices') {
                        var dstBoneIndices = splitVertexArray[attribName].data;
                        for (j = 0; j < partitionedVertices.length; j++) {
                            var srcBoneIndices = partitionedVertices[j].boneIndices;
                            dstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);
                        }
                    } else {
                        attrib = vertexArray[attribName];
                        data = attrib.data;
                        components = attrib.components;
                        for (j = 0; j < partitionedVertices.length; j++) {
                            index = partitionedVertices[j].index;
                            for (k = 0; k < components; k++) {
                                splitVertexArray[attribName].data.push(data[index * components + k]);
                            }
                        }
                    }
                }

                // Replace original vertex array with split one
                vertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;

                // Phase 5

                // Build new mesh array
                for (j = 0; j < partitions.length; j++) {
                    partition = partitions[j];

                    mesh = {
                        aabb: {
                            min: [0, 0, 0],
                            max: [0, 0, 0]
                        },
                        vertices: splitVertexArray,
                        skin: splitSkins[j],
                        indices: partitionedIndices.splice(0, partition.indexCount),
                        type: 'triangles',
                        base: 0,
                        count: partition.indexCount
                    };

                    meshes.push(mesh);

                    // Find all the original mesh instances that referred to the pre-split mesh
                    for (k = meshInstances.length - 1; k >= 0; k--) {
                        if (meshInstances[k].mesh === partition.originalMesh) {
                            meshInstances.push({
                                mesh: mesh,
                                node: meshInstances[k].node
                            });
                            if (materialMappings) {
                                materialMappings.push({
                                    material: materialMappings[k].material,
                                    path: materialMappings[k].path
                                });
                            }
                        }
                    }
                }

                for (j = 0; j < partitions.length; j++) {
                    partition = partitions[j];

                    // Find all the original mesh instances that referred to the pre-split mesh
                    for (k = meshInstances.length - 1; k >= 0; k--) {
                        if (meshInstances[k].mesh === partition.originalMesh) {
                            meshInstances.splice(k, 1);
                            if (materialMappings) {
                                materialMappings.splice(k, 1);
                            }
                        }
                    }
                }
            }
        }

        // Convert references back to indices
        referencesToIndices(model);
    }

    var JSON_PRIMITIVE_TYPE = {
        "points": PRIMITIVE_POINTS,
        "lines": PRIMITIVE_LINES,
        "lineloop": PRIMITIVE_LINELOOP,
        "linestrip": PRIMITIVE_LINESTRIP,
        "triangles": PRIMITIVE_TRIANGLES,
        "trianglestrip": PRIMITIVE_TRISTRIP,
        "trianglefan": PRIMITIVE_TRIFAN
    };

    var JSON_VERTEX_ELEMENT_TYPE = {
        "int8": TYPE_INT8,
        "uint8": TYPE_UINT8,
        "int16": TYPE_INT16,
        "uint16": TYPE_UINT16,
        "int32": TYPE_INT32,
        "uint32": TYPE_UINT32,
        "float32": TYPE_FLOAT32
    };

    // Take PlayCanvas JSON model data and create pc.Model
    function JsonModelParser(device) {
        this._device = device;
        this._defaultMaterial = getDefaultMaterial();
    }

    Object.assign(JsonModelParser.prototype, {
        parse: function (data) {
            var modelData = data.model;
            if (!modelData) {
                return null;
            }

            if (modelData.version <= 1) {
                return null;
            }

            // NODE HIERARCHY
            var nodes = this._parseNodes(data);

            // SKINS
            var skins = this._parseSkins(data, nodes);

            // VERTEX BUFFERS
            var vertexBuffers = this._parseVertexBuffers(data);

            // INDEX BUFFER
            var indices = this._parseIndexBuffers(data, vertexBuffers);

            // MORPHS
            var morphs = this._parseMorphs(data, nodes, vertexBuffers);

            // MESHES
            var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);

            // MESH INSTANCES
            var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);

            var model = new Model();
            model.graph = nodes[0];
            model.meshInstances = meshInstances;
            model.skinInstances = skins.instances;
            model.morphInstances = morphs.instances;
            model.getGraph().syncHierarchy();

            return model;
        },

        _parseNodes: function (data) {
            var modelData = data.model;
            var nodes = [];
            var i;

            for (i = 0; i < modelData.nodes.length; i++) {
                var nodeData = modelData.nodes[i];

                var node = new GraphNode(nodeData.name);
                node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
                node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
                node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
                node.scaleCompensation = !!nodeData.scaleCompensation;

                nodes.push(node);
            }

            for (i = 1; i < modelData.parents.length; i++) {
                nodes[modelData.parents[i]].addChild(nodes[i]);
            }

            return nodes;
        },

        _parseSkins: function (data, nodes) {
            var modelData = data.model;
            var skins = [];
            var skinInstances = [];
            var i, j;

            if (!this._device.supportsBoneTextures && modelData.skins.length > 0) {
                var boneLimit = this._device.getBoneLimit();
                partitionSkin(modelData, null, boneLimit);
            }

            for (i = 0; i < modelData.skins.length; i++) {
                var skinData = modelData.skins[i];

                var inverseBindMatrices = [];
                for (j = 0; j < skinData.inverseBindMatrices.length; j++) {
                    var ibm = skinData.inverseBindMatrices[j];
                    inverseBindMatrices[j] = new Mat4().set(ibm);
                }

                var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
                skins.push(skin);

                var skinInstance = new SkinInstance(skin);
                // Resolve bone IDs to actual graph nodes
                var bones = [];
                for (j = 0; j < skin.boneNames.length; j++) {
                    var boneName = skin.boneNames[j];
                    var bone = nodes[0].findByName(boneName);
                    bones.push(bone);
                }
                skinInstance.bones = bones;
                skinInstances.push(skinInstance);
            }

            return {
                skins: skins,
                instances: skinInstances
            };
        },

        // find number of vertices used by a mesh that is using morph target with index morphIndex
        _getMorphVertexCount: function (modelData, morphIndex, vertexBuffers) {
            for (var i = 0; i < modelData.meshes.length; i++) {
                var meshData = modelData.meshes[i];

                if (meshData.morph === morphIndex) {
                    var vertexBuffer = vertexBuffers[meshData.vertices];
                    return vertexBuffer.numVertices;
                }
            }
            return undefined;
        },

        _parseMorphs: function (data, nodes, vertexBuffers) {
            var modelData = data.model;
            var morphs = [];
            var morphInstances = [];
            var i, j, vertexCount;

            var targets, morphTarget, morphTargetArray;

            if (modelData.morphs) {

                // convert sparse morph target vertex data to full format
                var sparseToFull = function (data, indices, totalCount) {
                    var full = new Float32Array(totalCount * 3);
                    for (var s = 0; s < indices.length; s++) {
                        var dstIndex = indices[s] * 3;
                        full[dstIndex] = data[s * 3];
                        full[dstIndex + 1] = data[s * 3 + 1];
                        full[dstIndex + 2] = data[s * 3 + 2];
                    }
                    return full;
                };

                for (i = 0; i < modelData.morphs.length; i++) {
                    targets = modelData.morphs[i].targets;
                    morphTargetArray = [];

                    // total number of verticies of the mesh
                    vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);

                    for (j = 0; j < targets.length; j++) {
                        var targetAabb = targets[j].aabb;

                        var min = targetAabb.min;
                        var max = targetAabb.max;
                        var aabb = new BoundingBox(
                            new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5),
                            new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5)
                        );

                        // convert sparse to full format
                        var indices = targets[j].indices;
                        var deltaPositions = targets[j].deltaPositions;
                        var deltaNormals = targets[j].deltaNormals;
                        if (indices) {
                            deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
                            deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
                        }

                        morphTarget = new MorphTarget(this._device, { deltaPositions: deltaPositions,
                            deltaNormals: deltaNormals,
                            name: targets[j].name,
                            aabb: aabb });

                        morphTargetArray.push(morphTarget);
                    }

                    var morph = new Morph(morphTargetArray);
                    morphs.push(morph);

                    var morphInstance = new MorphInstance(morph);
                    morphInstances.push(morphInstance);
                }
            }

            return {
                morphs: morphs,
                instances: morphInstances
            };
        },

        _parseVertexBuffers: function (data) {
            var modelData = data.model;
            var vertexBuffers = [];
            var attribute, attributeName;
            var attributeMap = {
                position: SEMANTIC_POSITION,
                normal: SEMANTIC_NORMAL,
                tangent: SEMANTIC_TANGENT,
                blendWeight: SEMANTIC_BLENDWEIGHT,
                blendIndices: SEMANTIC_BLENDINDICES,
                color: SEMANTIC_COLOR,
                texCoord0: SEMANTIC_TEXCOORD0,
                texCoord1: SEMANTIC_TEXCOORD1,
                texCoord2: SEMANTIC_TEXCOORD2,
                texCoord3: SEMANTIC_TEXCOORD3,
                texCoord4: SEMANTIC_TEXCOORD4,
                texCoord5: SEMANTIC_TEXCOORD5,
                texCoord6: SEMANTIC_TEXCOORD6,
                texCoord7: SEMANTIC_TEXCOORD7
            };

            var i, j;
            for (i = 0; i < modelData.vertices.length; i++) {
                var vertexData = modelData.vertices[i];

                var formatDesc = [];
                for (attributeName in vertexData) {
                    attribute = vertexData[attributeName];

                    formatDesc.push({
                        semantic: attributeMap[attributeName],
                        components: attribute.components,
                        type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
                        normalize: (attributeMap[attributeName] === SEMANTIC_COLOR)
                    });
                }
                var vertexFormat = new VertexFormat(this._device, formatDesc);

                // Create the vertex buffer
                var numVertices = vertexData.position.data.length / vertexData.position.components;
                var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);

                var iterator = new VertexIterator(vertexBuffer);
                for (j = 0; j < numVertices; j++) {
                    for (attributeName in vertexData) {
                        attribute = vertexData[attributeName];

                        switch (attribute.components) {
                            case 1:
                                iterator.element[attributeMap[attributeName]].set(attribute.data[j]);
                                break;
                            case 2:
                                iterator.element[attributeMap[attributeName]].set(attribute.data[j * 2], attribute.data[j * 2 + 1]);
                                break;
                            case 3:
                                iterator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);
                                break;
                            case 4:
                                iterator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);
                                break;
                        }
                    }
                    iterator.next();
                }
                iterator.end();

                vertexBuffers.push(vertexBuffer);
            }

            return vertexBuffers;
        },

        _parseIndexBuffers: function (data, vertexBuffers) {
            var modelData = data.model;
            var indexBuffer = null;
            var indexData = null;
            var i;

            // Count the number of indices in the model
            var numIndices = 0;
            for (i = 0; i < modelData.meshes.length; i++) {
                var meshData = modelData.meshes[i];
                if (meshData.indices !== undefined) {
                    numIndices += meshData.indices.length;
                }
            }

            // Create an index buffer big enough to store all indices in the model
            var maxVerts = 0;
            for (i = 0; i < vertexBuffers.length; i++) {
                maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
            }
            if (numIndices > 0) {
                if (maxVerts > 0xFFFF && this._device.extUintElement) {
                    indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
                    indexData = new Uint32Array(indexBuffer.lock());
                } else {
                    indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
                    indexData = new Uint16Array(indexBuffer.lock());
                }
            }

            return {
                buffer: indexBuffer,
                data: indexData
            };
        },

        _parseMeshes: function (data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
            var modelData = data.model;

            var meshes = [];
            var indexBase = 0;
            var i;

            for (i = 0; i < modelData.meshes.length; i++) {
                var meshData = modelData.meshes[i];

                var meshAabb = meshData.aabb;
                var min = meshAabb.min;
                var max = meshAabb.max;
                var aabb = new BoundingBox(
                    new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5),
                    new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5)
                );

                var indexed = (meshData.indices !== undefined);
                var mesh = new Mesh(this._device);
                mesh.vertexBuffer = vertexBuffers[meshData.vertices];
                mesh.indexBuffer[0] = indexed ? indexBuffer : null;
                mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
                mesh.primitive[0].base = indexed ? (meshData.base + indexBase) : meshData.base;
                mesh.primitive[0].count = meshData.count;
                mesh.primitive[0].indexed = indexed;
                mesh.skin = (meshData.skin !== undefined) ? skins[meshData.skin] : null;
                mesh.morph = (meshData.morph !== undefined) ? morphs[meshData.morph] : null;
                mesh.aabb = aabb;

                if (indexed) {
                    // Create the index buffer
                    indexData.set(meshData.indices, indexBase);
                    indexBase += meshData.indices.length;
                }

                meshes.push(mesh);
            }

            if (indexBuffer !== null) {
                indexBuffer.unlock();
            }

            return meshes;
        },

        _parseMeshInstances: function (data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
            var modelData = data.model;
            var meshInstances = [];
            var i;

            for (i = 0; i < modelData.meshInstances.length; i++) {
                var meshInstanceData = modelData.meshInstances[i];

                var node = nodes[meshInstanceData.node];
                var mesh = meshes[meshInstanceData.mesh];

                var meshInstance = new MeshInstance(node, mesh, this._defaultMaterial);

                if (mesh.skin) {
                    var skinIndex = skins.indexOf(mesh.skin);
                    meshInstance.skinInstance = skinInstances[skinIndex];
                }

                if (mesh.morph) {
                    var morphIndex = morphs.indexOf(mesh.morph);
                    meshInstance.morphInstance = morphInstances[morphIndex];
                }

                meshInstances.push(meshInstance);
            }

            return meshInstances;
        }
    });

    /**
     * @class
     * @name pc.ModelHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Model} resources.
     * @param {pc.GraphicsDevice} device - The graphics device that will be rendering.
     * @param {pc.StandardMaterial} defaultMaterial - The shared default material that is used in any place that a material is not specified.
     */
    function ModelHandler(device, defaultMaterial) {
        this._device = device;
        this._parsers = [];
        this._defaultMaterial = defaultMaterial;
        this.retryRequests = false;

        this.addParser(new JsonModelParser(this._device), function (url, data) {
            return (path.getExtension(url) === '.json');
        });
        this.addParser(new GlbModelParser(this._device), function (url, data) {
            return (path.getExtension(url) === '.glb');
        });
    }

    Object.assign(ModelHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // we need to specify JSON for blob URLs
            var options = {
                retry: this.retryRequests
            };

            if (url.load.startsWith('blob:')) {
                if (path.getExtension(url.original).toLowerCase() === '.glb') {
                    options.responseType = Http.ResponseType.ARRAY_BUFFER;
                } else {
                    options.responseType = Http.ResponseType.JSON;
                }
            }

            http.get(url.load, options, function (err, response) {
                if (!callback)
                    return;

                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading model: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            for (var i = 0; i < this._parsers.length; i++) {
                var p = this._parsers[i];

                if (p.decider(url, data)) {
                    return p.parser.parse(data);
                }
            }
            return null;
        },

        patch: function (asset, assets) {
            if (!asset.resource)
                return;

            var data = asset.data;

            var self = this;
            asset.resource.meshInstances.forEach(function (meshInstance, i) {
                if (data.mapping) {
                    var handleMaterial = function (asset) {
                        if (asset.resource) {
                            meshInstance.material = asset.resource;
                        } else {
                            asset.once('load', handleMaterial);
                            assets.load(asset);
                        }

                        asset.once('remove', function (asset) {
                            if (meshInstance.material === asset.resource) {
                                meshInstance.material = self._defaultMaterial;
                            }
                        });
                    };

                    if (!data.mapping[i]) {
                        meshInstance.material = self._defaultMaterial;
                        return;
                    }

                    var id = data.mapping[i].material;
                    var url = data.mapping[i].path;
                    var material;

                    if (id !== undefined) { // id mapping
                        if (!id) {
                            meshInstance.material = self._defaultMaterial;
                        } else {
                            material = assets.get(id);
                            if (material) {
                                handleMaterial(material);
                            } else {
                                assets.once('add:' + id, handleMaterial);
                            }
                        }
                    } else if (url) {
                        // url mapping
                        var path = asset.getAbsoluteUrl(data.mapping[i].path);
                        material = assets.getByUrl(path);

                        if (material) {
                            handleMaterial(material);
                        } else {
                            assets.once('add:url:' + path, handleMaterial);
                        }
                    }
                }
            });
        },

        /**
         * @function
         * @name pc.ModelHandler#addParser
         * @description Add a parser that converts raw data into a {@link pc.Model}
         * Default parser is for JSON models.
         * @param {object} parser - See JsonModelParser for example.
         * @param {pc.callbacks.AddParser} decider - Function that decides on which parser to use.
         * Function should take (url, data) arguments and return true if this parser should be used to parse the data into a {@link pc.Model}.
         * The first parser to return true is used.
         */
        addParser: function (parser, decider) {
            this._parsers.push({
                parser: parser,
                decider: decider
            });
        }
    });

    /**
     * @class
     * @name pc.ResourceLoader
     * @param {pc.Application} app - The application.
     * @classdesc Load resource data, potentially from remote sources. Caches resource on load to prevent
     * multiple requests. Add ResourceHandlers to handle different types of resources.
     */
    function ResourceLoader(app) {
        this._handlers = {};
        this._requests = {};
        this._cache = {};
        this._app = app;
    }

    Object.assign(ResourceLoader.prototype, {
        /**
         * @function
         * @name pc.ResourceLoader#addHandler
         * @description Add a {@link pc.ResourceHandler} for a resource type. Handler should support atleast load() and open().
         * Handlers can optionally support patch(asset, assets) to handle dependencies on other assets.
         * @param {string} type - The name of the resource type that the handler will be registerd with. Can be:
         *
         * * {@link pc.ASSET_ANIMATION}
         * * {@link pc.ASSET_AUDIO}
         * * {@link pc.ASSET_IMAGE}
         * * {@link pc.ASSET_JSON}
         * * {@link pc.ASSET_MODEL}
         * * {@link pc.ASSET_MATERIAL}
         * * {@link pc.ASSET_TEXT}
         * * {@link pc.ASSET_TEXTURE}
         * * {@link pc.ASSET_CUBEMAP}
         * * {@link pc.ASSET_SHADER}
         * * {@link pc.ASSET_CSS}
         * * {@link pc.ASSET_HTML}
         * * {@link pc.ASSET_SCRIPT}
         * * {@link pc.ASSET_CONTAINER}
         *
         * @param {pc.ResourceHandler} handler - An instance of a resource handler supporting atleast load() and open().
         * @example
         * var loader = new ResourceLoader();
         * loader.addHandler("json", new pc.JsonHandler());
         */
        addHandler: function (type, handler) {
            this._handlers[type] = handler;
            handler._loader = this;
        },

        /**
         * @function
         * @name pc.ResourceLoader#removeHandler
         * @description Remove a {@link pc.ResourceHandler} for a resource type.
         * @param {string} type - The name of the type that the handler will be removed.
         */
        removeHandler: function (type) {
            delete this._handlers[type];
        },

        /**
         * @function
         * @name pc.ResourceLoader#getHandler
         * @description Get a {@link pc.ResourceHandler} for a resource type.
         * @param {string} type - The name of the resource type that the handler is registerd with.
         * @returns {pc.ResourceHandler} The registerd handler.
         */
        getHandler: function (type) {
            return this._handlers[type];
        },

        /**
         * @function
         * @name pc.ResourceLoader#load
         * @description Make a request for a resource from a remote URL. Parse the returned data using the
         * handler for the specified type. When loaded and parsed, use the callback to return an instance of
         * the resource.
         * @param {string} url - The URL of the resource to load.
         * @param {string} type - The type of resource expected.
         * @param {pc.callbacks.ResourceLoader} callback - The callback used when the resource is loaded or an error occurs.
         * @param {pc.Asset} [asset] - Optional asset that is passed into handler
         * Passed (err, resource) where err is null if there are no errors.
         * @example
         * app.loader.load("../path/to/texture.png", "texture", function (err, texture) {
         *     // use texture here
         * });
         */
        load: function (url, type, callback, asset) {
            var handler = this._handlers[type];
            if (!handler) {
                var err = "No handler for asset type: " + type;
                callback(err);
                return;
            }

            var key = url + type;

            if (this._cache[key] !== undefined) {
                // in cache
                callback(null, this._cache[key]);
            } else if (this._requests[key]) {
                // existing request
                this._requests[key].push(callback);
            } else {
                // new request
                this._requests[key] = [callback];

                var self = this;

                var handleLoad = function (err, urlObj) {
                    if (err) {
                        self._onFailure(key, err);
                        return;
                    }

                    handler.load(urlObj, function (err, data, extra) {
                        // make sure key exists because loader
                        // might have been destroyed by now
                        if (!self._requests[key]) {
                            return;
                        }

                        if (err) {
                            self._onFailure(key, err);
                            return;
                        }

                        try {
                            self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
                        } catch (e) {
                            self._onFailure(key, e);
                        }
                    }, asset);
                };

                var normalizedUrl = url.split('?')[0];
                if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {
                    if (!this._app.bundles.canLoadUrl(normalizedUrl)) {
                        handleLoad('Bundle for ' + url + ' not loaded yet');
                        return;
                    }

                    this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {
                        handleLoad(err, {
                            load: fileUrlFromBundle,
                            original: normalizedUrl
                        });
                    });
                } else {
                    handleLoad(null, {
                        load: url,
                        original: asset && asset.getPreferredFile().filename || url
                    });
                }
            }
        },

        _onSuccess: function (key, result, extra) {
            this._cache[key] = result;
            for (var i = 0; i < this._requests[key].length; i++) {
                this._requests[key][i](null, result, extra);
            }
            delete this._requests[key];
        },

        _onFailure: function (key, err) {
            console.error(err);
            if (this._requests[key]) {
                for (var i = 0; i < this._requests[key].length; i++) {
                    this._requests[key][i](err);
                }
                delete this._requests[key];
            }
        },

        /**
         * @function
         * @name pc.ResourceLoader#open
         * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a pc.Model.
         * @param {string} type - The type of resource.
         * @param {*} data - The raw resource data.
         * @returns {*} The parsed resource data.
         */
        open: function (type, data) {
            var handler = this._handlers[type];
            if (!handler) {
                console.warn("No resource handler found for: " + type);
                return data;
            }

            return handler.open(null, data);

        },

        /**
         * @function
         * @name pc.ResourceLoader#patch
         * @description Perform any operations on a resource, that requires a dependency on its asset data
         * or any other asset data.
         * @param {pc.Asset} asset - The asset to patch.
         * @param {pc.AssetRegistry} assets - The asset registry.
         */
        patch: function (asset, assets) {
            var handler = this._handlers[asset.type];
            if (!handler)  {
                console.warn("No resource handler found for: " + asset.type);
                return;
            }

            if (handler.patch) {
                handler.patch(asset, assets);
            }
        },

        /**
         * @function
         * @name pc.ResourceLoader#clearCache
         * @description Remove resource from cache.
         * @param {string} url - The URL of the resource.
         * @param {string} type - The type of resource.
         */
        clearCache: function (url, type) {
            delete this._cache[url + type];
        },

        /**
         * @function
         * @name pc.ResourceLoader#getFromCache
         * @description Check cache for resource from a URL. If present, return the cached value.
         * @param {string} url - The URL of the resource to get from the cache.
         * @param {string} type - The type of the resource.
         * @returns {*} The resource loaded from the cache.
         */
        getFromCache: function (url, type) {
            if (this._cache[url + type]) {
                return this._cache[url + type];
            }
        },

        /**
         * @private
         * @function
         * @name pc.ResourceLoader#enableRetry
         * @description Enables retrying of failed requests when loading assets.
         */
        enableRetry: function () {
            for (var key in this._handlers) {
                this._handlers[key].retryRequests = true;
            }
        },

        /**
         * @private
         * @function
         * @name pc.ResourceLoader#disableRetry
         * @description Disables retrying of failed requests when loading assets.
         */
        disableRetry: function () {
            for (var key in this._handlers) {
                this._handlers[key].retryRequests = false;
            }
        },

        /**
         * @function
         * @name pc.ResourceLoader#destroy
         * @description Destroys the resource loader.
         */
        destroy: function () {
            this._handlers = {};
            this._requests = {};
            this._cache = {};
        }
    });

    /**
     * @class
     * @name pc.SceneHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Scene} resources.
     * @param {pc.Application} app - The running {@link pc.Application}.
     */
    function SceneHandler(app) {
        this._app = app;
        this.retryRequests = false;
    }

    Object.assign(SceneHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var assets = this._app.assets;

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    TemplateUtils.waitForTemplatesInScene(
                        response,
                        assets,
                        callback);
                } else {
                    var errMsg = 'Error while loading scene ' + url.original;
                    if (err.message) {
                        errMsg += ': ' + err.message;
                        if (err.stack) {
                            errMsg += '\n' + err.stack;
                        }
                    } else {
                        errMsg += ': ' + err;
                    }

                    callback(errMsg);
                }
            });
        },

        open: function (url, data) {
            // prevent script initialization until entire scene is open
            this._app.systems.script.preloading = true;

            var parser = new SceneParser(this._app, false);
            var parent = parser.parse(data);

            // set scene root
            var scene = this._app.scene;
            scene.root = parent;

            this._app.applySceneSettings(data.settings);

            // re-enable script initialization
            this._app.systems.script.preloading = false;

            return scene;
        },

        patch: function (asset, assets) {
        }
    });

    function SceneSettingsHandler(app) {
        this._app = app;
        this.retryRequests = false;
    }

    Object.assign(SceneSettingsHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    var errMsg = 'Error while loading scene settings ' + url.original;
                    if (err.message) {
                        errMsg += ': ' + err.message;
                        if (err.stack) {
                            errMsg += '\n' + err.stack;
                        }
                    } else {
                        errMsg += ': ' + err;
                    }

                    callback(errMsg);
                }
            });
        },

        open: function (url, data) {
            return data.settings;
        }
    });

    /**
     * @name pc.script
     * @namespace
     * @description The pc.script namespace holds the createLoadingScreen function that
     * is used to override the default PlayCanvas loading screen.
     */
    var _legacy = false;

    // flag to avoid creating multiple loading screens e.g. when
    // loading screen scripts are reloaded
    var _createdLoadingScreen = false;

    var script = {
        // set during script load to be used for initializing script
        app: null,

        /**
         * @private
         * @function
         * @name pc.script.create
         * @description Create a script resource object. A script file should contain a single call to pc.script.create and the callback should return a script object which will be
         * instantiated when attached to Entities.
         * @param {string} name - The name of the script object.
         * @param {pc.callbacks.CreateScript} callback - The callback function which is passed an {pc.Application} object,
         * which is used to access Entities and Components, and should return the Type of the script resource
         * to be instanced for each Entity.
         * @example
         * pc.script.create(function (app) {
         *     var Scriptable = function (entity) {
         *         // store entity
         *         this.entity = entity;
         *
         *         // use app
         *         app.components.model.addComponent(entity, {
         *             // component properties
         *         });
         *     };
         *
         *     return Scriptable;
         * });
         */
        create: function (name, callback) {
            if (!_legacy)
                return;

            // get the ScriptType from the callback
            var ScriptType = callback(script.app);

            // store the script name
            ScriptType._pcScriptName = name;

            // Push this onto loading stack
            ScriptHandler._push(ScriptType);

            this.fire("created", name, callback);
        },

        /**
         * @private
         * @function
         * @name pc.script.attribute
         * @description Creates a script attribute for the current script. The script attribute can be accessed
         * inside the script instance like so 'this.attributeName' or outside a script instance like so 'entity.script.attributeName'.
         * Script attributes can be edited from the Attribute Editor of the PlayCanvas Editor like normal Components.
         * @param {string} name - The name of the attribute.
         * @param {string} type - The type of the attribute. Can be: 'number', 'string', 'boolean', 'asset', 'entity', 'rgb', 'rgba', 'vector', 'enumeration', 'curve', 'colorcurve'.
         * @param {object} defaultValue - The default value of the attribute.
         * @param {object} options - Optional parameters for the attribute.
         * @param {number} options.min - The minimum value of the attribute.
         * @param {number} options.max - The maximum value of the attribute.
         * @param {number} options.step - The step that will be used when changing the attribute value in the PlayCanvas Editor.
         * @param {number} options.decimalPrecision - A number that specifies the number of decimal digits allowed for the value.
         * @param {object[]} options.enumerations - An array of name, value pairs from which the user can select one if the attribute type is an enumeration.
         * @param {string[]} options.curves - (For 'curve' attributes only) An array of strings that define the names of each curve in the curve editor.
         * @param {boolean} options.color - (For 'curve' attributes only) If true then the curve attribute will be a color curve.
         * @example
         * pc.script.attribute('speed', 'number', 5);
         * pc.script.attribute('message', 'string', "My message");
         * pc.script.attribute('enemyPosition', 'vector', [1, 0, 0]);
         * pc.script.attribute('spellType', 'enumeration', 0, {
         *     enumerations: [{
         *         name: "Fire",
         *         value: 0
         *     }, {
         *         name: "Ice",
         *         value: 1
         *     }]
         * });
         * pc.script.attribute('enemy', 'entity');
         * pc.script.attribute('enemySpeed', 'curve');
         * pc.script.attribute('enemyPosition', 'curve', null, {
         *     curves: ['x', 'y', 'z']
         * });
         * pc.script.attribute('color', 'colorcurve', null, {
         *     type: 'rgba'
         * });
         *
         * pc.script.create('scriptable', function (app) {
         *     var Scriptable = function (entity) {
         *         // store entity
         *         this.entity = entity;
         *     };
         *
         *     return Scriptable;
         * });
         */
        attribute: function (name, type, defaultValue, options) {
            // only works when parsing the script...
        },

        /**
         * @function
         * @name pc.script.createLoadingScreen
         * @description Handles the creation of the loading screen of the application. A script can subscribe to
         * the events of a {@link pc.Application} to show a loading screen, progress bar etc. In order for this to work
         * you need to set the project's loading screen script to the script that calls this method.
         * @param  {pc.callbacks.CreateScreen} callback - A function which can set up and tear down a customised loading screen.
         * @example
         * pc.script.createLoadingScreen(function (app) {
         *     var showSplashScreen = function () {};
         *     var hideSplashScreen = function () {};
         *     var showProgress = function (progress) {};
         *     app.on("preload:start", showSplashScreen);
         *     app.on("preload:progress", showProgress);
         *     app.on("start", hideSplashScreen);
         * });
         */
        createLoadingScreen: function (callback) {
            if (_createdLoadingScreen)
                return;

            _createdLoadingScreen = true;

            var app = Application.getApplication();
            callback(app);
        }
    };

    Object.defineProperty(script, 'legacy', {
        get: function () {
            return _legacy;
        },
        set: function (value) {
            _legacy = value;
        }
    });

    events.attach(script);

    /**
     * @class
     * @name pc.ScriptHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler for loading JavaScript files dynamically
     * Two types of JavaScript files can be loaded, PlayCanvas scripts which contain calls to {@link pc.createScript},
     * or regular JavaScript files, such as third-party libraries.
     * @param {pc.Application} app - The running {@link pc.Application}.
     */
    function ScriptHandler(app) {
        this._app = app;
        this._scripts = { };
        this._cache = { };
    }

    ScriptHandler._types = [];
    ScriptHandler._push = function (Type) {
        if (script.legacy && ScriptHandler._types.length > 0) {
            console.assert("Script Ordering Error. Contact support@playcanvas.com");
        } else {
            ScriptHandler._types.push(Type);
        }
    };

    Object.assign(ScriptHandler.prototype, {
        load: function (url, callback) {
            // Scripts don't support bundling since we concatenate them. Below is for consistency.
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var self = this;
            script.app = this._app;

            this._loadScript(url.load, function (err, url, extra) {
                if (!err) {
                    if (script.legacy) {
                        var Type = null;
                        // pop the type from the loading stack
                        if (ScriptHandler._types.length) {
                            Type = ScriptHandler._types.pop();
                        }

                        if (Type) {
                            // store indexed by URL
                            this._scripts[url] = Type;
                        } else {
                            Type = null;
                        }

                        // return the resource
                        callback(null, Type, extra);
                    } else {
                        var obj = { };

                        for (var i = 0; i < ScriptHandler._types.length; i++)
                            obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];

                        ScriptHandler._types.length = 0;

                        callback(null, obj, extra);

                        // no cache for scripts
                        delete self._loader._cache[url + 'script'];
                    }
                } else {
                    callback(err);
                }
            }.bind(this));
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) { },

        _loadScript: function (url, callback) {
            var head = document.head;
            var element = document.createElement('script');
            this._cache[url] = element;

            // use async=false to force scripts to execute in order
            element.async = false;

            element.addEventListener('error', function (e) {
                callback("Script: " + e.target.src + " failed to load");
            }, false);

            var done = false;
            element.onload = element.onreadystatechange = function () {
                if (!done && (!this.readyState || (this.readyState == "loaded" || this.readyState == "complete"))) {
                    done = true; // prevent double event firing
                    callback(null, url, element);
                }
            };
            // set the src attribute after the onload callback is set, to avoid an instant loading failing to fire the callback
            element.src = url;

            head.appendChild(element);
        }
    });

    function ShaderHandler() {
        this.retryRequests = false;
    }

    Object.assign(ShaderHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading shader resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    // normals are the same for every mesh
    var spriteNormals = [
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1
    ];

    // indices are the same for every mesh
    var spriteIndices = [
        0, 1, 3,
        2, 3, 1
    ];

    /**
     * @class
     * @name pc.Sprite
     * @augments pc.EventHandler
     * @classdesc A pc.Sprite is contains references to one or more frames of a {@link pc.TextureAtlas}.
     * It can be used by the {@link pc.SpriteComponent} or the {@link pc.ElementComponent} to render a
     * single frame or a sprite animation.
     * @param {pc.GraphicsDevice} device - The graphics device of the application.
     * @param {object} [options] - Options for creating the pc.Sprite.
     * @param {number} [options.pixelsPerUnit] - The number of pixels that map to one PlayCanvas unit.
     * Defaults to 1.
     * @param {number} [options.renderMode] - The rendering mode of the sprite. Can be:
     *
     * * {@link pc.SPRITE_RENDERMODE_SIMPLE}
     * * {@link pc.SPRITE_RENDERMODE_SLICED}
     * * {@link pc.SPRITE_RENDERMODE_TILED}
     *
     * Defaults to pc.SPRITE_RENDERMODE_SIMPLE.
     * @param {pc.TextureAtlas} [options.atlas] - The texture atlas. Defaults to null.
     * @param {string[]} [options.frameKeys] - The keys of the frames in the sprite atlas that this sprite is
     * using. Defaults to null.
     * @property {number} pixelsPerUnit The number of pixels that map to one PlayCanvas unit.
     * @property {pc.TextureAtlas} atlas The texture atlas.
     * @property {number} renderMode The rendering mode of the sprite. Can be:
     *
     * * {@link pc.SPRITE_RENDERMODE_SIMPLE}
     * * {@link pc.SPRITE_RENDERMODE_SLICED}
     * * {@link pc.SPRITE_RENDERMODE_TILED}
     *
     * @property {string[]} frameKeys The keys of the frames in the sprite atlas that this sprite is using.
     * @property {pc.Mesh[]} meshes An array that contains a mesh for each frame.
     */
    function Sprite(device, options) {
        EventHandler.call(this);

        this._device = device;
        this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
        this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
        this._atlas = options && options.atlas !== undefined ? options.atlas : null;
        this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
        this._meshes = [];

        // set to true to update multiple
        // properties without re-creating meshes
        this._updatingProperties = false;
        // if true, endUpdate() will re-create meshes when it's called
        this._meshesDirty = false;

        if (this._atlas && this._frameKeys) {
            this._createMeshes();
        }
    }
    Sprite.prototype = Object.create(EventHandler.prototype);
    Sprite.prototype.constructor = Sprite;

    Sprite.prototype._createMeshes = function () {
        var i, len;

        // destroy old meshes
        for (i = 0, len = this._meshes.length; i < len; i++) {
            var mesh = this._meshes[i];
            if (!mesh) continue;

            mesh.vertexBuffer.destroy();
            for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
                mesh.indexBuffer[j].destroy();
            }
        }

        // clear meshes array
        var count = this._frameKeys.length;
        this._meshes = new Array(count);

        // get function to create meshes
        var createMeshFunc = (this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh);

        // create a mesh for each frame in the sprite
        for (i = 0; i < count; i++) {
            var frame = this._atlas.frames[this._frameKeys[i]];
            this._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;
        }

        this.fire('set:meshes');
    };

    Sprite.prototype._createSimpleMesh = function (frame) {
        var rect = frame.rect;
        var texWidth = this._atlas.texture.width;
        var texHeight = this._atlas.texture.height;

        var w = rect.z / this._pixelsPerUnit;
        var h = rect.w / this._pixelsPerUnit;
        var hp = frame.pivot.x;
        var vp = frame.pivot.y;

        // positions based on pivot and size of frame
        var positions = [
            -hp * w,      -vp * h,      0,
            (1 - hp) * w, -vp * h,      0,
            (1 - hp) * w, (1 - vp) * h, 0,
            -hp * w,      (1 - vp) * h, 0
        ];

        // uvs based on frame rect
        // uvs
        var lu = rect.x / texWidth;
        var bv = rect.y / texHeight;
        var ru = (rect.x + rect.z) / texWidth;
        var tv = (rect.y + rect.w) / texHeight;

        var uvs = [
            lu, bv,
            ru, bv,
            ru, tv,
            lu, tv
        ];

        var mesh = createMesh(this._device, positions, {
            uvs: uvs,
            normals: spriteNormals,
            indices: spriteIndices
        });

        return mesh;
    };

    Sprite.prototype._create9SliceMesh = function () {
        // Check the supplied options and provide defaults for unspecified ones
        var he = Vec2.ONE;
        var ws = 3;
        var ls = 3;

        // Variable declarations
        var i, j;
        var x, y, z, u, v;
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        // Generate plane as follows (assigned UVs denoted at corners):
        // (0,1)x---------x(1,1)
        //      |         |
        //      |         |
        //      |    O--X |length
        //      |    |    |
        //      |    Z    |
        // (0,0)x---------x(1,0)
        // width
        var vcounter = 0;
        for (i = 0; i <= ws; i++) {
            u = (i === 0 || i === ws) ? 0 : 1;

            for (j = 0; j <= ls; j++) {

                x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
                y = 0.0;
                z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);

                v = (j === 0 || j === ls) ? 0 : 1;

                positions.push(-x, y, z);
                normals.push(0.0, 1.0, 0.0);
                uvs.push(u, v);

                if ((i < ws) && (j < ls)) {
                    indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
                    indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
                }

                vcounter++;
            }
        }

        var options = {
            normals: normals, // crashes without normals on mac?
            uvs: uvs,
            indices: indices
        };

        return createMesh(this._device, positions, options);
    };

    Sprite.prototype._onSetFrames = function (frames) {
        if (this._updatingProperties) {
            this._meshesDirty = true;
        } else {
            this._createMeshes();
        }
    };

    Sprite.prototype._onFrameChanged = function (frameKey, frame) {
        var idx = this._frameKeys.indexOf(frameKey);
        if (idx < 0) return;

        if (frame) {
            // only re-create frame for simple render mode, since
            // 9-sliced meshes don't need frame info to create their mesh
            if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
                this._meshes[idx] = this._createSimpleMesh(frame);
            }
        } else {
            this._meshes[idx] = null;
        }

        this.fire('set:meshes');
    };

    Sprite.prototype._onFrameRemoved = function (frameKey) {
        var idx = this._frameKeys.indexOf(frameKey);
        if (idx < 0) return;

        this._meshes[idx] = null;
        this.fire('set:meshes');
    };

    Sprite.prototype.startUpdate = function () {
        this._updatingProperties = true;
        this._meshesDirty = false;
    };

    Sprite.prototype.endUpdate = function () {
        this._updatingProperties = false;
        if (this._meshesDirty && this._atlas && this._frameKeys) {
            this._createMeshes();

        }
        this._meshesDirty = false;
    };

    /**
     * @function
     * @name pc.Sprite#destroy
     * @description Free up the meshes created by the sprite.
     */
    Sprite.prototype.destroy = function () {
        var i;
        var len;

        // destroy old meshes
        for (i = 0, len = this._meshes.length; i < len; i++) {
            var mesh = this._meshes[i];
            if (!mesh) continue;

            mesh.vertexBuffer.destroy();
            for (var j = 0, len2 = mesh.indexBuffer.length; j < len2; j++) {
                mesh.indexBuffer[j].destroy();
            }
        }
        this._meshes.length = 0;
    };

    Object.defineProperty(Sprite.prototype, 'frameKeys', {
        get: function () {
            return this._frameKeys;
        },
        set: function (value) {
            this._frameKeys = value;

            if (this._atlas && this._frameKeys) {
                if (this._updatingProperties) {
                    this._meshesDirty = true;
                } else {
                    this._createMeshes();
                }
            }

            this.fire('set:frameKeys', value);
        }
    });

    Object.defineProperty(Sprite.prototype, 'atlas', {
        get: function () {
            return this._atlas;
        },
        set: function (value) {
            if (value === this._atlas) return;

            if (this._atlas) {
                this._atlas.off('set:frames', this._onSetFrames, this);
                this._atlas.off('set:frame', this._onFrameChanged, this);
                this._atlas.off('remove:frame', this._onFrameRemoved, this);
            }

            this._atlas = value;
            if (this._atlas && this._frameKeys) {
                this._atlas.on('set:frames', this._onSetFrames, this);
                this._atlas.on('set:frame', this._onFrameChanged, this);
                this._atlas.on('remove:frame', this._onFrameRemoved, this);

                if (this._updatingProperties) {
                    this._meshesDirty = true;
                } else {
                    this._createMeshes();
                }
            }

            this.fire('set:atlas', value);
        }
    });

    Object.defineProperty(Sprite.prototype, 'pixelsPerUnit', {
        get: function () {
            return this._pixelsPerUnit;
        },
        set: function (value) {
            if (this._pixelsPerUnit === value) return;

            this._pixelsPerUnit = value;
            this.fire('set:pixelsPerUnit', value);

            // simple mode uses pixelsPerUnit to create the mesh so re-create those meshes
            if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
                if (this._updatingProperties) {
                    this._meshesDirty = true;
                } else {
                    this._createMeshes();
                }
            }

        }
    });

    Object.defineProperty(Sprite.prototype, 'renderMode', {
        get: function () {
            return this._renderMode;
        },
        set: function (value) {
            if (this._renderMode === value)
                return;

            var prev = this._renderMode;
            this._renderMode = value;
            this.fire('set:renderMode', value);

            // re-create the meshes if we're going from simple to 9-sliced or vice versa
            if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
                if (this._atlas && this._frameKeys) {
                    if (this._updatingProperties) {
                        this._meshesDirty = true;
                    } else {
                        this._createMeshes();
                    }
                }
            }
        }
    });

    Object.defineProperty(Sprite.prototype, 'meshes', {
        get: function () {
            return this._meshes;
        }
    });

    /**
     * @class
     * @name pc.SpriteHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.Sprite} resources.
     * @param {pc.AssetRegistry} assets - The asset registry.
     * @param {pc.GraphicsDevice} device - The graphics device.
     */
    function SpriteHandler(assets, device) {
        this._assets = assets;
        this._device = device;
        this.retryRequests = false;
    }

    // The scope of this function is the sprite asset
    function onTextureAtlasLoaded(atlasAsset) {
        var spriteAsset = this;
        if (spriteAsset.resource) {
            spriteAsset.resource.atlas = atlasAsset.resource;
        }
    }

    // The scope of this function is the sprite asset
    function onTextureAtlasAdded(atlasAsset) {
        var spriteAsset = this;
        spriteAsset.registry.load(atlasAsset);
    }

    Object.assign(SpriteHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            // if given a json file (probably engine-only use case)
            if (path.getExtension(url.original) === '.json') {
                http.get(url.load, {
                    retry: this.retryRequests
                }, function (err, response) {
                    if (!err) {
                        callback(null, response);
                    } else {
                        callback(err);
                    }
                });
            }
        },

        // Create sprite resource
        open: function (url, data) {
            var sprite = new Sprite(this._device);
            if (url) {
                // if url field is present json data is being loaded from file
                // store data on sprite object temporarily
                sprite.__data = data;
            }

            return sprite;
        },

        // Set sprite data
        patch: function (asset, assets) {
            var sprite = asset.resource;
            if (sprite.__data) {
                // loading from a json file we have asset data store temporarily on the sprite resource
                // copy it into asset.data and delete

                asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
                asset.data.renderMode = sprite.__data.renderMode;
                asset.data.frameKeys = sprite.__data.frameKeys;

                if (sprite.__data.textureAtlasAsset) {
                    var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
                    if (atlas) {
                        asset.data.textureAtlasAsset = atlas.id;
                    } else {
                        console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
                    }
                }

                // note: we don't remove sprite.__data in case another asset is loaded from the same URL when it is fetched from the cache
                // the __data is not re-assigned and so asset.data is not set up.
            }

            sprite.startUpdate();
            sprite.renderMode = asset.data.renderMode;
            sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
            sprite.frameKeys = asset.data.frameKeys;
            this._updateAtlas(asset);
            sprite.endUpdate();

            asset.off('change', this._onAssetChange, this);
            asset.on('change', this._onAssetChange, this);
        },

        // Load atlas
        _updateAtlas: function (asset) {
            var sprite = asset.resource;
            if (!asset.data.textureAtlasAsset) {
                sprite.atlas = null;
                return;
            }

            this._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
            this._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);

            var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
            if (atlasAsset && atlasAsset.resource) {
                sprite.atlas = atlasAsset.resource;
            } else {
                if (!atlasAsset) {
                    this._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
                    this._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
                } else {
                    this._assets.load(atlasAsset);
                }
            }
        },

        _onAssetChange: function (asset, attribute, value, oldValue) {
            if (attribute === 'data') {
                // if the texture atlas changed, clear events for old atlas asset
                if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
                    this._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
                    this._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
                }
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.Template
     * @classdesc Create a Template resource from raw database data.
     * @param {pc.Application} app - The application.
     * @param {object} data - Asset data from the database.
     */
    function Template(app, data) {
        this._app = app;

        this._data = data;

        this._expandedData = {};

        this._templateRoot = null;
    }

    /**
     * @private
     * @function
     * @name pc.Template#instantiate
     * @description Create an instance of this template.
     * @returns {pc.Entity} The root entity of the created instance.
     */
    Template.prototype.instantiate = function () {
        if (!this._templateRoot) { // at first use, after scripts are loaded
            this._parseTemplate();
        }

        return this._templateRoot.clone();
    };


    /**
     * @private
     * @function
     * @name pc.Template#getExpandedData
     * @description Creates, if needed, and returns an object whose entities field contains
     * expanded entity data. This output format matches the format of raw scene data.
     * @returns {object} An object whose entities field contains
     * expanded entity data.
     */
    Template.prototype.getExpandedData = function () {
        if (!this._expandedData.entities) {
            this._expandedData.entities = TemplateUtils.expandTemplateEntities(
                this._app, this._data.entities);
        }

        return this._expandedData;
    };

    Template.prototype._parseTemplate = function () {
        var parser = new SceneParser(this._app, true);

        this._templateRoot = parser.parse(this.getExpandedData());
    };

    function TemplateHandler(app) {
        this._app = app;
    }

    Object.assign(TemplateHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var assets = this._app.assets;

            http.get(url.load, function (err, response) {
                if (err) {
                    callback("Error requesting template: " + url.original);
                } else {
                    TemplateUtils.waitForTemplateAssets(
                        response.entities,
                        assets,
                        callback,
                        response);
                }
            });
        },

        open: function (url, data) {
            return new Template(this._app, data);
        }
    });

    function TextHandler() {
        this.retryRequests = false;
    }

    Object.assign(TextHandler.prototype, {
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            http.get(url.load, {
                retry: this.retryRequests
            }, function (err, response) {
                if (!err) {
                    callback(null, response);
                } else {
                    callback("Error loading text resource: " + url.original + " [" + err + "]");
                }
            });
        },

        open: function (url, data) {
            return data;
        },

        patch: function (asset, assets) {
        }
    });

    /**
     * @class
     * @name pc.TextureAtlas
     * @augments pc.EventHandler
     * @classdesc A pc.TextureAtlas contains a number of frames from a texture. Each frame
     * defines a region in a texture. The pc.TextureAtlas is referenced by {@link pc.Sprite}s.
     * @property {pc.Texture} texture The texture atlas.
     * @property {object} frames Contains frames which define portions of the texture atlas.
     * @example
     * var atlas = new pc.TextureAtlas();
     * atlas.frames = {
     *     '0': {
     *         // rect has u, v, width and height in pixels
     *         rect: new pc.Vec4(0, 0, 256, 256),
     *         // pivot has x, y values between 0-1 which define the point
     *         // within the frame around which rotation and scale is calculated
     *         pivot: new pc.Vec2(0.5, 0.5),
     *         // border has left, bottom, right and top in pixels defining regions for 9-slicing
     *         border: new pc.Vec4(5, 5, 5, 5)
     *     },
     *     '1': {
     *         rect: new pc.Vec4(256, 0, 256, 256),
     *         pivot: new pc.Vec2(0.5, 0.5),
     *         border: new pc.Vec4(5, 5, 5, 5)
     *     }
     * };
     */
    function TextureAtlas() {
        EventHandler.call(this);

        this._texture = null;
        this._frames = null;
    }
    TextureAtlas.prototype = Object.create(EventHandler.prototype);
    TextureAtlas.prototype.constructor = TextureAtlas;

    /**
     * @function
     * @name pc.TextureAtlas#setFrame
     * @param {string} key - The key of the frame.
     * @param {object} data - The properties of the frame.
     * @param {pc.Vec4} data.rect - The u, v, width, height properties of the frame in pixels.
     * @param {pc.Vec2} data.pivot - The pivot of the frame - values are between 0-1.
     * @param {pc.Vec4} data.border - The border of the frame for 9-slicing. Values are ordered
     * as follows: left, bottom, right, top border in pixels.
     * @example
     * atlas.setFrame('1', {
     *     rect: new pc.Vec4(0, 0, 128, 128),
     *     pivot: new pc.Vec2(0.5, 0.5),
     *     border: new pc.Vec4(5, 5, 5, 5)
     * });
     */
    TextureAtlas.prototype.setFrame = function (key, data) {
        var frame = this._frames[key];
        if (!frame) {
            frame = {
                rect: data.rect.clone(),
                pivot: data.pivot.clone(),
                border: data.border.clone()
            };
            this._frames[key] = frame;
        } else {
            frame.rect.copy(data.rect);
            frame.pivot.copy(data.pivot);
            frame.border.copy(data.border);
        }

        this.fire('set:frame', key.toString(), frame);
    };

    /**
     * @function
     * @name pc.TextureAtlas#removeFrame
     * @param {string} key - The key of the frame.
     * @example
     * atlas.removeFrame('1');
     */
    TextureAtlas.prototype.removeFrame = function (key) {
        var frame = this._frames[key];
        if (frame) {
            delete this._frames[key];
            this.fire('remove:frame', key.toString(), frame);
        }
    };

    /**
     * @function
     * @name pc.TextureAtlas#destroy
     * @description Free up the underlying texture owned by the atlas.
     */
    TextureAtlas.prototype.destroy = function () {
        if (this._texture) {
            this._texture.destroy();
        }
    };

    Object.defineProperty(TextureAtlas.prototype, 'texture', {
        get: function () {
            return this._texture;
        },
        set: function (value) {
            this._texture = value;
            this.fire('set:texture', value);
        }
    });

    Object.defineProperty(TextureAtlas.prototype, 'frames', {
        get: function () {
            return this._frames;
        },
        set: function (value) {
            this._frames = value;
            this.fire('set:frames', value);
        }
    });

    var JSON_ADDRESS_MODE = {
        "repeat": ADDRESS_REPEAT,
        "clamp": ADDRESS_CLAMP_TO_EDGE,
        "mirror": ADDRESS_MIRRORED_REPEAT
    };

    var JSON_FILTER_MODE = {
        "nearest": FILTER_NEAREST,
        "linear": FILTER_LINEAR,
        "nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
        "linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
        "nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
        "linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
    };

    var regexFrame = /^data\.frames\.(\d+)$/;

    /**
     * @class
     * @name pc.TextureAtlasHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading {@link pc.TextureAtlas} resources.
     * @param {pc.ResourceLoader} loader - The resource loader.
     */
    function TextureAtlasHandler(loader) {
        this._loader = loader;
        this.retryRequests = false;
    }

    Object.assign(TextureAtlasHandler.prototype, {
        // Load the texture atlas texture using the texture resource loader
        load: function (url, callback) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            var self = this;
            var handler = this._loader.getHandler("texture");

            // if supplied with a json file url (probably engine-only)
            // load json data then load texture of same name
            if (path.getExtension(url.original) === '.json') {
                http.get(url.load, {
                    retry: this.retryRequests
                }, function (err, response) {
                    if (!err) {
                        // load texture
                        var textureUrl = url.original.replace('.json', '.png');
                        self._loader.load(textureUrl, "texture", function (err, texture) {
                            if (err) {
                                callback(err);
                            } else {
                                callback(null, {
                                    data: response,
                                    texture: texture
                                });
                            }
                        });
                    } else {
                        callback(err);
                    }
                });
            } else {
                return handler.load(url, callback);
            }
        },

        // Create texture atlas resource using the texture from the texture loader
        open: function (url, data) {
            var resource = new TextureAtlas();
            if (data.texture && data.data) {
                resource.texture = data.texture;
                resource.__data = data.data; // store data temporarily to be copied into asset
            } else {
                var handler = this._loader.getHandler("texture");
                var texture = handler.open(url, data);
                if (!texture) return null;
                resource.texture = texture;
            }
            return resource;
        },

        patch: function (asset, assets) {
            if (asset.resource.__data) {
                // engine-only, so copy temporary asset data from texture atlas into asset and delete temp property
                if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
                if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
                if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
                if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
                if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
                if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
                if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;

                asset.data.frames = asset.resource.__data.frames;

                delete asset.resource.__data;
            }

            // pass texture data
            var texture = asset.resource.texture;
            if (texture) {
                texture.name = asset.name;

                if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter])
                    texture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];

                if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter])
                    texture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];

                if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu])
                    texture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];

                if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv])
                    texture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];

                if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps)
                    texture.mipmaps = asset.data.mipmaps;

                if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy)
                    texture.anisotropy = asset.data.anisotropy;

                if (asset.data.hasOwnProperty('rgbm')) {
                    var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
                    if (texture.type !== type) {
                        texture.type = type;
                    }
                }
            }

            asset.resource.texture = texture;

            // set frames
            var frames = {};
            for (var key in asset.data.frames) {
                var frame = asset.data.frames[key];
                frames[key] = {
                    rect: new Vec4(frame.rect),
                    pivot: new Vec2(frame.pivot),
                    border: new Vec4(frame.border)
                };
            }
            asset.resource.frames = frames;

            asset.off('change', this._onAssetChange, this);
            asset.on('change', this._onAssetChange, this);
        },

        _onAssetChange: function (asset, attribute, value) {
            var frame;

            if (attribute === 'data' || attribute === 'data.frames') {
                // set frames
                var frames = {};
                for (var key in value.frames) {
                    frame = value.frames[key];
                    frames[key] = {
                        rect: new Vec4(frame.rect),
                        pivot: new Vec2(frame.pivot),
                        border: new Vec4(frame.border)
                    };
                }
                asset.resource.frames = frames;
            } else {
                var match = attribute.match(regexFrame);
                if (match) {
                    var frameKey = match[1];

                    if (value) {
                        // add or update frame
                        if (!asset.resource.frames[frameKey]) {
                            asset.resource.frames[frameKey] = {
                                rect: new Vec4(value.rect),
                                pivot: new Vec2(value.pivot),
                                border: new Vec4(value.border)
                            };
                        } else {
                            frame = asset.resource.frames[frameKey];
                            frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
                            frame.pivot.set(value.pivot[0], value.pivot[1]);
                            frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
                        }

                        asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);

                    } else {
                        // delete frame
                        if (asset.resource.frames[frameKey]) {
                            delete asset.resource.frames[frameKey];
                            asset.resource.fire('remove:frame', frameKey);
                        }
                    }

                }
            }
        }
    });

    /**
     * @class
     * @name pc.BasisParser
     * @implements {pc.TextureParser}
     * @classdesc Parser for basis files.
     */
    function BasisParser(registry, retryRequests) {
        this.retryRequests = !!retryRequests;
    }

    Object.assign(BasisParser.prototype, {
        load: function (url, callback, asset) {
            var options = {
                cache: true,
                responseType: "arraybuffer",
                retry: this.retryRequests
            };
            pc.http.get(
                url.load,
                options,
                function (err, result) {
                    if (err) {
                        callback(err, result);
                    } else {
                        // massive hack for pvr textures (i.e. apple devices)
                        // the quality of GGGR normal maps under PVR compression is still terrible
                        // so here we instruct the basis transcoder to unswizzle the normal map data
                        // and pack to 565
                        var unswizzleGGGR = pc.basisTargetFormat() === 'pvr' &&
                                            asset && asset.file && asset.file.variants &&
                                            asset.file.variants.basis &&
                                            ((asset.file.variants.basis.opt & 8) !== 0);
                        if (unswizzleGGGR) {
                            // remove the swizzled flag from the asset
                            asset.file.variants.basis.opt &= ~8;
                        }
                        pc.basisTranscode(url.load, result, callback, { unswizzleGGGR: unswizzleGGGR });
                    }
                }
            );
        },

        // our async transcode call provides the neat structure we need to create the texture instance
        open: function (url, data, device) {
            var texture = new Texture(device, {
                name: url,
                addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                width: data.width,
                height: data.height,
                format: data.format,
                cubemap: data.cubemap,
                levels: data.levels
            });

            texture.upload();

            return texture;
        }
    });

    /**
     * @class
     * @name pc.ImgParser
     * @implements {pc.TextureParser}
     * @classdesc Parser for browser-supported image formats.
     */
    function ImgParser(registry, retryRequests) {
        // by default don't try cross-origin, because some browsers send different cookies (e.g. safari) if this is set.
        this.crossOrigin = registry.prefix ? 'anonymous' : null;
        this.retryRequests = !!retryRequests;
    }

    Object.assign(ImgParser.prototype, {
        load: function (url, callback, asset) {
            var crossOrigin;
            if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
                crossOrigin = asset.options.crossOrigin;
            } else if (ABSOLUTE_URL.test(url.load)) {
                crossOrigin = this.crossOrigin;
            }
            this._loadImage(url.load, url.original, crossOrigin, callback);
        },

        open: function (url, data, device) {
            var ext = path.getExtension(url).toLowerCase();
            var format = (ext === ".jpg" || ext === ".jpeg") ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;
            var texture = new Texture(device, {
                name: url,
                width: data.width,
                height: data.height,
                format: format
            });
            texture.setSource(data);
            return texture;
        },

        _loadImage: function (url, originalUrl, crossOrigin, callback) {
            var image = new Image();
            if (crossOrigin) {
                image.crossOrigin = crossOrigin;
            }

            var retries = 0;
            var maxRetries = 5;
            var retryTimeout;
            var retryRequests = this.retryRequests;

            // Call success callback after opening Texture
            image.onload = function () {
                callback(null, image);
            };

            image.onerror = function () {
                // Retry a few times before failing
                if (retryTimeout) return;

                if (retryRequests && ++retries <= maxRetries) {
                    var retryDelay = Math.pow(2, retries) * 100;
                    console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");

                    var idx = url.indexOf('?');
                    var separator = idx >= 0 ? '&' : '?';

                    retryTimeout = setTimeout(function () {
                        // we need to add a cache busting argument if we are trying to re-load an image element
                        // with the same URL
                        image.src = url + separator + 'retry=' + Date.now();
                        retryTimeout = null;
                    }, retryDelay);
                } else {
                    // Call error callback with details.
                    callback("Error loading Texture from: '" + originalUrl + "'");
                }
            };

            image.src = url;
        }
    });

    // Defined here: https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
    var IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D]; // «KTX 11»\r\n\x1A\n
    var KNOWN_FORMATS = {
        0x83F0: PIXELFORMAT_DXT1,
        0x83F2: PIXELFORMAT_DXT3,
        0x83F3: PIXELFORMAT_DXT5,
        0x8D64: PIXELFORMAT_ETC1,
        0x9274: PIXELFORMAT_ETC2_RGB,
        0x9278: PIXELFORMAT_ETC2_RGBA,
        0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
        0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
        0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
        0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1
    };

    /**
     * @class
     * @name pc.KtxParser
     * @implements {pc.TextureParser}
     * @classdesc Texture parser for ktx files.
     */
    function KtxParser(registry, retryRequests) {
        this.retryRequests = !!retryRequests;
    }

    Object.assign(KtxParser.prototype, {

        load: function (url, callback, asset) {
            var options = {
                cache: true,
                responseType: "arraybuffer",
                retry: this.retryRequests
            };
            http.get(url.load, options, callback);
        },

        open: function (url, data, device) {
            var textureData = this.parse(data);

            if (!textureData) {
                return null;
            }

            var texture = new Texture(device, {
                name: url,
                addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                width: textureData.width,
                height: textureData.height,
                format: textureData.format,
                cubemap: textureData.cubemap,
                levels: textureData.levels
            });

            texture.upload();

            return texture;
        },

        parse: function (data) {
            var headerU32 = new Uint32Array(data, 0, 16);

            if (IDENTIFIER[0] !== headerU32[0] || IDENTIFIER[1] !== headerU32[1] || IDENTIFIER[2] !== headerU32[2]) {
                return null;
            }

            var header = {
                endianness: headerU32[3], // todo: Use this information
                glType: headerU32[4],
                glTypeSize: headerU32[5],
                glFormat: headerU32[6],
                glInternalFormat: headerU32[7],
                glBaseInternalFormat: headerU32[8],
                pixelWidth: headerU32[9],
                pixelHeight: headerU32[10],
                pixelDepth: headerU32[11],
                numberOfArrayElements: headerU32[12],
                numberOfFaces: headerU32[13],
                numberOfMipmapLevels: headerU32[14],
                bytesOfKeyValueData: headerU32[15]
            };

            if (header.pixelDepth > 1) {
                return null;
            }

            if (header.numberOfArrayElements > 1) {
                return null;
            }

            if (header.glFormat !== 0) {
                return null;
            }

            if (!KNOWN_FORMATS[header.glInternalFormat]) {
                return null;
            }

            // Byte offset locating the first byte of texture level data
            var offset = (16 * 4) + header.bytesOfKeyValueData;

            var levels = [];
            var isCubeMap = false;
            for (var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {
                var imageSizeInBytes = new Uint32Array(data.slice(offset, offset + 4))[0];
                offset += 4;
                // Currently array textures not supported. Keeping this here for referance.
                // for (var arrayElement = 0; arrayElement < (header.numberOfArrayElements || 1); arrayElement++) {
                var faceSizeInBytes = imageSizeInBytes / (header.numberOfFaces || 1);
                // Create array for cubemaps
                if (header.numberOfFaces > 1) {
                    isCubeMap = true;
                    levels.push([]);
                }
                for (var face = 0; face < header.numberOfFaces; face++) {
                    // Currently more than 1 pixel depth not supported. Keeping this here for referance.
                    // for (var  zSlice = 0; zSlice < (header.pixelDepth || 1); zSlice++) {
                    var mipData = new Uint8Array(data, offset, faceSizeInBytes);
                    // Handle cubemaps
                    if (header.numberOfFaces > 1) {
                        levels[mipmapLevel].push(mipData);
                    } else {
                        levels.push(mipData);
                    }
                    offset += faceSizeInBytes;
                // }
                }
                offset += 3 - ((offset + 3) % 4);
                // }
                // offset += 3 - ((offset + 3) % 4);
            }

            return {
                format: KNOWN_FORMATS[header.glInternalFormat],
                width: header.pixelWidth,
                height: header.pixelHeight,
                levels: levels,
                cubemap: isCubeMap
            };
        }
    });

    /**
     * @class
     * @name pc.LegacyDdsParser
     * @implements {pc.TextureParser}
     * @classdesc Legacy texture parser for dds files.
     */
    function LegacyDdsParser(registry, retryRequests) {
        this.retryRequests = retryRequests;
    }

    Object.assign(LegacyDdsParser.prototype, {
        load: function (url, callback, asset) {
            var options = {
                cache: true,
                responseType: "arraybuffer",
                retry: this.retryRequests
            };
            http.get(url.load, options, callback);
        },

        open: function (url, data, device) {
            var header = new Uint32Array(data, 0, 128 / 4);

            var width = header[4];
            var height = header[3];
            var mips = Math.max(header[7], 1);
            var isFourCc = header[20] === 4;
            var fcc = header[21];
            var bpp = header[22];
            var isCubemap = header[28] === 65024; // TODO: check by bitflag

            var FCC_DXT1 = 827611204; // DXT1
            var FCC_DXT5 = 894720068; // DXT5
            var FCC_FP32 = 116; // RGBA32f

            // non standard
            var FCC_ETC1 = 826496069;
            var FCC_PVRTC_2BPP_RGB_1 = 825438800;
            var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
            var FCC_PVRTC_4BPP_RGB_1 = 825439312;
            var FCC_PVRTC_4BPP_RGBA_1 = 825504848;

            var compressed = false;
            var floating = false;
            var etc1 = false;
            var pvrtc2 = false;
            var pvrtc4 = false;
            var format = null;

            var texture;

            if (isFourCc) {
                if (fcc === FCC_DXT1) {
                    format = PIXELFORMAT_DXT1;
                    compressed = true;
                } else if (fcc === FCC_DXT5) {
                    format = PIXELFORMAT_DXT5;
                    compressed = true;
                } else if (fcc === FCC_FP32) {
                    format = PIXELFORMAT_RGBA32F;
                    floating = true;
                } else if (fcc === FCC_ETC1) {
                    format = PIXELFORMAT_ETC1;
                    compressed = true;
                    etc1 = true;
                } else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
                    format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
                    compressed = true;
                    pvrtc2 = true;
                } else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
                    format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
                    compressed = true;
                    pvrtc4 = true;
                }
            } else {
                if (bpp === 32) {
                    format = PIXELFORMAT_R8_G8_B8_A8;
                }
            }

            if (!format) {
                texture = new Texture(device, {
                    width: 4,
                    height: 4,
                    format: PIXELFORMAT_R8_G8_B8
                });
                texture.name = 'dds-legacy-empty';
                return texture;
            }

            texture = new Texture(device, {
                name: url,
                addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
                width: width,
                height: height,
                format: format,
                cubemap: isCubemap
            });

            var offset = 128;
            var faces = isCubemap ? 6 : 1;
            var mipSize;
            var DXT_BLOCK_WIDTH = 4;
            var DXT_BLOCK_HEIGHT = 4;
            var blockSize = fcc === FCC_DXT1 ? 8 : 16;
            var numBlocksAcross, numBlocksDown, numBlocks;
            for (var face = 0; face < faces; face++) {
                var mipWidth = width;
                var mipHeight = height;
                for (var i = 0; i < mips; i++) {
                    if (compressed) {
                        if (etc1) {
                            mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
                        } else if (pvrtc2) {
                            mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
                        } else if (pvrtc4) {
                            mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
                        } else {
                            numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
                            numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
                            numBlocks = numBlocksAcross * numBlocksDown;
                            mipSize = numBlocks * blockSize;
                        }
                    } else {
                        mipSize = mipWidth * mipHeight * 4;
                    }

                    var mipBuff = floating ? new Float32Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
                    if (!isCubemap) {
                        texture._levels[i] = mipBuff;
                    } else {
                        if (!texture._levels[i]) texture._levels[i] = [];
                        texture._levels[i][face] = mipBuff;
                    }
                    offset += floating ? mipSize * 4 : mipSize;
                    mipWidth = Math.max(mipWidth * 0.5, 1);
                    mipHeight = Math.max(mipHeight * 0.5, 1);
                }
            }

            texture.upload();

            return texture;
        }
    });

    var JSON_ADDRESS_MODE$1 = {
        "repeat": ADDRESS_REPEAT,
        "clamp": ADDRESS_CLAMP_TO_EDGE,
        "mirror": ADDRESS_MIRRORED_REPEAT
    };

    var JSON_FILTER_MODE$1 = {
        "nearest": FILTER_NEAREST,
        "linear": FILTER_LINEAR,
        "nearest_mip_nearest": FILTER_NEAREST_MIPMAP_NEAREST,
        "linear_mip_nearest": FILTER_LINEAR_MIPMAP_NEAREST,
        "nearest_mip_linear": FILTER_NEAREST_MIPMAP_LINEAR,
        "linear_mip_linear": FILTER_LINEAR_MIPMAP_LINEAR
    };

    var JSON_TEXTURE_TYPE = {
        "default": TEXTURETYPE_DEFAULT,
        "rgbm": TEXTURETYPE_RGBM,
        "rgbe": TEXTURETYPE_RGBE,
        "swizzleGGGR": TEXTURETYPE_SWIZZLEGGGR
    };

    /**
     * @interface
     * @name pc.TextureParser
     * @description Interface to a texture parser. Implementations of this interface handle the loading
     * and opening of texture assets.
     */
    function TextureParser() {}

    Object.assign(TextureParser.prototype, {
        /**
         * @function
         * @name pc.TextureParser#load
         * @description Load the texture from the remote URL. When loaded (or failed),
         * use the callback to return an the raw resource data (or error).
         * @param {object} url - The URL of the resource to load.
         * @param {string} url.load - The URL to use for loading the resource
         * @param {string} url.original - The original URL useful for identifying the resource type
         * @param {pc.callbacks.ResourceHandler} callback - The callback used when the resource is loaded or an error occurs.
         * @param {pc.Asset} [asset] - Optional asset that is passed by ResourceLoader.
         */
        /* eslint-disable jsdoc/require-returns-check */
        load: function (url, callback, asset) {
            throw new Error('not implemented');
        },
        /* eslint-enable jsdoc/require-returns-check */

        /**
         * @function
         * @name pc.TextureParser#open
         * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a pc.Model.
         * @param {string} url - The URL of the resource to open.
         * @param {*} data - The raw resource data passed by callback from {@link pc.ResourceHandler#load}.
         * @param {pc.Asset|null} asset - Optional asset which is passed in by ResourceLoader.
         * @param {pc.GraphicsDevice} device - The graphics device
         * @returns {pc.Texture} The parsed resource data.
         */
        /* eslint-disable jsdoc/require-returns-check */
        open: function (url, data, device) {
            throw new Error('not implemented');
        }
        /* eslint-enable jsdoc/require-returns-check */
    });

    // In the case where a texture has more than 1 level of mip data specified, but not the full
    // mip chain, we generate the missing levels here.
    // This is to overcome an issue where iphone xr and xs ignores further updates to the mip data
    // after invoking gl.generateMipmap on the texture (which was the previous method of ensuring
    // the texture's full mip chain was complete).
    // NOTE: this function only resamples RGBA8 and RGBAFloat32 data.
    var _completePartialMipmapChain = function (texture) {

        var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

        var isHtmlElement = function (object) {
            return (object instanceof HTMLCanvasElement) ||
                   (object instanceof HTMLImageElement) ||
                   (object instanceof HTMLVideoElement);
        };

        if (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 ||
              texture._format === PIXELFORMAT_RGBA32F) ||
              texture._volume ||
              texture._compressed ||
              texture._levels.length === 1 ||
              texture._levels.length === requiredMipLevels ||
              isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
            return;
        }

        var downsample = function (width, height, data) {
            var sampledWidth = Math.max(1, width >> 1);
            var sampledHeight = Math.max(1, height >> 1);
            var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);

            var xs = Math.floor(width / sampledWidth);
            var ys = Math.floor(height / sampledHeight);
            var xsys = xs * ys;

            for (var y = 0; y < sampledHeight; ++y) {
                for (var x = 0; x < sampledWidth; ++x) {
                    for (var e = 0; e < 4; ++e) {
                        var sum = 0;
                        for (var sy = 0; sy < ys; ++sy) {
                            for (var sx = 0; sx < xs; ++sx) {
                                sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
                            }
                        }
                        sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
                    }
                }
            }

            return sampledData;
        };

        // step through levels
        for (var level = texture._levels.length; level < requiredMipLevels; ++level) {
            var width = Math.max(1, texture._width >> (level - 1));
            var height = Math.max(1, texture._height >> (level - 1));
            if (texture._cubemap) {
                var mips = [];
                for (var face = 0; face < 6; ++face) {
                    mips.push(downsample(width, height, texture._levels[level - 1][face]));
                }
                texture._levels.push(mips);
            } else {
                texture._levels.push(downsample(width, height, texture._levels[level - 1]));
            }
        }

        texture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];
    };

    /**
     * @class
     * @name pc.TextureHandler
     * @implements {pc.ResourceHandler}
     * @classdesc Resource handler used for loading 2D and 3D {@link pc.Texture} resources.
     * @param {pc.GraphicsDevice} device - The graphics device.
     * @param {pc.AssetRegistry} assets - The asset registry.
     * @param {pc.ResourceLoader} loader - The resource loader.
     */
    function TextureHandler(device, assets, loader) {
        this._device = device;
        this._assets = assets;
        this._loader = loader;

        // img parser handles all broswer-supported image formats, this
        // parser will be used when other more specific parsers are not found.
        this.imgParser = new ImgParser(assets, false);

        this.parsers = {
            dds: new LegacyDdsParser(assets, false),
            ktx: new KtxParser(assets, false),
            basis: new BasisParser(assets, false)
        };
    }

    Object.defineProperties(TextureHandler.prototype, {
        crossOrigin: {
            get: function () {
                return this.imgParser.crossOrigin;
            },
            set: function (value) {
                this.imgParser.crossOrigin = value;
            }
        },

        retryRequests: {
            get: function () {
                return this.imgParser.retryRequests;
            },
            set: function (value) {
                this.imgParser.retryRequests = value;
                for (var parser in this.parsers) {
                    if (this.parsers.hasOwnProperty(parser)) {
                        this.parsers[parser].retryRequests = value;
                    }
                }
            }
        }
    });

    Object.assign(TextureHandler.prototype, {
        _getUrlWithoutParams: function (url) {
            return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
        },

        _getParser: function (url) {
            var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
            return this.parsers[ext] || this.imgParser;
        },

        load: function (url, callback, asset) {
            if (typeof url === 'string') {
                url = {
                    load: url,
                    original: url
                };
            }

            this._getParser(url.original).load(url, callback, asset);
        },

        open: function (url, data, asset) {
            if (!url)
                return;

            var texture = this._getParser(url).open(url, data, this._device);

            if (texture === null) {
                texture = new Texture(this._device, {
                    width: 4,
                    height: 4,
                    format: PIXELFORMAT_R8_G8_B8
                });
            } else {
                // check if the texture has only a partial mipmap chain specified and generate the
                // missing levels if possible.
                _completePartialMipmapChain(texture);
            }

            return texture;
        },

        patch: function (asset, assets) {
            var texture = asset.resource;
            if (!texture) {
                return;
            }

            if (asset.name && asset.name.length > 0) {
                texture.name = asset.name;
            }

            var assetData = asset.data;

            if (assetData.hasOwnProperty('minfilter')) {
                texture.minFilter = JSON_FILTER_MODE$1[assetData.minfilter];
            }

            if (assetData.hasOwnProperty('magfilter')) {
                texture.magFilter = JSON_FILTER_MODE$1[assetData.magfilter];
            }

            if (!texture.cubemap) {
                if (assetData.hasOwnProperty('addressu')) {
                    texture.addressU = JSON_ADDRESS_MODE$1[assetData.addressu];
                }

                if (assetData.hasOwnProperty('addressv')) {
                    texture.addressV = JSON_ADDRESS_MODE$1[assetData.addressv];
                }
            }

            if (assetData.hasOwnProperty('mipmaps')) {
                texture.mipmaps = assetData.mipmaps;
            }

            if (assetData.hasOwnProperty('anisotropy')) {
                texture.anisotropy = assetData.anisotropy;
            }

            if (assetData.hasOwnProperty('flipY')) {
                texture.flipY = !!assetData.flipY;
            }

            // extract asset type (this is bit of a mess)
            if (assetData.hasOwnProperty('type')) {
                texture.type = JSON_TEXTURE_TYPE[assetData.type];
            } else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
                texture.type = TEXTURETYPE_RGBM;
            } else if (asset.file && asset.getPreferredFile) {
                // basis normalmaps flag the variant as swizzled
                var preferredFile = asset.getPreferredFile();
                if (preferredFile) {
                    if (preferredFile.opt && ((preferredFile.opt & 8) !== 0)) {
                        texture.type = TEXTURETYPE_SWIZZLEGGGR;
                    }
                }
            }
        }
    });

    /**
     * @class
     * @name pc.AssetRegistry
     * @augments pc.EventHandler
     * @classdesc Container for all assets that are available to this application.
     * @description Create an instance of an AssetRegistry.
     * Note: PlayCanvas scripts are provided with an AssetRegistry instance as 'app.assets'.
     * @param {pc.ResourceLoader} loader - The ResourceLoader used to load the asset files.
     * @property {string} prefix A URL prefix that will be added to all asset loading requests.
     */
    function AssetRegistry(loader) {
        EventHandler.call(this);

        this._loader = loader;

        this._assets = []; // list of all assets
        this._cache = {}; // index for looking up assets by id
        this._names = {}; // index for looking up assets by name
        this._tags = new TagsCache('_id'); // index for looking up by tags
        this._urls = {}; // index for looking up assets by url

        this.prefix = null;
    }
    AssetRegistry.prototype = Object.create(EventHandler.prototype);
    AssetRegistry.prototype.constructor = AssetRegistry;

    /**
     * @event
     * @name pc.AssetRegistry#load
     * @description Fired when an asset completes loading.
     * @param {pc.Asset} asset - The asset that has just loaded.
     * @example
     * app.assets.on("load", function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     */

    /**
     * @event
     * @name pc.AssetRegistry#load:[id]
     * @description Fired when an asset completes loading.
     * @param {pc.Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:" + id, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */

    /**
     * @event
     * @name pc.AssetRegistry#load:url:[url]
     * @description Fired when an asset completes loading.
     * @param {pc.Asset} asset - The asset that has just loaded.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("load:url:" + asset.file.url, function (asset) {
     *     console.log("asset loaded: " + asset.name);
     * });
     * app.assets.load(asset);
     */

    /**
     * @event
     * @name pc.AssetRegistry#add
     * @description Fired when an asset is added to the registry.
     * @param {pc.Asset} asset - The asset that was added.
     * @example
     * app.assets.on("add", function (asset) {
     *     console.log("New asset added: " + asset.name);
     * });
     */

    /**
     * @event
     * @name pc.AssetRegistry#add:[id]
     * @description Fired when an asset is added to the registry.
     * @param {pc.Asset} asset - The asset that was added.
     * @example
     * var id = 123456;
     * app.assets.on("add:" + id, function (asset) {
     *     console.log("Asset 123456 loaded");
     * });
     */

    /**
     * @event
     * @name pc.AssetRegistry#add:url:[url]
     * @description Fired when an asset is added to the registry.
     * @param {pc.Asset} asset - The asset that was added.
     */

    /**
     * @event
     * @name pc.AssetRegistry#remove
     * @description Fired when an asset is removed from the registry.
     * @param {pc.Asset} asset - The asset that was removed.
     * @example
     * app.assets.on("remove", function (aseet) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */

    /**
     * @event
     * @name pc.AssetRegistry#remove:[id]
     * @description Fired when an asset is removed from the registry.
     * @param {pc.Asset} asset - The asset that was removed.
     * @example
     * var id = 123456;
     * app.assets.on("remove:" + id, function (asset) {
     *     console.log("Asset removed: " + asset.name);
     * });
     */

    /**
     * @event
     * @name pc.AssetRegistry#remove:url:[url]
     * @description Fired when an asset is removed from the registry.
     * @param {pc.Asset} asset - The asset that was removed.
     */

    /**
     * @event
     * @name pc.AssetRegistry#error
     * @description Fired when an error occurs during asset loading.
     * @param {string} err - The error message.
     * @param {pc.Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error", function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */

    /**
     * @event
     * @name pc.AssetRegistry#error:[id]
     * @description Fired when an error occurs during asset loading.
     * @param {pc.Asset} asset - The asset that generated the error.
     * @example
     * var id = 123456;
     * var asset = app.assets.get(id);
     * app.assets.on("error:" + id, function (err, asset) {
     *     console.error(err);
     * });
     * app.assets.load(asset);
     */

    Object.assign(AssetRegistry.prototype, {
        /**
         * @function
         * @name pc.AssetRegistry#list
         * @description Create a filtered list of assets from the registry.
         * @param {object} filters - Properties to filter on, currently supports: 'preload: true|false'.
         * @returns {pc.Asset[]} The filtered list of assets.
         */
        list: function (filters) {
            filters = filters || {};
            return this._assets.filter(function (asset) {
                var include = true;
                if (filters.preload !== undefined) {
                    include = (asset.preload === filters.preload);
                }
                return include;
            });
        },

        /**
         * @function
         * @name pc.AssetRegistry#add
         * @description Add an asset to the registry.
         * @param {pc.Asset} asset - The asset to add.
         * @example
         * var asset = new pc.Asset("My Asset", "texture", {
         *     url: "../path/to/image.jpg"
         * });
         * app.assets.add(asset);
         */
        add: function (asset) {
            var index = this._assets.push(asset) - 1;
            var url;

            // id cache
            this._cache[asset.id] = index;
            if (!this._names[asset.name])
                this._names[asset.name] = [];

            // name cache
            this._names[asset.name].push(index);
            if (asset.file) {
                url = asset.file.url;
                this._urls[url] = index;
            }
            asset.registry = this;

            // tags cache
            this._tags.addItem(asset);
            asset.tags.on('add', this._onTagAdd, this);
            asset.tags.on('remove', this._onTagRemove, this);

            this.fire("add", asset);
            this.fire("add:" + asset.id, asset);
            if (url)
                this.fire("add:url:" + url, asset);

            if (asset.preload)
                this.load(asset);
        },

        /**
         * @function
         * @name pc.AssetRegistry#remove
         * @description Remove an asset from the registry.
         * @param {pc.Asset} asset - The asset to remove.
         * @returns {boolean} True if the asset was successfully removed and false otherwise.
         * @example
         * var asset = app.assets.get(100);
         * app.assets.remove(asset);
         */
        remove: function (asset) {
            var idx = this._cache[asset.id];
            var url = asset.file ? asset.file.url : null;

            if (idx !== undefined) {
                // remove from list
                this._assets.splice(idx, 1);

                // remove id -> index cache
                delete this._cache[asset.id];

                // name cache needs to be completely rebuilt
                this._names = {};

                // urls cache needs to be completely rebuilt
                this._urls = [];

                // update id cache and rebuild name cache
                for (var i = 0, l = this._assets.length; i < l; i++) {
                    var a = this._assets[i];

                    this._cache[a.id] = i;
                    if (!this._names[a.name]) {
                        this._names[a.name] = [];
                    }
                    this._names[a.name].push(i);

                    if (a.file) {
                        this._urls[a.file.url] = i;
                    }
                }

                // tags cache
                this._tags.removeItem(asset);
                asset.tags.off('add', this._onTagAdd, this);
                asset.tags.off('remove', this._onTagRemove, this);

                asset.fire("remove", asset);
                this.fire("remove", asset);
                this.fire("remove:" + asset.id, asset);
                if (url)
                    this.fire("remove:url:" + url, asset);

                return true;
            }

            // asset not in registry
            return false;
        },

        /**
         * @function
         * @name pc.AssetRegistry#get
         * @description Retrieve an asset from the registry by its id field.
         * @param {number} id - The id of the asset to get.
         * @returns {pc.Asset} The asset.
         * @example
         * var asset = app.assets.get(100);
         */
        get: function (id) {
            var idx = this._cache[id];
            return this._assets[idx];
        },

        /**
         * @function
         * @name pc.AssetRegistry#getByUrl
         * @description Retrieve an asset from the registry by it's file's URL field.
         * @param {string} url - The url of the asset to get.
         * @returns {pc.Asset} The asset.
         * @example
         * var asset = app.assets.getByUrl("../path/to/image.jpg");
         */
        getByUrl: function (url) {
            var idx = this._urls[url];
            return this._assets[idx];
        },

        /**
         * @function
         * @name pc.AssetRegistry#load
         * @description Load the asset's file from a remote source. Listen for "load" events on the asset to find out when it is loaded.
         * @param {pc.Asset} asset - The asset to load.
         * @example
         * // load some assets
         * var assetsToLoad = [
         *     app.assets.find("My Asset"),
         *     app.assets.find("Another Asset")
         * ];
         * var count = 0;
         * assetsToLoad.forEach(function (assetToLoad) {
         *     assetToLoad.ready(function (asset) {
         *         count++;
         *         if (count === assetsToLoad.length) {
         *             // done
         *         }
         *     });
         *     app.assets.load(assetToLoad);
         * });
         */
        load: function (asset) {
            if (asset.loading)
                return;

            var self = this;

            // do nothing if asset is already loaded
            // note: lots of code calls assets.load() assuming this check is present
            // don't remove it without updating calls to assets.load() with checks for the asset.loaded state
            if (asset.loaded) {
                if (asset.type === 'cubemap')
                    self._loader.patch(asset, this);
                return;
            }

            var file = asset.getPreferredFile();
            var load = !!file;

            // open has completed on the resource
            var _opened = function (resource) {
                if (resource instanceof Array) {
                    asset.resources = resource;
                } else {
                    asset.resource = resource;
                }

                self._loader.patch(asset, self);

                self.fire("load", asset);
                self.fire("load:" + asset.id, asset);
                if (file && file.url)
                    self.fire("load:url:" + file.url, asset);
                asset.fire("load", asset);
            };

            var _load = function () {
                var url = asset.getFileUrl();

                asset.loading = true;

                self._loader.load(url, asset.type, function (err, resource, extra) {
                    asset.loaded = true;
                    asset.loading = false;

                    if (err) {
                        self.fire("error", err, asset);
                        self.fire("error:" + asset.id, err, asset);
                        asset.fire("error", err, asset);
                        return;
                    }

                    if (!script.legacy && asset.type === 'script') {
                        var loader = self._loader.getHandler('script');

                        if (loader._cache[asset.id] && loader._cache[asset.id].parentNode === document.head) {
                            // remove old element
                            document.head.removeChild(loader._cache[asset.id]);
                        }

                        loader._cache[asset.id] = extra;
                    }

                    _opened(resource);
                }, asset);
            };

            var _open = function () {
                var resource = self._loader.open(asset.type, asset.data);
                asset.loaded = true;
                _opened(resource);
            };

            // check for special case for cubemaps
            if (file && asset.type === "cubemap") {
                load = false;
                // loading prefiltered cubemap data
                var url = asset.getFileUrl();

                this._loader.load(url, "texture", function (err, texture) {
                    if (!err) {
                        // Fudging an asset so that we can apply texture settings from the cubemap to the DDS texture
                        self._loader.patch({
                            resource: texture,
                            type: "texture",
                            data: asset.data
                        }, self);

                        // store in asset data
                        asset._dds = texture;
                        _open();
                    } else {
                        self.fire("error", err, asset);
                        self.fire("error:" + asset.id, err, asset);
                        asset.fire("error", err, asset);
                    }
                });
            }

            if (!file) {
                _open();
            } else if (load) {
                this.fire("load:start", asset);
                this.fire("load:" + asset.id + ":start", asset);
                _load();
            }
        },

        /**
         * @function
         * @name pc.AssetRegistry#loadFromUrl
         * @description Use this to load and create an asset if you don't have assets created. Usually you would only use this
         * if you are not integrated with the PlayCanvas Editor.
         * @param {string} url - The url to load.
         * @param {string} type - The type of asset to load.
         * @param {pc.callbacks.LoadAsset} callback - Function called when asset is loaded, passed (err, asset), where err is null if no errors were encountered.
         * @example
         * app.assets.loadFromUrl("../path/to/texture.jpg", "texture", function (err, asset) {
         *     var texture = asset.resource;
         * });
         */
        loadFromUrl: function (url, type, callback) {
            this.loadFromUrlAndFilename(url, null, type, callback);
        },

        /**
         * @function
         * @name pc.AssetRegistry#loadFromUrlAndFilename
         * @description Use this to load and create an asset when both the URL and filename are required. For example, use this function when loading
         * BLOB assets, where the URL does not adequately identify the file.
         * @param {string} url - The url to load.
         * @param {string} filename - The filename of the asset to load.
         * @param {string} type - The type of asset to load.
         * @param {pc.callbacks.LoadAsset} callback - Function called when asset is loaded, passed (err, asset), where err is null if no errors were encountered.
         * @example
         * var file = magicallyAttainAFile();
         * app.assets.loadFromUrlAndFilename(URL.createObjectURL(file), "texture.png", "texture", function (err, asset) {
         *     var texture = asset.resource;
         * });
         */
        loadFromUrlAndFilename: function (url, filename, type, callback) {
            var self = this;

            var name = path.getBasename(filename || url);

            var file = {
                filename: filename || name,
                url: url
            };

            var asset = self.getByUrl(url);
            if (!asset) {
                asset = new Asset(name, type, file);
                self.add(asset);
            }

            var startLoad = function (asset) {
                asset.once("load", function (loadedAsset) {
                    callback(null, loadedAsset);
                });
                asset.once("error", function (err) {
                    callback(err);
                });
                self.load(asset);
            };

            if (asset.resource) {
                callback(null, asset);
            } else if (type === 'model') {
                self._loadModel(asset, startLoad);
            } else {
                startLoad(asset);
            }
        },

        // private method used for engine-only loading of model data
        _loadModel: function (modelAsset, continuation) {
            var self = this;

            var url = modelAsset.getFileUrl();
            var ext = path.getExtension(url);

            if (ext === '.json' || ext === '.glb') {
                var dir = path.getDirectory(url);
                var basename = path.getBasename(url);

                // playcanvas model format supports material mapping file
                var mappingUrl = path.join(dir, basename.replace(ext, ".mapping.json"));
                this._loader.load(mappingUrl, 'json', function (err, data) {
                    if (err) {
                        modelAsset.data = { mapping: [] };
                        continuation(modelAsset);
                    } else {
                        self._loadMaterials(modelAsset, data, function (e, materials) {
                            modelAsset.data = data;
                            continuation(modelAsset);
                        });
                    }
                });
            } else {
                // other model format (e.g. obj)
                continuation(modelAsset);
            }
        },

        // private method used for engine-only loading of model materials
        _loadMaterials: function (modelAsset, mapping, callback) {
            var self = this;
            var materials = [];
            var count = 0;

            var onMaterialLoaded = function (err, materialAsset) {
                // load dependent textures
                self._loadTextures(materialAsset, function (err, textures) {
                    materials.push(materialAsset);
                    if (materials.length === count) {
                        callback(null, materials);
                    }
                });
            };

            for (var i = 0; i < mapping.mapping.length; i++) {
                var path = mapping.mapping[i].path;
                if (path) {
                    count++;
                    self.loadFromUrl(modelAsset.getAbsoluteUrl(path), "material", onMaterialLoaded);
                }
            }

            if (count === 0) {
                callback(null, materials);
            }
        },

        // private method used for engine-only loading of the textures referenced by
        // the material asset
        _loadTextures: function (materialAsset, callback) {
            var self = this;
            var textures = [];
            var count = 0;

            var data = materialAsset.data;
            if (data.mappingFormat !== 'path') {
                callback(null, textures);
                return;
            }

            var onTextureLoaded = function (err, texture) {
                if (err) console.error(err);
                textures.push(texture);
                if (textures.length === count) {
                    callback(null, textures);
                }
            };

            var texParams = standardMaterialTextureParameters;
            for (var i = 0; i < texParams.length; i++) {
                var path = data[texParams[i]];
                if (path && typeof(path) === 'string') {
                    count++;
                    self.loadFromUrl(materialAsset.getAbsoluteUrl(path), "texture", onTextureLoaded);
                }
            }

            if (count === 0) {
                callback(null, textures);
            }
        },

        /**
         * @function
         * @name pc.AssetRegistry#findAll
         * @description Return all Assets with the specified name and type found in the registry.
         * @param {string} name - The name of the Assets to find.
         * @param {string} [type] - The type of the Assets to find.
         * @returns {pc.Asset[]} A list of all Assets found.
         * @example
         * var assets = app.assets.findAll("myTextureAsset", "texture");
         * console.log("Found " + assets.length + " assets called " + name);
         */
        findAll: function (name, type) {
            var self = this;
            var idxs = this._names[name];
            if (idxs) {
                var assets = idxs.map(function (idx) {
                    return self._assets[idx];
                });

                if (type) {
                    return assets.filter(function (asset) {
                        return (asset.type === type);
                    });
                }

                return assets;
            }

            return [];
        },

        _onTagAdd: function (tag, asset) {
            this._tags.add(tag, asset);
        },

        _onTagRemove: function (tag, asset) {
            this._tags.remove(tag, asset);
        },

        /**
         * @function
         * @name pc.AssetRegistry#findByTag
         * @description Return all Assets that satisfy the search query.
         * Query can be simply a string, or comma separated strings,
         * to have inclusive results of assets that match at least one query.
         * A query that consists of an array of tags can be used to match assets that have each tag of array.
         * @param {...*} query - Name of a tag or array of tags.
         * @returns {pc.Asset[]} A list of all Assets matched query.
         * @example
         * var assets = app.assets.findByTag("level-1");
         * // returns all assets that tagged by `level-1`
         * @example
         * var assets = app.assets.findByTag("level-1", "level-2");
         * // returns all assets that tagged by `level-1` OR `level-2`
         * @example
         * var assets = app.assets.findByTag(["level-1", "monster"]);
         * // returns all assets that tagged by `level-1` AND `monster`
         * @example
         * var assets = app.assets.findByTag(["level-1", "monster"], ["level-2", "monster"]);
         * // returns all assets that tagged by (`level-1` AND `monster`) OR (`level-2` AND `monster`)
         */
        findByTag: function () {
            return this._tags.find(arguments);
        },

        /**
         * @function
         * @name pc.AssetRegistry#filter
         * @description Return all Assets that satisfy filter callback.
         * @param {pc.callbacks.FilterAsset} callback - The callback function that is used to filter assets, return `true` to include asset to result list.
         * @returns {pc.Asset[]} A list of all Assets found.
         * @example
         * var assets = app.assets.filter(function (asset) {
         *     return asset.name.indexOf('monster') !== -1;
         * });
         * console.log("Found " + assets.length + " assets, where names contains 'monster'");
         */
        filter: function (callback) {
            var items = [];
            for (var i = 0, len = this._assets.length; i < len; i++) {
                if (callback(this._assets[i]))
                    items.push(this._assets[i]);
            }
            return items;
        },

        /**
         * @function
         * @name pc.AssetRegistry#find
         * @description Return the first Asset with the specified name and type found in the registry.
         * @param {string} name - The name of the Asset to find.
         * @param {string} [type] - The type of the Asset to find.
         * @returns {pc.Asset} A single Asset or null if no Asset is found.
         * @example
         * var asset = app.assets.find("myTextureAsset", "texture");
         */
        find: function (name, type) {
            var asset = this.findAll(name, type);
            return asset ? asset[0] : null;
        }
    });

    /**
     * @private
     * @class
     * @name pc.BundleRegistry
     * @param {pc.AssetRegistry} assets - The asset registry.
     * @classdesc Keeps track of which assets are in bundles and loads files from bundles.
     */
    function BundleRegistry(assets) {
        this._assets = assets;

        // index of bundle assets
        this._bundleAssets = {};
        // index asset id to one more bundle assets
        this._assetsInBundles = {};
        // index file urls to one or more bundle assets
        this._urlsInBundles = {};
        // contains requests to load file URLs indexed by URL
        this._fileRequests = {};

        this._assets.on('add', this._onAssetAdded, this);
        this._assets.on('remove', this._onAssetRemoved, this);
    }

    Object.assign(BundleRegistry.prototype, {
        // Add asset in internal indexes
        _onAssetAdded: function (asset) {
            // if this is a bundle asset then add it and
            // index its referenced assets
            if (asset.type === 'bundle') {
                this._bundleAssets[asset.id] = asset;

                this._registerBundleEventListeners(asset.id);

                for (var i = 0, len = asset.data.assets.length; i < len; i++) {
                    this._indexAssetInBundle(asset.data.assets[i], asset);
                }
            } else {
                // if this is not a bundle then index its URLs
                if (this._assetsInBundles[asset.id]) {
                    this._indexAssetFileUrls(asset);
                }
            }
        },

        _registerBundleEventListeners: function (bundleAssetId) {
            this._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);
            this._assets.on('error:' + bundleAssetId, this._onBundleError, this);
        },

        _unregisterBundleEventListeners: function (bundleAssetId) {
            this._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);
            this._assets.off('error:' + bundleAssetId, this._onBundleError, this);
        },

        // Index the specified asset id and its file URLs so that
        // the registry knows that the asset is in that bundle
        _indexAssetInBundle: function (assetId, bundleAsset) {
            if (! this._assetsInBundles[assetId]) {
                this._assetsInBundles[assetId] = [bundleAsset];
            } else {
                var bundles = this._assetsInBundles[assetId];
                var idx = bundles.indexOf(bundleAsset);
                if (idx === -1) {
                    bundles.push(bundleAsset);
                }
            }

            var asset = this._assets.get(assetId);
            if (asset) {
                this._indexAssetFileUrls(asset);
            }
        },

        // Index the file URLs of the specified asset
        _indexAssetFileUrls: function (asset) {
            var urls = this._getAssetFileUrls(asset);
            if (! urls) return;

            for (var i = 0, len = urls.length; i < len; i++) {
                var url = urls[i];
                // Just set the URL to point to the same bundles as the asset does.
                // This is a performance/memory optimization and it assumes that
                // the URL will not exist in any other asset. If that does happen then
                // this will not work as expected if the asset is removed, as the URL will
                // be removed too.
                this._urlsInBundles[url] = this._assetsInBundles[asset.id];
            }
        },

        // Get all the possible URLs of an asset
        _getAssetFileUrls: function (asset) {
            var url = asset.getFileUrl();
            if (! url) return null;

            url = this._normalizeUrl(url);
            var urls = [url];

            // a font might have additional files
            // so add them in the list
            if (asset.type === 'font') {
                var numFiles = asset.data.info.maps.length;
                for (var i = 1; i < numFiles; i++) {
                    urls.push(url.replace('.png', i + '.png'));
                }
            }

            return urls;
        },

        // Removes query parameters from a URL
        _normalizeUrl: function (url) {
            return url && url.split('?')[0];
        },

        // Remove asset from internal indexes
        _onAssetRemoved: function (asset) {
            if (asset.type === 'bundle') {
                // remove bundle from index
                delete this._bundleAssets[asset.id];

                // remove event listeners
                this._unregisterBundleEventListeners(asset.id);

                // remove bundle from _assetsInBundles and _urlInBundles indexes
                var idx, id;
                for (id in this._assetsInBundles) {
                    var array = this._assetsInBundles[id];
                    idx = array.indexOf(asset);
                    if (idx !== -1) {
                        array.splice(idx, 1);
                        if (! array.length) {
                            delete this._assetsInBundles[id];

                            // make sure we do not leave that array in
                            // any _urlInBundles entries
                            for (var url in this._urlsInBundles) {
                                if (this._urlsInBundles[url] === array) {
                                    delete this._urlsInBundles[url];
                                }
                            }
                        }
                    }
                }

                // fail any pending requests for this bundle
                this._onBundleError('Bundle ' + asset.id + ' was removed', asset);

            } else if (this._assetsInBundles[asset.id]) {
                // remove asset from _assetInBundles
                delete this._assetsInBundles[asset.id];

                // remove asset urls from _urlsInBundles
                var urls = this._getAssetFileUrls(asset);
                for (var i = 0, len = urls.length; i < len; i++) {
                    delete this._urlsInBundles[urls[i]];
                }
            }

        },

        // If we have any pending file requests
        // that can be satisfied by the specified bundle
        // then resolve them
        _onBundleLoaded: function (bundleAsset) {
            // this can happen if the bundleAsset failed
            // to create its resource
            if (! bundleAsset.resource) {
                this._onBundleError('Bundle ' + bundleAsset.id + ' failed to load', bundleAsset);
                return;
            }

            // on next tick resolve the pending asset requests
            // don't do it on the same tick because that ties the loading
            // of the bundle to the loading of all the assets
            requestAnimationFrame(function () {
                // make sure the registry hasn't been destroyed already
                if (!this._fileRequests) {
                    return;
                }

                for (var url in this._fileRequests) {
                    var bundles = this._urlsInBundles[url];
                    if (!bundles || bundles.indexOf(bundleAsset) === -1) continue;

                    var decodedUrl = decodeURIComponent(url);
                    var err = null;
                    if (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {
                        err = 'Bundle ' + bundleAsset.id + ' does not contain URL ' + url;
                    }

                    var requests = this._fileRequests[url];
                    for (var i = 0, len = requests.length; i < len; i++) {
                        if (err) {
                            requests[i](err);
                        } else {
                            requests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));
                        }
                    }

                    delete this._fileRequests[url];
                }
            }.bind(this));
        },

        // If we have outstanding file requests for any
        // of the URLs in the specified bundle then search for
        // other bundles that can satisfy these requests.
        // If we do not find any other bundles then fail
        // those pending file requests with the specified error.
        _onBundleError: function (err, bundleAsset) {
            for (var url in this._fileRequests) {
                var bundle = this._findLoadedOrLoadingBundleForUrl(url);
                if (! bundle) {
                    var requests = this._fileRequests[url];
                    for (var i = 0, len = requests.length; i < len; i++) {
                        requests[i](err);
                    }

                    delete this._fileRequests[url];

                }
            }
        },

        // Finds a bundle that contains the specified URL but
        // only returns the bundle if it's either loaded or being loaded
        _findLoadedOrLoadingBundleForUrl: function (url) {
            var bundles = this._urlsInBundles[url];
            if (! bundles) return null;

            // look for loaded bundle first...
            var len = bundles.length;
            var i;
            for (i = 0; i < len; i++) {
                // 'loaded' can be true but if there was an error
                // then 'resource' would be null
                if (bundles[i].loaded && bundles[i].resource) {
                    return bundles[i];
                }
            }

            // ...then look for loading bundles
            for (i = 0; i < len; i++) {
                if (bundles[i].loading) {
                    return bundles[i];
                }
            }

            return null;
        },

        /**
         * @private
         * @function
         * @name pc.BundleRegistry#listBundlesForAsset
         * @description Lists all of the available bundles that reference the specified asset id.
         * @param {pc.Asset} asset - The asset.
         * @returns {pc.Asset[]} An array of bundle assets or null if the asset is not in any bundle.
         */
        listBundlesForAsset: function (asset) {
            return this._assetsInBundles[asset.id] || null;
        },

        /**
         * @private
         * @function
         * @name pc.BundleRegistry#list
         * @description Lists all of the available bundles. This includes bundles that are not loaded.
         * @returns {pc.Asset[]} An array of bundle assets.
         */
        list: function () {
            var result = [];
            for (var id in this._bundleAssets) {
                result.push(this._bundleAssets[id]);
            }

            return result;
        },

        /**
         * @private
         * @function
         * @name pc.BundleRegistry#hasUrl
         * @description Returns true if there is a bundle that contains the specified URL.
         * @param {string} url - The url.
         * @returns {boolean} True or false.
         */
        hasUrl: function (url) {
            return !!this._urlsInBundles[url];
        },

        /**
         * @private
         * @function
         * @name pc.BundleRegistry#canLoadUrl
         * @description Returns true if there is a bundle that contains the specified URL
         * and that bundle is either loaded or currently being loaded.
         * @param {string} url - The url.
         * @returns {boolean} True or false.
         */
        canLoadUrl: function (url) {
            return !!this._findLoadedOrLoadingBundleForUrl(url);
        },

        /**
         * @private
         * @function
         * @name pc.BundleRegistry#loadUrl
         * @description Loads the specified file URL from a bundle that is either loaded or currently being loaded.
         * @param {string} url - The URL. Make sure you are using a relative URL that does not contain any query parameters.
         * @param {Function} callback - The callback is called when the file has been loaded or if an error occures. The callback
         * expects the first argment to be the error message (if any) and the second argument is the file blob URL.
         * @example
         * var url = asset.getFileUrl().split('?')[0]; // get normalized asset URL
         * this.app.bundles.loadFile(url, function (err, blobUrl) {
         *     // do something with the blob URL
         * });
         */
        loadUrl: function (url, callback) {
            var bundle = this._findLoadedOrLoadingBundleForUrl(url);
            if (! bundle) {
                callback('URL ' + url + ' not found in any bundles');
                return;
            }

            // Only load files from bundles that're explicilty requested to be loaded.
            if (bundle.loaded) {
                var decodedUrl = decodeURIComponent(url);
                if (!bundle.resource.hasBlobUrl(decodedUrl)) {
                    callback('Bundle ' + bundle.id + ' does not contain URL ' + url);
                    return;
                }

                callback(null, bundle.resource.getBlobUrl(decodedUrl));
            } else if (this._fileRequests.hasOwnProperty(url)) {
                this._fileRequests[url].push(callback);
            } else {
                this._fileRequests[url] = [callback];
            }
        },

        /**
         * @private
         * @function
         * @name pc.ResourceLoader#destroy
         * @description Destroys the registry, and releases its resources. Does not unload bundle assets
         * as these should be unloaded by the {@link pc.AssetRegistry}.
         */
        destroy: function () {
            this._assets.off('add', this._onAssetAdded, this);
            this._assets.off('remove', this._onAssetRemoved, this);

            for (var id in this._bundleAssets) {
                this._unregisterBundleEventListeners(id);
            }

            this._assets = null;
            this._bundleAssets = null;
            this._assetsInBundles = null;
            this._urlsInBundles = null;
            this._fileRequests = null;
        }
    });

    /**
     * @class
     * @name pc.ScriptRegistry
     * @augments pc.EventHandler
     * @classdesc Container for all Script Types that are available to this application.
     * @description Create an instance of a pc.ScriptRegistry.
     * Note: PlayCanvas scripts can access the Script Registry from inside the application with {@link pc.Application#scripts} {@link pc.ADDRESS_REPEAT}.
     * @param {pc.Application} app - Application to attach registry to.
     */
    function ScriptRegistry(app) {
        EventHandler.call(this);

        this.app = app;
        this._scripts = { };
        this._list = [];
    }
    ScriptRegistry.prototype = Object.create(EventHandler.prototype);
    ScriptRegistry.prototype.constructor = ScriptRegistry;

    ScriptRegistry.prototype.destroy = function () {
        this.app = null;
        this.off();
    };

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @function
     * @name pc.ScriptRegistry#add
     * @description Add {@link pc.ScriptType} to registry.
     * Note: when {@link pc.createScript} is called, it will add the {@link pc.ScriptType} to the registry automatically.
     * If a script already exists in registry, and the new script has a `swap` method defined,
     * it will perform code hot swapping automatically in async manner.
     * @param {Class<pc.ScriptType>} script - Script Type that is created using {@link pc.createScript}.
     * @returns {boolean} True if added for the first time or false if script already exists.
     * @example
     * var PlayerController = pc.createScript('playerController');
     * // playerController Script Type will be added to pc.ScriptRegistry automatically
     * console.log(app.scripts.has('playerController')); // outputs true
     */
    /* eslint-enable jsdoc/no-undefined-types */
    ScriptRegistry.prototype.add = function (script) {
        var self = this;
        var scriptName = script.__name;

        if (this._scripts.hasOwnProperty(scriptName)) {
            setTimeout(function () {
                if (script.prototype.swap) {
                    // swapping
                    var old = self._scripts[scriptName];
                    var ind = self._list.indexOf(old);
                    self._list[ind] = script;
                    self._scripts[scriptName] = script;

                    self.fire('swap', scriptName, script);
                    self.fire('swap:' + scriptName, script);
                } else {
                    console.warn('script registry already has \'' + scriptName + '\' script, define \'swap\' method for new script type to enable code hot swapping');
                }
            });
            return false;
        }

        this._scripts[scriptName] = script;
        this._list.push(script);

        this.fire('add', scriptName, script);
        this.fire('add:' + scriptName, script);

        // for all components awaiting Script Type
        // create script instance
        setTimeout(function () {
            if (!self._scripts.hasOwnProperty(scriptName))
                return;


            // this is a check for a possible error
            // that might happen if the app has been destroyed before
            // setTimeout has finished
            if (!self.app || !self.app.systems || !self.app.systems.script) {
                return;
            }

            var components = self.app.systems.script._components;
            var i, scriptInstance, attributes;
            var scriptInstances = [];
            var scriptInstancesInitialized = [];

            for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
                var component = components.items[components.loopIndex];
                // check if awaiting for script
                if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
                    if (component._scriptsData && component._scriptsData[scriptName])
                        attributes = component._scriptsData[scriptName].attributes;

                    scriptInstance = component.create(scriptName, {
                        preloading: true,
                        ind: component._scriptsIndex[scriptName].ind,
                        attributes: attributes
                    });

                    if (scriptInstance)
                        scriptInstances.push(scriptInstance);
                }
            }

            // initialize attributes
            for (i = 0; i < scriptInstances.length; i++)
                scriptInstances[i].__initializeAttributes();

            // call initialize()
            for (i = 0; i < scriptInstances.length; i++) {
                if (scriptInstances[i].enabled) {
                    scriptInstances[i]._initialized = true;

                    scriptInstancesInitialized.push(scriptInstances[i]);

                    if (scriptInstances[i].initialize)
                        scriptInstances[i].initialize();
                }
            }

            // call postInitialize()
            for (i = 0; i < scriptInstancesInitialized.length; i++) {
                if (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {
                    continue;
                }

                scriptInstancesInitialized[i]._postInitialized = true;

                if (scriptInstancesInitialized[i].postInitialize)
                    scriptInstancesInitialized[i].postInitialize();
            }
        });

        return true;
    };

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @function
     * @name pc.ScriptRegistry#remove
     * @description Remove {@link pc.ScriptType}.
     * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
     * @returns {boolean} True if removed or False if already not in registry.
     * @example
     * app.scripts.remove('playerController');
     */
    /* eslint-enable jsdoc/no-undefined-types */
    ScriptRegistry.prototype.remove = function (nameOrType) {
        var scriptType = nameOrType;
        var scriptName = nameOrType;

        if (typeof scriptName !== 'string') {
            scriptName = scriptType.__name;
        } else {
            scriptType = this.get(scriptName);
        }

        if (this.get(scriptName) !== scriptType)
            return false;

        delete this._scripts[scriptName];
        var ind = this._list.indexOf(scriptType);
        this._list.splice(ind, 1);

        this.fire('remove', scriptName, scriptType);
        this.fire('remove:' + scriptName, scriptType);

        return true;
    };

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @function
     * @name pc.ScriptRegistry#get
     * @description Get {@link pc.ScriptType} by name.
     * @param {string} name - Name of a {@link pc.ScriptType}.
     * @returns {Class<pc.ScriptType>} The Script Type if it exists in the registry or null otherwise.
     * @example
     * var PlayerController = app.scripts.get('playerController');
     */
    /* eslint-enable jsdoc/no-undefined-types */
    ScriptRegistry.prototype.get = function (name) {
        return this._scripts[name] || null;
    };

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @function
     * @name pc.ScriptRegistry#has
     * @description Check if a {@link pc.ScriptType} with the specified name is in the registry.
     * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
     * @returns {boolean} True if {@link pc.ScriptType} is in registry.
     * @example
     * if (app.scripts.has('playerController')) {
     *     // playerController is in pc.ScriptRegistry
     * }
     */
    /* eslint-enable jsdoc/no-undefined-types */
    ScriptRegistry.prototype.has = function (nameOrType) {
        if (typeof nameOrType === 'string') {
            return this._scripts.hasOwnProperty(nameOrType);
        }

        if (!nameOrType) return false;
        var scriptName = nameOrType.__name;
        return this._scripts[scriptName] === nameOrType;
    };

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @function
     * @name pc.ScriptRegistry#list
     * @description Get list of all {@link pc.ScriptType}s from registry.
     * @returns {Array<Class<pc.ScriptType>>} list of all {@link pc.ScriptType}s in registry.
     * @example
     * // logs array of all Script Type names available in registry
     * console.log(app.scripts.list().map(function (o) {
     *     return o.name;
     * }));
     */
    /* eslint-enable jsdoc/no-undefined-types */
    ScriptRegistry.prototype.list = function () {
        return this._list;
    };

    /**
     * @constant
     * @type {string}
     * @name pc.FILLMODE_NONE
     * @description When resizing the window the size of the canvas will not change.
     */
    var FILLMODE_NONE = 'NONE';
    /**
     * @constant
     * @type {string}
     * @name pc.FILLMODE_FILL_WINDOW
     * @description When resizing the window the size of the canvas will change to fill the window exactly.
     */
    var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
    /**
     * @constant
     * @type {string}
     * @name pc.FILLMODE_KEEP_ASPECT
     * @description When resizing the window the size of the canvas will change to fill the window as best it can, while maintaining the same aspect ratio.
     */
    var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
    /**
     * @constant
     * @type {string}
     * @name pc.RESOLUTION_AUTO
     * @description When the canvas is resized the resolution of the canvas will change to match the size of the canvas.
     */
    var RESOLUTION_AUTO = 'AUTO';
    /**
     * @constant
     * @type {string}
     * @name pc.RESOLUTION_FIXED
     * @description When the canvas is resized the resolution of the canvas will remain at the same value and the output will just be scaled to fit the canvas.
     */
    var RESOLUTION_FIXED = 'FIXED';

    /**
     * @private
     * @deprecated
     * @class
     * @name pc.VrDisplay
     * @augments pc.EventHandler
     * @classdesc Represents a single Display for VR content. This could be a Head Mounted display that can present content on a separate screen
     * or a phone which can display content full screen on the same screen. This object contains the native `navigator.VRDisplay` object
     * from the WebVR API.
     * @description Represents a single Display for VR content. This could be a Head Mounted display that can present content on a separate screen
     * or a phone which can display content full screen on the same screen. This object contains the native `navigator.VRDisplay` object
     * from the WebVR API.
     * @param {pc.Application} app - The application outputting to this VR display.
     * @param {VRDisplay} display - The native VRDisplay object from the WebVR API.
     * @property {number} id An identifier for this distinct VRDisplay.
     * @property {VRDisplay} display The native VRDisplay object from the WebVR API.
     * @property {boolean} presenting True if this display is currently presenting VR content.
     * @property {VRDisplayCapabilities} capabilities Returns the <a href="https://w3c.github.io/webvr/#interface-vrdisplaycapabilities" target="_blank">VRDisplayCapabilities</a> object from the VRDisplay.
     * This can be used to determine what features are available on this display.
     */
    function VrDisplay(app, display) {
        EventHandler.call(this);

        var self = this;

        this._app = app;
        this._device = app.graphicsDevice;

        this.id = display.displayId;

        this._frameData = null;
        if (window.VRFrameData) {
            this._frameData = new window.VRFrameData();
        }
        this.display = display;

        this._camera = null; // camera component

        this.sitToStandInv = new Mat4();

        this.leftView = new Mat4();
        this.leftProj = new Mat4();
        this.leftViewInv = new Mat4();
        this.leftPos = new Vec3();

        this.rightView = new Mat4();
        this.rightProj = new Mat4();
        this.rightViewInv = new Mat4();
        this.rightPos = new Vec3();

        this.combinedPos = new Vec3();
        this.combinedView = new Mat4();
        this.combinedProj = new Mat4();
        this.combinedViewInv = new Mat4();
        this.combinedFov = 0;
        this.combinedAspect = 0;

        this.presenting = false;

        self._presentChange = function (event) {
            var display;
            // handle various events formats
            if (event.display) {
                // this is the official spec event format
                display = event.display;
            } else if (event.detail && event.detail.display) {
                // webvr-polyfill uses this
                display = event.detail.display;
            } else if (event.detail && event.detail.vrdisplay) {
                // this was used in the webvr emulation chrome extension
                display = event.detail.vrdisplay;
            } else {
                // final catch all is to use this display as Firefox Nightly (54.0a1)
                // does not include the display within the event data
                display = self.display;
            }

            // check if event refers to this display
            if (display === self.display) {
                self.presenting = (self.display && self.display.isPresenting);

                if (self.presenting) {
                    var leftEye = self.display.getEyeParameters("left");
                    var rightEye = self.display.getEyeParameters("right");
                    var w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;
                    var h = Math.max(leftEye.renderHeight, rightEye.renderHeight);
                    // set canvas resolution to the display resolution
                    self._app.graphicsDevice.setResolution(w, h);
                    // prevent window resizing from resizing it
                    self._app._allowResize = false;
                } else {
                    // restore original resolution
                    self._app.setCanvasResolution(RESOLUTION_AUTO);
                    self._app._allowResize = true;
                }

                self.fire('beforepresentchange', self); // fire internal event for camera component
                self.fire('presentchange', self);
            }
        };
        window.addEventListener('vrdisplaypresentchange', self._presentChange, false);
    }
    VrDisplay.prototype = Object.create(EventHandler.prototype);
    VrDisplay.prototype.constructor = VrDisplay;

    Object.assign(VrDisplay.prototype, {
        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#destroy
         * @description Destroy this display object.
         */
        destroy: function () {
            window.removeEventListener('vrdisplaypresentchange', self._presentChange);
            if (this._camera) this._camera.vrDisplay = null;
            this._camera = null;
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#poll
         * @description Called once per frame to update the current status from the display. Usually called by {@link pc.VrManager}.
         */
        poll: function () {
            if (this.display) {
                this.display.getFrameData(this._frameData);

                this.leftProj.data = this._frameData.leftProjectionMatrix;
                this.rightProj.data = this._frameData.rightProjectionMatrix;

                var stage = this.display.stageParameters;
                if (stage) {

                    this.sitToStandInv.set(stage.sittingToStandingTransform).invert();

                    this.combinedView.set(this._frameData.leftViewMatrix);
                    this.leftView.mul2(this.combinedView, this.sitToStandInv);

                    this.combinedView.set(this._frameData.rightViewMatrix);
                    this.rightView.mul2(this.combinedView, this.sitToStandInv);
                } else {

                    this.leftView.set(this._frameData.leftViewMatrix);
                    this.rightView.set(this._frameData.rightViewMatrix);
                }

                // Find combined position and view matrix
                // Camera is offset backwards to cover both frustums

                // Extract widest frustum plane and calculate fov
                var nx = this.leftProj.data[3] + this.leftProj.data[0];
                var nz = this.leftProj.data[11] + this.leftProj.data[8];
                var l = 1.0 / Math.sqrt(nx * nx + nz * nz);
                nx *= l;
                nz *= l;
                var maxFov = -Math.atan2(nz, nx);

                nx = this.rightProj.data[3] + this.rightProj.data[0];
                nz = this.rightProj.data[11] + this.rightProj.data[8];
                l = 1.0 / Math.sqrt(nx * nx + nz * nz);
                nx *= l;
                nz *= l;
                maxFov = Math.max(maxFov, -Math.atan2(nz, nx));
                maxFov *= 2.0;

                this.combinedFov = maxFov;

                var aspect = this.rightProj.data[5] / this.rightProj.data[0];
                this.combinedAspect = aspect;

                var view = this.combinedView;
                view.copy(this.leftView);
                view.invert();
                this.leftViewInv.copy(view);
                var pos = this.combinedPos;
                pos.x = this.leftPos.x = view.data[12];
                pos.y = this.leftPos.y = view.data[13];
                pos.z = this.leftPos.z = view.data[14];
                view.copy(this.rightView);
                view.invert();
                this.rightViewInv.copy(view);
                var deltaX = pos.x - view.data[12];
                var deltaY = pos.y - view.data[13];
                var deltaZ = pos.z - view.data[14];
                var dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
                this.rightPos.x = view.data[12];
                this.rightPos.y = view.data[13];
                this.rightPos.z = view.data[14];
                pos.x += view.data[12];
                pos.y += view.data[13];
                pos.z += view.data[14];
                pos.x *= 0.5; // middle pos
                pos.y *= 0.5;
                pos.z *= 0.5;
                var b = Math.PI * 0.5;
                var c = maxFov * 0.5;
                var a = Math.PI - (b + c);
                var offset = dist * 0.5 * ( Math.sin(a) );// / Math.sin(b) ); // equals 1
                var fwdX = view.data[8];
                var fwdY = view.data[9];
                var fwdZ = view.data[10];
                view.data[12] = pos.x + fwdX * offset; // our forward goes backwards so + instead of -
                view.data[13] = pos.y + fwdY * offset;
                view.data[14] = pos.z + fwdZ * offset;
                this.combinedViewInv.copy(view);
                view.invert();

                // Find combined projection matrix
                this.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG,
                                                 aspect,
                                                 this.display.depthNear + offset,
                                                 this.display.depthFar + offset,
                                                 true);
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#requestPresent
         * @description Try to present full screen VR content on this display.
         * @param {pc.callbacks.VrDisplay} callback - Called when the request is completed. Callback takes a single argument (err) that is the error message return
         * if presenting fails, or null if the call succeeds. Usually called by {@link pc.CameraComponent#enterVr}.
         */
        requestPresent: function (callback) {
            if (!this.display) {
                if (callback) callback(new Error("No VrDisplay to requestPresent"));
                return;
            }

            if (this.presenting) {
                if (callback) callback(new Error("VrDisplay already presenting"));
                return;
            }

            this.display.requestPresent([{ source: this._device.canvas }]).then(function () {
                if (callback) callback();
            }, function (err) {
                if (callback) callback(err);
            });
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#exitPresent
         * @description Try to stop presenting VR content on this display.
         * @param {pc.callbacks.VrDisplay} callback - Called when the request is completed. Callback takes a single argument (err) that is the error message return
         * if presenting fails, or null if the call succeeds. Usually called by {@link pc.CameraComponent#exitVr}.
         */
        exitPresent: function (callback) {
            if (!this.display) {
                if (callback) callback(new Error("No VrDisplay to exitPresent"));
            }

            if (!this.presenting) {
                if (callback) callback(new Error("VrDisplay not presenting"));
                return;
            }

            this.display.exitPresent().then(function () {
                if (callback) callback();
            }, function () {
                if (callback) callback(new Error("exitPresent failed"));
            });
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#requestAnimationFrame
         * @description Used in the main application loop instead of the regular `window.requestAnimationFrame`. Usually only called from inside {@link pc.Application}.
         * @param {pc.callbacks.VrFrame} fn - Function called when it is time to update the frame.
         */
        requestAnimationFrame: function (fn) {
            if (this.display) this.display.requestAnimationFrame(fn);
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#submitFrame
         * @description Called when animation update is complete and the frame is ready to be sent to the display. Usually only called from inside {@link pc.Application}.
         */
        submitFrame: function () {
            if (this.display) this.display.submitFrame();
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#reset
         * @description Called to reset the pose of the pc.VrDisplay. Treating its current pose as the origin/zero. This should only be called in 'sitting' experiences.
         */
        reset: function () {
            if (this.display) this.display.resetPose();
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#setClipPlanes
         * @description Set the near and far depth plans of the display. This enables mapping of values in the
         * render target depth attachment to scene coordinates.
         * @param {number} n - The near depth distance.
         * @param {number} f - The far depth distance.
         */
        setClipPlanes: function (n, f) {
            if (this.display) {
                this.display.depthNear = n;
                this.display.depthFar = f;
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrDisplay#getFrameData
         * @description Return the current frame data that is updated during polling.
         * @returns {VRFrameData} The frame data object.
         */
        getFrameData: function () {
            if (this.display) return this._frameData;
        }
    });

    Object.defineProperty(VrDisplay.prototype, "capabilities", {
        get: function () {
            if (this.display) return this.display.capabilities;
            return {};
        }
    });

    /**
     * @private
     * @deprecated
     * @class
     * @name pc.VrManager
     * @augments pc.EventHandler
     * @classdesc Manage and update {@link pc.VrDisplay}s that are attached to this device.
     * @description Manage and update {@link pc.VrDisplay}s that are attached to this device.
     * @param {pc.Application} app - The main application.
     * @property {pc.VrDisplay[]} displays The list of {@link pc.VrDisplay}s that are attached to this device.
     * @property {pc.VrDisplay} display The default {@link pc.VrDisplay} to be used. Usually the first in the `displays` list.
     * @property {boolean} isSupported Reports whether this device supports the WebVR API.
     */
    function VrManager(app) {
        EventHandler.call(this);

        var self = this;

        this.isSupported = VrManager.isSupported;

        this._index = { };
        this.displays = [];
        this.display = null; // primary display (usually the first in list)

        this._app = app;

        // bind functions for event callbacks
        this._onDisplayConnect = this._onDisplayConnect.bind(this);
        this._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);

        self._attach();

        this._getDisplays(function (err, displays) {
            if (err) {
                // webvr not available
                self.fire('error', err);
            } else {
                for (var i = 0; i < displays.length; i++) {
                    self._addDisplay(displays[i]);
                }

                self.fire('ready', self.displays);
            }
        });
    }
    VrManager.prototype = Object.create(EventHandler.prototype);
    VrManager.prototype.constructor = VrManager;

    /**
     * @private
     * @deprecated
     * @event
     * @name pc.VrManager#displayconnect
     * @description Fired when an VR display is connected.
     * @param {pc.VrDisplay} display - The {@link pc.VrDisplay} that has just been connected.
     * @example
     * this.app.vr.on("displayconnect", function (display) {
     *     // use `display` here
     * });
     */

    /**
     * @private
     * @deprecated
     * @event
     * @name pc.VrManager#displaydisconnect
     * @description Fired when an VR display is disconnected.
     * @param {pc.VrDisplay} display - The {@link pc.VrDisplay} that has just been disconnected.
     * @example
     * this.app.vr.on("displaydisconnect", function (display) {
     *     // `display` is no longer connected
     * });
     */

    /**
     * @private
     * @deprecated
     * @static
     * @name pc.VrManager.isSupported
     * @type {boolean}
     * @description Reports whether this device supports the WebVR API.
     */
    if (typeof navigator !== 'undefined') {
        VrManager.isSupported = !!navigator.getVRDisplays;
    } else {
        VrManager.isSupported = false;
    }

    Object.assign(VrManager.prototype, {
        _attach: function () {
            window.addEventListener('vrdisplayconnect', this._onDisplayConnect);
            window.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
        },

        _detach: function () {
            window.removeEventListener('vrdisplayconnect', this._onDisplayConnect);
            window.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrManager#destroy
         * @description Remove events and clear up manager.
         */
        destroy: function () {
            this._detach();
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.VrManager#poll
         * @description Called once per frame to poll all attached displays.
         */
        poll: function () {
            var l = this.displays.length;
            if (!l) return;
            for (var i = 0; i < l; i++) {
                if (this.displays[i]._camera) this.displays[i].poll();
            }
        },

        _getDisplays: function (callback) {
            if (navigator.getVRDisplays) {
                navigator.getVRDisplays().then(function (displays) {
                    if (callback) callback(null, displays);
                });
            } else {
                if (callback) callback(new Error('WebVR not supported'));
            }
        },

        _addDisplay: function (vrDisplay) {
            if (this._index[vrDisplay.displayId])
                return;

            var display = new VrDisplay(this._app, vrDisplay);
            this._index[display.id] = display;
            this.displays.push(display);

            if (!this.display)
                this.display = display;

            this.fire('displayconnect', display);
        },

        _onDisplayConnect: function (e) {
            if (e.detail && e.detail.display) {
                // polyfill has different event format
                this._addDisplay(e.detail.display);
            } else {
                // real event API
                this._addDisplay(e.display);
            }

        },

        _onDisplayDisconnect: function (e) {
            var id;
            if (e.detail && e.detail.display) {
                // polyfill has different event format
                id = e.detail.display.displayId;
            } else {
                // real event API
                id = e.display.displayId;
            }

            var display = this._index[id];
            if (!display)
                return;

            display.destroy();

            delete this._index[display.id];

            var ind = this.displays.indexOf(display);
            this.displays.splice(ind, 1);

            if (this.display === display) {
                if (this.displays.length) {
                    this.display = this.displays[0];
                } else {
                    this.display = null;
                }
            }

            this.fire('displaydisconnect', display);
        }
    });

    /**
     * @constant
     * @type string
     * @name pc.XRTYPE_INLINE
     * @description Inline - always available type of session. It has limited features availability and is rendered
     * into HTML element.
     */
    var XRTYPE_INLINE = 'inline';

    /**
     * @constant
     * @type string
     * @name pc.XRTYPE_VR
     * @description Immersive VR - session that provides exclusive access to VR device with best available tracking
     * features.
     */
    var XRTYPE_VR = 'immersive-vr';

    /**
     * @constant
     * @type string
     * @name pc.XRTYPE_AR
     * @description Immersive AR - session that provides exclusive access to VR/AR device that is intended to be blended
     * with real-world environment.
     */
    var XRTYPE_AR = 'immersive-ar';

    /**
     * @constant
     * @type string
     * @name pc.XRSPACE_VIEWER
     * @description Viewer - always supported space with some basic tracking capabilities.
     */
    var XRSPACE_VIEWER = 'viewer';

    /**
     * @constant
     * @type string
     * @name pc.XRSPACE_LOCAL
     * @description Local - represents a tracking space with a native origin near the viewer at the time of creation.
     * The exact position and orientation will be initialized based on the conventions of the underlying platform.
     * When using this reference space the user is not expected to move beyond their initial position much, if at all,
     * and tracking is optimized for that purpose. For devices with 6DoF tracking, local reference spaces should
     * emphasize keeping the origin stable relative to the user’s environment.
     */
    var XRSPACE_LOCAL = 'local';

    /**
     * @constant
     * @type string
     * @name pc.XRSPACE_LOCALFLOOR
     * @description Local Floor - represents a tracking space with a native origin at the floor in a safe position for
     * the user to stand. The y axis equals 0 at floor level, with the x and z position and orientation initialized
     * based on the conventions of the underlying platform. Floor level value might be estimated by the underlying
     * platform. When using this reference space, the user is not expected to move beyond their initial position much,
     * if at all, and tracking is optimized for that purpose. For devices with 6DoF tracking, local-floor reference
     * spaces should emphasize keeping the origin stable relative to the user’s environment.
     */
    var XRSPACE_LOCALFLOOR = 'local-floor';

    /**
     * @constant
     * @type string
     * @name pc.XRSPACE_BOUNDEDFLOOR
     * @description Bounded Floor - represents a tracking space with its native origin at the floor, where the user
     * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference space is optimized
     * for keeping the native origin and bounds geometry stable relative to the user’s environment.
     */
    var XRSPACE_BOUNDEDFLOOR = 'bounded-floor';

    /**
     * @constant
     * @type string
     * @name pc.XRSPACE_UNBOUNDED
     * @description Unbounded - represents a tracking space where the user is expected to move freely around their
     * environment, potentially even long distances from their starting point. Tracking in an unbounded reference space
     * is optimized for stability around the user’s current position, and as such the native origin may drift over time.
     */
    var XRSPACE_UNBOUNDED = 'unbounded';

    /**
     * @constant
     * @type string
     * @name pc.XRTARGETRAY_GAZE
     * @description Gaze - indicates the target ray will originate at the viewer and follow the direction it is facing. (This is commonly referred to as a "gaze input" device in the context of head-mounted displays.)
     */
    var XRTARGETRAY_GAZE = 'gaze';

    /**
     * @constant
     * @type string
     * @name pc.XRTARGETRAY_SCREEN
     * @description Screen - indicates that the input source was an interaction with the canvas element associated with an inline session’s output context, such as a mouse click or touch event.
     */
    var XRTARGETRAY_SCREEN = 'screen';

    /**
     * @constant
     * @type string
     * @name pc.XRTARGETRAY_POINTER
     * @description Tracked Pointer - indicates that the target ray originates from either a handheld device or other hand-tracking mechanism and represents that the user is using their hands or the held device for pointing.
     */
    var XRTARGETRAY_POINTER = 'tracked-pointer';

    /**
     * @constant
     * @type string
     * @name pc.XRHAND_NONE
     * @description None - input source is not meant to be held in hands.
     */
    var XRHAND_NONE = 'none';

    /**
     * @constant
     * @type string
     * @name pc.XRHAND_LEFT
     * @description Left - indicates that input source is meant to be held in left hand.
     */
    var XRHAND_LEFT = 'left';

    /**
     * @constant
     * @type string
     * @name pc.XRHAND_RIGHT
     * @description Right - indicates that input source is meant to be held in right hand.
     */
    var XRHAND_RIGHT = 'right';

    /**
     * @constant
     * @type string
     * @name pc.XRTRACKABLE_POINT
     * @description Point - indicates that the hit test results will be computed based on the feature points detected by the underlying Augmented Reality system.
     */
    var XRTRACKABLE_POINT = 'point';

    /**
     * @constant
     * @type string
     * @name pc.XRTRACKABLE_PLANE
     * @description Plane - indicates that the hit test results will be computed based on the planes detected by the underlying Augmented Reality system.
     */
    var XRTRACKABLE_PLANE = 'plane';

    /**
     * @constant
     * @type string
     * @name pc.XRTRACKABLE_MESH
     * @description Mesh - indicates that the hit test results will be computed based on the meshes detected by the underlying Augmented Reality system.
     */
    var XRTRACKABLE_MESH = 'mesh';

    var poolVec3 = [];
    var poolQuat = [];

    /**
     * @class
     * @name pc.XrHitTestSource
     * @augments pc.EventHandler
     * @classdesc Represents XR hit test source, which provides access to hit results of real world geometry from AR session.
     * @description Represents XR hit test source, which provides access to hit results of real world geometry from AR session.
     * @param {pc.XrManager} manager - WebXR Manager.
     * @param {object} xrHitTestSource - XRHitTestSource object that is created by WebXR API.
     * @param {boolean} transient - True if XRHitTestSource created for input source profile.
     * @example
     * hitTestSource.on('result', function (position, rotation) {
     *     target.setPosition(position);
     * });
     */
    function XrHitTestSource(manager, xrHitTestSource, transient) {
        EventHandler.call(this);

        this.manager = manager;
        this._xrHitTestSource = xrHitTestSource;
        this._transient = transient;
    }
    XrHitTestSource.prototype = Object.create(EventHandler.prototype);
    XrHitTestSource.prototype.constructor = XrHitTestSource;

    /**
     * @event
     * @name pc.XrHitTestSource#remove
     * @description Fired when {pc.XrHitTestSource} is removed.
     * @example
     * hitTestSource.once('remove', function () {
     *     // hit test source has been removed
     * });
     */

    /**
     * @event
     * @name pc.XrHitTestSource#result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {pc.Vec3} position - Position of hit test
     * @param {pc.Quat} rotation - Rotation of hit test
     * @param {pc.XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source
     * @example
     * hitTestSource.on('result', function (position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */

    /**
     * @function
     * @name pc.XrHitTestSource#remove
     * @description Stop and remove hit test source.
     */
    XrHitTestSource.prototype.remove = function () {
        if (! this._xrHitTestSource)
            return;

        var sources = this.manager.hitTest.sources;
        var ind = sources.indexOf(this);
        if (ind !== -1) sources.splice(ind, 1);

        this.onStop();
    };

    XrHitTestSource.prototype.onStop = function () {
        this._xrHitTestSource.cancel();
        this._xrHitTestSource = null;

        this.fire('remove');
        this.manager.hitTest.fire('remove', this);
    };

    XrHitTestSource.prototype.update = function (frame) {
        if (this._transient) {
            var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
            for (var i = 0; i < transientResults.length; i++) {
                var transientResult = transientResults[i];
                var inputSource;

                if (transientResult.inputSource)
                    inputSource = this.manager.input._getByInputSource(transientResult.inputSource);

                this.updateHitResults(transientResult.results, inputSource);
            }
        } else {
            this.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));
        }
    };

    XrHitTestSource.prototype.updateHitResults = function (results, inputSource) {
        for (var i = 0; i < results.length; i++) {
            var pose = results[i].getPose(this.manager._referenceSpace);

            var position = poolVec3.pop();
            if (! position) position = new Vec3();
            position.copy(pose.transform.position);

            var rotation = poolQuat.pop();
            if (! rotation) rotation = new Quat();
            rotation.copy(pose.transform.orientation);

            this.fire('result', position, rotation, inputSource);
            this.manager.hitTest.fire('result', this, position, rotation, inputSource);

            poolVec3.push(position);
            poolQuat.push(rotation);
        }
    };

    /**
     * @class
     * @name pc.XrHitTest
     * @augments pc.EventHandler
     * @classdesc Hit Test provides ability to get position and rotation of ray intersecting point with representation of real world geometry by underlying AR system.
     * @description Hit Test provides ability to get position and rotation of ray intersecting point with representation of real world geometry by underlying AR system.
     * @param {pc.XrManager} manager - WebXR Manager.
     * @property {boolean} supported True if AR Hit Test is supported.
     * @property {pc.XrHitTestSource[]} sources list of active {@link pc.XrHitTestSource}.
     */
    function XrHitTest(manager) {
        EventHandler.call(this);

        this.manager = manager;
        this._supported = !! (window.XRSession && window.XRSession.prototype.requestHitTestSource);

        this._session = null;

        this.sources = [];

        if (this._supported) {
            this.manager.on('start', this._onSessionStart, this);
            this.manager.on('end', this._onSessionEnd, this);
        }
    }
    XrHitTest.prototype = Object.create(EventHandler.prototype);
    XrHitTest.prototype.constructor = XrHitTest;

    /**
     * @event
     * @name pc.XrHitTest#add
     * @description Fired when new {@link pc.XrHitTestSource} is added to the list.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that has been added
     * @example
     * app.xr.hitTest.on('add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */

    /**
     * @event
     * @name pc.XrHitTest#remove
     * @description Fired when {@link pc.XrHitTestSource} is removed to the list.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that has been removed
     * @example
     * app.xr.hitTest.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */

    /**
     * @event
     * @name pc.XrHitTest#result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that produced the hit result
     * @param {pc.Vec3} position - Position of hit test
     * @param {pc.Quat} rotation - Rotation of hit test
     * @param {pc.XrInputSource|null} inputSource - If is transient hit test source, then it will provide related input source
     * @example
     * app.xr.hitTest.on('result', function (hitTestSource, position, rotation, inputSource) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */

    /**
     * @event
     * @name pc.XrHitTest#error
     * @param {Error} error - Error object related to failure of creating hit test source.
     * @description Fired when failed create hit test source.
     */

    XrHitTest.prototype._onSessionStart = function () {
        if (this.manager.type !== XRTYPE_AR)
            return;

        this._session = this.manager.session;
    };

    XrHitTest.prototype._onSessionEnd = function () {
        if (! this._session)
            return;

        this._session = null;

        for (var i = 0; i < this.sources.length; i++) {
            this.sources[i].onStop();
        }
        this.sources = [];
    };

    XrHitTest.prototype.isAvailable = function (callback, fireError) {
        var err;

        if (! this._supported)
            err = new Error('XR HitTest is not supported');

        if (! this._session)
            err = new Error('XR Session is not started (1)');

        if (this.manager.type !== XRTYPE_AR)
            err = new Error('XR HitTest is available only for AR');

        if (err) {
            if (callback) callback(err);
            if (fireError) fireError.fire('error', err);
            return false;
        }

        return true;
    };

    /**
     * @function
     * @name pc.XrHitTest#start
     * @description Attempts to start hit test with provided reference space.
     * @param {object} [options] - Optional object for passing arguments.
     * @param {string} [options.spaceType] - Reference space type. Defaults to {@link pc.XRSPACE_VIEWER}. Can be one of the following:
     *
     * * {@link pc.XRSPACE_VIEWER}: Viewer - hit test will be facing relative to viewers space.
     * * {@link pc.XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the viewer at the time of creation.
     * * {@link pc.XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin at the floor in a safe position for the user to stand. The y axis equals 0 at floor level. Floor level value might be estimated by the underlying platform.
     * * {@link pc.XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native origin at the floor, where the user is expected to move within a pre-established boundary.
     * * {@link pc.XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is expected to move freely around their environment, potentially long distances from their starting point.
     *
     * @param {string} [options.profile] - if hit test source meant to match input source instead of reference space, then name of profile of the {@link pc.XrInputSource} should be provided.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types against which hit tests will be performed. Defaults to [ {pc.XRTRACKABLE_PLANE} ]. Can be any combination of the following:
     *
     * * {@link pc.XRTRACKABLE_POINT}: Point - indicates that the hit test results will be computed based on the feature points detected by the underlying Augmented Reality system.
     * * {@link pc.XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be computed based on the planes detected by the underlying Augmented Reality system.
     * * {@link pc.XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be computed based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {pc.Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {pc.callbacks.XrHitTestStart} [options.callback] - Optional callback function called once hit test source is created or failed.
     * @example
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_VIEWER,
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation) {
     *             // position and rotation of hit test result
     *             // based on Ray facing forward from the Viewer reference space
     *         });
     *     }
     * });
     * @example
     * var ray = new pc.Ray(new pc.Vec3(0, 0, 0), new pc.Vec3(0, -1, 0));
     * app.xr.hitTest.start({
     *     spaceType: pc.XRSPACE_LOCAL,
     *     offsetRay: ray,
     *     callback: function (err, hitTestSource) {
     *         // hit test source that will sample real world geometry straight down
     *         // from the position where AR session started
     *     }
     * });
     * @example
     * app.xr.hitTest.start({
     *     profile: 'generic-touchscreen',
     *     callback: function (err, hitTestSource) {
     *         if (err) return;
     *         hitTestSource.on('result', function (position, rotation, inputSource) {
     *             // position and rotation of hit test result
     *             // that will be created from touch on mobile devices
     *         });
     *     }
     * });
     */
    XrHitTest.prototype.start = function (options) {
        var self = this;

        options = options || { };

        if (! this.isAvailable(options.callback, this))
            return;

        if (! options.profile && ! options.spaceType)
            options.spaceType = XRSPACE_VIEWER;

        var xrRay;
        var offsetRay = options.offsetRay;
        if (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));

        var callback = options.callback;

        if (options.spaceType) {
            this._session.requestReferenceSpace(options.spaceType).then(function (referenceSpace) {
                if (! self._session) {
                    var err = new Error('XR Session is not started (2)');
                    if (callback) callback(err);
                    self.fire('error', err);
                    return;
                }

                self._session.requestHitTestSource({
                    space: referenceSpace,
                    entityTypes: options.entityTypes || undefined,
                    offsetRay: xrRay
                }).then(function (xrHitTestSource) {
                    self._onHitTestSource(xrHitTestSource, false, callback);
                }).catch(function (ex) {
                    if (callback) callback(ex);
                    self.fire('error', ex);
                });
            }).catch(function (ex) {
                if (callback) callback(ex);
                self.fire('error', ex);
            });
        } else {
            this._session.requestHitTestSourceForTransientInput({
                profile: options.profile,
                entityTypes: options.entityTypes || undefined,
                offsetRay: xrRay
            }).then(function (xrHitTestSource) {
                self._onHitTestSource(xrHitTestSource, true, callback);
            }).catch(function (ex) {
                if (callback) callback(ex);
                self.fire('error', ex);
            });
        }
    };

    XrHitTest.prototype._onHitTestSource = function (xrHitTestSource, transient, callback) {
        if (! this._session) {
            xrHitTestSource.cancel();
            var err = new Error('XR Session is not started (3)');
            if (callback) callback(err);
            this.fire('error', err);
            return;
        }

        var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);
        this.sources.push(hitTestSource);

        if (callback) callback(null, hitTestSource);
        this.fire('add', hitTestSource);
    };

    XrHitTest.prototype.update = function (frame) {
        for (var i = 0; i < this.sources.length; i++) {
            this.sources[i].update(frame);
        }
    };


    Object.defineProperty(XrHitTest.prototype, 'supported', {
        get: function () {
            return this._supported;
        }
    });

    var quat = new Quat();
    var ids = 0;

    /**
     * @class
     * @name pc.XrInputSource
     * @augments pc.EventHandler
     * @classdesc Represents XR input source, which is any input mechanism which allows the user to perform targeted actions in the same virtual space as the viewer. Example XR input sources include, but are not limited to, handheld controllers, optically tracked hands, and gaze-based input methods that operate on the viewer's pose.
     * @description Represents XR input source, which is any input mechanism which allows the user to perform targeted actions in the same virtual space as the viewer. Example XR input sources include, but are not limited to, handheld controllers, optically tracked hands, and gaze-based input methods that operate on the viewer's pose.
     * @param {pc.XrManager} manager - WebXR Manager.
     * @param {object} xrInputSource - XRInputSource object that is created by WebXR API.
     * @property {number} id Unique number associated with instance of input source. Same physical devices when reconnected will not share this ID.
     * @property {object} inputSource XRInputSource object that is associated with this input source.
     * @property {string} targetRayMode Type of ray Input Device is based on. Can be one of the following:
     *
     * * {@link pc.XRTARGETRAY_GAZE}: Gaze - indicates the target ray will originate at the viewer and follow the direction it is facing. (This is commonly referred to as a "gaze input" device in the context of head-mounted displays.)
     * * {@link pc.XRTARGETRAY_SCREEN}: Screen - indicates that the input source was an interaction with the canvas element associated with an inline session’s output context, such as a mouse click or touch event.
     * * {@link pc.XRTARGETRAY_POINTER}: Tracked Pointer - indicates that the target ray originates from either a handheld device or other hand-tracking mechanism and represents that the user is using their hands or the held device for pointing.
     *
     * @property {string} handedness Describes which hand input source is associated with. Can be one of the following:
     *
     * * {@link pc.XRHAND_NONE}: None - input source is not meant to be held in hands.
     * * {@link pc.XRHAND_LEFT}: Left - indicates that input source is meant to be held in left hand.
     * * {@link pc.XRHAND_RIGHT}: Right - indicates that input source is meant to be held in right hand.
     *
     * @property {string[]} profiles List of input profile names indicating both the prefered visual representation and behavior of the input source.
     * @property {boolean} grip If input source can be held, then it will have node with its world transformation, that can be used to position and rotate virtual joystics based on it.
     * @property {Gamepad|null} gamepad If input source has buttons, triggers, thumbstick or touchpad, then this object provides access to its states.
     * @property {boolean} selecting True if input source is in active primary action between selectstart and selectend events.
     * @property {boolean} elementInput Set to true to allow input source to interact with Element components. Defaults to true.
     * @property {pc.Entity} elementEntity If {@link pc.XrInputSource#elementInput} is true, this property will hold entity with Element component at which this input source is hovering, or null if not hovering over any element.
     * @property {pc.XrHitTestSource[]} hitTestSources list of active {@link pc.XrHitTestSource} created by this input source.
     */
    function XrInputSource(manager, xrInputSource) {
        EventHandler.call(this);

        this._id = ++ids;

        this._manager = manager;
        this._xrInputSource = xrInputSource;

        this._ray = new Ray();
        this._rayLocal = new Ray();
        this._grip = false;

        this._localTransform = null;
        this._worldTransform = null;
        this._position = new Vec3();
        this._rotation = new Quat();
        this._localPosition = null;
        this._localRotation = null;
        this._dirtyLocal = true;

        this._selecting = false;

        this._elementInput = true;
        this._elementEntity = null;

        this._hitTestSources = [];
    }
    XrInputSource.prototype = Object.create(EventHandler.prototype);
    XrInputSource.prototype.constructor = XrInputSource;

    /**
     * @event
     * @name pc.XrInputSource#remove
     * @description Fired when {@link pc.XrInputSource} is removed.
     * @example
     * inputSource.once('remove', function () {
     *     // input source is not available anymore
     * });
     */

    /**
     * @event
     * @name pc.XrInputSource#select
     * @description Fired when input source has triggered primary action. This could be pressing a trigger button, or touching a screen.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     * @example
     * var ray = new pc.Ray();
     * inputSource.on('select', function (evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */

    /**
     * @event
     * @name pc.XrInputSource#selectstart
     * @description Fired when input source has started to trigger primary action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     */

    /**
     * @event
     * @name pc.XrInputSource#selectend
     * @description Fired when input source has ended triggerring primary action.
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     */

    /**
     * @event
     * @name pc.XrInputSource#hittest:add
     * @description Fired when new {@link pc.XrHitTestSource} is added to the input source.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that has been added
     * @example
     * inputSource.on('hittest:add', function (hitTestSource) {
     *     // new hit test source is added
     * });
     */

    /**
     * @event
     * @name pc.XrInputSource#hittest:remove
     * @description Fired when {@link pc.XrHitTestSource} is removed to the the input source.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that has been removed
     * @example
     * inputSource.on('remove', function (hitTestSource) {
     *     // hit test source is removed
     * });
     */

    /**
     * @event
     * @name pc.XrInputSource#hittest:result
     * @description Fired when hit test source receives new results. It provides transform information that tries to match real world picked geometry.
     * @param {pc.XrHitTestSource} hitTestSource - Hit test source that produced the hit result
     * @param {pc.Vec3} position - Position of hit test
     * @param {pc.Quat} rotation - Rotation of hit test
     * @example
     * inputSource.on('hittest:result', function (hitTestSource, position, rotation) {
     *     target.setPosition(position);
     *     target.setRotation(rotation);
     * });
     */

    XrInputSource.prototype.update = function (frame) {
        var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
        if (! targetRayPose) return;

        // grip
        if (this._xrInputSource.gripSpace) {
            var gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
            if (gripPose) {
                if (! this._grip) {
                    this._grip = true;

                    this._localTransform = new Mat4();
                    this._worldTransform = new Mat4();

                    this._localPosition = new Vec3();
                    this._localRotation = new Quat();
                }
                this._dirtyLocal = true;
                this._localPosition.copy(gripPose.transform.position);
                this._localRotation.copy(gripPose.transform.orientation);
            }
        }

        // ray
        this._dirtyRay = true;
        this._rayLocal.origin.copy(targetRayPose.transform.position);
        this._rayLocal.direction.set(0, 0, -1);
        quat.copy(targetRayPose.transform.orientation);
        quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
    };

    XrInputSource.prototype._updateTransforms = function () {
        var dirty;

        if (this._dirtyLocal) {
            dirty = true;
            this._dirtyLocal = false;
            this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
        }

        var parent = this._manager.camera.parent;
        if (parent) {
            dirty = dirty || parent._dirtyLocal || parent._dirtyWorld;

            if (dirty) {
                var parentTransform = this._manager.camera.parent.getWorldTransform();
                this._worldTransform.mul2(parentTransform, this._localTransform);
            }
        } else {
            this._worldTransform.copy(this._localTransform);
        }
    };

    XrInputSource.prototype._updateRayTransforms = function () {
        var dirty = this._dirtyRay;
        this._dirtyRay = false;

        var parent = this._manager.camera.parent;
        if (parent) {
            dirty = dirty || parent._dirtyLocal || parent._dirtyWorld;

            if (dirty) {
                var parentTransform = this._manager.camera.parent.getWorldTransform();

                parentTransform.getTranslation(this._position);
                this._rotation.setFromMat4(parentTransform);

                this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
                this._ray.origin.add(this._position);
                this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
            }
        } else if (dirty) {
            this._ray.origin.copy(this._rayLocal.origin);
            this._ray.direction.copy(this._rayLocal.direction);
        }
    };

    /**
     * @function
     * @name pc.XrInputSource#getPosition
     * @description Get the world space position of input source if it is handheld ({@link pc.XrInputSource#grip} is true). Otherwise it will return null.
     * @returns {pc.Vec3|null} The world space position of handheld input source.
     */
    XrInputSource.prototype.getPosition = function () {
        if (! this._position) return null;

        this._updateTransforms();
        this._worldTransform.getTranslation(this._position);

        return this._position;
    };

    /**
     * @function
     * @name pc.XrInputSource#getLocalPosition
     * @description Get the local space position of input source if it is handheld ({@link pc.XrInputSource#grip} is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     * @returns {pc.Vec3|null} The world space position of handheld input source.
     */
    XrInputSource.prototype.getLocalPosition = function () {
        return this._localPosition;
    };

    /**
     * @function
     * @name pc.XrInputSource#getRotation
     * @description Get the world space rotation of input source if it is handheld ({@link pc.XrInputSource#grip} is true). Otherwise it will return null.
     * @returns {pc.Vec3|null} The world space rotation of handheld input source.
     */
    XrInputSource.prototype.getRotation = function () {
        if (! this._rotation) return null;

        this._updateTransforms();
        this._rotation.setFromMat4(this._worldTransform);

        return this._rotation;
    };

    /**
     * @function
     * @name pc.XrInputSource#getLocalRotation
     * @description Get the local space rotation of input source if it is handheld ({@link pc.XrInputSource#grip} is true). Local space is relative to parent of the XR camera. Otherwise it will return null.
     * @returns {pc.Vec3|null} The world space rotation of handheld input source.
     */
    XrInputSource.prototype.getLocalRotation = function () {
        return this._localRotation;
    };

    /**
     * @function
     * @name pc.XrInputSource#getOrigin
     * @description Get the world space origin of input source ray.
     * @returns {pc.Vec3} The world space origin of input source ray.
     */
    XrInputSource.prototype.getOrigin = function () {
        this._updateRayTransforms();
        return this._ray.origin;
    };

    /**
     * @function
     * @name pc.XrInputSource#getDirection
     * @description Get the world space direction of input source ray.
     * @returns {pc.Vec3} The world space direction of input source ray.
     */
    XrInputSource.prototype.getDirection = function () {
        this._updateRayTransforms();
        return this._ray.direction;
    };

    /**
     * @function
     * @name pc.XrInputSource#hitTestStart
     * @description Attempts to start hit test source based on this input source.
     * @param {object} [options] - Object for passing optional arguments.
     * @param {string[]} [options.entityTypes] - Optional list of underlying entity types
     * against which hit tests will be performed. Defaults to [ {pc.XRTRACKABLE_PLANE} ].
     * Can be any combination of the following:
     *
     * * {@link pc.XRTRACKABLE_POINT}: Point - indicates that the hit test results will be
     * computed based on the feature points detected by the underlying Augmented Reality system.
     * * {@link pc.XRTRACKABLE_PLANE}: Plane - indicates that the hit test results will be
     * computed based on the planes detected by the underlying Augmented Reality system.
     * * {@link pc.XRTRACKABLE_MESH}: Mesh - indicates that the hit test results will be
     * computed based on the meshes detected by the underlying Augmented Reality system.
     *
     * @param {pc.Ray} [options.offsetRay] - Optional ray by which hit test ray can be offset.
     * @param {pc.callbacks.XrHitTestStart} [options.callback] - Optional callback function
     * called once hit test source is created or failed.
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     inputSource.hitTestStart({
     *         callback: function (err, hitTestSource) {
     *             if (err) return;
     *             hitTestSource.on('result', function (position, rotation) {
     *                 // position and rotation of hit test result
     *                 // that will be created from touch on mobile devices
     *             });
     *         }
     *     });
     * });
     */
    XrInputSource.prototype.hitTestStart = function (options) {
        var self = this;

        options = options || { };
        options.profile = this._xrInputSource.profiles[0];

        var callback = options.callback;
        options.callback = function (err, hitTestSource) {
            if (hitTestSource) self.onHitTestSourceAdd(hitTestSource);
            if (callback) callback(err, hitTestSource);
        };

        this._manager.hitTest.start(options);
    };

    XrInputSource.prototype.onHitTestSourceAdd = function (hitTestSource) {
        this._hitTestSources.push(hitTestSource);

        this.fire('hittest:add', hitTestSource);

        hitTestSource.on('result', function (position, rotation, inputSource) {
            if (inputSource !== this)
                return;

            this.fire('hittest:result', hitTestSource, position, rotation);
        }, this);
        hitTestSource.once('remove', function () {
            this.onHitTestSourceRemove(hitTestSource);
            this.fire('hittest:remove', hitTestSource);
        }, this);
    };

    XrInputSource.prototype.onHitTestSourceRemove = function (hitTestSource) {
        var ind = this._hitTestSources.indexOf(hitTestSource);
        if (ind !== -1) this._hitTestSources.splice(ind, 1);
    };

    Object.defineProperty(XrInputSource.prototype, 'id', {
        get: function () {
            return this._id;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'inputSource', {
        get: function () {
            return this._xrInputSource;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'targetRayMode', {
        get: function () {
            return this._xrInputSource.targetRayMode;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'handedness', {
        get: function () {
            return this._xrInputSource.handedness;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'profiles', {
        get: function () {
            return this._xrInputSource.profiles;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'grip', {
        get: function () {
            return this._grip;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'gamepad', {
        get: function () {
            return this._xrInputSource.gamepad || null;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'selecting', {
        get: function () {
            return this._selecting;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'elementInput', {
        get: function () {
            return this._elementInput;
        },
        set: function (value) {
            if (this._elementInput === value)
                return;

            this._elementInput = value;

            if (! this._elementInput)
                this._elementEntity = null;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'elementEntity', {
        get: function () {
            return this._elementEntity;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'hitTestSources', {
        get: function () {
            return this._hitTestSources;
        }
    });

    /**
     * @class
     * @name pc.XrInput
     * @augments pc.EventHandler
     * @classdesc Provides access to input sources for WebXR.
     * @description Provides access to input sources for WebXR.
     * @param {pc.XrManager} manager - WebXR Manager.
     * @property {pc.XrInputSource[]} inputSources List of active {@link pc.XrInputSource}.
     */
    function XrInput(manager) {
        EventHandler.call(this);

        var self = this;

        this.manager = manager;
        this._session = null;
        this._inputSources = [];

        this._onInputSourcesChangeEvt = function (evt) {
            self._onInputSourcesChange(evt);
        };

        this.manager.on('start', this._onSessionStart, this);
        this.manager.on('end', this._onSessionEnd, this);
    }
    XrInput.prototype = Object.create(EventHandler.prototype);
    XrInput.prototype.constructor = XrInput;

    /**
     * @event
     * @name pc.XrInput#add
     * @description Fired when new {@link pc.XrInputSource} is added to the list.
     * @param {pc.XrInputSource} inputSource - Input source that has been added
     * @example
     * app.xr.input.on('add', function (inputSource) {
     *     // new input source is added
     * });
     */

    /**
     * @event
     * @name pc.XrInput#remove
     * @description Fired when {@link pc.XrInputSource} is removed to the list.
     * @param {pc.XrInputSource} inputSource - Input source that has been removed
     * @example
     * app.xr.input.on('remove', function (inputSource) {
     *     // input source is removed
     * });
     */

    /**
     * @event
     * @name pc.XrInput#select
     * @description Fired when {@link pc.XrInputSource} has triggered primary action. This could be pressing a trigger button, or touching a screen.
     * @param {pc.XrInputSource} inputSource - Input source that triggered select event
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     * @example
     * var ray = new pc.Ray();
     * app.xr.input.on('select', function (inputSource, evt) {
     *     ray.set(inputSource.getOrigin(), inputSource.getDirection());
     *     if (obj.intersectsRay(ray)) {
     *         // selected an object with input source
     *     }
     * });
     */

    /**
     * @event
     * @name pc.XrInput#selectstart
     * @description Fired when {pc.XrInputSource} has started to trigger primary action.
     * @param {pc.XrInputSource} inputSource - Input source that triggered selectstart event
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     */

    /**
     * @event
     * @name pc.XrInput#selectend
     * @description Fired when {pc.XrInputSource} has ended triggerring primary action.
     * @param {pc.XrInputSource} inputSource - Input source that triggered selectend event
     * @param {object} evt - XRInputSourceEvent event data from WebXR API
     */

    XrInput.prototype._onSessionStart = function () {
        this._session = this.manager.session;
        this._session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);

        var self = this;

        this._session.addEventListener('select', function (evt) {
            var inputSource = self._getByInputSource(evt.inputSource);
            inputSource.update(evt.frame);
            inputSource.fire('select', evt);
            self.fire('select', inputSource, evt);
        });
        this._session.addEventListener('selectstart', function (evt) {
            var inputSource = self._getByInputSource(evt.inputSource);
            inputSource.update(evt.frame);
            inputSource._selecting = true;
            inputSource.fire('selectstart', evt);
            self.fire('selectstart', inputSource, evt);
        });
        this._session.addEventListener('selectend', function (evt) {
            var inputSource = self._getByInputSource(evt.inputSource);
            inputSource.update(evt.frame);
            inputSource._selecting = false;
            inputSource.fire('selectend', evt);
            self.fire('selectend', inputSource, evt);
        });

        // add input sources
        var inputSources = this._session.inputSources;
        for (var i = 0; i < inputSources.length; i++) {
            this._addInputSource(inputSources[i]);
        }
    };

    XrInput.prototype._onSessionEnd = function () {
        var i = this._inputSources.length;
        while (i--) {
            var inputSource = this._inputSources[i];
            this._inputSources.splice(i, 1);
            inputSource.fire('remove');
            this.fire('remove', inputSource);
        }

        this._session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
        this._session = null;
    };

    XrInput.prototype._onInputSourcesChange = function (evt) {
        var i;

        // remove
        for (i = 0; i < evt.removed.length; i++) {
            this._removeInputSource(evt.removed[i]);
        }

        // add
        for (i = 0; i < evt.added.length; i++) {
            this._addInputSource(evt.added[i]);
        }
    };

    XrInput.prototype._getByInputSource = function (xrInputSource) {
        for (var i = 0; i < this._inputSources.length; i++) {
            if (this._inputSources[i].inputSource === xrInputSource) {
                return this._inputSources[i];
            }
        }

        return null;
    };

    XrInput.prototype._addInputSource = function (xrInputSource) {
        if (this._getByInputSource(xrInputSource))
            return;

        var inputSource = new XrInputSource(this.manager, xrInputSource);
        this._inputSources.push(inputSource);
        this.fire('add', inputSource);
    };

    XrInput.prototype._removeInputSource = function (xrInputSource) {
        for (var i = 0; i < this._inputSources.length; i++) {
            if (this._inputSources[i].inputSource !== xrInputSource)
                continue;

            var inputSource = this._inputSources[i];
            this._inputSources.splice(i, 1);

            var h = inputSource.hitTestSources.length;
            while (h--) {
                inputSource.hitTestSources[h].remove();
            }

            inputSource.fire('remove');
            this.fire('remove', inputSource);
            return;
        }
    };

    XrInput.prototype.update = function (frame) {
        for (var i = 0; i < this._inputSources.length; i++) {
            this._inputSources[i].update(frame);
        }
    };

    Object.defineProperty(XrInput.prototype, 'inputSources', {
        get: function () {
            return this._inputSources;
        }
    });

    var vec3A = new Vec3();
    var vec3B = new Vec3();
    var mat4A = new Mat4();
    var mat4B = new Mat4();

    /**
     * @class
     * @name pc.XrLightEstimation
     * @augments pc.EventHandler
     * @classdesc Light Estimation provides illimunation data from the real world, which is estimated by the underlying AR system.
     * It provides a reflection Cube Map, that represents the reflection estimation from the viewer position.
     * A more simplified approximation of light is provided by L2 Spherical Harmonics data.
     * And the most simple level of light estimation is the most prominent directional light, its rotation, intensity and color.
     * @description Creates a new XrLightEstimation. Note that this is created internally by the {@link pc.XrManager}.
     * @param {pc.XrManager} manager - WebXR Manager.
     * @property {boolean} supported True if Light Estimation is supported. This information is available only during an active AR session.
     * @property {number|null} intensity Intensity of what is estimated to be the most prominent directional light. Or null if data is not available.
     * @property {pc.Color|null} color Color of what is estimated to be the most prominent directional light. Or null if data is not available.
     * @property {pc.Quat|null} rotation Rotation of what is estimated to be the most prominent directional light. Or null if data is not available.
     */
    function XrLightEstimation(manager) {
        EventHandler.call(this);

        this._manager = manager;

        this._supported = false;
        this._available = false;

        this._lightProbeRequested = false;
        this._lightProbe = null;

        this._intensity = 0;
        this._rotation = new Quat();
        this._color = new Color();

        this._sphericalHarmonics = new Float32Array(27);

        this._manager.on('start', this._onSessionStart, this);
        this._manager.on('end', this._onSessionEnd, this);
    }
    XrLightEstimation.prototype = Object.create(EventHandler.prototype);
    XrLightEstimation.prototype.constructor = XrLightEstimation;

    /**
     * @event
     * @name pc.XrLightEstimation#available
     * @description Fired when light estimation data becomes available.
     */

    /**
     * @event
     * @name pc.XrLightEstimation#error
     * @param {Error} error - Error object related to failure of light estimation start.
     * @description Fired when light estimation has failed to start.
     * @example
     * app.xr.lightEstimation.on('error', function (ex) {
     *     // has failed to start
     * });
     */

    XrLightEstimation.prototype._onSessionStart = function () {
        var supported = !! this._manager.session.requestLightProbe;
        if (! supported) return;
        this._supported = true;
    };

    XrLightEstimation.prototype._onSessionEnd = function () {
        this._supported = false;
        this._available = false;

        this._lightProbeRequested = false;
        this._lightProbe = null;
    };

    /**
     * @function
     * @name pc.XrLightEstimation#start
     * @description Start estimation of illimunation data.
     * Availability of such data will come later and an `available` event will be fired.
     * If it failed to start estimation, an `error` event will be fired.
     * @example
     * app.xr.on('start', function () {
     *     if (app.xr.lightEstimation.supported) {
     *         app.xr.lightEstimation.start();
     *     }
     * });
     */
    XrLightEstimation.prototype.start = function () {
        var err;

        if (! this._manager.session)
            err = new Error('XR session is not running');

        if (! err && this._manager.type !== XRTYPE_AR)
            err = new Error('XR session type is not AR');

        if (! err && ! this._supported)
            err = new Error('light-estimation is not supported');

        if (! err && this._lightProbe || this._lightProbeRequested)
            err = new Error('light estimation is already requested');

        if (err) {
            this.fire('error', err);
            return;
        }

        var self = this;
        this._lightProbeRequested = true;

        this._manager.session.requestLightProbe(
        ).then(function (lightProbe) {
            var wasRequested = self._lightProbeRequested;
            self._lightProbeRequested = false;

            if (self._manager.active) {
                if (wasRequested) {
                    self._lightProbe = lightProbe;
                }
            } else {
                self.fire('error', new Error('XR session is not active'));
            }
        }).catch(function (ex) {
            self._lightProbeRequested = false;
            self.fire('error', ex);
        });
    };

    /**
     * @function
     * @name pc.XrLightEstimation#end
     * @description End estimation of illumination data.
     */
    XrLightEstimation.prototype.end = function () {
        this._lightProbeRequested = false;
        this._lightProbe = null;
        this._available = false;
    };

    XrLightEstimation.prototype.update = function (frame) {
        if (! this._lightProbe) return;

        var lightEstimate = frame.getLightEstimate(this._lightProbe);
        if (! lightEstimate) return;

        if (! this._available) {
            this._available = true;
            this.fire('available');
        }

        // intensity
        var pli = lightEstimate.primaryLightIntensity;
        this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));

        // color
        vec3A.copy(pli).scale(1 / this._intensity);
        this._color.set(vec3A.x, vec3A.y, vec3A.z);

        // rotation
        vec3A.set(0, 0, 0);
        vec3B.copy(lightEstimate.primaryLightDirection);
        mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
        mat4B.setFromAxisAngle(Vec3.RIGHT, 90); // direcitonal light is looking down
        mat4A.mul(mat4B);
        this._rotation.setFromMat4(mat4A);

        // spherical harmonics
        this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
    };

    Object.defineProperty(XrLightEstimation.prototype, 'supported', {
        get: function () {
            return this._supported;
        }
    });

    /**
     * @name pc.XrLightEstimation#available
     * @type {boolean}
     * @description True if estimated light information is available.
     * @example
     * if (app.xr.lightEstimation.available) {
     *     entity.light.intensity = app.xr.lightEstimation.intensity;
     * }
     */
    Object.defineProperty(XrLightEstimation.prototype, 'available', {
        get: function () {
            return !! this._available;
        }
    });

    Object.defineProperty(XrLightEstimation.prototype, 'intensity', {
        get: function () {
            return this._available ? this._intensity : null;
        }
    });

    Object.defineProperty(XrLightEstimation.prototype, 'color', {
        get: function () {
            return this._available ? this._color : null;
        }
    });

    Object.defineProperty(XrLightEstimation.prototype, 'rotation', {
        get: function () {
            return this._available ? this._rotation : null;
        }
    });

    Object.defineProperty(XrLightEstimation.prototype, 'sphericalHarmonics', {
        get: function () {
            return this._available ? this._sphericalHarmonics : null;
        }
    });

    /**
     * @class
     * @name pc.XrManager
     * @augments pc.EventHandler
     * @classdesc Manage and update XR session and its states.
     * @description Manage and update XR session and its states.
     * @param {pc.Application} app - The main application.
     * @property {boolean} supported True if XR is supported.
     * @property {boolean} active True if XR session is running.
     * @property {string|null} type Returns type of currently running XR session or null if no session is running. Can be
     * any of pc.XRTYPE_*.
     * @property {string|null} spaceType Returns reference space type of currently running XR session or null if no session
     * is running. Can be any of pc.XRSPACE_*.
     * @property {pc.Entity|null} camera Active camera for which XR session is running or null.
     * @property {pc.XrInput} input provides access to Input Sources.
     * @property {pc.XrHitTest} hitTest provides ability to hit test representation of real world geometry of underlying AR system.
     */
    function XrManager(app) {
        EventHandler.call(this);

        var self = this;

        this.app = app;

        this._supported = !! navigator.xr;

        this._available = {
            XRTYPE_AR: false,
            XRTYPE_VR: false,
            XRTYPE_INLINE: false
        };

        this._type = null;
        this._spaceType = null;
        this._session = null;
        this._baseLayer = null;
        this._referenceSpace = null;

        this.input = new XrInput(this);
        this.hitTest = new XrHitTest(this);
        this.lightEstimation = new XrLightEstimation(this);

        this._camera = null;
        this.views = [];
        this.viewsPool = [];
        this._localPosition = new Vec3();
        this._localRotation = new Quat();

        this._depthNear = 0.1;
        this._depthFar = 1000;

        this._width = 0;
        this._height = 0;

        // TODO
        // 1. HMD class with its params
        // 2. Space class
        // 3. Controllers class

        if (this._supported) {
            navigator.xr.addEventListener('devicechange', function () {
                self._deviceAvailabilityCheck();
            });
            this._deviceAvailabilityCheck();
        }
    }
    XrManager.prototype = Object.create(EventHandler.prototype);
    XrManager.prototype.constructor = XrManager;

    /**
     * @event
     * @name pc.XrManager#available
     * @description Fired when availability of specific XR type is changed.
     * @param {string} type - The session type that has changed availability.
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available', function (type, available) {
     *     console.log('"' + type + '" XR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */

    /**
     * @event
     * @name pc.XrManager#available:[type]
     * @description Fired when availability of specific XR type is changed.
     * @param {boolean} available - True if specified session type is now available.
     * @example
     * app.xr.on('available:' + pc.XRTYPE_VR, function (available) {
     *     console.log('Immersive VR session is now ' + (available ? 'available' : 'unavailable'));
     * });
     */

    /**
     * @event
     * @name pc.XrManager#start
     * @description Fired when XR session is started
     * @example
     * app.xr.on('start', function () {
     *     // XR session has started
     * });
     */

    /**
     * @event
     * @name pc.XrManager#end
     * @description Fired when XR session is ended
     * @example
     * app.xr.on('end', function () {
     *     // XR session has ended
     * });
     */

     /**
      * @event
      * @name pc.XrManager#error
      * @param {Error} error - Error object related to failure of session start or check of session type support.
      * @description Fired when XR session is failed to start or failed to check for session type support.
      * @example
      * app.xr.on('error', function (ex) {
      *     // XR session has failed to start, or failed to check for session type support
      * });
      */

    /**
     * @function
     * @name pc.XrManager#start
     * @description Attempts to start XR session for provided {@link pc.CameraComponent} and optionally fires callback when session is created or failed to create.
     * @param {pc.CameraComponent} camera - it will be used to render XR session and manipulated based on pose tracking
     * @param {string} type - session type. Can be one of the following:
     *
     * * {@link pc.XRTYPE_INLINE}: Inline - always available type of session. It has limited features availability and is rendered into HTML element.
     * * {@link pc.XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with best available tracking features.
     * * {@link pc.XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device that is intended to be blended with real-world environment.
     *
     * @param {string} spaceType - reference space type. Can be one of the following:
     *
     * * {@link pc.XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking capabilities.
     * * {@link pc.XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the viewer at the time of creation. It is meant for seated or basic local XR sessions.
     * * {@link pc.XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin at the floor in a safe position for the user to stand. The y axis equals 0 at floor level. Floor level value might be estimated by the underlying platform. It is meant for seated or basic local XR sessions.
     * * {@link pc.XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native origin at the floor, where the user is expected to move within a pre-established boundary.
     * * {@link pc.XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is expected to move freely around their environment, potentially long distances from their starting point.
     *
     * @example
     * button.on('click', function () {
     *     app.xr.start(camera, pc.XRTYPE_VR, pc.XRSPACE_LOCAL);
     * });
     * @param {pc.callbacks.XrError} [callback] - Optional callback function called once session is started. The callback has one argument Error - it is null if successfully started XR session.
     */
    XrManager.prototype.start = function (camera, type, spaceType, callback) {
        if (! this._available[type]) {
            if (callback) callback(new Error('XR is not available'));
            return;
        }

        if (this._session) {
            if (callback) callback(new Error('XR session is already started'));
            return;
        }

        var self = this;

        this._camera = camera;
        this._camera.camera.xr = this;
        this._type = type;
        this._spaceType = spaceType;

        this._setClipPlanes(camera.nearClip, camera.farClip);

        // TODO
        // makeXRCompatible
        // scenario to test:
        // 1. app is running on integrated GPU
        // 2. XR device is connected, to another GPU
        // 3. probably immersive-vr will fail to be created
        // 4. call makeXRCompatible, very likely will lead to context loss

        var optionalFeatures = [];

        if (type === XRTYPE_AR)
            optionalFeatures.push('light-estimation');

        navigator.xr.requestSession(type, {
            requiredFeatures: [spaceType],
            optionalFeatures: optionalFeatures
        }).then(function (session) {
            self._onSessionStart(session, spaceType, callback);
        }).catch(function (ex) {
            self._camera.camera.xr = null;
            self._camera = null;
            self._type = null;
            self._spaceType = null;

            if (callback) callback(ex);
            self.fire('error', ex);
        });
    };

    /**
     * @function
     * @name pc.XrManager#end
     * @description Attempts to end XR session and optionally fires callback when session is ended or failed to end.
     * @example
     * app.keyboard.on('keydown', function (evt) {
     *     if (evt.key === pc.KEY_ESCAPE && app.xr.active) {
     *         app.xr.end();
     *     }
     * });
     * @param {pc.callbacks.XrError} [callback] - Optional callback function called once session is started. The callback has one argument Error - it is null if successfully started XR session.
     */
    XrManager.prototype.end = function (callback) {
        if (! this._session) {
            if (callback) callback(new Error('XR Session is not initialized'));
            return;
        }

        if (callback) this.once('end', callback);

        this._session.end();
    };

    /**
     * @function
     * @name pc.XrManager#isAvailable
     * @description Check if specific type of session is available
     * @param {string} type - session type. Can be one of the following:
     *
     * * {@link pc.XRTYPE_INLINE}: Inline - always available type of session. It has limited features availability and is rendered into HTML element.
     * * {@link pc.XRTYPE_VR}: Immersive VR - session that provides exclusive access to VR device with best available tracking features.
     * * {@link pc.XRTYPE_AR}: Immersive AR - session that provides exclusive access to VR/AR device that is intended to be blended with real-world environment.
     *
     * @example
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     * @returns {boolean} True if specified session type is available.
     */
    XrManager.prototype.isAvailable = function (type) {
        return this._available[type];
    };

    XrManager.prototype._deviceAvailabilityCheck = function () {
        for (var key in this._available) {
            this._sessionSupportCheck(key);
        }
    };

    XrManager.prototype._sessionSupportCheck = function (type) {
        var self = this;

        navigator.xr.isSessionSupported(type).then(function (available) {
            if (self._available[type] === available)
                return;

            self._available[type] = available;
            self.fire('available', type, available);
            self.fire('available:' + type, available);
        }).catch(function (ex) {
            self.fire('error', ex);
        });
    };

    XrManager.prototype._onSessionStart = function (session, spaceType, callback) {
        var self = this;
        var failed = false;

        this._session = session;

        var onVisibilityChange = function () {
            self.fire('visibility:change', session.visibilityState);
        };

        var onClipPlanesChange = function () {
            self._setClipPlanes(self._camera.nearClip, self._camera.farClip);
        };

        // clean up once session is ended
        var onEnd = function () {
            self._session = null;
            self._referenceSpace = null;
            self.views = [];
            self._width = 0;
            self._height = 0;
            self._type = null;
            self._spaceType = null;

            if (self._camera) {
                self._camera.off('set_nearClip', onClipPlanesChange);
                self._camera.off('set_farClip', onClipPlanesChange);

                self._camera.camera.xr = null;
                self._camera = null;
            }

            session.removeEventListener('end', onEnd);
            session.removeEventListener('visibilitychange', onVisibilityChange);

            if (! failed) self.fire('end');

            // old requestAnimationFrame will never be triggered,
            // so queue up new tick
            self.app.tick();
        };

        session.addEventListener('end', onEnd);
        session.addEventListener('visibilitychange', onVisibilityChange);

        this._camera.on('set_nearClip', onClipPlanesChange);
        this._camera.on('set_farClip', onClipPlanesChange);

        this._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl);

        session.updateRenderState({
            baseLayer: this._baseLayer,
            depthNear: this._depthNear,
            depthFar: this._depthFar
        });

        // request reference space
        session.requestReferenceSpace(spaceType).then(function (referenceSpace) {
            self._referenceSpace = referenceSpace;

            // old requestAnimationFrame will never be triggered,
            // so queue up new tick
            self.app.tick();

            if (callback) callback(null);
            self.fire('start');
        }).catch(function (ex) {
            failed = true;
            session.end();
            if (callback) callback(ex);
            self.fire('error', ex);
        });
    };

    XrManager.prototype._setClipPlanes = function (near, far) {
        if (this._depthNear === near && this._depthFar === far)
            return;

        this._depthNear = near;
        this._depthFar = far;

        if (! this._session)
            return;

        // if session is available,
        // queue up render state update
        this._session.updateRenderState({
            depthNear: this._depthNear,
            depthFar: this._depthFar
        });
    };

    XrManager.prototype.update = function (frame) {
        if (! this._session) return;

        var i, view, viewRaw, layer, viewport;
        var lengthNew;

        // canvas resolution should be set on first frame availability or resolution changes
        var width = frame.session.renderState.baseLayer.framebufferWidth;
        var height = frame.session.renderState.baseLayer.framebufferHeight;
        if (this._width !== width || this._height !== height) {
            this._width = width;
            this._height = height;
            this.app.graphicsDevice.setResolution(width, height);
        }

        var pose = frame.getViewerPose(this._referenceSpace);
        lengthNew = pose ? pose.views.length : 0;

        if (lengthNew > this.views.length) {
            // add new views into list
            for (i = 0; i <= (lengthNew - this.views.length); i++) {
                view = this.viewsPool.pop();
                if (! view) {
                    view = {
                        viewport: new Vec4(),
                        projMat: new Mat4(),
                        viewMat: new Mat4(),
                        viewOffMat: new Mat4(),
                        viewInvMat: new Mat4(),
                        viewInvOffMat: new Mat4(),
                        projViewOffMat: new Mat4(),
                        viewMat3: new Mat3(),
                        position: new Float32Array(3),
                        rotation: new Quat()
                    };
                }

                this.views.push(view);
            }
        } else if (lengthNew <= this.views.length) {
            // remove views from list into pool
            for (i = 0; i < (this.views.length - lengthNew); i++) {
                this.viewsPool.push(this.views.pop());
            }
        }

        if (pose) {
            // reset position
            var posePosition = pose.transform.position;
            var poseOrientation = pose.transform.orientation;
            this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
            this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);

            layer = frame.session.renderState.baseLayer;

            for (i = 0; i < pose.views.length; i++) {
                // for each view, calculate matrices
                viewRaw = pose.views[i];
                view = this.views[i];
                viewport = layer.getViewport(viewRaw);

                view.viewport.x = viewport.x;
                view.viewport.y = viewport.y;
                view.viewport.z = viewport.width;
                view.viewport.w = viewport.height;

                view.projMat.set(viewRaw.projectionMatrix);
                view.viewMat.set(viewRaw.transform.inverse.matrix);
                view.viewInvMat.set(viewRaw.transform.matrix);
            }
        }

        // position and rotate camera based on calculated vectors
        this._camera.camera._node.setLocalPosition(this._localPosition);
        this._camera.camera._node.setLocalRotation(this._localRotation);

        this.input.update(frame);

        if (this._type === XRTYPE_AR) {
            if (this.hitTest.supported) {
                this.hitTest.update(frame);
            }
            if (this.lightEstimation.supported) {
                this.lightEstimation.update(frame);
            }
        }

        this.fire('update');
    };

    Object.defineProperty(XrManager.prototype, 'supported', {
        get: function () {
            return this._supported;
        }
    });

    Object.defineProperty(XrManager.prototype, 'active', {
        get: function () {
            return !! this._session;
        }
    });

    Object.defineProperty(XrManager.prototype, 'type', {
        get: function () {
            return this._type;
        }
    });

    Object.defineProperty(XrManager.prototype, 'spaceType', {
        get: function () {
            return this._spaceType;
        }
    });

    Object.defineProperty(XrManager.prototype, 'session', {
        get: function () {
            return this._session;
        }
    });

    Object.defineProperty(XrManager.prototype, 'visibilityState', {
        get: function () {
            if (! this._session)
                return null;

            return this._session.visibilityState;
        }
    });

    Object.defineProperty(XrManager.prototype, 'camera', {
        get: function () {
            return this._camera ? this._camera.entity : null;
        }
    });

    /**
     * @class
     * @name pc.Component
     * @augments pc.EventHandler
     * @classdesc Components are used to attach functionality on a {@link pc.Entity}. Components
     * can receive update events each frame, and expose properties to the PlayCanvas Editor.
     * @description Base constructor for a Component.
     * @param {pc.ComponentSystem} system - The ComponentSystem used to create this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {pc.ComponentSystem} system The ComponentSystem used to create this Component.
     * @property {pc.Entity} entity The Entity that this Component is attached to.
     * @property {boolean} enabled Enables or disables the component.
     */
    function Component(system, entity) {
        EventHandler.call(this);

        this.system = system;
        this.entity = entity;

        if (this.system.schema && !this._accessorsBuilt) {
            this.buildAccessors(this.system.schema);
        }

        this.on("set", function (name, oldValue, newValue) {
            this.fire("set_" + name, name, oldValue, newValue);
        });

        this.on('set_enabled', this.onSetEnabled, this);
    }
    Component.prototype = Object.create(EventHandler.prototype);
    Component.prototype.constructor = Component;

    Component._buildAccessors = function (obj, schema) {
        // Create getter/setter pairs for each property defined in the schema
        schema.forEach(function (descriptor) {
            // If the property descriptor is an object, it should have a `name`
            // member. If not, it should just be the plain property name.
            var name = (typeof descriptor === 'object') ? descriptor.name : descriptor;

            Object.defineProperty(obj, name, {
                get: function () {
                    return this.data[name];
                },
                set: function (value) {
                    var data = this.data;
                    var oldValue = data[name];
                    data[name] = value;
                    this.fire('set', name, oldValue, value);
                },
                configurable: true
            });
        });

        obj._accessorsBuilt = true;
    };

    Object.assign(Component.prototype, {
        buildAccessors: function (schema) {
            Component._buildAccessors(this, schema);
        },

        onSetEnabled: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                if (this.entity.enabled) {
                    if (newValue) {
                        this.onEnable();
                    } else {
                        this.onDisable();
                    }
                }
            }
        },

        onEnable: function () { },

        onDisable: function () { },

        onPostStateChange: function () { }
    });

    /**
     * @private
     * @property {pc.ComponentData} data Access the {@link pc.ComponentData} directly.
     * Usually you should access the data properties via the individual properties as
     * modifying this data directly will not fire 'set' events.
     */
    Object.defineProperty(Component.prototype, "data", {
        get: function () {
            var record = this.system.store[this.entity.getGuid()];
            return record ? record.data : null;
        }
    });

    /**
     * @class
     * @name pc.ComponentSystem
     * @augments pc.EventHandler
     * @classdesc Component Systems contain the logic and functionality to update all Components of a particular type.
     * @param {pc.Application} app - The application managing this system.
     */
    function ComponentSystem(app) {
        EventHandler.call(this);

        this.app = app;

        // The store where all pc.ComponentData objects are kept
        this.store = {};
        this.schema = [];
    }
    ComponentSystem.prototype = Object.create(EventHandler.prototype);
    ComponentSystem.prototype.constructor = ComponentSystem;

    // Class methods
    Object.assign(ComponentSystem, {
        _helper: function (a, p) {
            for (var i = 0, l = a.length; i < l; i++) {
                a[i].f.call(a[i].s, p);
            }
        },

        initialize: function (root) {
            this._helper(this._init, root);
        },

        postInitialize: function (root) {
            this._helper(this._postInit, root);

            // temp, this is for internal use on entity-references until a better system is found
            this.fire('postinitialize', root);
        },

        // Update all ComponentSystems
        update: function (dt, inTools) {
            this._helper(inTools ? this._toolsUpdate : this._update, dt);
        },

        animationUpdate: function (dt, inTools) {
            this._helper(this._animationUpdate, dt);
        },

        // Update all ComponentSystems
        fixedUpdate: function (dt, inTools) {
            this._helper(this._fixedUpdate, dt);
        },

        // Update all ComponentSystems
        postUpdate: function (dt, inTools) {
            this._helper(this._postUpdate, dt);
        },

        _init: [],
        _postInit: [],
        _toolsUpdate: [],
        _update: [],
        _animationUpdate: [],
        _fixedUpdate: [],
        _postUpdate: [],

        bind: function (event, func, scope) {
            switch (event) {
                case 'initialize':
                    this._init.push({ f: func, s: scope });
                    break;
                case 'postInitialize':
                    this._postInit.push({ f: func, s: scope });
                    break;
                case 'update':
                    this._update.push({ f: func, s: scope });
                    break;
                case 'animationUpdate':
                    this._animationUpdate.push({ f: func, s: scope });
                    break;
                case 'postUpdate':
                    this._postUpdate.push({ f: func, s: scope });
                    break;
                case 'fixedUpdate':
                    this._fixedUpdate.push({ f: func, s: scope });
                    break;
                case 'toolsUpdate':
                    this._toolsUpdate.push({ f: func, s: scope });
                    break;
                default:
                    console.error('Component System does not support event', event);
            }
        },

        _erase: function (a, f, s) {
            for (var i = 0; i < a.length; i++) {
                if (a[i].f === f && a[i].s === s) {
                    a.splice(i--, 1);
                }
            }
        },

        unbind: function (event, func, scope) {
            switch (event) {
                case 'initialize':
                    this._erase(this._init, func, scope);
                    break;
                case 'postInitialize':
                    this._erase(this._postInit, func, scope);
                    break;
                case 'update':
                    this._erase(this._update, func, scope);
                    break;
                case 'animationUpdate':
                    this._erase(this._animationUpdate, func, scope);
                    break;
                case 'postUpdate':
                    this._erase(this._postUpdate, func, scope);
                    break;
                case 'fixedUpdate':
                    this._erase(this._fixedUpdate, func, scope);
                    break;
                case 'toolsUpdate':
                    this._erase(this._toolsUpdate, func, scope);
                    break;
                default:
                    console.error('Component System does not support event', event);
            }
        }
    });

    // Instance methods
    Object.assign(ComponentSystem.prototype, {
        /**
         * @private
         * @function
         * @name pc.ComponentSystem#addComponent
         * @description Create new {@link pc.Component} and {@link pc.ComponentData} instances and attach them to the entity.
         * @param {pc.Entity} entity - The Entity to attach this component to.
         * @param {object} [data] - The source data with which to create the component.
         * @returns {pc.Component} Returns a Component of type defined by the component system.
         * @example
         * var entity = new pc.Entity(app);
         * app.systems.model.addComponent(entity, { type: 'box' });
         * // entity.model is now set to a pc.ModelComponent
         */
        addComponent: function (entity, data) {
            var component = new this.ComponentType(this, entity);
            var componentData = new this.DataType();

            data = data || {};

            this.store[entity.getGuid()] = {
                entity: entity,
                data: componentData
            };

            entity[this.id] = component;
            entity.c[this.id] = component;

            this.initializeComponentData(component, data, []);

            this.fire('add', entity, component);

            return component;
        },

        /**
         * @private
         * @function
         * @name pc.ComponentSystem#removeComponent
         * @description Remove the {@link pc.Component} from the entity and delete the associated {@link pc.ComponentData}.
         * @param {pc.Entity} entity - The entity to remove the component from.
         * @example
         * app.systems.model.removeComponent(entity);
         * // entity.model === undefined
         */
        removeComponent: function (entity) {
            var record = this.store[entity.getGuid()];
            var component = entity.c[this.id];
            this.fire('beforeremove', entity, component);
            delete this.store[entity.getGuid()];
            delete entity[this.id];
            delete entity.c[this.id];
            this.fire('remove', entity, record.data);
        },

        /**
         * @private
         * @function
         * @name pc.ComponentSystem#cloneComponent
         * @description Create a clone of component. This creates a copy all ComponentData variables.
         * @param {pc.Entity} entity - The entity to clone the component from.
         * @param {pc.Entity} clone - The entity to clone the component into.
         * @returns {pc.Component} The newly cloned component.
         */
        cloneComponent: function (entity, clone) {
            // default clone is just to add a new component with existing data
            var src = this.store[entity.getGuid()];
            return this.addComponent(clone, src.data);
        },

        /**
         * @private
         * @function
         * @name pc.ComponentSystem#initializeComponentData
         * @description Called during {@link pc.ComponentSystem#addComponent} to initialize the {@link pc.ComponentData} in the store
         * This can be overridden by derived Component Systems and either called by the derived System or replaced entirely.
         * @param {pc.Component} component - The component being initialized.
         * @param {object} data - The data block used to initialize the component.
         * @param {string[]|object[]} properties - The array of property descriptors for the component. A descriptor can be either a plain property name, or an object specifying the name and type.
         */
        initializeComponentData: function (component, data, properties) {
            data = data || {};

            var descriptor;
            var name, type, value;

            // initialize
            for (var i = 0, len = properties.length; i < len; i++) {
                descriptor = properties[i];

                // If the descriptor is an object, it will have `name` and `type` members
                if (typeof descriptor === 'object') {
                    name = descriptor.name;
                    type = descriptor.type;
                } else {
                    // Otherwise, the descriptor is just the property name
                    name = descriptor;
                    type = undefined;
                }

                value = data[name];

                if (value !== undefined) {
                    // If we know the intended type of the value, convert the raw data
                    // into an instance of the specified type.
                    if (type !== undefined) {
                        value = convertValue(value, type);
                    }

                    component[name] = value;
                } else {
                    component[name] = component.data[name];
                }
            }

            // after component is initialized call onEnable
            if (component.enabled && component.entity.enabled) {
                component.onEnable();
            }
        },

        /**
         * @private
         * @function
         * @name pc.ComponentSystem#getPropertiesOfType
         * @description Searches the component schema for properties that match the specified type.
         * @param {string} type - The type to search for.
         * @returns {string[]|object[]} An array of property descriptors matching the specified type.
         */
        getPropertiesOfType: function (type) {
            var matchingProperties = [];
            var schema = this.schema || [];

            schema.forEach(function (descriptor) {
                if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
                    matchingProperties.push(descriptor);
                }
            });

            return matchingProperties;
        },

        destroy: function () {
            this.off();
        }
    });

    function convertValue(value, type) {
        if (!value) {
            return value;
        }

        switch (type) {
            case 'rgb':
                if (value instanceof Color) {
                    return value.clone();
                }
                return new Color(value[0], value[1], value[2]);
            case 'rgba':
                if (value instanceof Color) {
                    return value.clone();
                }
                return new Color(value[0], value[1], value[2], value[3]);
            case 'vec2':
                if (value instanceof Vec2) {
                    return value.clone();
                }
                return new Vec2(value[0], value[1]);
            case 'vec3':
                if (value instanceof Vec3) {
                    return value.clone();
                }
                return new Vec3(value[0], value[1], value[2]);
            case 'vec4':
                if (value instanceof Vec4) {
                    return value.clone();
                }
                return new Vec4(value[0], value[1], value[2], value[3]);
            case 'boolean':
            case 'number':
            case 'string':
                return value;
            case 'entity':
                return value; // Entity fields should just be a string guid
            default:
                throw new Error('Could not convert unhandled type: ' + type);
        }
    }

    // Add event support
    events.attach(ComponentSystem);

    ComponentSystem.destroy = function () {
        ComponentSystem.off('initialize');
        ComponentSystem.off('postInitialize');
        ComponentSystem.off('toolsUpdate');
        ComponentSystem.off('update');
        ComponentSystem.off('animationUpdate');
        ComponentSystem.off('fixedUpdate');
        ComponentSystem.off('postUpdate');
    };

    function InterpolatedKey() {
        this._written = false;
        this._name = "";
        this._keyFrames = [];

        // Result of interpolation
        this._quat = new Quat();
        this._pos = new Vec3();
        this._scale = new Vec3();

        // Optional destination for interpolated keyframe
        this._targetNode = null;
    }

    Object.assign(InterpolatedKey.prototype, {
        getTarget: function () {
            return this._targetNode;
        },

        setTarget: function (node) {
            this._targetNode = node;
        }
    });

    /**
     * @class
     * @name pc.Skeleton
     * @classdesc Represents a skeleton used to play animations.
     * @param {pc.GraphNode} graph - The root pc.GraphNode of the skeleton.
     * @property {boolean} looping Determines whether skeleton is looping its animation.
     */
    function Skeleton(graph) {
        this._animation = null;
        this._time = 0;
        this.looping = true;

        this._interpolatedKeys = [];
        this._interpolatedKeyDict = {};
        this._currKeyIndices = {};

        this.graph = null;

        var self = this;

        function addInterpolatedKeys(node) {
            var interpKey = new InterpolatedKey();
            interpKey._name = node.name;
            self._interpolatedKeys.push(interpKey);
            self._interpolatedKeyDict[node.name] = interpKey;
            self._currKeyIndices[node.name] = 0;

            for (var i = 0; i < node._children.length; i++)
                addInterpolatedKeys(node._children[i]);
        }

        addInterpolatedKeys(graph);
    }

    /**
     * @function
     * @name pc.Skeleton#addTime
     * @description Progresses The animation assigned to The specified skeleton by The
     * supplied time delta. If the delta takes the animation passed its end point, if
     * the skeleton is set to loop, the animation will continue from the beginning.
     * Otherwise, the animation's current time will remain at its duration (i.e. the
     * end).
     * @param {number} delta - The time in seconds to progress the skeleton's animation.
     */
    Skeleton.prototype.addTime = function (delta) {
        if (this._animation !== null) {
            var i;
            var node, nodeName;
            var keys, interpKey;
            var k1, k2, alpha;
            var nodes = this._animation._nodes;
            var duration = this._animation.duration;

            // Check if we can early out
            if ((this._time === duration) && !this.looping) {
                return;
            }

            // Step the current time and work out if we need to jump ahead, clamp or wrap around
            this._time += delta;

            if (this._time > duration) {
                this._time = this.looping ? 0.0 : duration;
                for (i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    nodeName = node._name;
                    this._currKeyIndices[nodeName] = 0;
                }
            } else if (this._time < 0) {
                this._time = this.looping ? duration : 0.0;
                for (i = 0; i < nodes.length; i++) {
                    node = nodes[i];
                    nodeName = node._name;
                    this._currKeyIndices[nodeName] = node._keys.length - 2;
                }
            }


            // For each animated node...

            // keys index offset
            var offset = (delta >= 0 ? 1 : -1);

            var foundKey;
            for (i = 0; i < nodes.length; i++) {
                node = nodes[i];
                nodeName = node._name;
                keys = node._keys;

                // Determine the interpolated keyframe for this animated node
                interpKey = this._interpolatedKeyDict[nodeName];
                if (interpKey === undefined) {
                    continue;
                }
                // If there's only a single key, just copy the key to the interpolated key...
                foundKey = false;
                if (keys.length !== 1) {
                    // Otherwise, find the keyframe pair for this node
                    for (var currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {
                        k1 = keys[currKeyIndex];
                        k2 = keys[currKeyIndex + 1];

                        if ((k1.time <= this._time) && (k2.time >= this._time)) {
                            alpha = (this._time - k1.time) / (k2.time - k1.time);

                            interpKey._pos.lerp(k1.position, k2.position, alpha);
                            interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
                            interpKey._scale.lerp(k1.scale, k2.scale, alpha);
                            interpKey._written = true;

                            this._currKeyIndices[nodeName] = currKeyIndex;
                            foundKey = true;
                            break;
                        }
                    }
                }
                if (keys.length === 1 || (!foundKey && this._time === 0.0 && this.looping)) {
                    interpKey._pos.copy(keys[0].position);
                    interpKey._quat.copy(keys[0].rotation);
                    interpKey._scale.copy(keys[0].scale);
                    interpKey._written = true;
                }
            }
        }
    };

    /**
     * @function
     * @name pc.Skeleton#blend
     * @description Blends two skeletons together.
     * @param {pc.Skeleton} skel1 - Skeleton holding the first pose to be blended.
     * @param {pc.Skeleton} skel2 - Skeleton holding the second pose to be blended.
     * @param {number} alpha - The value controlling the interpolation in relation to the two input
     * skeletons. The value is in the range 0 to 1, 0 generating skel1, 1 generating skel2 and anything
     * in between generating a spherical interpolation between the two.
     */
    Skeleton.prototype.blend = function (skel1, skel2, alpha) {
        var numNodes = this._interpolatedKeys.length;
        for (var i = 0; i < numNodes; i++) {
            var key1 = skel1._interpolatedKeys[i];
            var key2 = skel2._interpolatedKeys[i];
            var dstKey = this._interpolatedKeys[i];

            if (key1._written && key2._written) {
                dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
                dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
                dstKey._scale.lerp(key1._scale, key2._scale, alpha);
                dstKey._written = true;
            } else if (key1._written) {
                dstKey._quat.copy(key1._quat);
                dstKey._pos.copy(key1._pos);
                dstKey._scale.copy(key1._scale);
                dstKey._written = true;
            } else if (key2._written) {
                dstKey._quat.copy(key2._quat);
                dstKey._pos.copy(key2._pos);
                dstKey._scale.copy(key2._scale);
                dstKey._written = true;
            }
        }
    };

    /**
     * @name pc.Skeleton#animation
     * @type {pc.Animation}
     * @description Animation currently assigned to skeleton.
     */
    Object.defineProperty(Skeleton.prototype, 'animation', {
        get: function () {
            return this._animation;
        },
        set: function (value) {
            this._animation = value;
            this.currentTime = 0;
        }
    });

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#getAnimation
     * @description Returns the animation currently assigned to the specified skeleton.
     * @returns {pc.Animation} The animation set on the skeleton.
     */
    Skeleton.prototype.getAnimation = function () {
        return this._animation;
    };

    /**
     * @name pc.Skeleton#currentTime
     * @type {number}
     * @description Current time of currently active animation in seconds.
     * This value is between zero and the duration of the animation.
     */
    Object.defineProperty(Skeleton.prototype, 'currentTime', {
        get: function () {
            return this._time;
        },
        set: function (value) {
            this._time = value;
            var numNodes = this._interpolatedKeys.length;
            for (var i = 0; i < numNodes; i++) {
                var node = this._interpolatedKeys[i];
                var nodeName = node._name;
                this._currKeyIndices[nodeName] = 0;
            }

            this.addTime(0);
            this.updateGraph();
        }
    });

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#getCurrentTime
     * @description Returns the current time of the currently active animation as set on
     * the specified skeleton. This value will be between zero and the duration of the
     * animation.
     * @returns {number} The current time of the animation set on the skeleton.
     */
    Skeleton.prototype.getCurrentTime = function () {
        return this._time;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#setCurrentTime
     * @description Sets the current time of the currently active animation as set on
     * the specified skeleton. This value must be between zero and the duration of the
     * animation.
     * @param {number} time - The current time of the animation set on the skeleton.
     */
    Skeleton.prototype.setCurrentTime = function (time) {
        this.currentTime = time;
    };

    /**
     * @readonly
     * @name pc.Skeleton#numNodes
     * @type {number}
     * @description Read-only property that returns number of nodes of a skeleton.
     */
    Object.defineProperty(Skeleton.prototype, 'numNodes', {
        get: function () {
            return this._interpolatedKeys.length;
        }
    });

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#getNumNodes
     * @description Returns the number of nodes held by the specified skeleton.
     * @returns {number} The number of nodes held by the specified skeleton.
     */
    Skeleton.prototype.getNumNodes = function () {
        return this._interpolatedKeys.length;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#setAnimation
     * @description Sets an animation on the specified skeleton.
     * @param {pc.Animation} animation - The animation to set on the skeleton.
     */
    Skeleton.prototype.setAnimation = function (animation) {
        this.animation = animation;
    };

    /**
     * @function
     * @name pc.Skeleton#setGraph
     * @description Links a skeleton to a node hierarchy. The nodes animated skeleton are
     * then subsequently used to drive the local transformation matrices of the node
     * hierarchy.
     * @param {pc.GraphNode} graph - The root node of the graph that the skeleton is to drive.
     */
    Skeleton.prototype.setGraph = function (graph) {
        var i;
        this.graph = graph;

        if (graph) {
            for (i = 0; i < this._interpolatedKeys.length; i++) {
                var interpKey = this._interpolatedKeys[i];
                var graphNode = graph.findByName(interpKey._name);
                this._interpolatedKeys[i].setTarget(graphNode);
            }
        } else {
            for (i = 0; i < this._interpolatedKeys.length; i++) {
                this._interpolatedKeys[i].setTarget(null);
            }
        }
    };

    /**
     * @function
     * @name pc.Skeleton#updateGraph
     * @description Synchronizes the currently linked node hierarchy with the current state of the
     * skeleton. Internally, this function converts the interpolated keyframe at each node in the
     * skeleton into the local transformation matrix at each corresponding node in the linked node
     * hierarchy.
     */
    Skeleton.prototype.updateGraph = function () {
        if (this.graph) {
            for (var i = 0; i < this._interpolatedKeys.length; i++) {
                var interpKey = this._interpolatedKeys[i];
                if (interpKey._written) {
                    var transform = interpKey.getTarget();

                    transform.localPosition.copy(interpKey._pos);
                    transform.localRotation.copy(interpKey._quat);
                    transform.localScale.copy(interpKey._scale);

                    if (!transform._dirtyLocal)
                        transform._dirtifyLocal();

                    interpKey._written = false;
                }
            }
        }
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#setLooping
     * @description Specified whether a skeleton should loop its animation or not. If the animation
     * loops, it will wrap back to the start when adding time to the skeleton beyond the duration
     * of the animation. Otherwise, the animation stops at its end after a single play through.
     * @param {boolean} looping - True to cause the animation to loop back to the start on completion
     * and false otherwise.
     */
    Skeleton.prototype.setLooping = function (looping) {
        this.looping = looping;
    };

    /**
     * @private
     * @deprecated
     * @function
     * @name pc.Skeleton#getLooping
     * @description Queries the specified skeleton to determine whether it is looping its animation.
     * @returns {boolean} True if the skeleton is looping the animation, false otherwise.
     */
    Skeleton.prototype.getLooping = function () {
        return this.looping;
    };

    /**
     * @component Animation
     * @class
     * @name pc.AnimationComponent
     * @augments pc.Component
     * @classdesc The Animation Component allows an Entity to playback animations on models.
     * @description Create a new AnimationComponent.
     * @param {pc.AnimationComponentSystem} system - The {@link pc.ComponentSystem} that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {number} speed Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses the animation.
     * @property {boolean} loop If true the animation will restart from the beginning when it reaches the end.
     * @property {boolean} activate If true the first animation asset will begin playing when the scene is loaded.
     * @property {pc.Asset[]|number[]} assets The array of animation assets - can also be an array of asset ids.
     * @property {number} currentTime Get or Set the current time position (in seconds) of the animation.
     * @property {number} duration Get the duration in seconds of the current animation. [read only]
     * @property {pc.Skeleton|null} skeleton Get the skeleton for the current model; unless model is from glTF/glb, then skeleton is null. [read only]
     * @property {object<string, pc.Animation>} animations Get or Set dictionary of animations by name.
     */
    function AnimationComponent(system, entity) {
        Component.call(this, system, entity);

        this.animationsIndex = { };

        // Handle changes to the 'animations' value
        this.on('set_animations', this.onSetAnimations, this);
        // Handle changes to the 'assets' value
        this.on('set_assets', this.onSetAssets, this);
        // Handle changes to the 'loop' value
        this.on('set_loop', this.onSetLoop, this);
    }
    AnimationComponent.prototype = Object.create(Component.prototype);
    AnimationComponent.prototype.constructor = AnimationComponent;

    Object.assign(AnimationComponent.prototype, {
        /**
         * @function
         * @name pc.AnimationComponent#play
         * @description Start playing an animation.
         * @param {string} name - The name of the animation asset to begin playing.
         * @param {number} [blendTime] - The time in seconds to blend from the current
         * animation state to the start of the animation being set.
         */
        play: function (name, blendTime) {

            if (!this.enabled || !this.entity.enabled) {
                return;
            }

            var data = this.data;

            if (!data.animations[name]) {
                return;
            }

            blendTime = blendTime || 0;

            data.prevAnim = data.currAnim;
            data.currAnim = name;

            if (data.model) {

                if (!data.skeleton && !data.animEvaluator) {
                    this._createAnimationController();
                }

                var prevAnim = data.animations[data.prevAnim];
                var currAnim = data.animations[data.currAnim];

                data.blending = blendTime > 0 && data.prevAnim;
                if (data.blending) {
                    data.blend = 0;
                    data.blendSpeed = 1.0 / blendTime;
                }

                if (data.skeleton) {
                    if (data.blending) {
                        // Blend from the current time of the current animation to the start of
                        // the newly specified animation over the specified blend time period.
                        data.fromSkel.animation = prevAnim;
                        data.fromSkel.addTime(data.skeleton._time);
                        data.toSkel.animation = currAnim;
                    } else {
                        data.skeleton.animation = currAnim;
                    }
                }

                if (data.animEvaluator) {
                    var animEvaluator = data.animEvaluator;

                    if (data.blending) {
                        // remove all but the last clip
                        while (animEvaluator.clips.length > 1) {
                            animEvaluator.removeClip(0);
                        }
                    } else {
                        data.animEvaluator.removeClips();
                    }

                    var clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);
                    clip.name = data.currAnim;
                    clip.blendWeight = data.blending ? 0 : 1;
                    clip.reset();
                    data.animEvaluator.addClip(clip);
                }
            }

            data.playing = true;
        },

        /**
         * @function
         * @name pc.AnimationComponent#getAnimation
         * @description Return an animation.
         * @param {string} name - The name of the animation asset.
         * @returns {pc.Animation} An Animation.
         */
        getAnimation: function (name) {
            return this.data.animations[name];
        },

        setModel: function (model) {
            var data = this.data;

            if (model !== data.model) {
                // reset animation controller
                this._resetAnimationController();

                // set the model
                data.model = model;

                // Reset the current animation on the new model
                if (data.animations && data.currAnim && data.animations[data.currAnim]) {
                    this.play(data.currAnim);
                }
            }
        },

        _resetAnimationController: function () {
            var data = this.data;
            data.skeleton = null;
            data.fromSkel = null;
            data.toSkel = null;
            data.animEvaluator = null;
        },

        _createAnimationController: function () {
            var data = this.data;
            var model = data.model;
            var animations = data.animations;

            // check which type of animations are loaded
            var hasJson = false;
            var hasGlb = false;
            for (var animation in animations) {
                if (animations.hasOwnProperty(animation)) {
                    var anim = animations[animation];
                    if (anim.constructor === AnimTrack) {
                        hasGlb = true;
                    } else {
                        hasJson = true;
                    }
                }
            }

            var graph = model.getGraph();
            if (hasJson) {
                data.fromSkel = new Skeleton(graph);
                data.toSkel = new Skeleton(graph);
                data.skeleton = new Skeleton(graph);
                data.skeleton.looping = data.loop;
                data.skeleton.setGraph(graph);
            } else if (hasGlb) {
                data.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(graph));
            }
        },

        loadAnimationAssets: function (ids) {
            if (!ids || !ids.length)
                return;

            var self = this;
            var assets = this.system.app.assets;
            var i, l = ids.length;

            var onAssetReady = function (asset) {
                if (asset.resources.length > 1) {
                    for (var i = 0; i < asset.resources.length; i++) {
                        self.animations[asset.resources[i].name] = asset.resources[i];
                        self.animationsIndex[asset.id] = asset.resources[i].name;
                    }
                } else {
                    self.animations[asset.name] = asset.resource;
                    self.animationsIndex[asset.id] = asset.name;
                }
                /* eslint-disable no-self-assign */
                self.animations = self.animations; // assigning ensures set_animations event is fired
                /* eslint-enable no-self-assign */
            };

            var onAssetAdd = function (asset) {
                asset.off('change', self.onAssetChanged, self);
                asset.on('change', self.onAssetChanged, self);

                asset.off('remove', self.onAssetRemoved, self);
                asset.on('remove', self.onAssetRemoved, self);

                if (asset.resource) {
                    onAssetReady(asset);
                } else {
                    asset.once('load', onAssetReady, self);
                    if (self.enabled && self.entity.enabled)
                        assets.load(asset);
                }
            };

            for (i = 0; i < l; i++) {
                var asset = assets.get(ids[i]);
                if (asset) {
                    onAssetAdd(asset);
                } else {
                    assets.on('add:' + ids[i], onAssetAdd);
                }
            }
        },

        onAssetChanged: function (asset, attribute, newValue, oldValue) {
            var i;
            if (attribute === 'resource' || attribute === 'resources') {
                // replace old animation with new one
                if (newValue) {
                    var restarted = false;
                    if (newValue.length > 1) {
                        if (oldValue && oldValue.length > 1) {
                            for (i = 0; i < oldValue.length; i++) {
                                delete this.animations[oldValue[i].name];
                            }
                        } else {
                            delete this.animations[asset.name];
                        }
                        restarted = false;
                        for (i = 0; i < newValue.length; i++) {
                            this.animations[newValue[i].name] = newValue[i];

                            if (!restarted && this.data.currAnim === newValue[i].name) {
                                // restart animation
                                if (this.data.playing && this.data.enabled && this.entity.enabled) {
                                    restarted = true;
                                    this.play(newValue[i].name, 0);
                                }
                            }
                        }
                        if (!restarted) {
                            this._stopCurrentAnimation();
                            this.onSetAnimations();
                        }
                    } else {
                        if (oldValue && oldValue.length > 1) {
                            for (i = 0; i < oldValue.length; i++) {
                                delete this.animations[oldValue[i].name];
                            }
                        }
                        this.animations[asset.name] = newValue[0] || newValue;
                        restarted = false;
                        if (this.data.currAnim === asset.name) {
                            // restart animation
                            if (this.data.playing && this.data.enabled && this.entity.enabled) {
                                restarted = true;
                                this.play(asset.name, 0);
                            }
                        }
                        if (!restarted) {
                            this._stopCurrentAnimation();
                            this.onSetAnimations();
                        }
                    }
                    this.animationsIndex[asset.id] = asset.name;
                } else {
                    if (oldValue.length > 1) {
                        for (i = 0; i < oldValue.length; i++) {
                            delete this.animations[oldValue[i].name];
                        }
                    } else {
                        delete this.animations[asset.name];
                    }
                    delete this.animationsIndex[asset.id];
                }
            }
        },

        onAssetRemoved: function (asset) {
            asset.off('remove', this.onAssetRemoved, this);

            if (this.animations) {
                if (asset.resources.length > 1) {
                    for (var i = 0; i < asset.resources.length; i++) {
                        delete this.animations[asset.resources[i].name];
                        if (this.data.currAnim === asset.resources[i].name)
                            this._stopCurrentAnimation();
                    }
                } else {
                    delete this.animations[asset.name];
                    if (this.data.currAnim === asset.name)
                        this._stopCurrentAnimation();
                }
                delete this.animationsIndex[asset.id];
            }
        },

        _stopCurrentAnimation: function () {
            var data = this.data;
            data.currAnim = null;
            data.playing = false;
            if (data.skeleton) {
                data.skeleton.currentTime = 0;
                data.skeleton.animation = null;
            }
            if (data.animEvaluator) {
                data.animEvaluator.removeClips();
            }
        },

        onSetAnimations: function (name, oldValue, newValue) {
            var data = this.data;

            // If we have animations _and_ a model, we can create the skeletons
            var modelComponent = this.entity.model;
            if (modelComponent) {
                var m = modelComponent.model;
                if (m && m !== data.model) {
                    this.setModel(m);
                }
            }

            if (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {
                for (var animName in data.animations) {
                    // Set the first loaded animation as the current
                    this.play(animName, 0);
                    break;
                }
            }
        },

        onSetAssets: function (name, oldValue, newValue) {
            if (oldValue && oldValue.length) {
                for (var i = 0; i < oldValue.length; i++) {
                    // unsubscribe from change event for old assets
                    if (oldValue[i]) {
                        var asset = this.system.app.assets.get(oldValue[i]);
                        if (asset) {
                            asset.off('change', this.onAssetChanged, this);
                            asset.off('remove', this.onAssetRemoved, this);

                            var animName = this.animationsIndex[asset.id];

                            if (this.data.currAnim === animName)
                                this._stopCurrentAnimation();

                            delete this.animations[animName];
                            delete this.animationsIndex[asset.id];
                        }
                    }
                }
            }

            var ids = newValue.map(function (value) {
                return (value instanceof Asset) ? value.id : value;
            });

            this.loadAnimationAssets(ids);
        },

        onSetLoop: function (name, oldValue, newValue) {
            var data = this.data;

            if (data.skeleton) {
                data.skeleton.looping = data.loop;
            }

            if (data.animEvaluator) {
                for (var i = 0; i < data.animEvaluator.clips.length; ++i) {
                    data.animEvaluator.clips[i].loop = data.loop;
                }
            }
        },

        onSetCurrentTime: function (name, oldValue, newValue) {
            var data = this.data;

            if (data.skeleton) {
                var skeleton = data.skeleton;
                skeleton.currentTime = newValue;
                skeleton.addTime(0); // update
                skeleton.updateGraph();
            }

            if (data.animEvaluator) {
                var animEvaluator = data.animEvaluator;
                for (var i = 0; i < animEvaluator.clips.length; ++i) {
                    animEvaluator.clips[i].time = newValue;
                }
            }
        },

        onEnable: function () {
            Component.prototype.onEnable.call(this);

            var data = this.data;

            // load assets if they're not loaded
            var assets = data.assets;
            var registry = this.system.app.assets;
            if (assets) {
                for (var i = 0, len = assets.length; i < len; i++) {
                    var asset = assets[i];
                    if (!(asset instanceof Asset))
                        asset = registry.get(asset);

                    if (asset && !asset.resource)
                        registry.load(asset);
                }
            }

            if (data.activate && !data.currAnim) {
                for (var animName in data.animations) {
                    this.play(animName, 0);
                    break;
                }
            }
        },

        onBeforeRemove: function () {
            for (var i = 0; i < this.assets.length; i++) {
                var asset = this.system.app.assets.get(this.assets[i]);
                if (!asset) continue;

                asset.off('change', this.onAssetChanged, this);
                asset.off('remove', this.onAssetRemoved, this);
            }

            var data = this.data;

            delete data.animation;
            delete data.skeleton;
            delete data.fromSkel;
            delete data.toSkel;

            delete data.animEvaluator;
        }
    });

    Object.defineProperties(AnimationComponent.prototype, {
        currentTime: {
            get: function () {
                return this.data.skeleton._time;
            },
            set: function (currentTime) {
                var data = this.data;
                if (data.skeleton) {
                    var skeleton = data.skeleton;
                    skeleton.currentTime = currentTime;
                    skeleton.addTime(0);
                    skeleton.updateGraph();
                }

                if (data.animEvaluator) {
                    var animEvaluator = data.animEvaluator;
                    for (var i = 0; i < animEvaluator.clips.length; ++i) {
                        animEvaluator.clips[i].time = currentTime;
                    }
                }
            }
        },

        duration: {
            get: function () {
                return this.data.animations[this.data.currAnim].duration;
            }
        }
    });

    function AnimationComponentData() {
        // Serialized
        this.assets = [];
        this.speed = 1.0;
        this.loop = true;
        this.activate = true;
        this.enabled = true;

        // Non-serialized
        this.animations = { };
        this.model = null;
        this.prevAnim = null;
        this.currAnim = null;
        this.blending = false;
        this.blend = 0;
        this.blendSpeed = 0;
        this.playing = false;

        // json animation skeleton
        this.skeleton = null;
        this.fromSkel = null;
        this.toSkel = null;

        // glb animation controller
        this.animEvaluator = null;
    }

    var _schema = [
        'enabled',
        'assets',
        'speed',
        'loop',
        'activate',
        'animations',
        'skeleton',
        'model',
        'prevAnim',
        'currAnim',
        'fromSkel',
        'toSkel',
        'blending',
        'blendTimeRemaining',
        'playing'
    ];

    /**
     * @class
     * @name pc.AnimationComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc The AnimationComponentSystem manages creating and deleting AnimationComponents.
     * @description Create an AnimationComponentSystem.
     * @param {pc.Application} app - The application managing this system.
     */
    function AnimationComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'animation';
        this.description = "Specifies the animation assets that can run on the model specified by the Entity's model Component.";

        this.ComponentType = AnimationComponent;
        this.DataType = AnimationComponentData;

        this.schema = _schema;

        this.on('beforeremove', this.onBeforeRemove, this);
        this.on('update', this.onUpdate, this);

        ComponentSystem.bind('update', this.onUpdate, this);
    }
    AnimationComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    AnimationComponentSystem.prototype.constructor = AnimationComponentSystem;

    Component._buildAccessors(AnimationComponent.prototype, _schema);

    Object.assign(AnimationComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['activate', 'enabled', 'loop', 'speed', 'assets'];
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var key;
            this.addComponent(clone, {});

            clone.animation.assets = entity.animation.assets.slice();
            clone.animation.data.speed = entity.animation.speed;
            clone.animation.data.loop = entity.animation.loop;
            clone.animation.data.activate = entity.animation.activate;
            clone.animation.data.enabled = entity.animation.enabled;

            var clonedAnimations = { };
            var animations = entity.animation.animations;
            for (key in animations) {
                if (animations.hasOwnProperty(key)) {
                    clonedAnimations[key] = animations[key];
                }
            }
            clone.animation.animations = clonedAnimations;

            var clonedAnimationsIndex = { };
            var animationsIndex = entity.animation.animationsIndex;
            for (key in animationsIndex) {
                if (animationsIndex.hasOwnProperty(key)) {
                    clonedAnimationsIndex[key] = animationsIndex[key];
                }
            }
            clone.animation.animationsIndex = clonedAnimationsIndex;
        },

        onBeforeRemove: function (entity, component) {
            component.onBeforeRemove();
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    var component = components[id];
                    var componentData = component.data;

                    if (componentData.enabled && component.entity.enabled) {

                        // update blending
                        if (componentData.blending) {
                            componentData.blend += dt * componentData.blendSpeed;
                            if (componentData.blend >= 1.0) {
                                componentData.blend = 1.0;
                            }
                        }

                        // update skeleton
                        if (componentData.playing) {
                            var skeleton = componentData.skeleton;
                            if (skeleton !== null && componentData.model !== null) {
                                if (componentData.blending) {
                                    skeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);
                                } else {
                                    // Advance the animation, interpolating keyframes at each animated node in
                                    // skeleton
                                    var delta = dt * componentData.speed;
                                    skeleton.addTime(delta);
                                    if (componentData.speed > 0 && (skeleton._time === skeleton._animation.duration) && !componentData.loop) {
                                        componentData.playing = false;
                                    } else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {
                                        componentData.playing = false;
                                    }
                                }

                                if (componentData.blending && (componentData.blend === 1.0)) {
                                    skeleton.animation = componentData.toSkel._animation;
                                }

                                skeleton.updateGraph();
                            }
                        }

                        // update anim controller
                        var animEvaluator = componentData.animEvaluator;
                        if (animEvaluator) {

                            // force all clip's speed and playing state from the component
                            for (var i = 0; i < animEvaluator.clips.length; ++i) {
                                var clip = animEvaluator.clips[i];
                                clip.speed = componentData.speed;
                                if (!componentData.playing) {
                                    clip.pause();
                                } else {
                                    clip.resume();
                                }
                            }

                            // update blend weight
                            if (componentData.blending) {
                                animEvaluator.clips[1].blendWeight = componentData.blend;
                            }

                            animEvaluator.update(dt);
                        }

                        // clear blending flag
                        if (componentData.blending && componentData.blend === 1.0) {
                            componentData.blending = false;
                        }
                    }
                }
            }
        }
    });

    var ANIM_INTERRUPTION_NONE = 'NONE';
    var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
    var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
    var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
    var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';

    var ANIM_GREATER_THAN = 'GREATER_THAN';
    var ANIM_LESS_THAN = 'LESS_THAN';
    var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
    var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
    var ANIM_EQUAL_TO = 'EQUAL_TO';
    var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';

    var ANIM_PARAMETER_INTEGER = 'INTEGER';
    var ANIM_PARAMETER_FLOAT = 'FLOAT';
    var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
    var ANIM_PARAMETER_TRIGGER = 'TRIGGER';

    var ANIM_STATE_START = 'START';
    var ANIM_STATE_END = 'END';

    function AnimComponentBinder(animComponent, graph) {
        this.animComponent = animComponent;

        if (graph) {
            DefaultAnimBinder.call(this, graph);
        } else {
            this.propertyLocator = new AnimPropertyLocator();
        }
    }
    AnimComponentBinder.prototype = Object.create(DefaultAnimBinder.prototype);
    AnimComponentBinder.prototype.constructor = AnimComponentBinder;

    Object.assign(AnimComponentBinder.prototype, {
        resolve: function (path) {
            var pathSections = this.propertyLocator.decode(path);

            var entityHierarchy = pathSections[0];
            var component = pathSections[1];
            var propertyHierarchy = pathSections[2];

            var entity = this._getEntityFromHierarchy(entityHierarchy);

            if (!entity)
                return null;

            var propertyComponent;

            switch (component) {
                case 'entity':
                    propertyComponent = entity;
                    break;
                case 'graph':
                    propertyComponent = this.nodes[entityHierarchy[0]].node;
                    break;
                default:
                    propertyComponent = entity.findComponent(component);
                    if (!propertyComponent)
                        return null;
            }

            return this._createAnimTargetForProperty(propertyComponent, propertyHierarchy);
        },

        update: function (deltaTime) {
            // flag active nodes as dirty
            var activeNodes = this.activeNodes;
            if (activeNodes) {
                for (var i = 0; i < activeNodes.length; ++i) {
                    activeNodes[i]._dirtifyLocal();
                }
            }
        },

        _getEntityFromHierarchy: function (entityHierarchy) {
            if (!this.animComponent.entity.name === entityHierarchy[0]) {
                return null;
            }

            var currEntity = this.animComponent.entity;

            if (entityHierarchy.length === 1) {
                return currEntity;
            }
            return currEntity._parent.findByPath(entityHierarchy.join('/'));
        },

        _floatSetter: function (propertyComponent, propertyHierarchy) {
            var setter = function (values) {
                this._setProperty(propertyComponent, propertyHierarchy, values[0]);
            };
            return setter.bind(this);
        },
        _booleanSetter: function (propertyComponent, propertyHierarchy) {
            var setter = function (values) {
                this._setProperty(propertyComponent, propertyHierarchy, !!values[0]);
            };
            return setter.bind(this);
        },
        _colorSetter: function (propertyComponent, propertyHierarchy) {
            var colorKeys = ['r', 'g', 'b', 'a'];
            var setter = function (values) {
                for (var i = 0; i < values.length; i++) {
                    this._setProperty(propertyComponent, propertyHierarchy.concat(colorKeys[i]), values[i]);
                }
            };
            return setter.bind(this);
        },
        _vecSetter: function (propertyComponent, propertyHierarchy) {
            var vectorKeys = ['x', 'y', 'z', 'w'];
            var setter = function (values) {
                for (var i = 0; i < values.length; i++) {
                    this._setProperty(propertyComponent, propertyHierarchy.concat(vectorKeys[i]), values[i]);
                }
            };
            return setter.bind(this);
        },

        _getProperty: function (propertyComponent, propertyHierarchy) {
            if (propertyHierarchy.length === 1) {
                return propertyComponent[propertyHierarchy[0]];
            }
            var propertyObject = propertyComponent[propertyHierarchy[0]];
            return propertyObject[propertyHierarchy[1]];

        },

        _setProperty: function (propertyComponent, propertyHierarchy, value) {
            if (propertyHierarchy.length === 1) {
                propertyComponent[propertyHierarchy[0]] = value;
            } else {
                var propertyObject = propertyComponent[propertyHierarchy[0]];
                propertyObject[propertyHierarchy[1]] = value;
                propertyComponent[propertyHierarchy[0]] = propertyObject;
            }
        },

        _getEntityProperty: function (propertyHierarchy) {
            var entityProperties = [
                'localScale',
                'localPosition',
                'localRotation',
                'localEulerAngles',
                'position',
                'rotation',
                'eulerAngles'
            ];
            var entityProperty;
            for (var i = 0; i < entityProperties.length; i++) {
                if (propertyHierarchy.indexOf(entityProperties[i]) !== -1) {
                    entityProperty = entityProperties[i];
                }
            }
            return entityProperty;
        },

        _createAnimTargetForProperty: function (propertyComponent, propertyHierarchy) {

            if (this.handlers && propertyHierarchy[0] === 'weights') {
                return this.handlers.weights(propertyComponent);
            }

            var property = this._getProperty(propertyComponent, propertyHierarchy);

            if (typeof property === 'undefined')
                return null;

            var setter;
            var animDataType;
            var animDataComponents;

            if (typeof property === 'number') {
                setter = this._floatSetter(propertyComponent, propertyHierarchy);
                animDataType = 'vector';
                animDataComponents = 1;
            } else if (typeof property === 'boolean') {
                setter = this._booleanSetter(propertyComponent, propertyHierarchy);
                animDataType = 'vector';
                animDataComponents = 1;
            } else if (typeof property === 'object') {
                switch (property.constructor) {
                    case Vec2:
                        setter = this._vecSetter(propertyComponent, propertyHierarchy);
                        animDataType = 'vector';
                        animDataComponents = 2;
                        break;
                    case Vec3:
                        setter = this._vecSetter(propertyComponent, propertyHierarchy);
                        animDataType = 'vector';
                        animDataComponents = 3;
                        break;
                    case Vec4:
                        setter = this._vecSetter(propertyComponent, propertyHierarchy);
                        animDataType = 'vector';
                        animDataComponents = 4;
                        break;
                    case Color:
                        setter = this._colorSetter(propertyComponent, propertyHierarchy);
                        animDataType = 'vector';
                        animDataComponents = 4;
                        break;
                    case Quat:
                        setter = this._vecSetter(propertyComponent, propertyHierarchy);
                        animDataType = 'quaternion';
                        animDataComponents = 4;
                        break;
                    default:
                        return null;
                }
            }

            // for entity properties we cannot just set their values, we must also call the values setter function.
            var entityProperty = this._getEntityProperty(propertyHierarchy);
            if (entityProperty) {
                var entityPropertySetter = function (values) {
                    // first set new values on the property as before
                    setter(values);

                    // create the function name of the entity properties setter
                    var entityPropertySetterFunctionName = "set" +
                        entityProperty.substring(0, 1).toUpperCase() +
                        entityProperty.substring(1);

                    // call the setter function for entities updated property using the newly set property value
                    propertyComponent[entityPropertySetterFunctionName](this._getProperty(propertyComponent, [entityProperty]));
                };
                return new AnimTarget(entityPropertySetter.bind(this), animDataType, animDataComponents);
            } else if (propertyHierarchy.indexOf('material') !== -1) {
                return new AnimTarget(function (values) {
                    setter(values);
                    propertyComponent.material.update();
                }, animDataType, animDataComponents);
            }

            return new AnimTarget(setter, animDataType, animDataComponents);

        }
    });

    /**
     * @private
     * @class
     * @name pc.AnimComponentLayer
     * @classdesc The Anim Component Layer allows managers a single layer of the animation state graph.
     * @description Create a new AnimComponentLayer.
     * @param {string} name - The name of the layer.
     * @param {object} controller - The controller to manage this layers animations.
     * @param {pc.AnimComponent} component - The component that this layer is a member of.
     */
    function AnimComponentLayer(name, controller, component) {
        this._name = name;
        this._controller = controller;
        this._component = component;
    }

    Object.assign(AnimComponentLayer.prototype, {
        /**
         * @private
         * @function
         * @name pc.AnimComponentLayer#play
         * @description Start playing the animation in the current state.
         * @param {string} [name] - If provided, will begin playing from the start of the state with this name.
         */
        play: function (name) {
            this._controller.play(name);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponentLayer#pause
         * @description Start playing the animation in the current state.
         */
        pause: function () {
            this._controller.pause();
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponentLayer#reset
         * @description Reset the animation component to it's initial state, including all parameters. The system will be paused.
         */
        reset: function () {
            this._controller.reset();
        },

        update: function (dt) {
            this._controller.update(dt);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponentLayer#assignAnimation
         * @description Associates an animation with a state node in the loaded state graph. If all states nodes are linked and the pc.AnimComponent.activate value was set to true then the component will begin playing.
         * @param {string} nodeName - The name of the node that this animation should be associated with.
         * @param {object} animTrack - The animation track that will be assigned to this state and played whenever this state is active.
         */
        assignAnimation: function (nodeName, animTrack) {
            this._controller.assignAnimation(nodeName, animTrack);

            if (this._component.activate && this._component.playable) {
                this._component.playing = true;
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponentLayer#removeNodeAnimations
         * @description Removes animations from a node in the loaded state graph.
         * @param {string} nodeName - The name of the node that should have its animation tracks removed.
         */
        removeNodeAnimations: function (nodeName) {
            this._controller.removeNodeAnimations(nodeName);
        }
    });

    Object.defineProperties(AnimComponentLayer.prototype, {
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#name
         * @type {string}
         * @description Returns the name of the layer
         */
        name: {
            get: function () {
                return this._name;
            }
        },
        /**
         * @private
         * @name pc.AnimComponentLayer#playing
         * @type {string}
         * @description Whether this layer is currently playing
         */
        playing: {
            get: function () {
                return this._controller.playing;
            },
            set: function (value) {
                this._controller.playing = value;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#playable
         * @type {string}
         * @description Returns true if a state graph has been loaded and all states in the graph have been assigned animation tracks.
         */
        playable: {
            get: function () {
                return this._controller.playable;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#activeState
         * @type {string}
         * @description Returns the currently active state name.
         */
        activeState: {
            get: function () {
                return this._controller.activeStateName;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#previousState
         * @type {string}
         * @description Returns the previously active state name.
         */
        previousState: {
            get: function () {
                return this._controller.previousStateName;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#activeStateProgress
         * @type {number}
         * @description Returns the currently active states progress as a value normalised by the states animation duration. Looped animations will return values greater than 1.
         */
        activeStateProgress: {
            get: function () {
                return this._controller.activeStateProgress;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#transitioning
         * @type {boolean}
         * @description Returns whether the anim component layer is currently transitioning between states.
         */
        transitioning: {
            get: function () {
                return this._controller.transitioning;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#transitionProgress
         * @type {number}
         * @description If the anim component layer is currently transitioning between states, returns the progress. Otherwise returns null.
         */
        transitionProgress: {
            get: function () {
                if (this.transitioning) {
                    return this._controller.transitionProgress;
                }
                return null;
            }
        },
        /**
         * @private
         * @readonly
         * @name pc.AnimComponentLayer#states
         * @type {string[]}
         * @description Lists all available states in this layers state graph
         */
        states: {
            get: function () {
                return this._controller.states;
            }
        }
    });

    function AnimState(controller, name, speed) {
        this._controller = controller;
        this._name = name;
        this._animations = [];
        this._speed = speed || 1.0;
    }

    Object.defineProperties(AnimState.prototype, {
        name: {
            get: function () {
                return this._name;
            }
        },
        animations: {
            get: function () {
                return this._animations;
            }
        },
        speed: {
            get: function () {
                return this._speed;
            }
        },
        playable: {
            get: function () {
                return (this.animations.length > 0 || this.name === ANIM_STATE_START || this.name === ANIM_STATE_END);
            }
        },
        looping: {
            get: function () {
                if (this.animations.length > 0) {
                    var trackClipName = this.name + '.' + this.animations[0].animTrack.name;
                    var trackClip = this._controller.animEvaluator.findClip(trackClipName);
                    if (trackClip) {
                        return trackClip.loop;
                    }
                }
                return false;
            }
        },
        totalWeight: {
            get: function () {
                var sum = 0;
                var i;
                for (i = 0; i < this.animations.length; i++) {
                    sum += this.animations[i].weight;
                }
                return sum;
            }
        },
        timelineDuration: {
            get: function () {
                var duration = 0;
                var i;
                for (i = 0; i < this.animations.length; i++) {
                    var animation = this.animations[i];
                    if (animation.animTrack.duration > duration) {
                        duration = animation.animTrack.duration > duration;
                    }
                }
                return duration;
            }
        }
    });

    function AnimTransition(controller, from, to, time, priority, conditions, exitTime, transitionOffset, interruptionSource) {
        this._controller = controller;
        this._from = from;
        this._to = to;
        this._time = time;
        this._priority = priority;
        this._conditions = conditions || [];
        this._exitTime = exitTime || null;
        this._transitionOffset = transitionOffset || null;
        this._interruptionSource = interruptionSource || ANIM_INTERRUPTION_NONE;
    }

    Object.defineProperties(AnimTransition.prototype, {
        from: {
            get: function () {
                return this._from;
            }
        },
        to: {
            get: function () {
                return this._to;
            }
        },
        time: {
            get: function () {
                return this._time;
            }
        },
        priority: {
            get: function () {
                return this._priority;
            }
        },
        conditions: {
            get: function () {
                return this._conditions;
            }
        },
        exitTime: {
            get: function () {
                return this._exitTime;
            }
        },
        transitionOffset: {
            get: function () {
                return this._transitionOffset;
            }
        },
        interruptionSource: {
            get: function () {
                return this._interruptionSource;
            }
        },
        hasExitTime: {
            get: function () {
                return !!this.exitTime;
            }
        },
        hasConditionsMet: {
            get: function () {
                var conditionsMet = true;
                var i;
                for (i = 0; i < this.conditions.length; i++) {
                    var condition = this.conditions[i];
                    var parameter = this._controller.findParameter(condition.parameterName);
                    switch (condition.predicate) {
                        case ANIM_GREATER_THAN:
                            conditionsMet = conditionsMet && parameter.value > condition.value;
                            break;
                        case ANIM_LESS_THAN:
                            conditionsMet = conditionsMet && parameter.value < condition.value;
                            break;
                        case ANIM_GREATER_THAN_EQUAL_TO:
                            conditionsMet = conditionsMet && parameter.value >= condition.value;
                            break;
                        case ANIM_LESS_THAN_EQUAL_TO:
                            conditionsMet = conditionsMet && parameter.value <= condition.value;
                            break;
                        case ANIM_EQUAL_TO:
                            conditionsMet = conditionsMet && parameter.value === condition.value;
                            break;
                        case ANIM_NOT_EQUAL_TO:
                            conditionsMet = conditionsMet && parameter.value !== condition.value;
                            break;
                    }
                    if (!conditionsMet)
                        return conditionsMet;
                }
                return conditionsMet;
            }
        }
    });

    function AnimController(animEvaluator, states, transitions, parameters, activate) {
        this._animEvaluator = animEvaluator;
        this._states = {};
        this._stateNames = [];
        var i;
        for (i = 0; i < states.length; i++) {
            this._states[states[i].name] = new AnimState(
                this,
                states[i].name,
                states[i].speed
            );
            this._stateNames.push(states[i].name);
        }
        this._transitions = transitions.map(function (transition) {
            return new AnimTransition(
                this,
                transition.from,
                transition.to,
                transition.time,
                transition.priority,
                transition.conditions,
                transition.exitTime,
                transition.transitionOffset,
                transition.interruptionSource
            );
        }.bind(this));
        this._findTransitionsFromStateCache = {};
        this._findTransitionsBetweenStatesCache = {};
        this._parameters = parameters;
        this._previousStateName = null;
        this._activeStateName = ANIM_STATE_START;
        this._playing = false;
        this._activate = activate;

        this._currTransitionTime = 1.0;
        this._totalTransitionTime = 1.0;
        this._isTransitioning = false;
        this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
        this._transitionPreviousStates = [];

        this._timeInState = 0;
        this._timeInStateBefore = 0;
    }

    Object.defineProperties(AnimController.prototype, {
        animEvaluator: {
            get: function () {
                return this._animEvaluator;
            }
        },
        activeState: {
            get: function () {
                return this._findState(this._activeStateName);
            },
            set: function (stateName) {
                this._activeStateName = stateName;
            }
        },
        activeStateName: {
            get: function () {
                return this._activeStateName;
            }
        },
        previousState: {
            get: function () {
                return this._findState(this._previousStateName);
            },
            set: function (stateName) {
                this._previousStateName = stateName;
            }
        },
        previousStateName: {
            get: function () {
                return this._previousStateName;
            }
        },
        playable: {
            get: function () {
                var playable = true;
                var i;
                for (i = 0; i < this._stateNames.length; i++) {
                    if (!this._states[this._stateNames[i]].playable) {
                        playable = false;
                    }
                }
                return playable;
            }
        },
        activeStateProgress: {
            get: function () {
                return this._getActiveStateProgressForTime(this._timeInState);
            }
        },
        transitioning: {
            get: function () {
                return this._isTransitioning;
            }
        },
        transitionProgress: {
            get: function () {
                return this._currTransitionTime / this._totalTransitionTime;
            }
        },
        states: {
            get: function () {
                return this._stateNames;
            }
        }
    });

    Object.assign(AnimController.prototype, {

        _findState: function (stateName) {
            return this._states[stateName];
        },

        _getActiveStateProgressForTime: function (time) {
            if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END)
                return 1.0;

            var activeClip = this._animEvaluator.findClip(this.activeState.animations[0].name);
            if (activeClip) {
                return time / activeClip.track.duration;
            }

            return null;
        },

        // return all the transitions that have the given stateName as their source state
        _findTransitionsFromState: function (stateName) {
            var transitions = this._findTransitionsFromStateCache[stateName];
            if (!transitions) {
                transitions = this._transitions.filter(function (transition) {
                    return transition.from === stateName;
                });

                // sort transitions in priority order
                transitions.sort(function (a, b) {
                    return a.priority < b.priority;
                });

                this._findTransitionsFromStateCache[stateName] = transitions;
            }
            return transitions;
        },

        // return all the transitions that contain the given source and destination states
        _findTransitionsBetweenStates: function (sourceStateName, destinationStateName) {
            var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];
            if (!transitions) {
                transitions = this._transitions.filter(function (transition) {
                    return transition.from === sourceStateName && transition.to === destinationStateName;
                });

                // sort transitions in priority order
                transitions.sort(function (a, b) {
                    return a.priority < b.priority;
                });

                this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;
            }
            return transitions;
        },

        _findTransition: function (from, to) {
            var transitions = [];

            if (from && to) {
                // find transitions that include the required source and destination states if from and to is supplied
                transitions.concat(this._findTransitionsBetweenStates(this._activeStateName));
            } else {
                // otherwise look for transitions from the previous and active states based on the current interruption source
                if (!this._isTransitioning) {
                    transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
                } else {
                    switch (this._transitionInterruptionSource) {
                        case ANIM_INTERRUPTION_PREV:
                            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
                            break;
                        case ANIM_INTERRUPTION_NEXT:
                            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
                            break;
                        case ANIM_INTERRUPTION_PREV_NEXT:
                            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
                            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
                            break;
                        case ANIM_INTERRUPTION_NEXT_PREV:
                            transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
                            transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
                            break;
                    }
                }
            }

            // filter out transitions that don't have their conditions met
            transitions = transitions.filter(function (transition) {
                // if the transition is moving to the already active state, ignore it
                if (transition.to === this.activeStateName) {
                    return false;
                }
                // when an exit time is present, we should only exit if it falls within the current frame delta time
                if (transition.hasExitTime) {
                    var progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);
                    var progress = this._getActiveStateProgressForTime(this._timeInState);
                    // when the exit time is smaller than 1 and the state is looping, we should check for an exit each loop
                    if (transition.exitTime < 1.0 && this.activeState.looping) {
                        progressBefore -= Math.floor(progressBefore);
                        progress -= Math.floor(progress);
                    }
                    // return false if exit time isn't within the frames delta time
                    if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
                        return null;
                    }
                }
                // if the exitTime condition has been met or is not present, check condition parameters
                return transition.hasConditionsMet;
            }.bind(this));

            // return the highest priority transition to use
            if (transitions.length > 0) {
                return transitions[0];
            }
            return null;

        },

        _updateStateFromTransition: function (transition) {
            var i;
            var j;
            var state;
            var animation;
            var clip;
            this.previousState = transition.from;
            this.activeState = transition.to;

            // turn off any triggers which were required to activate this transition
            for (i = 0; i < transition.conditions.length; i++) {
                var condition = transition.conditions[i];
                var parameter = this.findParameter(condition.parameterName);
                if (parameter.type === ANIM_PARAMETER_TRIGGER) {
                    parameter.value = false;
                }
            }

            if (this.previousState) {
                if (!this._isTransitioning) {
                    this._transitionPreviousStates = [];
                }

                // record the transition source state in the previous states array
                this._transitionPreviousStates.push({
                    name: this._previousStateName,
                    weight: 1
                });

                // if this new transition was activated during another transition, update the previous transition state weights based
                // on the progress through the previous transition.
                var interpolatedTime = this._currTransitionTime / this._totalTransitionTime;
                for (i = 0; i < this._transitionPreviousStates.length; i++) {
                    // interpolate the weights of the most recent previous state and all other previous states based on the progress through the previous transition
                    if (i !== this._transitionPreviousStates.length - 1) {
                        this._transitionPreviousStates[i].weight *= (1.0 - interpolatedTime);
                    } else {
                        this._transitionPreviousStates[i].weight = interpolatedTime;
                    }
                    state = this._findState(this._transitionPreviousStates[i].name);
                    // update the animations of previous states, set their name to include their position in the previous state array
                    // to uniquely identify animations from the same state that were added during different transitions
                    for (j = 0; j < state.animations.length; j++) {
                        animation = state.animations[j];
                        clip = this._animEvaluator.findClip(animation.name + '.previous.' + i);
                        if (!clip) {
                            clip = this._animEvaluator.findClip(animation.name);
                            clip.name = animation.name + '.previous.' + i;
                        }
                        // // pause previous animation clips to reduce their impact on performance
                        // if (i !== this._transitionPreviousStates.length - 1) {
                        clip.pause();
                        // }
                    }
                }
            }

            // start a new transition based on the current transitions information
            if (transition.time > 0) {
                this._isTransitioning = true;
                this._totalTransitionTime = transition.time;
                this._currTransitionTime = 0;
                this._transitionInterruptionSource = transition.interruptionSource;
            }

            var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
            var activeState = this.activeState;
            // Add clips to the evaluator for each animation in the new state.
            for (i = 0; i < activeState.animations.length; i++) {
                clip = this._animEvaluator.findClip(activeState.animations[i].name);
                if (!clip) {
                    clip = new AnimClip(activeState.animations[i].animTrack, 0, activeState.speed, true, true);
                    clip.name = activeState.animations[i].name;
                    this._animEvaluator.addClip(clip);
                }
                if (transition.time > 0) {
                    clip.blendWeight = 0.0;
                } else {
                    clip.blendWeight = 1.0 / activeState.totalWeight;
                }
                clip.reset();
                if (hasTransitionOffset) {
                    clip.time = activeState.timelineDuration * transition.transitionOffset;
                }
                clip.play();
            }

            // set the time in the new state to 0 or to a value based on transitionOffset if one was given
            var timeInState = 0;
            var timeInStateBefore = 0;
            if (hasTransitionOffset) {
                var offsetTime = activeState.timelineDuration * transition.transitionOffset;
                timeInState = offsetTime;
                timeInStateBefore = offsetTime;
            }
            this._timeInState = timeInState;
            this._timeInStateBefore = timeInStateBefore;
        },

        _transitionToState: function (newStateName) {
            if (newStateName === this._activeStateName) {
                return;
            }

            if (!this._findState(newStateName)) {
                return;
            }

            // move to the given state, if a transition is present in the state graph use it. Otherwise move instantly to it.
            var transition = this._findTransition(this._activeStateName, newStateName);
            if (!transition) {
                this._animEvaluator.removeClips();
                transition = new AnimTransition(this, null, newStateName, 0, 0);
            }
            this._updateStateFromTransition(transition);
        },

        assignAnimation: function (stateName, animTrack) {
            var state = this._findState(stateName);
            if (!state) {
                return;
            }

            var animation = {
                name: stateName + '.' + animTrack.name,
                animTrack: animTrack,
                weight: 1.0
            };

            // Currently the anim controller only supports single animations in a state
            if (state.animations.length > 0) {
                state.animations = [];
                this.reset();
            }
            state.animations.push(animation);

            if (!this._playing && this._activate && this.playable) {
                this.play();
            }
        },

        removeNodeAnimations: function (nodeName) {
            var state = this._findState(nodeName);
            if (!state) {
                return;
            }

            state.animations = [];
        },

        play: function (stateName) {
            if (stateName) {
                this._transitionToState(stateName);
            }
            this._playing = true;
        },

        pause: function () {
            this._playing = false;
        },

        reset: function () {
            this._previousStateName = null;
            this._activeStateName = ANIM_STATE_START;
            this._playing = false;
            this._currTransitionTime = 1.0;
            this._totalTransitionTime = 1.0;
            this._isTransitioning = false;
            this._timeInState = 0;
            this._timeInStateBefore = 0;
            this._animEvaluator.removeClips();
        },

        update: function (dt) {
            if (!this._playing) {
                return;
            }
            var i;
            var j;
            var state;
            var animation;
            this._timeInStateBefore = this._timeInState;
            this._timeInState += dt;

            // transition between states if a transition is available from the active state
            var transition = this._findTransition(this._activeStateName);
            if (transition)
                this._updateStateFromTransition(transition);

            if (this._isTransitioning) {
                if (this._currTransitionTime < this._totalTransitionTime) {
                    var interpolatedTime = this._currTransitionTime / this._totalTransitionTime;
                    // while transitioning, set all previous state animations to be weighted by (1.0 - interpolationTime).
                    for (i = 0; i < this._transitionPreviousStates.length; i++) {
                        state = this._findState(this._transitionPreviousStates[i].name);
                        var stateWeight = this._transitionPreviousStates[i].weight;
                        for (j = 0; j < state.animations.length; j++) {
                            animation = state.animations[j];
                            this._animEvaluator.findClip(animation.name + '.previous.' + i).blendWeight = (1.0 - interpolatedTime) * animation.weight / state.totalWeight * stateWeight;
                        }
                    }
                    // while transitioning, set active state animations to be weighted by (interpolationTime).
                    state = this.activeState;
                    for (i = 0; i < state.animations.length; i++) {
                        animation = state.animations[i];
                        this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.weight / state.totalWeight;
                    }
                } else {
                    this._isTransitioning = false;
                    // when a transition ends, remove all previous state clips from the evaluator
                    var activeClips = this.activeState.animations.length;
                    var totalClips = this._animEvaluator.clips.length;
                    for (i = 0; i < totalClips - activeClips; i++) {
                        this._animEvaluator.removeClip(0);
                    }
                    this._transitionPreviousStates = [];
                    // when a transition ends, set the active state clip weights so they sum to 1
                    state = this.activeState;
                    for (i = 0; i < state.animations.length; i++) {
                        animation = state.animations[i];
                        this._animEvaluator.findClip(animation.name).blendWeight = animation.weight / state.totalWeight;
                    }
                }
                this._currTransitionTime += dt;
            }
            this._animEvaluator.update(dt);
        },

        findParameter: function (name) {
            return this._parameters[name];
        }
    });

    /**
     * @private
     * @component Anim
     * @class
     * @name pc.AnimComponent
     * @augments pc.Component
     * @classdesc The Anim Component allows an Entity to playback animations on models and entity properties.
     * @description Create a new AnimComponent.
     * @param {pc.AnimComponentSystem} system - The {@link pc.ComponentSystem} that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {number} speed Speed multiplier for animation play back speed. 1.0 is playback at normal speed, 0.0 pauses the animation.
     * @property {boolean} activate If true the first animation will begin playing when the scene is loaded.
     */
    function AnimComponent(system, entity) {
        Component.call(this, system, entity);
    }
    AnimComponent.prototype = Object.create(Component.prototype);
    AnimComponent.prototype.constructor = AnimComponent;

    Object.assign(AnimComponent.prototype, {
        /**
         * @private
         * @function
         * @name pc.AnimComponent#loadStateGraph
         * @description Initialises component animation controllers using the provided state graph.
         * @param {object} stateGraph - The state graph asset to load into the component. Contains the states, transitions and parameters used to define a complete animation controller.
         */
        loadStateGraph: function (stateGraph) {
            this.data.stateGraph = stateGraph;

            var graph;
            var modelComponent = this.entity.model;
            if (modelComponent) {
                var m = modelComponent.model;
                if (m) {
                    graph = m.getGraph();
                }
            }

            var data = this.data;

            data.parameters = stateGraph.parameters;

            function addLayer(name, states, transitions, order) {
                var animBinder = new AnimComponentBinder(this, graph);
                var animEvaluator = new AnimEvaluator(animBinder);
                var controller = new AnimController(
                    animEvaluator,
                    states,
                    transitions,
                    data.parameters,
                    data.activate
                );
                data.layers.push(new AnimComponentLayer(name, controller, this));
                data.layerIndices[name] = order;
            }

            for (var i = 0; i < stateGraph.layers.length; i++) {
                var layer = stateGraph.layers[i];
                addLayer.bind(this)(layer.name, layer.states, layer.transitions, i);
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#removeStateGraph
         * @description Removes all layers from the anim component.
         */
        removeStateGraph: function () {
            this.data.stateGraph = null;
            this.data.layers = [];
            this.data.layerIndices = {};
            this.data.parameters = {};
            this.data.playing = false;
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#reset
         * @description Reset all of the components layers and parameters to their initial states. If a layer was playing before it will continue playing
         */
        reset: function () {
            this.data.parameters = Object.assign({}, this.data.stateGraph.parameters);
            for (var i = 0; i < this.data.layers.length; i++) {
                var layerPlaying = this.data.layers[i].playing;
                this.data.layers[i].reset();
                this.data.layers[i].playing = layerPlaying;
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#findAnimationLayer
         * @description Finds a pc.AnimComponentLayer in this component.
         * @param {string} layerName - The name of the anim component layer to find
         * @returns {pc.AnimComponentLayer} layer
         */
        findAnimationLayer: function (layerName) {
            var layerIndex = this.data.layerIndices[layerName];
            return this.data.layers[layerIndex] || null;
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#assignAnimation
         * @description Associates an animation with a state in the loaded state graph. If all states are linked and the pc.AnimComponent.activate value was set to true then the component will begin playing.
         * @param {string} nodeName - The name of the state node that this animation should be associated with.
         * @param {object} animTrack - The animation track that will be assigned to this state and played whenever this state is active.
         * @param {string?} layerName - The name of the anim component layer to update. If omitted the default layer is used.
         */
        assignAnimation: function (nodeName, animTrack, layerName) {
            if (!this.data.stateGraph) {
                return;
            }
            layerName = layerName || 'DEFAULT_LAYER';
            var layer = this.findAnimationLayer(layerName);
            if (!layer) {
                return;
            }
            layer.assignAnimation(nodeName, animTrack);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#removeStateAnimations
         * @description Removes animations from a state in the loaded state graph.
         * @param {string} nodeName - The name of the state node that should have its animation tracks removed.
         * @param {string?} layerName - The name of the anim component layer to update. If omitted the default layer is used.
         */
        removeNodeAnimations: function (nodeName, layerName) {
            layerName = layerName || 'DEFAULT_LAYER';
            var layer = this.findAnimationLayer(layerName);
            if (!layer) {
                return;
            }
            layer.removeNodeAnimations(nodeName);
        },

        getParameterValue: function (name, type) {
            var param = this.data.parameters[name];
            if (param && param.type === type) {
                return param.value;
            }
        },

        setParameterValue: function (name, type, value) {
            var param = this.data.parameters[name];
            if (param && param.type === type) {
                param.value = value;
                return;
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#getFloat
         * @description Returns a float parameter value by name.
         * @param {string} name - The name of the float to return the value of.
         * @returns {number} A float
         */
        getFloat: function (name) {
            return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#setFloat
         * @description Sets the value of a float parameter that was defined in the animation components state graph.
         * @param {string} name - The name of the parameter to set.
         * @param {number} value - The new float value to set this parameter to.
         */
        setFloat: function (name, value) {
            this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#getInteger
         * @description Returns an integer parameter value by name.
         * @param {string} name - The name of the integer to return the value of.
         * @returns {number} An integer
         */
        getInteger: function (name) {
            return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#setInteger
         * @description Sets the value of an integer parameter that was defined in the animation components state graph.
         * @param {string} name - The name of the parameter to set.
         * @param {number} value - The new integer value to set this parameter to.
         */
        setInteger: function (name, value) {
            if (typeof value === 'number' && value % 1 === 0) {
                this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
            }
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#getBoolean
         * @description Returns a boolean parameter value by name.
         * @param {string} name - The name of the boolean to return the value of.
         * @returns {boolean} A boolean
         */
        getBoolean: function (name) {
            return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#setBoolean
         * @description Sets the value of a boolean parameter that was defined in the animation components state graph.
         * @param {string} name - The name of the parameter to set.
         * @param {boolean} value - The new boolean value to set this parameter to.
         */
        setBoolean: function (name, value) {
            this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#getTrigger
         * @description Returns a trigger parameter value by name.
         * @param {string} name - The name of the trigger to return the value of.
         * @returns {boolean} A boolean
         */
        getTrigger: function (name) {
            return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#setTrigger
         * @description Sets the value of a trigger parameter that was defined in the animation components state graph to true.
         * @param {string} name - The name of the parameter to set.
         */
        setTrigger: function (name) {
            this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
        },

        /**
         * @private
         * @function
         * @name pc.AnimComponent#setTrigger
         * @description Resets the value of a trigger parameter that was defined in the animation components state graph to false.
         * @param {string} name - The name of the parameter to set.
         */
        resetTrigger: function (name) {
            this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
        }
    });

    Object.defineProperties(AnimComponent.prototype, {
        /**
         * @private
         * @name pc.AnimComponent#stateGraphAsset
         * @type {number}
         * @description The state graph asset this component should use to generate it's animation state graph
         */
        stateGraphAsset: {
            get: function () {
                return this.data.stateGraphAsset;
            },
            set: function (value) {
                var _id;
                var _asset;

                if (value instanceof Asset) {
                    _id = value.id;
                    _asset = this.system.app.assets.get(_id);
                    if (!_asset) {
                        this.system.app.assets.add(value);
                        _asset = this.system.app.assets.get(_id);
                    }
                } else {
                    _id = value;
                    _asset = this.system.app.assets.get(_id);
                }
                if (!_asset || this.data.stateGraphAsset === _id) {
                    return;
                }

                if (_asset.resource) {
                    this.data.stateGraph = _asset.resource;
                    this.loadStateGraph(this.data.stateGraph);
                } else {
                    _asset.on('load', function (asset) {
                        this.data.stateGraph = asset.resource;
                        this.loadStateGraph(this.data.stateGraph);
                    }.bind(this));
                    this.system.app.assets.load(_asset);
                }
                this.data.stateGraphAsset = _id;
            }
        },
        /**
         * @private
         * @name pc.AnimComponent#playable
         * @type {boolean}
         * @readonly
         * @description Returns whether all component layers are currently playable
         */
        playable: {
            get: function () {
                for (var i = 0; i < this.data.layers.length; i++) {
                    if (!this.data.layers[i].playable) {
                        return false;
                    }
                }
                return true;
            }
        },
        /**
         * @private
         * @name pc.AnimComponent#baseLayer
         * @type {pc.AnimComponentLayer}
         * @readonly
         * @description Returns the base layer of the state graph
         */
        baseLayer: {
            get: function () {
                if (this.data.layers.length > 0) {
                    return this.data.layers[0];
                }
                return null;
            }
        }
    });

    function AnimComponentData() {
        // Serialized
        this.stateGraphAsset = null;
        this.speed = 1.0;
        this.activate = true;
        this.enabled = true;
        this.playing = false;

        // Non-serialized
        this.stateGraph = null;
        this.layers = [];
        this.layerIndices = {};
        this.parameters = {};
    }

    var _schema$1 = [
        'enabled',
        'speed',
        'activate',
        'playing'
    ];

    /**
     * @private
     * @class
     * @name pc.AnimComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc The AnimComponentSystem manages creating and deleting AnimComponents.
     * @description Create an AnimComponentSystem.
     * @param {pc.Application} app - The application managing this system.
     */
    function AnimComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'anim';
        this.description = "State based animation system that can animate the models and component properties of this entity and its children";

        this.ComponentType = AnimComponent;
        this.DataType = AnimComponentData;

        this.schema = _schema$1;

        this.on('beforeremove', this.onBeforeRemove, this);
        this.on('animationUpdate', this.onAnimationUpdate, this);

        ComponentSystem.bind('animationUpdate', this.onAnimationUpdate, this);
    }
    AnimComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    AnimComponentSystem.prototype.constructor = AnimComponentSystem;

    Component._buildAccessors(AnimComponent.prototype, _schema$1);

    Object.assign(AnimComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['activate', 'enabled', 'speed', 'playing'];
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        onAnimationUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    var component = components[id];
                    var componentData = component.data;

                    if (componentData.enabled && component.entity.enabled && componentData.playing) {
                        for (var i = 0; i < componentData.layers.length; i++) {
                            componentData.layers[i].update(dt * componentData.speed);
                        }
                    }
                }
            }
        }
    });

    /**
     * @component
     * @class
     * @name pc.AudioListenerComponent
     * @augments pc.Component
     * @classdesc Represents the audio listener in the 3D world, so that 3D positioned audio sources are heard correctly.
     * @description Create new AudioListenerComponent.
     * @param {pc.AudioListenerComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     */
    function AudioListenerComponent(system, entity) {
        Component.call(this, system, entity);
    }
    AudioListenerComponent.prototype = Object.create(Component.prototype);
    AudioListenerComponent.prototype.constructor = AudioListenerComponent;

    Object.assign(AudioListenerComponent.prototype, {
        setCurrentListener: function () {
            if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
                this.system.current = this.entity;
                var position = this.system.current.getPosition();
                this.system.manager.listener.setPosition(position);
            }
        },

        onEnable: function () {
            this.setCurrentListener();
        },

        onDisable: function () {
            if (this.system.current === this.entity) {
                this.system.current = null;
            }
        }

    });

    function AudioListenerComponentData() {
        // Serialized
        this.enabled = true;
    }

    var _schema$2 = ['enabled'];

    /**
     * @class
     * @name pc.AudioListenerComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Component System for adding and removing {@link pc.AudioComponent} objects to Entities.
     * @description Create a new AudioListenerComponentSystem.
     * @param {pc.Application} app - The application managing this system.
     * @param {pc.SoundManager} manager - A sound manager instance.
     */
    function AudioListenerComponentSystem(app, manager) {
        ComponentSystem.call(this, app);

        this.id = "audiolistener";
        this.description = "Specifies the location of the listener for 3D audio playback.";

        this.ComponentType = AudioListenerComponent;
        this.DataType = AudioListenerComponentData;

        this.schema = _schema$2;

        this.manager = manager;
        this.current = null;

        ComponentSystem.bind('update', this.onUpdate, this);
    }
    AudioListenerComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    AudioListenerComponentSystem.prototype.constructor = AudioListenerComponentSystem;

    Component._buildAccessors(AudioListenerComponent.prototype, _schema$2);

    Object.assign(AudioListenerComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['enabled'];

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        onUpdate: function (dt) {
            if (this.current) {
                var position = this.current.getPosition();
                this.manager.listener.setPosition(position);

                var wtm = this.current.getWorldTransform();
                this.manager.listener.setOrientation(wtm);
            }
        }
    });

    /**
     * @private
     * @component
     * @class
     * @name pc.AudioSourceComponent
     * @augments pc.Component
     * @classdesc The AudioSource Component controls playback of an audio sample. This
     * class will be deprecated in favor of {@link pc.SoundComponent}.
     * @description Create a new AudioSource Component.
     * @param {pc.AudioSourceComponentSystem} system - The ComponentSystem that created
     * this component.
     * @param {pc.Entity} entity - The entity that the Component is attached to.
     * @property {pc.Asset[]} assets The list of audio assets - can also be an array of
     * asset ids.
     * @property {boolean} activate If true the audio will begin playing as soon as the
     * scene is loaded.
     * @property {number} volume The volume modifier to play the audio with. In range 0-1.
     * @property {number} pitch The pitch modifier to play the audio with. Must be larger
     * than 0.01.
     * @property {boolean} loop If true the audio will restart when it finishes playing.
     * @property {boolean} 3d If true the audio will play back at the location of the*
     * entity in space, so the audio will be affect by the position of the
     * {@link pc.AudioListenerComponent}.
     * @property {string} distanceModel Determines which algorithm to use to reduce the
     * volume of the audio as it moves away from the listener. Can be:
     *
     * * "linear"
     * * "inverse"
     * * "exponential"
     *
     * Default is "inverse".
     * @property {number} minDistance The minimum distance from the listener at which
     * audio falloff begins.
     * @property {number} maxDistance The maximum distance from the listener at which
     * audio falloff stops. Note the volume of the audio is not 0 after this distance,
     * but just doesn't fall off anymore.
     * @property {number} rollOffFactor The factor used in the falloff equation.
     */
    function AudioSourceComponent(system, entity) {
        Component.call(this, system, entity);

        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_volume", this.onSetVolume, this);
        this.on("set_pitch", this.onSetPitch, this);
        this.on("set_minDistance", this.onSetMinDistance, this);
        this.on("set_maxDistance", this.onSetMaxDistance, this);
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
        this.on("set_distanceModel", this.onSetDistanceModel, this);
        this.on("set_3d", this.onSet3d, this);
    }
    AudioSourceComponent.prototype = Object.create(Component.prototype);
    AudioSourceComponent.prototype.constructor = AudioSourceComponent;

    Object.assign(AudioSourceComponent.prototype, {
        /**
         * @private
         * @function
         * @name pc.AudioSourceComponent#play
         * @description Begin playback of an audio asset in the component attached to an entity.
         * @param {string} name - The name of the Asset to play.
         */
        play: function (name) {
            if (!this.enabled || !this.entity.enabled) {
                return;
            }

            if (this.channel) {
                // If we are currently playing a channel, stop it.
                this.stop();
            }

            var channel;
            var componentData = this.data;
            if (componentData.sources[name]) {
                if (!componentData['3d']) {
                    channel = this.system.manager.playSound(componentData.sources[name], componentData);
                    componentData.currentSource = name;
                    componentData.channel = channel;
                } else {
                    var pos = this.entity.getPosition();
                    channel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);
                    componentData.currentSource = name;
                    componentData.channel = channel;
                }
            }
        },

        /**
         * @private
         * @function
         * @name pc.AudioSourceComponent#pause
         * @description Pause playback of the audio that is playing on the Entity. Playback can be resumed by calling {@link pc.AudioSourceComponent#unpause}.
         */
        pause: function () {
            if (this.channel) {
                this.channel.pause();
            }
        },

        /**
         * @private
         * @function
         * @name pc.AudioSourceComponent#unpause
         * @description Resume playback of the audio if paused. Playback is resumed at the time it was paused.
         */
        unpause: function () {
            if (this.channel && this.channel.paused) {
                this.channel.unpause();
            }
        },

        /**
         * @private
         * @function
         * @name pc.AudioSourceComponent#stop
         * @description Stop playback on an Entity. Playback can not be resumed after being stopped.
         */
        stop: function () {
            if (this.channel) {
                this.channel.stop();
                this.channel = null;
            }
        },

        onSetAssets: function (name, oldValue, newValue) {
            var newAssets = [];
            var i, len = newValue.length;

            if (oldValue && oldValue.length) {
                for (i = 0; i < oldValue.length; i++) {
                    // unsubscribe from change event for old assets
                    if (oldValue[i]) {
                        var asset = this.system.app.assets.get(oldValue[i]);
                        if (asset) {
                            asset.off('change', this.onAssetChanged, this);
                            asset.off('remove', this.onAssetRemoved, this);

                            if (this.currentSource === asset.name) {
                                this.stop();
                            }
                        }
                    }
                }
            }

            if (len) {
                for (i = 0; i < len; i++) {
                    if (oldValue.indexOf(newValue[i]) < 0) {
                        if (newValue[i] instanceof Asset) {
                            newAssets.push(newValue[i].id);
                        } else {
                            newAssets.push(newValue[i]);
                        }

                    }
                }
            }

            if (!this.system._inTools && newAssets.length) { // Only load audio data if we are not in the tools and if changes have been made
                this.loadAudioSourceAssets(newAssets);
            }
        },

        onAssetChanged: function (asset, attribute, newValue, oldValue) {
            if (attribute === 'resource') {
                var sources = this.data.sources;
                if (sources) {
                    this.data.sources[asset.name] = newValue;
                    if (this.data.currentSource === asset.name) {
                        // replace current sound if necessary
                        if (this.channel) {
                            if (this.channel.paused) {
                                this.play(asset.name);
                                this.pause();
                            } else {
                                this.play(asset.name);
                            }
                        }
                    }
                }
            }
        },

        onAssetRemoved: function (asset) {
            asset.off('remove', this.onAssetRemoved, this);
            if (this.data.sources[asset.name]) {
                delete this.data.sources[asset.name];
                if (this.data.currentSource === asset.name) {
                    this.stop();
                    this.data.currentSource = null;
                }
            }
        },

        onSetLoop: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel) {
                    this.channel.setLoop(newValue);
                }
            }
        },

        onSetVolume: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel) {
                    this.channel.setVolume(newValue);
                }
            }
        },

        onSetPitch: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel) {
                    this.channel.setPitch(newValue);
                }
            }
        },

        onSetMaxDistance: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel instanceof Channel3d) {
                    this.channel.setMaxDistance(newValue);
                }
            }
        },

        onSetMinDistance: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel instanceof Channel3d) {
                    this.channel.setMinDistance(newValue);
                }
            }
        },

        onSetRollOffFactor: function (name, oldValue, newValue) {
            if (oldValue != newValue) {
                if (this.channel instanceof Channel3d) {
                    this.channel.setRollOffFactor(newValue);
                }
            }
        },

        onSetDistanceModel: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                if (this.channel instanceof Channel3d) {
                    this.channel.setDistanceModel(newValue);
                }
            }
        },

        onSet3d: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                if (this.system.initialized && this.currentSource) {
                    var paused = false;
                    var suspended = false;
                    if (this.channel) {
                        paused = this.channel.paused;
                        suspended = this.channel.suspended;
                    }

                    this.play(this.currentSource);

                    if (this.channel) {
                        this.channel.paused = paused;
                        this.channel.suspended = suspended;
                    }
                }
            }
        },

        onEnable: function () {
            // load assets that haven't been loaded yet
            var assets = this.data.assets;
            if (assets) {
                var registry = this.system.app.assets;

                for (var i = 0, len = assets.length; i < len; i++) {
                    var asset = assets[i];
                    if (!(asset instanceof Asset))
                        asset = registry.get(asset);

                    if (asset && !asset.resource) {
                        registry.load(asset);
                    }
                }
            }

            if (this.system.initialized) {
                if (this.data.activate && !this.channel) {
                    this.play(this.currentSource);
                } else {
                    this.unpause();
                }
            }
        },

        onDisable: function () {
            this.pause();
        },

        loadAudioSourceAssets: function (ids) {
            var self = this;

            var assets = ids.map(function (id) {
                return this.system.app.assets.get(id);
            }, this);

            var sources = {};
            var currentSource = null;

            var count = assets.length;

            // make sure progress continues even if some audio doesn't load
            var _error = function (e) {
                count--;
            };

            // once all assets are accounted for continue
            var _done = function () {
                this.data.sources = sources;
                this.data.currentSource = currentSource;

                if (this.enabled && this.activate && currentSource) {
                    this.onEnable();
                }
            }.bind(this);

            assets.forEach(function (asset, index) {
                if (asset) {
                    // set the current source to the first entry (before calling set, so that it can play if needed)
                    currentSource = currentSource || asset.name;

                    // subscribe to change events to reload sounds if necessary
                    asset.off('change', this.onAssetChanged, this);
                    asset.on('change', this.onAssetChanged, this);

                    asset.off('remove', this.onAssetRemoved, this);
                    asset.on('remove', this.onAssetRemoved, this);

                    asset.off('error', _error, this);
                    asset.on('error', _error, this);
                    asset.ready(function (asset) {
                        sources[asset.name] = asset.resource;
                        count--;
                        if (count === 0) {
                            _done();
                        }
                    });

                    if (!asset.resource && self.enabled && self.entity.enabled)
                        this.system.app.assets.load(asset);
                } else {
                    // don't wait for assets that aren't in the registry
                    count--;
                    if (count === 0) {
                        _done();
                    }
                    // but if they are added insert them into source list
                    this.system.app.assets.on("add:" + ids[index], function (asset) {
                        asset.ready(function (asset) {
                            self.data.sources[asset.name] = asset.resource;
                        });

                        if (!asset.resource)
                            self.system.app.assets.load(asset);
                    });
                }
            }, this);
        }
    });

    function AudioSourceComponentData() {
        // serialized
        this.enabled = true;
        this.assets = [];
        this.activate = true;
        this.volume = 1;
        this.pitch = 1;
        this.loop = false;
        this['3d'] = true;

        this.minDistance = 1;
        this.maxDistance = 10000;
        this.rollOffFactor = 1;
        this.distanceModel = DISTANCE_INVERSE;

        // not serialized
        this.paused = true;

        this.sources = {};
        this.currentSource = null;
        this.channel = null;
    }

    var _schema$3 = [
        'enabled',
        'assets',
        'volume',
        'pitch',
        'loop',
        'activate',
        '3d',
        'minDistance',
        'maxDistance',
        'rollOffFactor',
        'distanceModel',
        'sources',
        'currentSource',
        'channel'
    ];

    /**
     * @private
     * @class
     * @name pc.AudioSourceComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Controls playback of an audio sample. This class will be deprecated in favor of {@link pc.SoundComponentSystem}.
     * @param {pc.Application} app - The application managing this system.
     * @param {pc.SoundManager} manager - A sound manager instance.
     */
    function AudioSourceComponentSystem(app, manager) {
        ComponentSystem.call(this, app);

        this.id = "audiosource";
        this.description = "Specifies audio assets that can be played at the position of the Entity.";

        this.ComponentType = AudioSourceComponent;
        this.DataType = AudioSourceComponentData;

        this.schema = _schema$3;

        this.manager = manager;

        this.initialized = false;

        ComponentSystem.bind('initialize', this.onInitialize, this);
        ComponentSystem.bind('update', this.onUpdate, this);

        this.on('remove', this.onRemove, this);
    }
    AudioSourceComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    AudioSourceComponentSystem.prototype.constructor = AudioSourceComponentSystem;

    Component._buildAccessors(AudioSourceComponent.prototype, _schema$3);

    Object.assign(AudioSourceComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

            component.paused = !(component.enabled && component.activate);
        },

        onInitialize: function (root) {
            if (root.audiosource &&
                root.enabled &&
                root.audiosource.enabled &&
                root.audiosource.activate) {

                root.audiosource.play(root.audiosource.currentSource);
            }

            var children = root._children;
            var i, len = children.length;
            for (i = 0; i < len; i++) {
                if (children[i] instanceof Entity) {
                    this.onInitialize(children[i]);
                }
            }

            this.initialized = true;
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    var component = components[id];
                    var entity = component.entity;
                    var componentData = component.data;

                    // Update channel position if this is a 3d sound
                    if (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {
                        var pos = entity.getPosition();
                        componentData.channel.setPosition(pos);
                    }
                }
            }
        },

        onRemove: function (entity, data) {
            if (data.channel) {
                data.channel.stop();
                data.channel = null;
            }
        },

        /**
         * @private
         * @function
         * @name pc.AudioSourceComponentSystem#setVolume
         * @description Set the volume for the entire AudioSource system. All sources will
         * have their volume multiplied by this value.
         * @param {number} volume - The value to set the volume to. Valid from 0 to 1.
         */
        setVolume: function (volume) {
            this.manager.setVolume(volume);
        }
    });

    /**
     * @private
     * @class
     * @name pc.EntityReference
     * @description Helper class used for managing component properties that represent entity references.
     * @classdesc An EntityReference can be used in scenarios where a component has one or more properties that
     * refer to entities in the scene graph. Using an EntityReference simplifies the job of dealing with the
     * presence or non-presence of the underlying entity and its components, especially when it comes to dealing
     * with the runtime addition or removal of components, and addition/removal of associated event listeners.
     * ## Usage Scenario ##
     * Imagine that you're creating a Checkbox component, which has a reference to an entity representing
     * the checkmark/tickmark that is rendered in the Checkbox. The reference is modelled as an entity guid
     * property on the Checkbox component, called simply 'checkmark'. We have to implement a basic piece of
     * functionality whereby when the 'checkmark' entity reference is set, the Checkbox component must toggle
     * the tint of an ImageElementComponent present on the checkmark entity to indicate whether the Checkbox
     * is currently in the active or inactive state.
     *
     * Without using an EntityReference, the Checkbox component must implement some or all of the following:
     *
     * * Listen for its 'checkmark' property being set to a valid guid, and retrieve a reference to the
     *   entity associated with this guid whenever it changes (i.e. via `app.root.findByGuid()`).
     * * Once a valid entity is received, check to see whether it has already has an ImageElementComponent
     *   or not:
     *   * If it has one, proceed to set the tint of the ImageElementComponent based on whether the Checkbox
     *     is currently active or inactive.
     *   * If it doesn't have one, add a listener to wait for the addition of an ImageElementComponent,
     *     and then apply the tint once one becomes present.
     * * If the checkmark entity is then reassigned (such as if the user reassigns the field in the editor,
     *   or if this is done at runtime via a script), a well-behaved Checkbox component must also undo the
     *   tinting so that no lasting effect is applied to the old entity.
     * * If the checkmark entity's ImageElementComponent is removed and then another ImageElementComponent
     *   is added, the Checkbox component must handle this in order to re-apply the tint.
     * * To prevent memory leaks, the Checkbox component must also make sure to correctly remove listeners
     *   in each of the following scenarios:
     *   * Destruction of the Checkbox component.
     *   * Reassignment of the checkmark entity.
     *   * Removal of the ImageElementComponent.
     * * It must also be careful not to double-add listeners in any of the above code paths, to avoid various
     *   forms of undesirable behavior.
     *
     * If the Checkbox component becomes more complicated and has multiple entity reference properties,
     * all of the above must be done correctly for each entity. Similarly, if it depends on multiple different
     * component types being present on the entities it has references to, it must correctly handle the presence
     * and non-presence of each of these components in the various possible sequences of addition and removal.
     * In addition to generating a lot of boilerplate, it's also very easy for subtle mistakes to be made that
     * lead to memory leaks, null reference errors or visual bugs.
     *
     * By using an EntityReference, all of the above can be reduced to the following:
     *
     * ```javascript
     * function CheckboxComponent() {
     *    this._checkmarkReference = new pc.EntityReference(this, 'checkmark', {
     *        'element#gain': this._onCheckmarkImageElementGain,
     *        'element#lose': this._onCheckmarkImageElementLose
     *    });
     * }
     * ```
     *
     * Using the above code snippet, the `_onCheckmarkImageElementGain()` listener will be called
     * in either of the following scenarios:
     *
     * 1. A checkmark entity is assigned and already has an ElementComponent.
     * 2. A checkmark entity is assigned that does not have an ElementComponent, but one is added later.
     *
     * Similarly, the `_onCheckmarkImageElementLose()` listener will be called in either of the
     * following scenarios:
     *
     * 1. An ElementComponent is removed from the checkmark entity.
     * 2. The checkmark entity is re-assigned (i.e. to another entity), or nullified. In this scenario the
     * callback will only be called if the entity actually had an ElementComponent.
     *
     * ## Event String Format ##
     *
     * The event string (i.e. "element#gain" in the above examples) is of the format `sourceName#eventName`,
     * and is defined as follows:
     *
     * * `sourceName`: May be any component name, or the special string "entity", which refers
     * to the entity itself.
     * * `eventName`: May be the name of any event dispatched by the relevant component or
     * entity, as well as the special strings "gain" or "lose".
     *
     * Some examples are as follows:
     *
     * ```javascript
     * "entity#destroy"    // Called when the entity managed by the entity reference is destroyed.
     * "element#set:width" // Called when the width of an ElementComponent is set.
     * ```
     *
     * ## Ownership and Destruction ##
     *
     * The lifetime of an ElementReference is tied to the parent component that instantiated it. This
     * coupling is indicated by the provision of the `this` keyword to the ElementReference's constructor
     * in the above examples (i.e. `new pc.EntityReference(this, ...`).
     *
     * Any event listeners managed by the ElementReference are automatically cleaned up when the parent
     * component is removed or the parent component's entity is destroyed – as such you should never have
     * to worry about dangling listeners.
     *
     * Additionally, any callbacks listed in the event config will automatically be called in the scope
     * of the parent component – you should never have to worry about manually calling `Function.bind()`.
     *
     * @param {pc.Component} parentComponent - A reference to the parent component that owns this entity reference.
     * @param {string} entityPropertyName - The name of the component property that contains the entity guid.
     * @param {object<string, Function>} [eventConfig] - A map of event listener configurations.
     * @property {pc.Entity} entity A reference to the entity, if present.
     */
    function EntityReference(parentComponent, entityPropertyName, eventConfig) {
        if (!parentComponent || !(parentComponent instanceof Component)) {
            throw new Error('The parentComponent argument is required and must be a Component');
        } else if (!entityPropertyName || typeof entityPropertyName !== 'string') {
            throw new Error('The propertyName argument is required and must be a string');
        } else if (eventConfig && typeof eventConfig !== 'object') {
            throw new Error('If provided, the eventConfig argument must be an object');
        }

        this._parentComponent = parentComponent;
        this._entityPropertyName = entityPropertyName;
        this._entity = null;
        this._app = parentComponent.system.app;

        this._configureEventListeners(eventConfig || {}, {
            'entity#destroy': this._onEntityDestroy
        });
        this._toggleLifecycleListeners('on');
    }

    Object.assign(EntityReference.prototype, {
        _configureEventListeners: function (externalEventConfig, internalEventConfig) {
            var externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);
            var internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);

            this._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);
            this._listenerStatusFlags = {};
            this._gainListeners = {};
            this._loseListeners = {};
        },

        _parseEventListenerConfig: function (eventConfig, prefix, scope) {
            return Object.keys(eventConfig).map(function (listenerDescription, index) {
                var listenerDescriptionParts = listenerDescription.split('#');
                var sourceName = listenerDescriptionParts[0];
                var eventName = listenerDescriptionParts[1];
                var callback = eventConfig[listenerDescription];

                if (listenerDescriptionParts.length !== 2 ||
                    typeof sourceName !== 'string' || sourceName.length === 0 ||
                    typeof eventName !== 'string' || eventName.length === 0) {
                    throw new Error('Invalid event listener description: `' + listenerDescription + '`');
                }

                if (typeof callback !== 'function') {
                    throw new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');
                }

                return {
                    id: prefix + '_' + index + '_' + listenerDescription,
                    sourceName: sourceName,
                    eventName: eventName,
                    callback: callback,
                    scope: scope
                };
            }, this);
        },

        _toggleLifecycleListeners: function (onOrOff) {
            this._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);
            this._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);

            ComponentSystem[onOrOff]('postinitialize', this._onPostInitialize, this);
            this._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);

            // For any event listeners that relate to the gain/loss of a component, register
            // listeners that will forward the add/remove component events
            var allComponentSystems = [];

            for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
                var config = this._eventListenerConfigs[i];
                var componentSystem = this._app.systems[config.sourceName];

                if (componentSystem) {
                    if (allComponentSystems.indexOf(componentSystem) === -1) {
                        allComponentSystems.push(componentSystem);
                    }

                    if (componentSystem && config.eventName === 'gain') {
                        this._gainListeners[config.sourceName] = config;
                    }

                    if (componentSystem && config.eventName === 'lose') {
                        this._loseListeners[config.sourceName] = config;
                    }
                }
            }

            for (var j = 0; j < allComponentSystems.length; ++j) {
                allComponentSystems[j][onOrOff]('add', this._onComponentAdd, this);
                allComponentSystems[j][onOrOff]('beforeremove', this._onComponentRemove, this);
            }
        },

        _onSetEntity: function (name, oldValue, newValue) {
            if (newValue instanceof Entity) {
                this._updateEntityReference();
            } else  {
                if (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {
                    console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + (typeof newValue) + "'");
                    return;
                }

                if (oldValue !== newValue) {
                    this._updateEntityReference();
                }
            }
        },

        _onPostInitialize: function () {
            this._updateEntityReference();
        },

        /**
         * @private
         * @function
         * @name pc.EntityReference#onParentComponentEnable
         * @description Must be called from the parent component's onEnable() method in
         * order for entity references to be correctly resolved when {@link pc.Entity#clone}
         * is called.
         */
        onParentComponentEnable: function () {
            // When an entity is cloned via the JS API, we won't be able to resolve the
            // entity reference until the cloned entity has been added to the scene graph.
            // We can detect this by waiting for the parent component to be enabled, in the
            // specific case where we haven't yet been able to resolve an entity reference.
            if (!this._entity) {
                this._updateEntityReference();
            }
        },

        // When running within the editor, postInitialize is fired before the scene graph
        // has been fully constructed. As such we use the special tools:sceneloaded event
        // in order to know when the graph is ready to traverse.
        _onSceneLoaded: function () {
            this._updateEntityReference();
        },

        _updateEntityReference: function () {
            var nextEntityGuid = this._parentComponent.data[this._entityPropertyName];
            var nextEntity;

            if (nextEntityGuid instanceof Entity) {
                // if value is set to a Entity itself replace value with the GUID
                nextEntity = nextEntityGuid;
                nextEntityGuid = nextEntity.getGuid();
                this._parentComponent.data[this._entityPropertyName] = nextEntityGuid;
            } else {
                var root = this._parentComponent.system.app.root;
                var isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);

                nextEntity = (isOnSceneGraph && nextEntityGuid) ? root.findByGuid(nextEntityGuid) : null;
            }

            var hasChanged = this._entity !== nextEntity;

            if (hasChanged) {
                if (this._entity) {
                    this._onBeforeEntityChange();
                }

                this._entity = nextEntity;

                if (this._entity) {
                    this._onAfterEntityChange();
                }
            }
        },

        _onBeforeEntityChange: function () {
            this._toggleEntityListeners('off');
            this._callAllGainOrLoseListeners(this._loseListeners);
        },

        _onAfterEntityChange: function () {
            this._toggleEntityListeners('on');
            this._callAllGainOrLoseListeners(this._gainListeners);
        },

        _onComponentAdd: function (entity, component) {
            var componentName = component.system.id;

            if (entity === this._entity) {
                this._callGainOrLoseListener(componentName, this._gainListeners);
                this._toggleComponentListeners('on', componentName);
            }
        },

        _onComponentRemove: function (entity, component) {
            var componentName = component.system.id;

            if (entity === this._entity) {
                this._callGainOrLoseListener(componentName, this._loseListeners);
                this._toggleComponentListeners('off', componentName, true);
            }
        },

        _callAllGainOrLoseListeners: function (listenerMap) {
            for (var componentName in this._entity.c) {
                this._callGainOrLoseListener(componentName, listenerMap);
            }
        },

        _callGainOrLoseListener: function (componentName, listenerMap) {
            if (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {
                var config = listenerMap[componentName];
                config.callback.call(config.scope);
            }
        },

        _toggleEntityListeners: function (onOrOff, isDestroying) {
            if (this._entity) {
                for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
                    this._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);
                }
            }
        },

        _toggleComponentListeners: function (onOrOff, componentName, isDestroying) {
            for (var i = 0; i < this._eventListenerConfigs.length; ++i) {
                var config = this._eventListenerConfigs[i];

                if (config.sourceName === componentName) {
                    this._safeToggleListener(onOrOff, config, isDestroying);
                }
            }
        },

        _safeToggleListener: function (onOrOff, config, isDestroying) {
            var isAdding = (onOrOff === 'on');

            // Prevent duplicate listeners
            if (isAdding && this._listenerStatusFlags[config.id]) {
                return;
            }

            var source = this._getEventSource(config.sourceName, isDestroying);

            if (source) {
                source[onOrOff](config.eventName, config.callback, config.scope);
                this._listenerStatusFlags[config.id] = isAdding;
            }
        },

        _getEventSource: function (sourceName, isDestroying) {
            // The 'entity' source name is a special case - we just want to return
            // a reference to the entity itself. For all other cases the source name
            // should refer to a component.
            if (sourceName === 'entity') {
                return this._entity;
            }

            var component = this._entity[sourceName];

            if (component) {
                return component;
            }

            if (!isDestroying) {
                console.warn('Entity has no component with name ' + sourceName);
            }

            return null;
        },

        _onEntityDestroy: function (entity) {
            if (this._entity === entity) {
                this._toggleEntityListeners('off', true);
                this._entity = null;
            }
        },

        _onParentComponentRemove: function (entity, component) {
            if (component === this._parentComponent) {
                this._toggleLifecycleListeners('off');
                this._toggleEntityListeners('off', true);
            }
        },

        /**
         * @private
         * @function
         * @name pc.EntityReference#hasComponent
         * @description Convenience method indicating whether the entity exists and has a
         * component of the provided type.
         * @param {string} componentName - Name of the component.
         * @returns {boolean} True if the entity exists and has a component of the provided type.
         */
        hasComponent: function (componentName) {
            return (this._entity && this._entity.c) ? !!this._entity.c[componentName] : false;
        }
    });

    Object.defineProperty(EntityReference.prototype, 'entity', {
        get: function () {
            return this._entity;
        }
    });

    /**
     * @constant
     * @type {number}
     * @name pc.BUTTON_TRANSITION_MODE_TINT
     * @description Specifies different color tints for the hover, pressed and inactive states.
     */
    var BUTTON_TRANSITION_MODE_TINT = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.BUTTON_TRANSITION_MODE_SPRITE_CHANGE
     * @description Specifies different sprites for the hover, pressed and inactive states.
     */
    var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;

    var VisualState = {
        DEFAULT: 'DEFAULT',
        HOVER: 'HOVER',
        PRESSED: 'PRESSED',
        INACTIVE: 'INACTIVE'
    };

    var STATES_TO_TINT_NAMES = {};
    STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
    STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
    STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
    STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';

    var STATES_TO_SPRITE_ASSET_NAMES = {};
    STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
    STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
    STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
    STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';

    var STATES_TO_SPRITE_FRAME_NAMES = {};
    STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
    STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
    STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
    STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';

    /**
     * @component
     * @class
     * @name pc.ButtonComponent
     * @augments pc.Component
     * @classdesc A ButtonComponent enables a group of entities to behave like a button, with different visual states for hover and press interactions.
     * @description Create a new ButtonComponent.
     * @param {pc.ButtonComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {boolean} active If set to false, the button will be visible but will not respond to hover or touch interactions.
     * @property {pc.Entity} imageEntity A reference to the entity to be used as the button background. The entity must have an ImageElement component.
     * @property {pc.Vec4} hitPadding Padding to be used in hit-test calculations. Can be used to expand the bounding box so that the button is easier to tap.
     * @property {number} transitionMode Controls how the button responds when the user hovers over it/presses it.
     * @property {pc.Color} hoverTint Color to be used on the button image when the user hovers over it.
     * @property {pc.Color} pressedTint Color to be used on the button image when the user presses it.
     * @property {pc.Color} inactiveTint Color to be used on the button image when the button is not interactive.
     * @property {number} fadeDuration Duration to be used when fading between tints, in milliseconds.
     * @property {pc.Asset} hoverSpriteAsset Sprite to be used as the button image when the user hovers over it.
     * @property {number} hoverSpriteFrame Frame to be used from the hover sprite.
     * @property {pc.Asset} pressedSpriteAsset Sprite to be used as the button image when the user presses it.
     * @property {number} pressedSpriteFrame Frame to be used from the pressed sprite.
     * @property {pc.Asset} inactiveSpriteAsset Sprite to be used as the button image when the button is not interactive.
     * @property {number} inactiveSpriteFrame Frame to be used from the inactive sprite.
     */
    function ButtonComponent(system, entity) {
        Component.call(this, system, entity);

        this._visualState = VisualState.DEFAULT;
        this._isHovering = false;
        this._hoveringCounter = 0;
        this._isPressed = false;

        this._defaultTint = new Color(1, 1, 1, 1);
        this._defaultSpriteAsset = null;
        this._defaultSpriteFrame = 0;

        this._imageReference = new EntityReference(this, 'imageEntity', {
            'element#gain': this._onImageElementGain,
            'element#lose': this._onImageElementLose,
            'element#set:color': this._onSetColor,
            'element#set:opacity': this._onSetOpacity,
            'element#set:spriteAsset': this._onSetSpriteAsset,
            'element#set:spriteFrame': this._onSetSpriteFrame
        });

        this._toggleLifecycleListeners('on', system);
    }
    ButtonComponent.prototype = Object.create(Component.prototype);
    ButtonComponent.prototype.constructor = ButtonComponent;

    Object.assign(ButtonComponent.prototype, {
        _toggleLifecycleListeners: function (onOrOff, system) {
            this[onOrOff]('set_active', this._onSetActive, this);
            this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
            this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
            this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
            this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
            this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
            this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
            this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
            this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
            this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
            this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);

            system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
            system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
        },

        _onSetActive: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                this._updateVisualState();
            }
        },

        _onSetTransitionMode: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                this._cancelTween();
                this._resetToDefaultVisualState(oldValue);
                this._forceReapplyVisualState();
            }
        },

        _onSetTransitionValue: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                this._forceReapplyVisualState();
            }
        },

        _onElementComponentRemove: function (entity) {
            if (this.entity === entity) {
                this._toggleHitElementListeners('off');
            }
        },

        _onElementComponentAdd: function (entity) {
            if (this.entity === entity) {
                this._toggleHitElementListeners('on');
            }
        },

        _onImageElementLose: function () {
            this._cancelTween();
            this._resetToDefaultVisualState(this.transitionMode);
        },

        _onImageElementGain: function () {
            this._storeDefaultVisualState();
            this._forceReapplyVisualState();
        },

        _toggleHitElementListeners: function (onOrOff) {
            if (this.entity.element) {
                var isAdding = (onOrOff === 'on');

                // Prevent duplicate listeners
                if (isAdding && this._hasHitElementListeners) {
                    return;
                }

                this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
                this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
                this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
                this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
                this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
                this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
                this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
                this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
                this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
                this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
                this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
                this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
                this.entity.element[onOrOff]('click', this._onClick, this);

                this._hasHitElementListeners = isAdding;
            }
        },

        _storeDefaultVisualState: function () {
            if (this._imageReference.hasComponent('element')) {
                this._storeDefaultColor(this._imageReference.entity.element.color);
                this._storeDefaultOpacity(this._imageReference.entity.element.opacity);
                this._storeDefaultSpriteAsset(this._imageReference.entity.element.spriteAsset);
                this._storeDefaultSpriteFrame(this._imageReference.entity.element.spriteFrame);
            }
        },

        _storeDefaultColor: function (color) {
            this._defaultTint.r = color.r;
            this._defaultTint.g = color.g;
            this._defaultTint.b = color.b;
        },

        _storeDefaultOpacity: function (opacity) {
            this._defaultTint.a = opacity;
        },

        _storeDefaultSpriteAsset: function (spriteAsset) {
            this._defaultSpriteAsset = spriteAsset;
        },

        _storeDefaultSpriteFrame: function (spriteFrame) {
            this._defaultSpriteFrame = spriteFrame;
        },

        _onSetColor: function (color) {
            if (!this._isApplyingTint) {
                this._storeDefaultColor(color);
                this._forceReapplyVisualState();
            }
        },

        _onSetOpacity: function (opacity) {
            if (!this._isApplyingTint) {
                this._storeDefaultOpacity(opacity);
                this._forceReapplyVisualState();
            }
        },

        _onSetSpriteAsset: function (spriteAsset) {
            if (!this._isApplyingSprite) {
                this._storeDefaultSpriteAsset(spriteAsset);
                this._forceReapplyVisualState();
            }
        },

        _onSetSpriteFrame: function (spriteFrame) {
            if (!this._isApplyingSprite) {
                this._storeDefaultSpriteFrame(spriteFrame);
                this._forceReapplyVisualState();
            }
        },

        _onMouseEnter: function (event) {
            this._isHovering = true;

            this._updateVisualState();
            this._fireIfActive('mouseenter', event);
        },

        _onMouseLeave: function (event) {
            this._isHovering = false;
            this._isPressed = false;

            this._updateVisualState();
            this._fireIfActive('mouseleave', event);
        },

        _onMouseDown: function (event) {
            this._isPressed = true;

            this._updateVisualState();
            this._fireIfActive('mousedown', event);
        },

        _onMouseUp: function (event) {
            this._isPressed = false;

            this._updateVisualState();
            this._fireIfActive('mouseup', event);
        },

        _onTouchStart: function (event) {
            this._isPressed = true;

            this._updateVisualState();
            this._fireIfActive('touchstart', event);
        },

        _onTouchEnd: function (event) {
            // The default behaviour of the browser is to simulate a series of
            // `mouseenter/down/up` events immediately after the `touchend` event,
            // in order to ensure that websites that don't explicitly listen for
            // touch events will still work on mobile (see https://www.html5rocks.com/en/mobile/touchandmouse/
            // for reference). This leads to an issue whereby buttons will enter
            // the `hover` state on mobile browsers after the `touchend` event is
            // received, instead of going back to the `default` state. Calling
            // preventDefault() here fixes the issue.
            event.event.preventDefault();

            this._isPressed = false;

            this._updateVisualState();
            this._fireIfActive('touchend', event);
        },

        _onTouchLeave: function (event) {
            this._isPressed = false;

            this._updateVisualState();
            this._fireIfActive('touchleave', event);
        },

        _onTouchCancel: function (event) {
            this._isPressed = false;

            this._updateVisualState();
            this._fireIfActive('touchcancel', event);
        },

        _onSelectStart: function (event) {
            this._isPressed = true;
            this._updateVisualState();
            this._fireIfActive('selectstart', event);
        },

        _onSelectEnd: function (event) {
            this._isPressed = false;
            this._updateVisualState();
            this._fireIfActive('selectend', event);
        },

        _onSelectEnter: function (event) {
            this._hoveringCounter++;

            if (this._hoveringCounter === 1) {
                this._isHovering = true;
                this._updateVisualState();
            }

            this._fireIfActive('selectenter', event);
        },

        _onSelectLeave: function (event) {
            this._hoveringCounter--;

            if (this._hoveringCounter === 0) {
                this._isHovering = false;
                this._isPressed = false;
                this._updateVisualState();
            }

            this._fireIfActive('selectleave', event);
        },

        _onClick: function (event) {
            this._fireIfActive('click', event);
        },

        _fireIfActive: function (name, event) {
            if (this.data.active) {
                this.fire(name, event);
            }
        },

        _updateVisualState: function (force) {
            var oldVisualState = this._visualState;
            var newVisualState = this._determineVisualState();

            if ((oldVisualState !== newVisualState || force) && this.enabled) {
                this._visualState = newVisualState;

                if (oldVisualState === VisualState.HOVER) {
                    this._fireIfActive('hoverend');
                }

                if (oldVisualState === VisualState.PRESSED) {
                    this._fireIfActive('pressedend');
                }

                if (newVisualState === VisualState.HOVER) {
                    this._fireIfActive('hoverstart');
                }

                if (newVisualState === VisualState.PRESSED) {
                    this._fireIfActive('pressedstart');
                }

                switch (this.transitionMode) {
                    case BUTTON_TRANSITION_MODE_TINT:
                        var tintName = STATES_TO_TINT_NAMES[this._visualState];
                        var tintColor = this[tintName];
                        this._applyTint(tintColor);
                        break;

                    case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
                        var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
                        var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
                        var spriteAsset = this[spriteAssetName];
                        var spriteFrame = this[spriteFrameName];
                        this._applySprite(spriteAsset, spriteFrame);
                        break;
                }
            }
        },

        // Called when a property changes that mean the visual state must be reapplied,
        // even if the state enum has not changed. Examples of this are when the tint
        // value for one of the states is changed via the editor.
        _forceReapplyVisualState: function () {
            this._updateVisualState(true);
        },

        // Called before the image entity changes, in order to restore the previous
        // image back to its original tint. Note that this happens immediately, i.e.
        // without any animation.
        _resetToDefaultVisualState: function (transitionMode) {
            if (this._imageReference.hasComponent('element')) {
                switch (transitionMode) {
                    case BUTTON_TRANSITION_MODE_TINT:
                        this._cancelTween();
                        this._applyTintImmediately(this._defaultTint);
                        break;

                    case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
                        this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
                        break;
                }
            }
        },

        _determineVisualState: function () {
            if (!this.active) {
                return VisualState.INACTIVE;
            } else if (this._isPressed) {
                return VisualState.PRESSED;
            } else if (this._isHovering) {
                return VisualState.HOVER;
            }

            return VisualState.DEFAULT;
        },

        _applySprite: function (spriteAsset, spriteFrame) {
            spriteFrame = spriteFrame || 0;

            if (this._imageReference.hasComponent('element')) {
                this._isApplyingSprite = true;
                this._imageReference.entity.element.spriteAsset = spriteAsset;
                this._imageReference.entity.element.spriteFrame = spriteFrame;
                this._isApplyingSprite = false;
            }
        },

        _applyTint: function (tintColor) {
            this._cancelTween();

            if (this.fadeDuration === 0) {
                this._applyTintImmediately(tintColor);
            } else {
                this._applyTintWithTween(tintColor);
            }
        },

        _applyTintImmediately: function (tintColor) {
            if (this._imageReference.hasComponent('element') && tintColor) {
                this._isApplyingTint = true;
                this._imageReference.entity.element.color = toColor3(tintColor);
                this._imageReference.entity.element.opacity = tintColor.a;
                this._isApplyingTint = false;
            }
        },

        _applyTintWithTween: function (tintColor) {
            if (this._imageReference.hasComponent('element') && tintColor) {
                var color = this._imageReference.entity.element.color;
                var opacity = this._imageReference.entity.element.opacity;

                this._tweenInfo = {
                    startTime: now(),
                    from: new Color(color.r, color.g, color.b, opacity),
                    to: tintColor.clone(),
                    lerpColor: new Color()
                };
            }
        },

        _updateTintTween: function () {
            var elapsedTime = now() - this._tweenInfo.startTime;
            var elapsedProportion = this.fadeDuration === 0 ? 1 : (elapsedTime / this.fadeDuration);
            elapsedProportion = math.clamp(elapsedProportion, 0, 1);

            if (Math.abs(elapsedProportion - 1) > 1e-5) {
                var lerpColor = this._tweenInfo.lerpColor;
                lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
                this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
            } else {
                this._applyTintImmediately(this._tweenInfo.to);
                this._cancelTween();
            }
        },

        _cancelTween: function () {
            delete this._tweenInfo;
        },

        onUpdate: function () {
            if (this._tweenInfo) {
                this._updateTintTween();
            }
        },

        onEnable: function () {
            // Reset input state
            this._isHovering = false;
            this._hoveringCounter = 0;
            this._isPressed = false;

            this._imageReference.onParentComponentEnable();
            this._toggleHitElementListeners('on');
            this._forceReapplyVisualState();
        },

        onDisable: function () {
            this._toggleHitElementListeners('off');
            this._resetToDefaultVisualState(this.transitionMode);
        },

        onRemove: function () {
            this._toggleLifecycleListeners('off', this.system);
            this.onDisable();
        }
    });

    function toColor3(color4) {
        return new Color(color4.r, color4.g, color4.b);
    }

    function ButtonComponentData() {
        this.enabled = true;

        this.active = true;
        this.imageEntity = null;
        this.hitPadding = new Vec4();
        this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
        this.hoverTint = new Color(0.75, 0.75, 0.75);
        this.pressedTint = new Color(0.5, 0.5, 0.5);
        this.inactiveTint = new Color(0.25, 0.25, 0.25);
        this.fadeDuration = 0;
        this.hoverSpriteAsset = null;
        this.hoverSpriteFrame = 0;
        this.pressedSpriteAsset = null;
        this.pressedSpriteFrame = 0;
        this.inactiveSpriteAsset = null;
        this.inactiveSpriteFrame = 0;
    }

    var _schema$4 = [
        'enabled',
        'active',
        { name: 'imageEntity', type: 'entity' },
        { name: 'hitPadding', type: 'vec4' },
        'transitionMode',
        { name: 'hoverTint', type: 'rgba' },
        { name: 'pressedTint', type: 'rgba' },
        { name: 'inactiveTint', type: 'rgba' },
        'fadeDuration',
        'hoverSpriteAsset',
        'hoverSpriteFrame',
        'pressedSpriteAsset',
        'pressedSpriteFrame',
        'inactiveSpriteAsset',
        'inactiveSpriteFrame'
    ];

    /**
     * @class
     * @name pc.ButtonComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.ButtonComponent}s.
     * @description Create a new ButtonComponentSystem.
     * @param {pc.Application} app - The application.
     */
    function ButtonComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'button';

        this.ComponentType = ButtonComponent;
        this.DataType = ButtonComponentData;

        this.schema = _schema$4;

        this.on('beforeremove', this._onRemoveComponent, this);

        ComponentSystem.bind('update', this.onUpdate, this);
    }
    ButtonComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ButtonComponentSystem.prototype.constructor = ButtonComponentSystem;

    Component._buildAccessors(ButtonComponent.prototype, _schema$4);

    Object.assign(ButtonComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$4);
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                var entity = components[id].entity;
                var component = entity.button;
                if (component.enabled && entity.enabled) {
                    component.onUpdate();
                }
            }
        },

        _onRemoveComponent: function (entity, component) {
            component.onRemove();
        }
    });

    /**
     * @component
     * @class
     * @name pc.CameraComponent
     * @augments pc.Component
     * @classdesc The Camera Component enables an Entity to render the scene. A scene requires at least one
     * enabled camera component to be rendered. Note that multiple camera components can be enabled
     * simultaneously (for split-screen or offscreen rendering, for example).
     * @description Create a new Camera Component.
     * @param {pc.CameraComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @example
     * // Add a pc.CameraComponent to an entity
     * var entity = new pc.Entity();
     * entity.addComponent('camera', {
     *     nearClip: 1,
     *     farClip: 100,
     *     fov: 55
     * });
     * @example
     * // Get the pc.CameraComponent on an entity
     * var cameraComponent = entity.camera;
     * @example
     * // Update a property on a camera component
     * entity.camera.nearClip = 2;
     * @property {number} projection The type of projection used to render the camera. Can be:
     *
     * * {@link pc.PROJECTION_PERSPECTIVE}: A perspective projection. The camera frustum resembles a truncated pyramid.
     * * {@link pc.PROJECTION_ORTHOGRAPHIC}: An orthographic projection. The camera frustum is a cuboid.
     *
     * Defaults to pc.PROJECTION_PERSPECTIVE.
     * @property {number} nearClip The distance from the camera before which no rendering will take place.
     * @property {number} farClip The distance from the camera after which no rendering will take place.
     * @property {number} aspectRatioMode The aspect ratio mode of the camera. Can be pc.ASPECT_AUTO (default) or pc.ASPECT_MANUAL. ASPECT_AUTO will always be current render target's width divided by height. ASPECT_MANUAL will use the aspectRatio value instead.
     * @property {number} aspectRatio The aspect ratio (width divided by height) of the camera. If aspectRatioMode is ASPECT_AUTO, then this value will be automatically calculated every frame, and you can only read it. If it's ASPECT_MANUAL, you can set the value.
     * @property {boolean} horizontalFov Set which axis to use for the Field of View calculation. Defaults to false (use Y-axis).
     * @property {number} fov The field of view of the camera in degrees. Usually this is the Y-axis field of
     * view, see {@link pc.CameraComponent#horizontalFov}. Used for {@link pc.PROJECTION_PERSPECTIVE} cameras only. Defaults to 45.
     * @property {number} orthoHeight The half-height of the orthographic view window (in the Y-axis). Used for
     * {@link pc.PROJECTION_ORTHOGRAPHIC} cameras only. Defaults to 10.
     * @property {number} priority Controls the order in which cameras are rendered. Cameras with smaller values for priority are rendered first.
     * @property {pc.Color} clearColor The color used to clear the canvas to before the camera starts to render.
     * @property {boolean} clearColorBuffer If true the camera will clear the color buffer to the color set in clearColor.
     * @property {boolean} clearDepthBuffer If true the camera will clear the depth buffer.
     * @property {boolean} clearStencilBuffer If true the camera will clear the stencil buffer.
     * @property {pc.Vec4} rect Controls where on the screen the camera will be rendered in normalized screen coordinates.
     * @property {pc.Vec4} scissorRect Clips all pixels which are not in the rectangle.
     * The order of the values is [x, y, width, height].
     * @property {pc.PostEffectQueue} postEffects The post effects queue for this camera. Use this to add or remove post effects from the camera.
     * @property {boolean} frustumCulling Controls the culling of mesh instances against the camera frustum, i.e. if objects outside of camera should be omitted from rendering.
     * If true, culling is enabled.
     * If false, all mesh instances in the scene are rendered by the camera, regardless of visibility. Defaults to false.
     * @property {pc.callbacks.CalculateMatrix} calculateTransform Custom function you can provide to calculate the camera transformation matrix manually. Can be used for complex effects like reflections. Function is called using component's scope.
     * Arguments:
     *
     * * {pc.Mat4} transformMatrix: output of the function.
     * * {number} view: Type of view. Can be pc.VIEW_CENTER, pc.VIEW_LEFT or pc.VIEW_RIGHT. Left and right are only used in stereo rendering.
     * @property {pc.callbacks.CalculateMatrix} calculateProjection Custom function you can provide to calculate the camera projection matrix manually. Can be used for complex effects like doing oblique projection. Function is called using component's scope.
     * Arguments:
     *
     * * {pc.Mat4} transformMatrix: output of the function
     * * {number} view: Type of view. Can be pc.VIEW_CENTER, pc.VIEW_LEFT or pc.VIEW_RIGHT. Left and right are only used in stereo rendering.
     * @property {boolean} cullFaces If true the camera will take material.cull into account. Otherwise both front and back faces will be rendered.
     * @property {boolean} flipFaces If true the camera will invert front and back faces. Can be useful for reflection rendering.
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this camera should belong.
     * Don't push/pop/splice or modify this array, if you want to change it - set a new one instead.
     */
    var CameraComponent = function CameraComponent(system, entity) {
        Component.call(this, system, entity);

        // Bind event to update hierarchy if camera node changes
        this.on("set_aspectRatioMode", this.onSetAspectRatioMode, this);
        this.on("set_aspectRatio", this.onSetAspectRatio, this);
        this.on("set_camera", this.onSetCamera, this);
        this.on("set_clearColor", this.onSetClearColor, this);
        this.on("set_fov", this.onSetFov, this);
        this.on("set_orthoHeight", this.onSetOrthoHeight, this);
        this.on("set_nearClip", this.onSetNearClip, this);
        this.on("set_farClip", this.onSetFarClip, this);
        this.on("set_projection", this.onSetProjection, this);
        this.on("set_priority", this.onSetPriority, this);
        this.on("set_clearColorBuffer", this.updateClearFlags, this);
        this.on("set_clearDepthBuffer", this.updateClearFlags, this);
        this.on("set_clearStencilBuffer", this.updateClearFlags, this);
        this.on("set_renderTarget", this.onSetRenderTarget, this);
        this.on("set_rect", this.onSetRect, this);
        this.on("set_scissorRect", this.onSetScissorRect, this);
        this.on("set_horizontalFov", this.onSetHorizontalFov, this);
        this.on("set_frustumCulling", this.onSetFrustumCulling, this);
        this.on("set_calculateTransform", this.onSetCalculateTransform, this);
        this.on("set_calculateProjection", this.onSetCalculateProjection, this);
        this.on("set_cullFaces", this.onSetCullFaces, this);
        this.on("set_flipFaces", this.onSetFlipFaces, this);
        this.on("set_layers", this.onSetLayers, this);
    };
    CameraComponent.prototype = Object.create(Component.prototype);
    CameraComponent.prototype.constructor = CameraComponent;

    /**
     * @readonly
     * @name pc.CameraComponent#projectionMatrix
     * @type {pc.Mat4}
     * @description Queries the camera's projection matrix.
     */
    Object.defineProperty(CameraComponent.prototype, "projectionMatrix", {
        get: function () {
            return this.data.camera.getProjectionMatrix();
        }
    });

    /**
     * @readonly
     * @name pc.CameraComponent#viewMatrix
     * @type {pc.Mat4}
     * @description Queries the camera's view matrix.
     */
    Object.defineProperty(CameraComponent.prototype, "viewMatrix", {
        get: function () {
            return this.data.camera.getViewMatrix();
        }
    });

    /**
     * @readonly
     * @name pc.CameraComponent#frustum
     * @type {pc.Frustum}
     * @description Queries the camera's frustum shape.
     */
    Object.defineProperty(CameraComponent.prototype, "frustum", {
        get: function () {
            return this.data.camera.frustum;
        }
    });

    /**
     * @private
     * @deprecated
     * @name pc.CameraComponent#vrDisplay
     * @type {pc.VrDisplay}
     * @description The {@link pc.VrDisplay} that the camera is current displaying to. This is set automatically by calls to {@link pc.CameraComponent#enterVr}
     * or {@link pc.CameraComponent#exitVr}. Setting this property to a display directly enables the camera to use the transformation information
     * from a display without rendering stereo to it, e.g. for "magic window" style experiences.
     * @example
     * // enable magic window style interface
     * var display = this.app.vr.display;
     * if (display) {
     *     this.entity.camera.vrDisplay = display;
     * }
     *
     * var camera = this.entity.camera;
     * camera.enterVr(function (err) {
     *     if (err) return;
     *     var display = camera.vrDisplay; // access presenting pc.VrDisplay
     * });
     */
    Object.defineProperty(CameraComponent.prototype, "vrDisplay", {
        get: function () {
            return this.data.camera.vrDisplay;
        },
        set: function (value) {
            this.data.camera.vrDisplay = value;
            if (value) {
                value._camera = this.data.camera;
            }
        }
    });

    /**
     * @readonly
     * @name pc.CameraComponent#node
     * @type {pc.GraphNode}
     * @description Queries the camera's GraphNode. Can be used to get position and rotation.
     */
    Object.defineProperty(CameraComponent.prototype, "node", {
        get: function () {
            return this.data.camera._node;
        }
    });

    Object.assign(CameraComponent.prototype, {
        /**
         * @function
         * @name pc.CameraComponent#screenToWorld
         * @description Convert a point from 2D screen space to 3D world space.
         * @param {number} screenx - X coordinate on PlayCanvas' canvas element.
         * @param {number} screeny - Y coordinate on PlayCanvas' canvas element.
         * @param {number} cameraz - The distance from the camera in world space to create the new point.
         * @param {pc.Vec3} [worldCoord] - 3D vector to receive world coordinate result.
         * @example
         * // Get the start and end points of a 3D ray fired from a screen click position
         * var start = entity.camera.screenToWorld(clickX, clickY, entity.camera.nearClip);
         * var end = entity.camera.screenToWorld(clickX, clickY, entity.camera.farClip);
         *
         * // Use the ray coordinates to perform a raycast
         * app.systems.rigidbody.raycastFirst(start, end, function (result) {
         *     console.log("Entity " + result.entity.name + " was selected");
         * });
         * @returns {pc.Vec3} The world space coordinate.
         */
        screenToWorld: function (screenx, screeny, cameraz, worldCoord) {
            var device = this.system.app.graphicsDevice;
            return this.data.camera.screenToWorld(screenx, screeny, cameraz, device.clientRect.width, device.clientRect.height, worldCoord);
        },

        onPrerender: function () {
            this.data.camera._viewMatDirty = true;
            this.data.camera._viewProjMatDirty = true;
        },

        /**
         * @function
         * @name pc.CameraComponent#worldToScreen
         * @description Convert a point from 3D world space to 2D screen space.
         * @param {pc.Vec3} worldCoord - The world space coordinate.
         * @param {pc.Vec3} [screenCoord] - 3D vector to receive screen coordinate result.
         * @returns {pc.Vec3} The screen space coordinate.
         */
        worldToScreen: function (worldCoord, screenCoord) {
            var device = this.system.app.graphicsDevice;
            return this.data.camera.worldToScreen(worldCoord, device.clientRect.width, device.clientRect.height, screenCoord);
        },

        onSetAspectRatioMode: function (name, oldValue, newValue) {
            this.data.camera.aspectRatioMode = newValue;
        },

        onSetAspectRatio: function (name, oldValue, newValue) {
            this.data.camera.aspectRatio = newValue;
        },

        onSetCamera: function (name, oldValue, newValue) {
            // remove old camera node from hierarchy and add new one
            if (oldValue) {
                oldValue._node = null;
            }
            newValue._node = this.entity;
        },

        onSetClearColor: function (name, oldValue, newValue) {
            var clearColor = this.data.camera.clearColor;
            clearColor[0] = newValue.r;
            clearColor[1] = newValue.g;
            clearColor[2] = newValue.b;
            clearColor[3] = newValue.a;
        },

        onSetFov: function (name, oldValue, newValue) {
            this.data.camera.fov = newValue;
        },

        onSetOrthoHeight: function (name, oldValue, newValue) {
            this.data.camera.orthoHeight = newValue;
        },

        onSetNearClip: function (name, oldValue, newValue) {
            this.data.camera.nearClip = newValue;
        },

        onSetFarClip: function (name, oldValue, newValue) {
            this.data.camera.farClip = newValue;
        },

        onSetHorizontalFov: function (name, oldValue, newValue) {
            this.data.camera.horizontalFov = newValue;
        },

        onSetFrustumCulling: function (name, oldValue, newValue) {
            this.data.camera.frustumCulling = newValue;
        },

        onSetCalculateTransform: function (name, oldValue, newValue) {
            this._calculateTransform = newValue;
            this.camera.overrideCalculateTransform = !!newValue;
        },

        onSetCalculateProjection: function (name, oldValue, newValue) {
            this._calculateProjection = newValue;
            this.camera._projMatDirty = true;
            this.camera.overrideCalculateProjection = !!newValue;
        },

        onSetCullFaces: function (name, oldValue, newValue) {
            this.camera._cullFaces = newValue;
        },

        onSetFlipFaces: function (name, oldValue, newValue) {
            this.camera._flipFaces = newValue;
        },

        onSetProjection: function (name, oldValue, newValue) {
            this.data.camera.projection = newValue;
        },

        onSetPriority: function (name, oldValue, newValue) {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer._sortCameras();
            }
        },

        onSetLayers: function (name, oldValue, newValue) {
            var i, layer;
            for (i = 0; i < oldValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
                if (!layer) continue;
                layer.removeCamera(this);
            }
            if (!this.enabled || !this.entity.enabled) return;
            for (i = 0; i < newValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(newValue[i]);
                if (!layer) continue;
                layer.addCamera(this);
            }
        },

        addCameraToLayers: function () {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.addCamera(this);
            }
        },

        removeCameraFromLayers: function () {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.removeCamera(this);
            }
        },

        onLayersChanged: function (oldComp, newComp) {
            this.addCameraToLayers();
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);
        },

        onLayerAdded: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.addCamera(this);
        },

        onLayerRemoved: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.removeCamera(this);
        },

        updateClearFlags: function () {
            var flags = 0;

            if (this.clearColorBuffer)
                flags |= CLEARFLAG_COLOR;

            if (this.clearDepthBuffer)
                flags |= CLEARFLAG_DEPTH;

            if (this.clearStencilBuffer)
                flags |= CLEARFLAG_STENCIL;

            this.data.camera.clearFlags = flags;
        },

        onSetRenderTarget: function (name, oldValue, newValue) {
            this.data.camera.renderTarget = newValue;
        },

        onSetRect: function (name, oldValue, newValue) {
            this.data.camera.setRect(newValue.x, newValue.y, newValue.z, newValue.w);
        },

        onSetScissorRect: function (name, oldValue, newValue) {
            this.data.camera.setScissorRect(newValue.x, newValue.y, newValue.z, newValue.w);
        },

        onEnable: function () {
            this.system.addCamera(this);

            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.on("add", this.onLayerAdded, this);
                this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
            }

            if (this.enabled && this.entity.enabled) {
                this.addCameraToLayers();
            }

            this.postEffects.enable();
        },

        onDisable: function () {
            this.postEffects.disable();

            this.removeCameraFromLayers();

            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.off("add", this.onLayerAdded, this);
                this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
            }

            this.system.removeCamera(this);
        },

        onRemove: function () {
            this.onDisable();
            this.off();
        },

        /**
         * @function
         * @name pc.CameraComponent#calculateAspectRatio
         * @description Calculates aspect ratio value for a given render target.
         * @param {pc.RenderTarget} [rt] - Optional render target. If unspecified, the backbuffer is assumed.
         * @returns {number} The aspect ratio of the render target (or backbuffer).
         */
        calculateAspectRatio: function (rt) {
            var src = rt ? rt : this.system.app.graphicsDevice;
            var rect = this.rect;
            return (src.width * rect.z) / (src.height * rect.w);
        },

        /**
         * @function
         * @private
         * @name pc.CameraComponent#frameBegin
         * @description Start rendering the frame for this camera.
         * @param {pc.RenderTarget} rt - Render target to which rendering will be performed. Will affect camera's aspect ratio, if aspectRatioMode is pc.ASPECT_AUTO.
         */
        frameBegin: function (rt) {
            if (this.aspectRatioMode === ASPECT_AUTO) {
                this.aspectRatio = this.calculateAspectRatio(rt);
            }
            this.data.isRendering = true;
        },

        /**
         * @private
         * @function
         * @name pc.CameraComponent#frameEnd
         * @description End rendering the frame for this camera.
         */
        frameEnd: function () {
            this.data.isRendering = false;
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.CameraComponent#enterVr
         * @description Attempt to start presenting this camera to a {@link pc.VrDisplay}.
         * @param {pc.callbacks.VrCamera} callback - Function called once to indicate success of failure. The callback takes one argument (err).
         * On success it returns null on failure it returns the error message.
         * @example
         * // On an entity with a camera component
         * this.entity.camera.enterVr(function (err) {
         *     if (err) {
         *         console.error(err);
         *     } else {
         *         // in VR!
         *     }
         * });
         */
        /**
         * @private
         * @deprecated
         * @function
         * @name pc.CameraComponent#enterVr
         * @variation 2
         * @description Attempt to start presenting this camera to a {@link pc.VrDisplay}.
         * @param {pc.VrDisplay} display - The VrDisplay to present. If not supplied this uses {@link pc.VrManager#display} as the default.
         * @param {pc.callbacks.VrCamera} callback - Function called once to indicate success of failure. The callback takes one argument (err).
         * On success it returns null on failure it returns the error message.
         * @example
         * // On an entity with a camera component
         * this.entity.camera.enterVr(function (err) {
         *     if (err) {
         *         console.error(err);
         *     } else {
         *         // in VR!
         *     }
         * });
         */
        enterVr: function (display, callback) {
            if ((display instanceof Function) && !callback) {
                callback = display;
                display = null;
            }

            if (!this.system.app.vr) {
                callback("VrManager not created. Enable VR in project settings.");
                return;
            }

            if (!display) {
                display = this.system.app.vr.display;
            }

            if (display) {
                var self = this;
                if (display.capabilities.canPresent) {
                    // try and present
                    display.requestPresent(function (err) {
                        if (!err) {
                            self.vrDisplay = display;
                            // camera component uses internal 'before' event
                            // this means display nulled before anyone other
                            // code gets to update
                            self.vrDisplay.once('beforepresentchange', function (display) {
                                if (!display.presenting) {
                                    self.vrDisplay = null;
                                }
                            });
                        }
                        callback(err);
                    });
                } else {
                    // mono rendering
                    self.vrDisplay = display;
                    callback();
                }
            } else {
                callback("No pc.VrDisplay to present");
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.CameraComponent#exitVr
         * @description Attempt to stop presenting this camera.
         * @param {pc.callbacks.VrCamera} callback - Function called once to indicate success of failure. The callback takes one argument (err).
         * On success it returns null on failure it returns the error message.
         * @example
         * this.entity.camera.exitVr(function (err) {
         *     if (err) {
         *         console.error(err);
         *     } else {
         *         // exited successfully
         *     }
         * });
         */
        exitVr: function (callback) {
            if (this.vrDisplay) {
                if (this.vrDisplay.capabilities.canPresent) {
                    var display = this.vrDisplay;
                    this.vrDisplay = null;
                    display.exitPresent(callback);
                } else {
                    this.vrDisplay = null;
                    callback();
                }
            } else {
                callback("Not presenting VR");
            }
        },

        /**
         * @function
         * @name pc.CameraComponent#startXr
         * @description Attempt to start XR session with this camera
         * @param {string} type - The type of session. Can be one of the following:
         *
         * * {@link pc.XRTYPE_INLINE}: Inline - always available type of session. It has limited feature availability and is rendered into HTML element.
         * * {@link pc.XRTYPE_VR}: Immersive VR - session that provides exclusive access to the VR device with the best available tracking features.
         * * {@link pc.XRTYPE_AR}: Immersive AR - session that provides exclusive access to the VR/AR device that is intended to be blended with the real-world environment.
         *
         * @param {string} spaceType - reference space type. Can be one of the following:
         *
         * * {@link pc.XRSPACE_VIEWER}: Viewer - always supported space with some basic tracking capabilities.
         * * {@link pc.XRSPACE_LOCAL}: Local - represents a tracking space with a native origin near the viewer at the time of creation. It is meant for seated or basic local XR sessions.
         * * {@link pc.XRSPACE_LOCALFLOOR}: Local Floor - represents a tracking space with a native origin at the floor in a safe position for the user to stand. The y axis equals 0 at floor level. Floor level value might be estimated by the underlying platform. It is meant for seated or basic local XR sessions.
         * * {@link pc.XRSPACE_BOUNDEDFLOOR}: Bounded Floor - represents a tracking space with its native origin at the floor, where the user is expected to move within a pre-established boundary.
         * * {@link pc.XRSPACE_UNBOUNDED}: Unbounded - represents a tracking space where the user is expected to move freely around their environment, potentially long distances from their starting point.
         *
         * @param {pc.callbacks.XrError} [callback] - Optional callback function called once the session is started. The callback has one argument Error - it is null if the XR session started successfully.
         * @example
         * // On an entity with a camera component
         * this.entity.camera.startXr(pc.XRTYPE_VR, pc.XRSPACE_LOCAL, function (err) {
         *     if (err) {
         *         // failed to start XR session
         *     } else {
         *         // in XR
         *     }
         * });
         */
        startXr: function (type, spaceType, callback) {
            this.system.app.xr.start(this, type, spaceType, callback);
        },

        /**
         * @function
         * @name pc.CameraComponent#endXr
         * @description Attempt to end XR session of this camera
         * @param {pc.callbacks.XrError} [callback] - Optional callback function called once session is ended. The callback has one argument Error - it is null if successfully ended XR session.
         * @example
         * // On an entity with a camera component
         * this.entity.camera.endXr(function (err) {
         *     // not anymore in XR
         * });
         */
        endXr: function (callback) {
            if (! this.camera.xr) {
                if (callback) callback(new Error("Camera is not in XR"));
                return;
            }

            this.camera.xr.end(callback);
        }
    });

    /**
     * @private
     * @class
     * @name pc.CameraComponentData
     * @augments pc.ComponentData
     * @classdesc ComponentData structure for Camera components.
     */
    function CameraComponentData() {
        // serialized
        this.clearColor = new Color(0.722, 0.722, 0.722, 1);
        this.clearColorBuffer = true;
        this.clearDepthBuffer = true;
        this.clearStencilBuffer = true;
        this.nearClip = 0.1;
        this.farClip = 1000;
        this.fov = 45;
        this.orthoHeight = 100;
        this.projection = PROJECTION_PERSPECTIVE;
        this.priority = 0;
        this.rect = new Vec4(0, 0, 1, 1);
        this.scissorRect = new Vec4(0, 0, 1, 1);
        this.enabled = true;
        this.frustumCulling = false;
        this.cullFaces = true;
        this.flipFaces = false;
        this.layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE]; // default to original world, depth skybox and gizmos layers

        // not serialized
        this.camera = null;
        this.aspectRatio = 16 / 9;
        this.aspectRatioMode = ASPECT_AUTO;
        this.renderTarget = null;
        this.postEffects = null;
        this.isRendering = false;
        this.calculateTransform = null;
        this.calculateProjection = null;
    }

    var depthLayer;
    /**
     * @class
     * @name pc.PostEffectQueue
     * @classdesc Used to manage multiple post effects for a camera.
     * @description Create a new PostEffectQueue.
     * @param {pc.Application} app - The application.
     * @param {pc.CameraComponent} camera - The camera component.
     */
    function PostEffectQueue(app, camera) {
        var self = this;

        this.app = app;
        this.camera = camera;
        // stores all of the post effects
        this.effects = [];
        // if the queue is enabled it will render all of its effects
        // otherwise it will not render anything
        this.enabled = false;

        // legacy
        this.depthTarget = null;

        this.renderTargetScale = 1;
        this.resizeTimeout = null;
        this.resizeLast = 0;

        this._resizeTimeoutCallback = function () {
            self.resizeRenderTargets();
        };

        camera.on('set_rect', this.onCameraRectChanged, this);

        this._origOverrideClear = false;
        this._origClearColorBuffer = false;
        this._origDepthColorBuffer = false;
        this._origStencilColorBuffer = false;
    }

    Object.assign(PostEffectQueue.prototype, {
        /**
         * @private
         * @function
         * @name pc.PostEffectQueue#_createOffscreenTarget
         * @description Creates a render target with the dimensions of the canvas, with an optional depth buffer.
         * @param {boolean} useDepth - Set to true if you want to create a render target with a depth buffer.
         * @param {boolean} hdr - Use HDR render target format.
         * @returns {pc.RenderTarget} The render target.
         */

        _createOffscreenTarget: function (useDepth, hdr) {
            var rect = this.camera.rect;

            var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
            var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);

            var device = this.app.graphicsDevice;
            var format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;
            var useStencil =  this.app.graphicsDevice.supportsStencil;
            var samples = useDepth ? device.samples : 1;

            var colorBuffer = new Texture(device, {
                format: format,
                width: width,
                height: height
            });
            colorBuffer.name = 'posteffect #' + this.effects.length;

            colorBuffer.minFilter = FILTER_NEAREST;
            colorBuffer.magFilter = FILTER_NEAREST;
            colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
            colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;

            return new RenderTarget(this.app.graphicsDevice, colorBuffer, { depth: useDepth, stencil: useStencil, samples: samples });
        },

        _resizeOffscreenTarget: function (rt) {
            var rect = this.camera.rect;

            var width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
            var height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);

            var device = this.app.graphicsDevice;
            var format = rt.colorBuffer.format;

            rt._colorBuffer.destroy();

            var colorBuffer = new Texture(device, {
                format: format,
                width: width,
                height: height
            });
            colorBuffer.name = 'posteffect';

            colorBuffer.minFilter = FILTER_NEAREST;
            colorBuffer.magFilter = FILTER_NEAREST;
            colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
            colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;

            rt._colorBuffer = colorBuffer;
            rt.destroy();
        },

        _destroyOffscreenTarget: function (rt) {
            if (rt._colorBuffer)
                rt._colorBuffer.destroy();
            if (rt._depthBuffer)
                rt._depthBuffer.destroy();

            rt.destroy();
        },

        setRenderTargetScale: function (scale) {
            this.renderTargetScale = scale;
            this.resizeRenderTargets();
        },

        /**
         * @function
         * @name pc.PostEffectQueue#addEffect
         * @description Adds a post effect to the queue. If the queue is disabled adding a post effect will
         * automatically enable the queue.
         * @param {pc.PostEffect} effect - The post effect to add to the queue.
         */
        addEffect: function (effect) {
            // first rendering of the scene requires depth buffer
            var isFirstEffect = this.effects.length === 0;

            var effects = this.effects;
            var newEntry = {
                effect: effect,
                inputTarget: this._createOffscreenTarget(isFirstEffect, effect.hdr),
                outputTarget: null
            };

            // legacy compatibility: create new layer
            if (!this.layer) {
                this.layer = new Layer({
                    opaqueSortMode: SORTMODE_NONE,
                    transparentSortMode: SORTMODE_NONE,
                    passThrough: true,
                    name: "PostEffectQueue",
                    renderTarget: this.camera.renderTarget,
                    clear: false,
                    onPostRender: function () {
                        for (var i = 0; i < this._commandList.length; i++) {
                            this._commandList[i]();
                        }
                    }
                });
                // insert it after the last occurence of this camera
                var layerList = this.app.scene.layers.layerList;
                var order = 0;
                var i;
                var start = layerList.length - 1;
                for (i = start; i >= 0; i--) {
                    if (layerList[i].id === LAYERID_UI) {
                        start = i - 1;

                        this._origOverrideClear = layerList[i].overrideClear;
                        this._origClearColorBuffer = layerList[i].clearColorBuffer;
                        this._origDepthColorBuffer = layerList[i].clearDepthBuffer;
                        this._origStencilColorBuffer = layerList[i].clearStencilBuffer;

                        layerList[i].overrideClear = true;
                        layerList[i].clearColorBuffer = false;
                        layerList[i].clearDepthBuffer = this.camera.clearDepthBuffer;
                        layerList[i].clearStencilBuffer = this.camera.clearStencilBuffer;
                        break;
                    }
                }

                this._sourceLayers = [];

                for (i = 0; i < this.camera.layers.length; i++) {
                    var layerID = this.camera.layers[i];
                    var layer = this.app.scene.layers.getLayerById(layerID);
                    var index = this.app.scene.layers.layerList.indexOf(layer);

                    if (index <= start) {
                        if (layerID != LAYERID_DEPTH) {
                            layer.renderTarget = newEntry.inputTarget;
                            this._sourceLayers.push(layer);
                        }

                        if (index > order)
                            order = index;
                    }
                }
                this.app.scene.layers.insertOpaque(this.layer, order + 1);
                this._sourceTarget = newEntry.inputTarget;
                this.layer._commandList = [];
                this.layer.isPostEffect = true;
            }

            effects.push(newEntry);

            var len = effects.length;
            if (len > 1) {
                // connect the effect with the previous effect if one exists
                effects[len - 2].outputTarget = newEntry.inputTarget;
            }

            // Request depthmap if needed
            this._newPostEffect = effect;
            if (effect.needsDepthBuffer) {
                this._requestDepthMap();
            }


            this.enable();
            this._newPostEffect = undefined;
        },

        /**
         * @function
         * @name pc.PostEffectQueue#removeEffect
         * @description Removes a post effect from the queue. If the queue becomes empty it will be disabled automatically.
         * @param {pc.PostEffect} effect - The post effect to remove.
         */
        removeEffect: function (effect) {
            // find index of effect
            var i, len, index = -1;
            for (i = 0, len = this.effects.length; i < len; i++) {
                if (this.effects[i].effect === effect) {
                    index = i;
                    break;
                }
            }

            if (index >= 0) {
                if (index > 0)  {
                    // connect the previous effect with the effect after the one we're about to remove
                    this.effects[index - 1].outputTarget = (index + 1) < this.effects.length ?
                        this.effects[index + 1].inputTarget :
                        null;
                } else {
                    if (this.effects.length > 1) {
                        // if we removed the first effect then make sure that
                        // the input render target of the effect that will now become the first one
                        // has a depth buffer
                        if (!this.effects[1].inputTarget._depth) {
                            this._destroyOffscreenTarget(this.effects[1].inputTarget);
                            this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
                            this._sourceTarget = this.effects[1].inputTarget;
                        }
                        // Also apply to the source layers
                        for (i = 0; i < this._sourceLayers.length; i++) {
                            this._sourceLayers[i].renderTarget = this.effects[1].inputTarget;
                        }

                    }
                }

                // release memory for removed effect
                this._destroyOffscreenTarget(this.effects[index].inputTarget);

                this.effects.splice(index, 1);
            }

            if (this.enabled) {
                if (effect.needsDepthBuffer) {
                    this._releaseDepthMap();
                }
            }

            if (this.effects.length === 0) {
                this.disable();
            }
        },

        _requestDepthMaps: function () {
            for (var i = 0, len = this.effects.length; i < len; i++) {
                var effect = this.effects[i].effect;
                if (this._newPostEffect === effect)
                    continue;

                if (effect.needsDepthBuffer) {
                    this._requestDepthMap();
                }
            }
        },

        _releaseDepthMaps: function () {
            for (var i = 0, len = this.effects.length; i < len; i++) {
                var effect = this.effects[i].effect;
                if (effect.needsDepthBuffer) {
                    this._releaseDepthMap();
                }
            }
        },

        _requestDepthMap: function () {
            if (!depthLayer) depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
            if (depthLayer) depthLayer.incrementCounter();
        },

        _releaseDepthMap: function () {
            if (depthLayer) depthLayer.decrementCounter();
        },

        /**
         * @function
         * @name pc.PostEffectQueue#destroy
         * @description Removes all the effects from the queue and disables it.
         */
        destroy: function () {
            // release memory for all effects
            for (var i = 0, len = this.effects.length; i < len; i++) {
                this.effects[i].inputTarget.destroy();
            }

            this.effects.length = 0;

            this.disable();
        },

        /**
         * @function
         * @name pc.PostEffectQueue#enable
         * @description Enables the queue and all of its effects. If there are no effects then the queue will not be enabled.
         */
        enable: function () {
            if (!this.enabled && this.effects.length) {
                this.enabled = true;

                var self = this;
                this._requestDepthMaps();

                this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);

                // set the camera's rect to full screen. Set it directly to the
                // camera node instead of the component because we want to keep the old
                // rect set in the component for restoring the camera to its original settings
                // when the queue is disabled.
                // self.camera.camera.setRect(0, 0, 1, 1);

                // create a new command that renders all of the effects one after the other
                this.command = function () {
                    if (self.enabled) {
                        var rect = null;
                        var len = self.effects.length;
                        if (len) {
                            self.layer.renderTarget = self.effects[0].inputTarget;
                            // self.depthTarget = self.camera.camera._depthTarget;

                            for (var i = 0; i < len; i++) {
                                var fx = self.effects[i];
                                // if (self.depthTarget) fx.effect.depthMap = self.depthTarget.colorBuffer;
                                if (i === len - 1) {
                                    rect = self.camera.rect;
                                }
                                fx.effect.render(fx.inputTarget, fx.outputTarget, rect);
                            }
                        }
                    }
                };

                this.layer._commandList.push(this.command);
            }
        },

        /**
         * @function
         * @name pc.PostEffectQueue#disable
         * @description Disables the queue and all of its effects.
         */
        disable: function () {
            if (this.enabled) {
                this.enabled = false;

                this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);

                this._releaseDepthMaps();
                this._destroyOffscreenTarget(this._sourceTarget);

                // remove the draw command
                var i = this.layer._commandList.indexOf(this.command);
                if (i >= 0) {
                    this.layer._commandList.splice(i, 1);
                }

                // Reset the UI layer to its original state
                var layerList = this.app.scene.layers.layerList;
                var start = layerList.length - 1;
                for (i = 0; i <= layerList.length; i++) {
                    if (layerList[i].id === LAYERID_UI) {
                        start = i - 1;
                        layerList[i].overrideClear = this._origOverrideClear;
                        layerList[i].clearColorBuffer = this._origClearColorBuffer;
                        layerList[i].clearDepthBuffer = this._origDepthColorBuffer;
                        layerList[i].clearStencilBuffer = this._origStencilColorBuffer;
                        break;
                    }
                }
                for (i = start; i >= 0; i--) {
                    if (layerList[i].cameras.indexOf(this.camera) >= 0) {
                        layerList[i].renderTarget = undefined;
                    }
                }

                this.app.scene.layers.removeOpaque(this.layer);
                this.layer = null;
            }
        },

        _onCanvasResized: function (width, height) {
            var rect = this.camera.rect;
            var device = this.app.graphicsDevice;
            this.camera.camera.aspectRatio = (device.width * rect.z) / (device.height * rect.w);

            // avoid resizing the render targets too often by using a timeout
            if (this.resizeTimeout)
                return;

            if ((now() - this.resizeLast) > 100) {
                // allow resizing immediately if haven't been resized recently
                this.resizeRenderTargets();
            } else {
                // target to maximum at 10 resizes a second
                this.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);
            }
        },

        resizeRenderTargets: function () {
            if (this.resizeTimeout) {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = null;
            }

            this.resizeLast = now();

            var rect = this.camera.rect;
            var desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);
            var desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);

            var effects = this.effects;

            for (var i = 0, len = effects.length; i < len; i++) {
                var fx = effects[i];
                if (fx.inputTarget.width !== desiredWidth ||
                    fx.inputTarget.height !== desiredHeight)  {
                    this._resizeOffscreenTarget(fx.inputTarget);
                }
            }
        },

        onCameraRectChanged: function (name, oldValue, newValue) {
            if (this.enabled) {
                // reset the camera node's rect to full screen otherwise
                // post effect will not work correctly
                // this.camera.camera.setRect(0, 0, 1, 1);
                this.resizeRenderTargets();
            }
        }
    });

    var _schema$5 = [
        'enabled',
        'clearColorBuffer',
        'clearColor',
        'clearDepthBuffer',
        'clearStencilBuffer',
        'frustumCulling',
        'projection',
        'fov',
        'orthoHeight',
        'nearClip',
        'farClip',
        'priority',
        'rect',
        'scissorRect',
        'camera',
        'aspectRatio',
        'aspectRatioMode',
        'horizontalFov',
        'model',
        'renderTarget',
        'calculateTransform',
        'calculateProjection',
        'cullFaces',
        'flipFaces',
        'layers'
    ];

    /**
     * @class
     * @name pc.CameraComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Used to add and remove {@link pc.CameraComponent}s from Entities. It also holds an
     * array of all active cameras.
     * @description Create a new CameraComponentSystem.
     * @param {pc.Application} app - The Application.
     * @property {pc.CameraComponent[]} cameras Holds all the active camera components.
     */
    var CameraComponentSystem = function (app) {
        ComponentSystem.call(this, app);

        this.id = 'camera';
        this.description = "Renders the scene from the location of the Entity.";

        this.ComponentType = CameraComponent;
        this.DataType = CameraComponentData;

        this.schema = _schema$5;

        // holds all the active camera components
        this.cameras = [];

        this.on('beforeremove', this.onBeforeRemove, this);
        this.on('remove', this.onRemove, this);
        this.app.on("prerender", this.onPrerender, this);

        ComponentSystem.bind('update', this.onUpdate, this);
    };
    CameraComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    CameraComponentSystem.prototype.constructor = CameraComponentSystem;

    Component._buildAccessors(CameraComponent.prototype, _schema$5);

    Object.assign(CameraComponentSystem.prototype, {
        initializeComponentData: function (component, _data, properties) {
            properties = [
                'postEffects',
                'enabled',
                'model',
                'camera',
                'aspectRatio',
                'aspectRatioMode',
                'horizontalFov',
                'renderTarget',
                'clearColor',
                'fov',
                'orthoHeight',
                'nearClip',
                'farClip',
                'projection',
                'priority',
                'clearColorBuffer',
                'clearDepthBuffer',
                'clearStencilBuffer',
                'frustumCulling',
                'rect',
                'scissorRect',
                'calculateTransform',
                'calculateProjection',
                'cullFaces',
                'flipFaces',
                'layers'
            ];

            // duplicate data because we're modifying the data
            var data = {};
            for (var i = 0, len = properties.length; i < len; i++) {
                var property = properties[i];
                data[property] = _data[property];
            }

            if (data.layers && type(data.layers) === 'array') {
                data.layers = data.layers.slice(0);
            }

            if (data.clearColor && type(data.clearColor) === 'array') {
                var c = data.clearColor;
                data.clearColor = new Color(c[0], c[1], c[2], c[3]);
            }

            if (data.rect && type(data.rect) === 'array') {
                var rect = data.rect;
                data.rect = new Vec4(rect[0], rect[1], rect[2], rect[3]);
            }

            if (data.scissorRect && type(data.scissorRect) === 'array') {
                var scissorRect = data.scissorRect;
                data.scissorRect = new Vec4(scissorRect[0], scissorRect[1], scissorRect[2], scissorRect[3]);
            }

            if (data.activate) {
                console.warn("WARNING: activate: Property is deprecated. Set enabled property instead.");
                data.enabled = data.activate;
            }

            data.camera = new Camera();
            data._node = component.entity;
            data.camera._component = component;

            var self = component;
            data.camera.calculateTransform = function (mat, mode) {
                if (!self._calculateTransform)
                    return null;

                return self._calculateTransform(mat, mode);
            };
            data.camera.calculateProjection = function (mat, mode) {
                if (!self._calculateProjection)
                    return null;

                return self._calculateProjection(mat, mode);
            };

            data.postEffects = new PostEffectQueue(this.app, component);

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        onBeforeRemove: function (entity, component) {
            this.removeCamera(component);
            component.onRemove();
        },

        onRemove: function (entity, data) {
            data.camera = null;
        },

        onUpdate: function (dt) {
            var components = this.store;
            var component, componentData, cam, vrDisplay;

            if (this.app.vr) {
                for (var id in components) {
                    component = components[id];
                    componentData = component.data;
                    cam = componentData.camera;
                    vrDisplay = cam.vrDisplay;
                    if (componentData.enabled && component.entity.enabled && vrDisplay) {
                        // Change WebVR near/far planes based on the stereo camera
                        vrDisplay.setClipPlanes(cam._nearClip, cam._farClip);

                        // update camera node transform from VrDisplay
                        if (cam._node) {
                            cam._node.localTransform.copy(vrDisplay.combinedViewInv);
                            cam._node._dirtyLocal = false;
                            cam._node._dirtifyWorld();
                        }
                    }
                }
            }
        },

        onPrerender: function () {
            for (var i = 0, len = this.cameras.length; i < len; i++) {
                this.cameras[i].onPrerender();
            }
        },

        addCamera: function (camera) {
            this.cameras.push(camera);
            this.sortCamerasByPriority();
        },

        removeCamera: function (camera) {
            var index = this.cameras.indexOf(camera);
            if (index >= 0) {
                this.cameras.splice(index, 1);
                this.sortCamerasByPriority();
            }
        },

        sortCamerasByPriority: function () {
            this.cameras.sort(function (a, b) {
                return a.priority - b.priority;
            });
        }
    });

    /**
     * @component
     * @class
     * @name pc.CollisionComponent
     * @augments pc.Component
     * @classdesc A collision volume. Use this in conjunction with a {@link pc.RigidBodyComponent}
     * to make a collision volume that can be simulated using the physics engine.
     *
     * If the {@link pc.Entity} does not have a {@link pc.RigidBodyComponent} then this collision
     * volume will act as a trigger volume. When an entity with a dynamic or kinematic body enters
     * or leaves an entity with a trigger volume, both entities will receive trigger events.
     *
     * The following table shows all the events that can be fired between two Entities:
     *
     * |                                       | Rigid Body (Static)                                                   | Rigid Body (Dynamic or Kinematic)                                     | Trigger Volume                                      |
     * | ------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------------------------- | --------------------------------------------------- |
     * | **Rigid Body (Static)**               |                                                                       | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> |                                                     |
     * | **Rigid Body (Dynamic or Kinematic)** | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>contact</li><li>collisionstart</li><li>collisionend</li></ul> | <ul><li>triggerenter</li><li>triggerleave</li></ul> |
     * | **Trigger Volume**                    |                                                                       | <ul><li>triggerenter</li><li>triggerleave</li></ul>                   |                                                     |
     *
     * @description Create a new CollisionComponent.
     * @param {pc.CollisionComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {string} type The type of the collision volume. Can be:
     *
     * * "box": A box-shaped collision volume.
     * * "capsule": A capsule-shaped collision volume.
     * * "compound": A compound shape. Any descendent entities with a collision component
     * of type box, capsule, cone, cylinder or sphere will be combined into a single, rigid
     * shape.
     * * "cone": A cone-shaped collision volume.
     * * "cylinder": A cylinder-shaped collision volume.
     * * "mesh": A collision volume that uses a model asset as its shape.
     * * "sphere": A sphere-shaped collision volume.
     *
     * Defaults to "box".
     * @property {pc.Vec3} halfExtents The half-extents of the box-shaped collision volume in the
     * x, y and z axes. Defaults to [0.5, 0.5, 0.5].
     * @property {number} radius The radius of the sphere, capsule, cylinder or cone-shaped collision
     * volumes. Defaults to 0.5.
     * @property {number} axis The local space axis with which the capsule, cylinder or cone-shaped
     * collision volume's length is aligned. 0 for X, 1 for Y and 2 for Z. Defaults to 1 (Y-axis).
     * @property {number} height The total height of the capsule, cylinder or cone-shaped collision
     * volume from tip to tip. Defaults to 2.
     * @property {pc.Asset} asset The asset for the model of the mesh collision volume - can also be
     * an asset id. Defaults to null.
     * @property {pc.Model} model The model that is added to the scene graph for the mesh collision
     * volume.
     */
    var CollisionComponent = function CollisionComponent(system, entity) {
        Component.call(this, system, entity);

        this._compoundParent = null;

        this.entity.on('insert', this._onInsert, this);

        this.on('set_type', this.onSetType, this);
        this.on('set_halfExtents', this.onSetHalfExtents, this);
        this.on('set_radius', this.onSetRadius, this);
        this.on('set_height', this.onSetHeight, this);
        this.on('set_axis', this.onSetAxis, this);
        this.on("set_asset", this.onSetAsset, this);
        this.on("set_model", this.onSetModel, this);
    };
    CollisionComponent.prototype = Object.create(Component.prototype);
    CollisionComponent.prototype.constructor = CollisionComponent;

    // Events Documentation
    /**
     * @event
     * @name pc.CollisionComponent#contact
     * @description The 'contact' event is fired when a contact occurs between two rigid bodies.
     * @param {pc.ContactResult} result - Details of the contact between the two rigid bodies.
     */

    /**
     * @event
     * @name pc.CollisionComponent#collisionstart
     * @description The 'collisionstart' event is fired when two rigid bodies start touching.
     * @param {pc.ContactResult} result - Details of the contact between the two Entities.
     */

    /**
     * @event
     * @name pc.CollisionComponent#collisionend
     * @description The 'collisionend' event is fired two rigid-bodies stop touching.
     * @param {pc.Entity} other - The {@link pc.Entity} that stopped touching this collision volume.
     */

    /**
     * @event
     * @name pc.CollisionComponent#triggerenter
     * @description The 'triggerenter' event is fired when a rigid body enters a trigger volume.
     * a {@link pc.RigidBodyComponent} attached.
     * @param {pc.Entity} other - The {@link pc.Entity} that entered this collision volume.
     */

    /**
     * @event
     * @name pc.CollisionComponent#triggerleave
     * @description The 'triggerleave' event is fired when a rigid body exits a trigger volume.
     * a {@link pc.RigidBodyComponent} attached.
     * @param {pc.Entity} other - The {@link pc.Entity} that exited this collision volume.
     */

    Object.assign(CollisionComponent.prototype, {
        onSetType: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                this.system.changeType(this, oldValue, newValue);
            }
        },

        onSetHalfExtents: function (name, oldValue, newValue) {
            var t = this.data.type;
            if (this.data.initialized && t === 'box') {
                this.system.recreatePhysicalShapes(this);
            }
        },

        onSetRadius: function (name, oldValue, newValue) {
            var t = this.data.type;
            if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
                this.system.recreatePhysicalShapes(this);
            }
        },

        onSetHeight: function (name, oldValue, newValue) {
            var t = this.data.type;
            if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
                this.system.recreatePhysicalShapes(this);
            }
        },

        onSetAxis: function (name, oldValue, newValue) {
            var t = this.data.type;
            if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
                this.system.recreatePhysicalShapes(this);
            }
        },

        onSetAsset: function (name, oldValue, newValue) {
            var asset;
            var assets = this.system.app.assets;

            if (oldValue) {
                // Remove old listeners
                asset = assets.get(oldValue);
                if (asset) {
                    asset.off('remove', this.onAssetRemoved, this);
                }
            }

            if (newValue) {
                if (newValue instanceof Asset) {
                    this.data.asset = newValue.id;
                }

                asset = assets.get(this.data.asset);
                if (asset) {
                    // make sure we don't subscribe twice
                    asset.off('remove', this.onAssetRemoved, this);
                    asset.on('remove', this.onAssetRemoved, this);
                }
            }

            if (this.data.initialized && this.data.type === 'mesh') {
                if (!newValue) {
                    // if asset is null set model to null
                    // so that it's going to be removed from the simulation
                    this.data.model = null;
                }
                this.system.recreatePhysicalShapes(this);
            }
        },

        onSetModel: function (name, oldValue, newValue) {
            if (this.data.initialized && this.data.type === 'mesh') {
                // recreate physical shapes skipping loading the model
                // from the 'asset' as the model passed in newValue might
                // have been created procedurally
                this.system.implementations.mesh.doRecreatePhysicalShape(this);
            }
        },

        onAssetRemoved: function (asset) {
            asset.off('remove', this.onAssetRemoved, this);
            if (this.data.asset === asset.id) {
                this.asset = null;
            }
        },

        _getCompoundChildShapeIndex: function (shape) {
            var compound = this.data.shape;
            var shapes = compound.getNumChildShapes();

            for (var i = 0; i < shapes; i++) {
                var childShape = compound.getChildShape(i);
                if (childShape.ptr === shape.ptr) {
                    return i;
                }
            }

            return null;
        },

        _onInsert: function (parent) {
            // TODO
            // if is child of compound shape
            // and there is no change of compoundParent, then update child transform
            // once updateChildTransform is exposed in ammo.js

            if (typeof Ammo === 'undefined')
                return;

            if (this._compoundParent) {
                this.system.recreatePhysicalShapes(this);
            } else if (! this.entity.rigidbody) {
                var ancestor = this.entity.parent;
                while (ancestor) {
                    if (ancestor.collision && ancestor.collision.type === 'compound') {
                        if (ancestor.collision.shape.getNumChildShapes() === 0) {
                            this.system.recreatePhysicalShapes(ancestor.collision);
                        } else {
                            this.system.recreatePhysicalShapes(this);
                        }
                        break;
                    }
                    ancestor = ancestor.parent;
                }
            }
        },

        _updateCompound: function () {
            var entity = this.entity;
            if (entity._dirtyWorld) {
                var dirty = entity._dirtyLocal;
                var parent = entity;
                while (parent && !dirty) {
                    if (parent.collision && parent.collision === this._compoundParent)
                        break;

                    if (parent._dirtyLocal)
                        dirty = true;

                    parent = parent.parent;
                }

                if (dirty) {
                    entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);

                    var bodyComponent = this._compoundParent.entity.rigidbody;
                    if (bodyComponent)
                        bodyComponent.activate();
                }
            }
        },

        onEnable: function () {
            if (this.data.type === 'mesh' && this.data.asset && this.data.initialized) {
                var asset = this.system.app.assets.get(this.data.asset);
                // recreate the collision shape if the model asset is not loaded
                // or the shape does not exist
                if (asset && (!asset.resource || !this.data.shape)) {
                    this.system.recreatePhysicalShapes(this);
                    return;
                }
            }

            if (this.entity.rigidbody) {
                if (this.entity.rigidbody.enabled) {
                    this.entity.rigidbody.enableSimulation();
                }
            } else if (this._compoundParent && this !== this._compoundParent) {
                if (this._compoundParent.shape.getNumChildShapes() === 0) {
                    this.system.recreatePhysicalShapes(this._compoundParent);
                } else {
                    var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
                    this._compoundParent.shape.addChildShape(transform, this.data.shape);
                    Ammo.destroy(transform);

                    if (this._compoundParent.entity.rigidbody)
                        this._compoundParent.entity.rigidbody.activate();
                }
            } else if (this.entity.trigger) {
                this.entity.trigger.enable();
            }
        },

        onDisable: function () {
            if (this.entity.rigidbody) {
                this.entity.rigidbody.disableSimulation();
            } else if (this._compoundParent && this !== this._compoundParent) {
                if (! this._compoundParent.entity._destroying) {
                    this.system._removeCompoundChild(this._compoundParent, this.data.shape);

                    if (this._compoundParent.entity.rigidbody)
                        this._compoundParent.entity.rigidbody.activate();
                }
            } else if (this.entity.trigger) {
                this.entity.trigger.disable();
            }
        },

        onBeforeRemove: function () {
            this.entity.off('insert', this._onInsert, this);
        }
    });

    function CollisionComponentData() {
        this.enabled = true;
        this.type = 'box';
        this.halfExtents = new Vec3(0.5, 0.5, 0.5);
        this.radius = 0.5;
        this.axis = 1;
        this.height = 2;
        this.asset = null;

        // Non-serialized properties
        this.shape = null;
        this.model = null;
        this.initialized = false;
    }

    // types
    /**
     * @constant
     * @type {string}
     * @name pc.BODYTYPE_STATIC
     * @description Rigid body has infinite mass and cannot move.
     */
    var BODYTYPE_STATIC = 'static';
    /**
     * @constant
     * @type {string}
     * @name pc.BODYTYPE_DYNAMIC
     * @description Rigid body is simulated according to applied forces.
     */
    var BODYTYPE_DYNAMIC = 'dynamic';
    /**
     * @constant
     * @type {string}
     * @name pc.BODYTYPE_KINEMATIC
     * @description Rigid body has infinite mass and does not respond to forces but can still be moved by setting their velocity or position.
     */
    var BODYTYPE_KINEMATIC = 'kinematic';

    // Collision flags
    var BODYFLAG_STATIC_OBJECT = 1;
    var BODYFLAG_KINEMATIC_OBJECT = 2;
    var BODYFLAG_NORESPONSE_OBJECT = 4;

    // Activation states
    var BODYSTATE_ACTIVE_TAG = 1;
    var BODYSTATE_ISLAND_SLEEPING = 2;
    var BODYSTATE_WANTS_DEACTIVATION = 3;
    var BODYSTATE_DISABLE_DEACTIVATION = 4;
    var BODYSTATE_DISABLE_SIMULATION = 5;

    // groups
    var BODYGROUP_NONE = 0;
    var BODYGROUP_DEFAULT = 1;
    var BODYGROUP_DYNAMIC = 1;
    var BODYGROUP_STATIC = 2;
    var BODYGROUP_KINEMATIC = 4;
    var BODYGROUP_ENGINE_1 = 8;
    var BODYGROUP_TRIGGER = 16;
    var BODYGROUP_ENGINE_2 = 32;
    var BODYGROUP_ENGINE_3 = 64;
    var BODYGROUP_USER_1 = 128;
    var BODYGROUP_USER_2 = 256;
    var BODYGROUP_USER_3 = 512;
    var BODYGROUP_USER_4 = 1024;
    var BODYGROUP_USER_5 = 2048;
    var BODYGROUP_USER_6 = 4096;
    var BODYGROUP_USER_7 = 8192;
    var BODYGROUP_USER_8 = 16384;

    // masks
    var BODYMASK_NONE = 0;
    var BODYMASK_ALL = 65535;
    var BODYMASK_STATIC = 2;
    var BODYMASK_NOT_STATIC = 65535 ^ 2;
    var BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);

    var ammoVec1, ammoQuat, ammoTransform;

    /**
     * @private
     * @class
     * @name pc.Trigger
     * @classdesc Creates a trigger object used to create internal physics objects that interact with
     * rigid bodies and trigger collision events with no collision response.
     * @param {pc.Application} app - The running {pc.Application}.
     * @param {pc.Component} component - The component for which the trigger will be created.
     * @param {pc.ComponentData} data - The data for the component.
     */
    function Trigger(app, component, data) {
        this.entity = component.entity;
        this.component = component;
        this.app = app;

        if (typeof Ammo !== 'undefined' && ! ammoVec1) {
            ammoVec1 = new Ammo.btVector3();
            ammoQuat = new Ammo.btQuaternion();
            ammoTransform = new Ammo.btTransform();
        }

        this.initialize(data);
    }

    Object.assign(Trigger.prototype,  {
        initialize: function (data) {
            var entity = this.entity;
            var shape = data.shape;

            if (shape && typeof Ammo !== 'undefined') {
                if (entity.trigger) {
                    entity.trigger.destroy();
                }

                var mass = 1;

                var pos = entity.getPosition();
                var rot = entity.getRotation();

                ammoVec1.setValue(pos.x, pos.y, pos.z);
                ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);

                ammoTransform.setOrigin(ammoVec1);
                ammoTransform.setRotation(ammoQuat);

                var body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform);

                body.setRestitution(0);
                body.setFriction(0);
                body.setDamping(0, 0);
                ammoVec1.setValue(0, 0, 0);
                body.setLinearFactor(ammoVec1);
                body.setAngularFactor(ammoVec1);

                body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
                body.entity = entity;

                this.body = body;

                if (this.component.enabled && entity.enabled) {
                    this.enable();
                }
            }
        },

        destroy: function () {
            var body = this.body;
            if (!body) return;

            this.disable();

            this.app.systems.rigidbody.destroyBody(body);
        },

        _getEntityTransform: function (transform) {
            var pos = this.entity.getPosition();
            var rot = this.entity.getRotation();

            ammoVec1.setValue(pos.x, pos.y, pos.z);
            ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);

            transform.setOrigin(ammoVec1);
            transform.setRotation(ammoQuat);
        },

        updateTransform: function () {
            this._getEntityTransform(ammoTransform);

            var body = this.body;
            body.setWorldTransform(ammoTransform);
            body.activate();
        },

        enable: function () {
            var body = this.body;
            if (!body) return;

            var systems = this.app.systems;
            systems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
            systems.rigidbody._triggers.push(this);

            // set the body's activation state to active so that it is
            // simulated properly again
            body.forceActivationState(BODYSTATE_ACTIVE_TAG);

            this.updateTransform();
        },

        disable: function () {
            var body = this.body;
            if (!body) return;

            var systems = this.app.systems;
            var idx = systems.rigidbody._triggers.indexOf(this);
            if (idx > -1) {
                systems.rigidbody._triggers.splice(idx, 1);
            }
            systems.rigidbody.removeBody(body);

            // set the body's activation state to disable simulation so
            // that it properly deactivates after we remove it from the physics world
            body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
        }
    });

    var mat4 = new Mat4();
    var vec3 = new Vec3();
    var quat$1 = new Quat();

    var _schema$6 = [
        'enabled',
        'type',
        'halfExtents',
        'radius',
        'axis',
        'height',
        'asset',
        'shape',
        'model'
    ];

    // Collision system implementations
    var CollisionSystemImpl = function (system) {
        this.system = system;
    };

    Object.assign(CollisionSystemImpl.prototype, {
        // Called before the call to system.super.initializeComponentData is made
        beforeInitialize: function (component, data) {
            data.shape = null;

            data.model = new Model();
            data.model.graph = new GraphNode();
        },

        // Called after the call to system.super.initializeComponentData is made
        afterInitialize: function (component, data) {
            this.recreatePhysicalShapes(component);
            component.data.initialized = true;
        },

        // Called when a collision component changes type in order to recreate debug and physical shapes
        reset: function (component, data) {
            this.beforeInitialize(component, data);
            this.afterInitialize(component, data);
        },

        // Re-creates rigid bodies / triggers
        recreatePhysicalShapes: function (component) {
            var entity = component.entity;
            var data = component.data;

            if (typeof Ammo !== 'undefined') {
                if (entity.trigger) {
                    entity.trigger.destroy();
                    delete entity.trigger;
                }

                if (data.shape) {
                    if (component._compoundParent) {
                        this.system._removeCompoundChild(component._compoundParent, data.shape);

                        if (component._compoundParent.entity.rigidbody)
                            component._compoundParent.entity.rigidbody.activate();
                    }

                    Ammo.destroy(data.shape);
                    data.shape = null;
                }

                data.shape = this.createPhysicalShape(component.entity, data);

                var firstCompoundChild = ! component._compoundParent;

                if (data.type === 'compound' && (! component._compoundParent || component === component._compoundParent)) {
                    component._compoundParent = component;

                    entity.forEach(this._addEachDescendant, component);
                } else if (data.type !== 'compound') {
                    if (component._compoundParent && component === component._compoundParent) {
                        entity.forEach(this.system.implementations.compound._updateEachDescendant, component);
                    }

                    if (! component.rigidbody) {
                        component._compoundParent = null;
                        var parent = entity.parent;
                        while (parent) {
                            if (parent.collision && parent.collision.type === 'compound') {
                                component._compoundParent = parent.collision;
                                break;
                            }
                            parent = parent.parent;
                        }
                    }
                }

                if (component._compoundParent) {
                    if (component !== component._compoundParent) {
                        if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
                            this.system.recreatePhysicalShapes(component._compoundParent);
                        } else {
                            this.system.updateCompoundChildTransform(entity);

                            if (component._compoundParent.entity.rigidbody)
                                component._compoundParent.entity.rigidbody.activate();
                        }
                    }
                }

                if (entity.rigidbody) {
                    entity.rigidbody.disableSimulation();
                    entity.rigidbody.createBody();

                    if (entity.enabled && entity.rigidbody.enabled) {
                        entity.rigidbody.enableSimulation();
                    }
                } else if (! component._compoundParent) {
                    if (! entity.trigger) {
                        entity.trigger = new Trigger(this.system.app, component, data);
                    } else {
                        entity.trigger.initialize(data);
                    }
                }
            }
        },

        // Creates a physical shape for the collision. This consists
        // of the actual shape that will be used for the rigid bodies / triggers of
        // the collision.
        createPhysicalShape: function (entity, data) {
            return undefined;
        },

        updateTransform: function (component, position, rotation, scale) {
            if (component.entity.trigger) {
                component.entity.trigger.updateTransform();
            }
        },

        beforeRemove: function (entity, component) {
            if (component.data.shape) {
                if (component._compoundParent && ! component._compoundParent.entity._destroying) {
                    this.system._removeCompoundChild(component._compoundParent, component.data.shape);

                    if (component._compoundParent.entity.rigidbody)
                        component._compoundParent.entity.rigidbody.activate();
                }

                component._compoundParent = null;

                Ammo.destroy(component.data.shape);
                component.data.shape = null;
            }
        },

        // Called when the collision is removed
        remove: function (entity, data) {
            var app = this.system.app;
            if (entity.rigidbody && entity.rigidbody.body) {
                app.systems.rigidbody.removeBody(entity.rigidbody.body);
                entity.rigidbody.disableSimulation();
            }

            if (entity.trigger) {
                entity.trigger.destroy();
                delete entity.trigger;
            }

            if (app.scene.containsModel(data.model)) {
                app.root.removeChild(data.model.graph);
                app.scene.removeModel(data.model);
            }
        },

        // Called when the collision is cloned to another entity
        clone: function (entity, clone) {
            var src = this.system.store[entity.getGuid()];

            var data = {
                enabled: src.data.enabled,
                type: src.data.type,
                halfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],
                radius: src.data.radius,
                axis: src.data.axis,
                height: src.data.height,
                asset: src.data.asset,
                model: src.data.model
            };

            return this.system.addComponent(clone, data);
        }
    });

    // Box Collision System
    var CollisionBoxSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionBoxSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionBoxSystemImpl.prototype.constructor = CollisionBoxSystemImpl;

    Object.assign(CollisionBoxSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            if (typeof Ammo !== 'undefined') {
                var he = data.halfExtents;
                var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
                var shape = new Ammo.btBoxShape(ammoHe);
                Ammo.destroy(ammoHe);
                return shape;
            }
            return undefined;
        }
    });

    // Sphere Collision System
    var CollisionSphereSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionSphereSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionSphereSystemImpl.prototype.constructor = CollisionSphereSystemImpl;

    Object.assign(CollisionSphereSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            if (typeof Ammo !== 'undefined') {
                return new Ammo.btSphereShape(data.radius);
            }
            return undefined;
        }
    });

    // Capsule Collision System
    var CollisionCapsuleSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionCapsuleSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionCapsuleSystemImpl.prototype.constructor = CollisionCapsuleSystemImpl;

    Object.assign(CollisionCapsuleSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            var shape = null;
            var axis = (data.axis !== undefined) ? data.axis : 1;
            var radius = data.radius || 0.5;
            var height = Math.max((data.height || 2) - 2 * radius, 0);

            if (typeof Ammo !== 'undefined') {
                switch (axis) {
                    case 0:
                        shape = new Ammo.btCapsuleShapeX(radius, height);
                        break;
                    case 1:
                        shape = new Ammo.btCapsuleShape(radius, height);
                        break;
                    case 2:
                        shape = new Ammo.btCapsuleShapeZ(radius, height);
                        break;
                }
            }
            return shape;
        }
    });

    // Cylinder Collision System
    var CollisionCylinderSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionCylinderSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionCylinderSystemImpl.prototype.constructor = CollisionCylinderSystemImpl;

    Object.assign(CollisionCylinderSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            var halfExtents = null;
            var shape = null;
            var axis = (data.axis !== undefined) ? data.axis : 1;
            var radius = (data.radius !== undefined) ? data.radius : 0.5;
            var height = (data.height !== undefined) ? data.height : 1;

            if (typeof Ammo !== 'undefined') {
                switch (axis) {
                    case 0:
                        halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
                        shape = new Ammo.btCylinderShapeX(halfExtents);
                        break;
                    case 1:
                        halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
                        shape = new Ammo.btCylinderShape(halfExtents);
                        break;
                    case 2:
                        halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
                        shape = new Ammo.btCylinderShapeZ(halfExtents);
                        break;
                }
            }

            if (halfExtents)
                Ammo.destroy(halfExtents);

            return shape;
        }
    });

    // Cone Collision System
    var CollisionConeSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionConeSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionConeSystemImpl.prototype.constructor = CollisionConeSystemImpl;

    Object.assign(CollisionConeSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            var shape = null;
            var axis = (data.axis !== undefined) ? data.axis : 1;
            var radius = (data.radius !== undefined) ? data.radius : 0.5;
            var height = (data.height !== undefined) ? data.height : 1;

            if (typeof Ammo !== 'undefined') {
                switch (axis) {
                    case 0:
                        shape = new Ammo.btConeShapeX(radius, height);
                        break;
                    case 1:
                        shape = new Ammo.btConeShape(radius, height);
                        break;
                    case 2:
                        shape = new Ammo.btConeShapeZ(radius, height);
                        break;
                }
            }
            return shape;
        }
    });

    // Mesh Collision System
    var CollisionMeshSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionMeshSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionMeshSystemImpl.prototype.constructor = CollisionMeshSystemImpl;

    Object.assign(CollisionMeshSystemImpl.prototype, {
        // override for the mesh implementation because the asset model needs
        // special handling
        beforeInitialize: function (component, data) {},

        createPhysicalShape: function (entity, data) {
            if (typeof Ammo !== 'undefined' && data.model) {
                var model = data.model;
                var shape = new Ammo.btCompoundShape();

                var i, j;
                for (i = 0; i < model.meshInstances.length; i++) {
                    var meshInstance = model.meshInstances[i];
                    var mesh = meshInstance.mesh;
                    var triMesh;

                    if (this.system._triMeshCache[mesh.id]) {
                        triMesh = this.system._triMeshCache[mesh.id];
                    } else {
                        var ib = mesh.indexBuffer[RENDERSTYLE_SOLID];
                        var vb = mesh.vertexBuffer;

                        var format = vb.getFormat();
                        var stride = format.size / 4;
                        var positions;
                        for (j = 0; j < format.elements.length; j++) {
                            var element = format.elements[j];
                            if (element.name === SEMANTIC_POSITION) {
                                positions = new Float32Array(vb.lock(), element.offset);
                            }
                        }

                        var indices = new Uint16Array(ib.lock());
                        var numTriangles = mesh.primitive[0].count / 3;

                        var v1 = new Ammo.btVector3();
                        var v2 = new Ammo.btVector3();
                        var v3 = new Ammo.btVector3();
                        var i1, i2, i3;

                        var base = mesh.primitive[0].base;
                        triMesh = new Ammo.btTriangleMesh();
                        this.system._triMeshCache[mesh.id] = triMesh;

                        for (j = 0; j < numTriangles; j++) {
                            i1 = indices[base + j * 3] * stride;
                            i2 = indices[base + j * 3 + 1] * stride;
                            i3 = indices[base + j * 3 + 2] * stride;
                            v1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);
                            v2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);
                            v3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                            triMesh.addTriangle(v1, v2, v3, true);
                        }

                        Ammo.destroy(v1);
                        Ammo.destroy(v2);
                        Ammo.destroy(v3);
                    }

                    var useQuantizedAabbCompression = true;
                    var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);

                    var scaling = this.system._getNodeScaling(meshInstance.node);
                    triMeshShape.setLocalScaling(scaling);
                    Ammo.destroy(scaling);

                    var transform = this.system._getNodeTransform(meshInstance.node);
                    shape.addChildShape(transform, triMeshShape);
                    Ammo.destroy(transform);
                }

                var entityTransform = entity.getWorldTransform();
                var scale = entityTransform.getScale();
                var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
                shape.setLocalScaling(vec);
                Ammo.destroy(vec);

                return shape;
            }
            return undefined;
        },

        recreatePhysicalShapes: function (component) {
            var data = component.data;

            if (data.asset !== null && component.enabled && component.entity.enabled) {
                this.loadModelAsset(component);
            } else {
                this.doRecreatePhysicalShape(component);
            }
        },

        loadModelAsset: function (component) {
            var self = this;
            var id = component.data.asset;
            var data = component.data;
            var assets = this.system.app.assets;

            var asset = assets.get(id);
            if (asset) {
                asset.ready(function (asset) {
                    data.model = asset.resource;
                    self.doRecreatePhysicalShape(component);
                });
                assets.load(asset);
            } else {
                assets.once("add:" + id, function (asset) {
                    asset.ready(function (asset) {
                        data.model = asset.resource;
                        self.doRecreatePhysicalShape(component);
                    });
                    assets.load(asset);
                });
            }
        },

        doRecreatePhysicalShape: function (component) {
            var entity = component.entity;
            var data = component.data;

            if (data.model) {
                this.destroyShape(data);

                data.shape = this.createPhysicalShape(entity, data);

                if (entity.rigidbody) {
                    entity.rigidbody.disableSimulation();
                    entity.rigidbody.createBody();

                    if (entity.enabled && entity.rigidbody.enabled) {
                        entity.rigidbody.enableSimulation();
                    }
                } else {
                    if (!entity.trigger) {
                        entity.trigger = new Trigger(this.system.app, component, data);
                    } else {
                        entity.trigger.initialize(data);
                    }
                }
            } else {
                this.beforeRemove(entity, component);
                this.remove(entity, data);
            }
        },

        updateTransform: function (component, position, rotation, scale) {
            if (component.shape) {
                var entityTransform = component.entity.getWorldTransform();
                var worldScale = entityTransform.getScale();

                // if the scale changed then recreate the shape
                var previousScale = component.shape.getLocalScaling();
                if (worldScale.x !== previousScale.x() ||
                    worldScale.y !== previousScale.y() ||
                    worldScale.z !== previousScale.z() ) {
                    this.doRecreatePhysicalShape(component);
                }
            }

            CollisionSystemImpl.prototype.updateTransform.call(this, component, position, rotation, scale);
        },

        destroyShape: function (data) {
            if (!data.shape)
                return;

            var numShapes = data.shape.getNumChildShapes();
            for (var i = 0; i < numShapes; i++) {
                var shape = data.shape.getChildShape(i);
                Ammo.destroy(shape);
            }

            Ammo.destroy(data.shape);
            data.shape = null;
        },

        remove: function (entity, data) {
            this.destroyShape(data);
            CollisionSystemImpl.prototype.remove.call(this, entity, data);
        }
    });

    // Compound Collision System
    var CollisionCompoundSystemImpl = function (system) {
        CollisionSystemImpl.call(this, system);
    };
    CollisionCompoundSystemImpl.prototype = Object.create(CollisionSystemImpl.prototype);
    CollisionCompoundSystemImpl.prototype.constructor = CollisionCompoundSystemImpl;

    Object.assign(CollisionCompoundSystemImpl.prototype, {
        createPhysicalShape: function (entity, data) {
            if (typeof Ammo !== 'undefined') {
                return new Ammo.btCompoundShape();
            }
            return undefined;
        },

        _addEachDescendant: function (entity) {
            if (! entity.collision || entity.rigidbody)
                return;

            entity.collision._compoundParent = this;

            if (entity !== this.entity) {
                entity.collision.system.recreatePhysicalShapes(entity.collision);
            }
        },

        _updateEachDescendant: function (entity) {
            if (! entity.collision)
                return;

            if (entity.collision._compoundParent !== this)
                return;

            entity.collision._compoundParent = null;

            if (entity !== this.entity && ! entity.rigidbody) {
                entity.collision.system.recreatePhysicalShapes(entity.collision);
            }
        },

        _updateEachDescendantTransform: function (entity) {
            if (! entity.collision || entity.collision._compoundParent !== this.collision._compoundParent)
                return;

            this.collision.system.updateCompoundChildTransform(entity);
        }
    });

    /**
     * @class
     * @name pc.CollisionComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.CollisionComponent}s.
     * @description Creates a new CollisionComponentSystem.
     * @param {pc.Application} app - The running {pc.Application}.
     */
    var CollisionComponentSystem = function CollisionComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = "collision";
        this.description = "Specifies a collision volume.";

        this.ComponentType = CollisionComponent;
        this.DataType = CollisionComponentData;

        this.schema = _schema$6;

        this.implementations = { };

        this._triMeshCache = { };

        this.on('beforeremove', this.onBeforeRemove, this);
        this.on('remove', this.onRemove, this);
    };
    CollisionComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    CollisionComponentSystem.prototype.constructor = CollisionComponentSystem;

    Component._buildAccessors(CollisionComponent.prototype, _schema$6);

    Object.assign(CollisionComponentSystem.prototype, {
        initializeComponentData: function (component, _data, properties) {
            properties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'enabled'];

            // duplicate the input data because we are modifying it
            var data = {};
            for (var i = 0, len = properties.length; i < len; i++) {
                var property = properties[i];
                data[property] = _data[property];
            }

            // asset takes priority over model
            // but they are both trying to change the mesh
            // so remove one of them to avoid conflicts
            var idx;
            if (_data.hasOwnProperty('asset')) {
                idx = properties.indexOf('model');
                if (idx !== -1) {
                    properties.splice(idx, 1);
                }
            } else if (_data.hasOwnProperty('model')) {
                idx = properties.indexOf('asset');
                if (idx !== -1) {
                    properties.splice(idx, 1);
                }
            }

            if (!data.type) {
                data.type = component.data.type;
            }
            component.data.type = data.type;

            if (data.halfExtents && type(data.halfExtents) === 'array') {
                data.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);
            }

            var impl = this._createImplementation(data.type);
            impl.beforeInitialize(component, data);

            ComponentSystem.prototype.initializeComponentData.call(this.system, component, data, properties);

            impl.afterInitialize(component, data);
        },

        // Creates an implementation based on the collision type and caches it
        // in an internal implementations structure, before returning it.
        _createImplementation: function (type) {
            if (this.implementations[type] === undefined) {
                var impl;
                switch (type) {
                    case 'box':
                        impl = new CollisionBoxSystemImpl(this);
                        break;
                    case 'sphere':
                        impl = new CollisionSphereSystemImpl(this);
                        break;
                    case 'capsule':
                        impl = new CollisionCapsuleSystemImpl(this);
                        break;
                    case 'cylinder':
                        impl = new CollisionCylinderSystemImpl(this);
                        break;
                    case 'cone':
                        impl = new CollisionConeSystemImpl(this);
                        break;
                    case 'mesh':
                        impl = new CollisionMeshSystemImpl(this);
                        break;
                    case 'compound':
                        impl = new CollisionCompoundSystemImpl(this);
                        break;
                }
                this.implementations[type] = impl;
            }

            return this.implementations[type];
        },

        // Gets an existing implementation for the specified entity
        _getImplementation: function (entity) {
            return this.implementations[entity.collision.data.type];
        },

        cloneComponent: function (entity, clone) {
            return this._getImplementation(entity).clone(entity, clone);
        },

        onBeforeRemove: function (entity, component) {
            this.implementations[component.data.type].beforeRemove(entity, component);
            component.onBeforeRemove();
        },

        onRemove: function (entity, data) {
            this.implementations[data.type].remove(entity, data);
        },

        updateCompoundChildTransform: function (entity) {
            // TODO
            // use updateChildTransform once it is exposed in ammo.js

            this._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);

            if (entity.enabled && entity.collision.enabled) {
                var transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);
                entity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);
                Ammo.destroy(transform);
            }
        },

        _removeCompoundChild: function (collision, shape) {
            if (collision.shape.removeChildShape) {
                collision.shape.removeChildShape(shape);
            } else {
                var ind = collision._getCompoundChildShapeIndex(shape);
                if (ind !== null) {
                    collision.shape.removeChildShapeByIndex(ind);
                }
            }
        },

        onTransformChanged: function (component, position, rotation, scale) {
            this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
        },

        // Destroys the previous collision type and creates a new one based on the new type provided
        changeType: function (component, previousType, newType) {
            this.implementations[previousType].beforeRemove(component.entity, component);
            this.implementations[previousType].remove(component.entity, component.data);
            this._createImplementation(newType).reset(component, component.data);
        },

        // Recreates rigid bodies or triggers for the specified component
        recreatePhysicalShapes: function (component) {
            this.implementations[component.data.type].recreatePhysicalShapes(component);
        },

        _calculateNodeRelativeTransform: function (node, relative) {
            if (node === relative) {
                var scale = node.getWorldTransform().getScale();
                mat4.setScale(scale.x, scale.y, scale.z);
            } else {
                this._calculateNodeRelativeTransform(node.parent, relative);
                mat4.mul(node.getLocalTransform());
            }
        },

        _getNodeScaling: function (node) {
            var wtm = node.getWorldTransform();
            var scl = wtm.getScale();
            return new Ammo.btVector3(scl.x, scl.y, scl.z);
        },

        _getNodeTransform: function (node, relative) {
            var pos, rot;

            if (relative) {
                this._calculateNodeRelativeTransform(node, relative);

                pos = vec3;
                rot = quat$1;

                mat4.getTranslation(pos);
                rot.setFromMat4(mat4);
            } else {
                pos = node.getPosition();
                rot = node.getRotation();
            }

            var transform = new Ammo.btTransform();
            transform.setIdentity();
            var origin = transform.getOrigin();
            origin.setValue(pos.x, pos.y, pos.z);

            var ammoQuat = new Ammo.btQuaternion();
            ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
            transform.setRotation(ammoQuat);
            Ammo.destroy(ammoQuat);
            Ammo.destroy(origin);

            return transform;
        },

        destroy: function () {
            for (var key in this._triMeshCache) {
                Ammo.destroy(this._triMeshCache[key]);
            }

            this._triMeshCache = null;

            ComponentSystem.prototype.destroy.call(this);
        }
    });

    /**
     * @class
     * @name pc.ComponentSystemRegistry
     * @classdesc Store, access and delete instances of the various ComponentSystems.
     * @description Create a new ComponentSystemRegistry.
     */
    function ComponentSystemRegistry() {
        // An array of pc.ComponentSystem objects
        this.list = [];
    }

    Object.assign(ComponentSystemRegistry.prototype, {
        /**
         * @private
         * @function
         * @name pc.ComponentSystemRegistry#add
         * @description Add a component system to the registry.
         * @param {object} system - The {pc.ComponentSystem} instance.
         */
        add: function (system) {
            var id = system.id;
            if (this[id]) {
                throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
            }

            this[id] = system;

            // Update the component system array
            this.list.push(system);
        },

        /**
         * @private
         * @function
         * @name pc.ComponentSystemRegistry#remove
         * @description Remove a component system from the registry.
         * @param {object} system - The {pc.ComponentSystem} instance.
         */
        remove: function (system) {
            var id = system.id;
            if (!this[id]) {
                throw new Error("No ComponentSystem named '" + id + "' registered");
            }

            delete this[id];

            // Update the component system array
            var index = this.list.indexOf(this[id]);
            if (index !== -1) {
                this.list.splice(index, 1);
            }
        }
    });

    /**
     * @constant
     * @type {string}
     * @name pc.ELEMENTTYPE_GROUP
     * @description A {@link pc.ElementComponent} that contains child {@link pc.ElementComponent}s.
     */
    var ELEMENTTYPE_GROUP = 'group';
    /**
     * @constant
     * @type {string}
     * @name pc.ELEMENTTYPE_IMAGE
     * @description A {@link pc.ElementComponent} that displays an image.
     */
    var ELEMENTTYPE_IMAGE = 'image';
    /**
     * @constant
     * @type {string}
     * @name pc.ELEMENTTYPE_TEXT
     * @description A {@link pc.ElementComponent} that displays text.
     */
    var ELEMENTTYPE_TEXT = 'text';

    /**
     * @class
     * @name pc.StencilParameters
     * @classdesc Holds stencil test settings.
     * @description Create a new StencilParameters instance.
     * @param {object} options - Options object to configure the stencil parameters.
     * @property {number} func Sets stencil test function. See {@link pc.GraphicsDevice#setStencilFunc}.
     * @property {number} ref Sets stencil test reference value. See {@link pc.GraphicsDevice#setStencilFunc}.
     * @property {number} fail Sets operation to perform if stencil test is failed. See {@link pc.GraphicsDevice#setStencilOperation}.
     * @property {number} zfail Sets operation to perform if depth test is failed. See {@link pc.GraphicsDevice#setStencilOperation}.
     * @property {number} zpass Sets operation to perform if both stencil and depth test are passed. See {@link pc.GraphicsDevice#setStencilOperation}.
     * @property {number} readMask Sets stencil test reading mask. See {@link pc.GraphicsDevice#setStencilFunc}.
     * @property {number} writeMask Sets stencil test writing mask. See {@link pc.GraphicsDevice#setStencilOperation}.
     */
    function StencilParameters(options) {
        this.func = options.func === undefined ? FUNC_ALWAYS : options.func;
        this.ref = options.ref || 0;
        this.readMask = options.readMask === undefined ? 0xFF : options.readMask;
        this.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;

        this.fail = options.fail || STENCILOP_KEEP; // keep == 0
        this.zfail = options.zfail || STENCILOP_KEEP;
        this.zpass = options.zpass || STENCILOP_KEEP;
    }

    StencilParameters.prototype.clone = function () {
        var clone = new StencilParameters({
            func: this.func,
            ref: this.ref,
            readMask: this.readMask,
            writeMask: this.writeMask,
            fail: this.fail,
            zfail: this.zfail,
            zpass: this.zpass
        });
        return clone;
    };

    function ImageRenderable(entity, mesh, material) {
        this._entity = entity;
        this._element = entity.element;

        this.model = new Model();
        this.node = new GraphNode();
        this.model.graph = this.node;

        this.mesh = mesh;
        this.meshInstance = new MeshInstance(this.node, this.mesh, material);
        this.meshInstance.name = 'ImageElement: ' + entity.name;
        this.meshInstance.castShadow = false;
        this.meshInstance.receiveShadow = false;

        this._meshDirty = false;

        this.model.meshInstances.push(this.meshInstance);

        this._entity.addChild(this.model.graph);
        this.model._entity = this._entity;

        this.unmaskMeshInstance = null;
    }

    ImageRenderable.prototype.destroy = function () {
        this.setMaterial(null); // clear material references
        this._element.removeModelFromLayers(this.model);
        this.model.destroy();
        this.model = null;
        this.node = null;
        this.mesh = null;
        this.meshInstance = null;
        this._entity = null;
        this._element = null;
    };

    ImageRenderable.prototype.setMesh = function (mesh) {
        if (!this.meshInstance) return;

        this.mesh = mesh;

        this.meshInstance.mesh = mesh;
        this.meshInstance.visible = !!mesh;

        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.mesh = mesh;
        }
        this.forceUpdateAabb();
    };

    ImageRenderable.prototype.setMask = function (mask) {
        if (!this.meshInstance) return;

        if (mask) {
            this.unmaskMeshInstance = new MeshInstance(this.node, this.mesh, this.meshInstance.material);
            this.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;
            this.unmaskMeshInstance.castShadow = false;
            this.unmaskMeshInstance.receiveShadow = false;
            this.unmaskMeshInstance.pick = false;

            this.model.meshInstances.push(this.unmaskMeshInstance);

            // copy parameters
            for (var name in this.meshInstance.parameters) {
                this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
            }
        } else {
            // remove unmask mesh instance from model
            var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
            if (idx >= 0) {
                this.model.meshInstances.splice(idx, 1);
            }

            this.unmaskMeshInstance = null;
        }

        // remove model then re-add to update to current mesh instances
        if (this._entity.enabled && this._element.enabled) {
            this._element.removeModelFromLayers(this.model);
            this._element.addModelToLayers(this.model);
        }
    };

    ImageRenderable.prototype.setMaterial = function (material) {
        if (!this.meshInstance) return;

        this.meshInstance.material = material;
        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.material = material;
        }
    };

    ImageRenderable.prototype.setParameter = function (name, value) {
        if (!this.meshInstance) return;

        this.meshInstance.setParameter(name, value);
        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.setParameter(name, value);
        }
    };

    ImageRenderable.prototype.deleteParameter = function (name) {
        if (!this.meshInstance) return;

        this.meshInstance.deleteParameter(name);
        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.deleteParameter(name);
        }
    };

    ImageRenderable.prototype.setUnmaskDrawOrder = function () {
        if (!this.meshInstance) return;

        var getLastChild = function (e) {
            var last;
            var c = e.children;
            var l = c.length;
            if (l) {
                for (var i = 0; i < l; i++) {
                    if (c[i].element) {
                        last = c[i];
                    }
                }

                if (!last) return null;

                var child = getLastChild(last);
                if (child) {
                    return child;
                }
                return last;
            }
            return null;
        };

        // The unmask mesh instance renders into the stencil buffer
        // with the ref of the previous mask. This essentially "clears"
        // the mask value
        //
        // The unmask has a drawOrder set to be mid-way between the last child of the
        // masked hierarchy and the next child to be drawn.
        //
        // The offset is reduced by a small fraction each time so that if multiple masks
        // end on the same last child they are unmasked in the correct order.
        if (this.unmaskMeshInstance) {
            var lastChild = getLastChild(this._entity);
            if (lastChild && lastChild.element) {
                this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
            } else {
                this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
            }
        }
    };

    ImageRenderable.prototype.setDrawOrder = function (drawOrder) {
        if (!this.meshInstance) return;
        this.meshInstance.drawOrder = drawOrder;
    };

    ImageRenderable.prototype.setCull = function (cull) {
        if (!this.meshInstance) return;
        var element = this._element;

        var visibleFn = null;
        if (cull && element._isScreenCulled()) {
            visibleFn = function (camera) {
                return element.isVisibleForCamera(camera);
            };
        }

        this.meshInstance.cull = cull;
        this.meshInstance.isVisibleFunc = visibleFn;

        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.cull = cull;
            this.unmaskMeshInstance.isVisibleFunc = visibleFn;
        }
    };


    ImageRenderable.prototype.setScreenSpace = function (screenSpace) {
        if (!this.meshInstance) return;

        this.meshInstance.screenSpace = screenSpace;

        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.screenSpace = screenSpace;
        }
    };


    ImageRenderable.prototype.setLayer = function (layer) {
        if (!this.meshInstance) return;

        this.meshInstance.layer = layer;

        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance.layer = layer;
        }
    };

    ImageRenderable.prototype.forceUpdateAabb = function (mask) {
        if (!this.meshInstance) return;

        this.meshInstance._aabbVer = -1;
        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance._aabbVer = -1;
        }
    };

    ImageRenderable.prototype.setAabbFunc = function (fn) {
        if (!this.meshInstance) return;

        this.meshInstance._updateAabbFunc = fn;
        if (this.unmaskMeshInstance) {
            this.unmaskMeshInstance._updateAabbFunc = fn;
        }
    };


    function ImageElement(element) {
        this._element = element;
        this._entity = element.entity;
        this._system = element.system;

        // public
        this._textureAsset = null;
        this._texture = null;
        this._materialAsset = null;
        this._material = null;
        this._spriteAsset = null;
        this._sprite = null;
        this._spriteFrame = 0;
        this._pixelsPerUnit = null;

        this._rect = new Vec4(0, 0, 1, 1); // x, y, w, h

        this._mask = false; // this image element is a mask
        this._maskRef = 0; // id used in stencil buffer to mask

        // 9-slicing
        this._outerScale = new Vec2();
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new Vec4();
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new Vec4();
        this._atlasRectUniform = new Float32Array(4);

        this._defaultMesh = this._createMesh();
        this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);

        // set default colors
        this._color = new Color(1, 1, 1, 1);
        this._colorUniform = new Float32Array([1, 1, 1]);
        this._renderable.setParameter('material_emissive', this._colorUniform);
        this._renderable.setParameter('material_opacity', 1);

        this._updateAabbFunc = this._updateAabb.bind(this);

        // initialize based on screen
        this._onScreenChange(this._element.screen);

        // listen for events
        this._element.on('resize', this._onParentResizeOrPivotChange, this);
        this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
        this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
        this._element.on('set:screen', this._onScreenChange, this);
        this._element.on('set:draworder', this._onDrawOrderChange, this);
        this._element.on('screen:set:resolution', this._onResolutionChange, this);
    }

    Object.assign(ImageElement.prototype, {
        destroy: function () {
            // reset all assets to unbind all asset events
            this.textureAsset = null;
            this.spriteAsset = null;
            this.materialAsset = null;

            this._renderable.setMesh(this._defaultMesh);
            this._renderable.destroy();
            this._defaultMesh = null;

            this._element.off('resize', this._onParentResizeOrPivotChange, this);
            this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
            this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
            this._element.off('set:screen', this._onScreenChange, this);
            this._element.off('set:draworder', this._onDrawOrderChange, this);
            this._element.off('screen:set:resolution', this._onResolutionChange, this);
        },

        _onResolutionChange: function (res) {
        },

        _onParentResizeOrPivotChange: function () {
            if (this._renderable.mesh) {
                this._updateMesh(this._renderable.mesh);
            }
        },

        _onScreenSpaceChange: function (value) {
            this._updateMaterial(value);
        },

        _onScreenChange: function (screen, previous) {
            if (screen) {
                this._updateMaterial(screen.screen.screenSpace);

            } else {
                this._updateMaterial(false);
            }
        },

        _onDrawOrderChange: function (order) {
            this._renderable.setDrawOrder(order);

            if (this.mask && this._element.screen) {
                this._element.screen.screen.once('syncdraworder', function () {
                    this._renderable.setUnmaskDrawOrder();
                }, this);
            }
        },

        // Returns true if we are using a material
        // other than the default materials
        _hasUserMaterial: function () {
            return !!this._materialAsset ||
                   (!!this._material &&
                    this._system.defaultImageMaterials.indexOf(this._material) === -1);
        },

        _use9Slicing: function () {
            return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
        },

        _updateMaterial: function (screenSpace) {
            var mask = !!this._mask;
            var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
            var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);

            if (!this._hasUserMaterial()) {
                this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
            }

            if (this._renderable) {
                this._renderable.setCull(true); // culling is now always true (screenspace culled by isCulled, worldspace by frustum)
                this._renderable.setMaterial(this._material);
                this._renderable.setScreenSpace(screenSpace);
                this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
            }
        },

        // build a quad for the image
        _createMesh: function () {
            var element = this._element;
            var w = element.calculatedWidth;
            var h = element.calculatedHeight;

            var r = this._rect;

            // Note that when creating a typed array, it's initialized to zeros.
            // Allocate memory for 4 vertices, 8 floats per vertex, 4 bytes per float.
            var vertexData = new ArrayBuffer(4 * 8 * 4);
            var vertexDataF32 = new Float32Array(vertexData);

            // Vertex layout is: PX, PY, PZ, NX, NY, NZ, U, V
            // Since the memory is zeroed, we will only set non-zero elements

            // POS: 0, 0, 0
            vertexDataF32[5] = 1;          // NZ
            vertexDataF32[6] = r.x;        // U
            vertexDataF32[7] = r.y;        // V

            // POS: w, 0, 0
            vertexDataF32[8] = w;          // PX
            vertexDataF32[13] = 1;         // NZ
            vertexDataF32[14] = r.x + r.z; // U
            vertexDataF32[15] = r.y;       // V

            // POS: w, h, 0
            vertexDataF32[16] = w;         // PX
            vertexDataF32[17] = h;         // PY
            vertexDataF32[21] = 1;         // NZ
            vertexDataF32[22] = r.x + r.z; // U
            vertexDataF32[23] = r.y + r.w; // V

            // POS: 0, h, 0
            vertexDataF32[25] = h;         // PY
            vertexDataF32[29] = 1;         // NZ
            vertexDataF32[30] = r.x;       // U
            vertexDataF32[31] = r.y + r.w; // V

            var vertexDesc = [
                { semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 },
                { semantic: SEMANTIC_NORMAL, components: 3, type: TYPE_FLOAT32 },
                { semantic: SEMANTIC_TEXCOORD0, components: 2, type: TYPE_FLOAT32 }
            ];

            var device = this._system.app.graphicsDevice;
            var vertexFormat = new VertexFormat(device, vertexDesc);
            var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);

            var mesh = new Mesh(device);
            mesh.vertexBuffer = vertexBuffer;
            mesh.primitive[0].type = PRIMITIVE_TRIFAN;
            mesh.primitive[0].base = 0;
            mesh.primitive[0].count = 4;
            mesh.primitive[0].indexed = false;
            mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));

            this._updateMesh(mesh);

            return mesh;
        },

        _updateMesh: function (mesh) {
            var element = this._element;
            var w = element.calculatedWidth;
            var h = element.calculatedHeight;

            // update material
            var screenSpace = element._isScreenSpace();
            this._updateMaterial(screenSpace);

            // force update meshInstance aabb
            if (this._renderable) this._renderable.forceUpdateAabb();

            if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {

                // calculate inner offset from the frame's border
                var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
                var borderWidthScale = 2 / frameData.rect.z;
                var borderHeightScale = 2 / frameData.rect.w;

                this._innerOffset.set(
                    frameData.border.x * borderWidthScale,
                    frameData.border.y * borderHeightScale,
                    frameData.border.z * borderWidthScale,
                    frameData.border.w * borderHeightScale
                );

                var tex = this.sprite.atlas.texture;
                this._atlasRect.set(frameData.rect.x / tex.width,
                                    frameData.rect.y / tex.height,
                                    frameData.rect.z / tex.width,
                                    frameData.rect.w / tex.height);

                // scale: apply PPU
                var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
                var scaleMulX = frameData.rect.z / ppu;
                var scaleMulY = frameData.rect.w / ppu;

                // scale borders if necessary instead of overlapping
                this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));

                var scaleX = scaleMulX;
                var scaleY = scaleMulY;

                this._outerScale.x /= scaleMulX;
                this._outerScale.y /= scaleMulY;

                // scale: shrinking below 1
                scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
                scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);

                // set scale
                if (this._renderable) {
                    this._innerOffsetUniform[0] = this._innerOffset.x;
                    this._innerOffsetUniform[1] = this._innerOffset.y;
                    this._innerOffsetUniform[2] = this._innerOffset.z;
                    this._innerOffsetUniform[3] = this._innerOffset.w;
                    this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
                    this._atlasRectUniform[0] = this._atlasRect.x;
                    this._atlasRectUniform[1] = this._atlasRect.y;
                    this._atlasRectUniform[2] = this._atlasRect.z;
                    this._atlasRectUniform[3] = this._atlasRect.w;
                    this._renderable.setParameter('atlasRect', this._atlasRectUniform);
                    this._outerScaleUniform[0] = this._outerScale.x;
                    this._outerScaleUniform[1] = this._outerScale.y;
                    this._renderable.setParameter('outerScale', this._outerScaleUniform);
                    this._renderable.setAabbFunc(this._updateAabbFunc);

                    this._renderable.node.setLocalScale(scaleX, scaleY, 1);
                    this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
                }
            } else {
                var vb = mesh.vertexBuffer;
                var vertexDataF32 = new Float32Array(vb.lock());

                // offset for pivot
                var hp = element.pivot.x;
                var vp = element.pivot.y;

                // Update vertex positions, accounting for the pivot offset
                vertexDataF32[0] = 0 - hp * w;
                vertexDataF32[1] = 0 - vp * h;
                vertexDataF32[8] = w - hp * w;
                vertexDataF32[9] = 0 - vp * h;
                vertexDataF32[16] = w - hp * w;
                vertexDataF32[17] = h - vp * h;
                vertexDataF32[24] = 0 - hp * w;
                vertexDataF32[25] = h - vp * h;


                var atlasTextureWidth = 1;
                var atlasTextureHeight = 1;
                var rect = this._rect;

                if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
                    var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
                    if (frame) {
                        rect = frame.rect;
                        atlasTextureWidth = this._sprite.atlas.texture.width;
                        atlasTextureHeight = this._sprite.atlas.texture.height;
                    }
                }

                // Update vertex texture coordinates
                vertexDataF32[6] = rect.x / atlasTextureWidth;
                vertexDataF32[7] = rect.y / atlasTextureHeight;
                vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
                vertexDataF32[15] = rect.y / atlasTextureHeight;
                vertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;
                vertexDataF32[23] = (rect.y + rect.w) / atlasTextureHeight;
                vertexDataF32[30] = rect.x / atlasTextureWidth;
                vertexDataF32[31] = (rect.y + rect.w) / atlasTextureHeight;

                vb.unlock();

                var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
                var max = new Vec3(w - hp * w, h - vp * h, 0);
                mesh.aabb.setMinMax(min, max);

                if (this._renderable) {
                    this._renderable.node.setLocalScale(1, 1, 1);
                    this._renderable.node.setLocalPosition(0, 0, 0);

                    this._renderable.setAabbFunc(null);
                }
            }

            this._meshDirty = false;
        },

        // Gets the mesh from the sprite asset
        // if the sprite is 9-sliced or the default mesh from the
        // image element and calls _updateMesh or sets meshDirty to true
        // if the component is currently being initialized. We need to call
        // _updateSprite every time something related to the sprite asset changes
        _updateSprite: function () {
            var nineSlice = false;
            var mesh = null;

            // take mesh from sprite
            if (this._sprite && this._sprite.atlas) {
                mesh = this._sprite.meshes[this.spriteFrame];
                nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
            }

            // if we use 9 slicing then use that mesh otherwise keep using the default mesh
            this.mesh = nineSlice ? mesh : this._defaultMesh;

            if (this.mesh) {
                if (! this._element._beingInitialized) {
                    this._updateMesh(this.mesh);
                } else {
                    this._meshDirty = true;
                }
            }
        },

        // updates AABB while 9-slicing
        _updateAabb: function (aabb) {
            aabb.center.set(0, 0, 0);
            aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
            aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
            return aabb;
        },

        _toggleMask: function () {
            this._element._dirtifyMask();

            var screenSpace = this._element._isScreenSpace();
            this._updateMaterial(screenSpace);

            this._renderable.setMask(!!this._mask);
        },

        _onMaterialLoad: function (asset) {
            this.material = asset.resource;
        },

        _onMaterialAdded: function (asset) {
            this._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);
            if (this._materialAsset === asset.id) {
                this._bindMaterialAsset(asset);
            }
        },

        _bindMaterialAsset: function (asset) {
            if (!this._entity.enabled) return; // don't bind until element is enabled

            asset.on("load", this._onMaterialLoad, this);
            asset.on("change", this._onMaterialChange, this);
            asset.on("remove", this._onMaterialRemove, this);

            if (asset.resource) {
                this._onMaterialLoad(asset);
            } else {
                this._system.app.assets.load(asset);
            }
        },

        _unbindMaterialAsset: function (asset) {
            asset.off("load", this._onMaterialLoad, this);
            asset.off("change", this._onMaterialChange, this);
            asset.off("remove", this._onMaterialRemove, this);
        },

        _onMaterialChange: function () {

        },

        _onMaterialRemove: function () {

        },

        _onTextureAdded: function (asset) {
            this._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);
            if (this._textureAsset === asset.id) {
                this._bindTextureAsset(asset);
            }
        },

        _bindTextureAsset: function (asset) {
            if (!this._entity.enabled) return; // don't bind until element is enabled

            asset.on("load", this._onTextureLoad, this);
            asset.on("change", this._onTextureChange, this);
            asset.on("remove", this._onTextureRemove, this);

            if (asset.resource) {
                this._onTextureLoad(asset);
            } else {
                this._system.app.assets.load(asset);
            }
        },

        _unbindTextureAsset: function (asset) {
            asset.off("load", this._onTextureLoad, this);
            asset.off("change", this._onTextureChange, this);
            asset.off("remove", this._onTextureRemove, this);
        },

        _onTextureLoad: function (asset) {
            this.texture = asset.resource;
        },

        _onTextureChange: function (asset) {

        },

        _onTextureRemove: function (asset) {

        },

        // When sprite asset is added bind it
        _onSpriteAssetAdded: function (asset) {
            this._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
            if (this._spriteAsset === asset.id) {
                this._bindSpriteAsset(asset);
            }
        },

        // Hook up event handlers on sprite asset
        _bindSpriteAsset: function (asset) {
            if (!this._entity.enabled) return; // don't bind until element is enabled

            asset.on("load", this._onSpriteAssetLoad, this);
            asset.on("change", this._onSpriteAssetChange, this);
            asset.on("remove", this._onSpriteAssetRemove, this);

            if (asset.resource) {
                this._onSpriteAssetLoad(asset);
            } else {
                this._system.app.assets.load(asset);
            }
        },

        _unbindSpriteAsset: function (asset) {
            asset.off("load", this._onSpriteAssetLoad, this);
            asset.off("change", this._onSpriteAssetChange, this);
            asset.off("remove", this._onSpriteAssetRemove, this);

            if (asset.data.textureAtlasAsset) {
                this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
            }
        },

        // When sprite asset is loaded make sure the texture atlas asset is loaded too
        // If so then set the sprite, otherwise wait for the atlas to be loaded first
        _onSpriteAssetLoad: function (asset) {
            if (!asset || !asset.resource) {
                this.sprite = null;
            } else {
                if (!asset.resource.atlas) {
                    var atlasAssetId = asset.data.textureAtlasAsset;
                    if (atlasAssetId) {
                        var assets = this._system.app.assets;
                        assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
                        assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
                    }
                } else {
                    this.sprite = asset.resource;
                }
            }
        },

        // When the sprite asset changes reset it
        _onSpriteAssetChange: function (asset) {
            this._onSpriteAssetLoad(asset);
        },

        _onSpriteAssetRemove: function (asset) {
        },

        // Hook up event handlers on sprite asset
        _bindSprite: function (sprite) {
            sprite.on('set:meshes', this._onSpriteMeshesChange, this);
            sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
            sprite.on('set:atlas', this._onAtlasTextureChange, this);
            if (sprite.atlas) {
                sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
            }
        },

        _unbindSprite: function (sprite) {
            sprite.off('set:meshes', this._onSpriteMeshesChange, this);
            sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
            sprite.off('set:atlas', this._onAtlasTextureChange, this);
            if (sprite.atlas) {
                sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
            }
        },

        _onSpriteMeshesChange: function () {
            // clamp frame
            if (this._sprite) {
                this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
            }

            // force update
            this._updateSprite();
        },

        _onSpritePpuChange: function () {
            // force update when the sprite is 9-sliced. If it's not
            // then its mesh will change when the ppu changes which will
            // be handled by onSpriteMeshesChange
            if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
                // force update
                this._updateSprite();
            }
        },

        _onAtlasTextureChange: function () {
            if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
                this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
                this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
            } else {
                this._renderable.deleteParameter('texture_emissiveMap');
                this._renderable.deleteParameter('texture_opacityMap');
            }
        },

        // When atlas is loaded try to reset the sprite asset
        _onTextureAtlasLoad: function (atlasAsset) {
            var spriteAsset = this._spriteAsset;
            if (spriteAsset instanceof Asset) {
                // TODO: _spriteAsset should never be an asset instance?
                this._onSpriteAssetLoad(spriteAsset);
            } else {
                this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
            }
        },

        onEnable: function () {
            var asset;
            if (this._materialAsset) {
                asset = this._system.app.assets.get(this._materialAsset);
                if (asset && asset.resource !== this._material) {
                    this._bindMaterialAsset(asset);
                }
            }
            if (this._textureAsset) {
                asset = this._system.app.assets.get(this._textureAsset);
                if (asset && asset.resource !== this._texture) {
                    this._bindTextureAsset(asset);
                }
            }
            if (this._spriteAsset) {
                asset = this._system.app.assets.get(this._spriteAsset);
                if (asset && asset.resource !== this._sprite) {
                    this._bindSpriteAsset(asset);
                }
            }

            this._element.addModelToLayers(this._renderable.model);
        },

        onDisable: function () {
            this._element.removeModelFromLayers(this._renderable.model);
        },

        _setStencil: function (stencilParams) {
            this._renderable.meshInstance.stencilFront = stencilParams;
            this._renderable.meshInstance.stencilBack = stencilParams;

            var ref = 0;
            if (this._element.maskedBy) {
                ref = this._element.maskedBy.element._image._maskRef;
            }
            if (this._renderable.unmaskMeshInstance) {
                var sp = new StencilParameters({
                    ref: ref + 1,
                    func: FUNC_EQUAL,
                    zpass: STENCILOP_DECREMENT
                });

                this._renderable.unmaskMeshInstance.stencilFront = sp;
                this._renderable.unmaskMeshInstance.stencilBack = sp;
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "color", {
        get: function () {
            return this._color;
        },

        set: function (value) {
            var r = value.r;
            var g = value.g;
            var b = value.b;


            if (this._color.r === r && this._color.g === g && this._color.b === b) {
                return;
            }

            this._color.r = r;
            this._color.g = g;
            this._color.b = b;

            this._colorUniform[0] = r;
            this._colorUniform[1] = g;
            this._colorUniform[2] = b;
            this._renderable.setParameter('material_emissive', this._colorUniform);

            if (this._element) {
                this._element.fire('set:color', this._color);
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "opacity", {
        get: function () {
            return this._color.a;
        },

        set: function (value) {
            if (value === this._color.a) return;

            this._color.a = value;

            this._renderable.setParameter('material_opacity', value);

            if (this._element) {
                this._element.fire('set:opacity', value);
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "rect", {
        get: function () {
            return this._rect;
        },

        set: function (value) {

            var x, y, z, w;
            if (value instanceof Vec4) {
                x = value.x;
                y = value.y;
                z = value.z;
                w = value.w;
            } else {
                x = value[0];
                y = value[1];
                z = value[2];
                w = value[3];
            }

            if (x === this._rect.x &&
                y === this._rect.y &&
                z === this._rect.z &&
                w === this._rect.w
            ) {
                return;
            }

            this._rect.set(x, y, z, w);

            if (this._renderable.mesh) {
                if (! this._element._beingInitialized) {
                    this._updateMesh(this._renderable.mesh);
                } else {
                    this._meshDirty = true;
                }
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "material", {
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (this._material === value) return;

            if (!value) {
                var screenSpace = this._element._isScreenSpace();
                if (this.mask) {
                    value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
                } else {
                    value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
                }
            }

            this._material = value;
            if (value) {
                this._renderable.setMaterial(value);

                // if this is not the default material then clear color and opacity overrides
                if (this._hasUserMaterial()) {
                    this._renderable.deleteParameter('material_opacity');
                    this._renderable.deleteParameter('material_emissive');
                } else {
                    // otherwise if we are back to the defaults reset the color and opacity
                    this._colorUniform[0] = this._color.r;
                    this._colorUniform[1] = this._color.g;
                    this._colorUniform[2] = this._color.b;
                    this._renderable.setParameter('material_emissive', this._colorUniform);
                    this._renderable.setParameter('material_opacity', this._color.a);
                }
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "materialAsset", {
        get: function () {
            return this._materialAsset;
        },

        set: function (value) {
            var assets = this._system.app.assets;
            var _id = value;

            if (value instanceof Asset) {
                _id = value.id;
            }

            if (this._materialAsset !== _id) {
                if (this._materialAsset) {
                    assets.off('add:' + this._materialAsset, this._onMaterialAdded, this);
                    var _prev = assets.get(this._materialAsset);
                    if (_prev) {
                        _prev.off("load", this._onMaterialLoad, this);
                        _prev.off("change", this._onMaterialChange, this);
                        _prev.off("remove", this._onMaterialRemove, this);
                    }
                }

                this._materialAsset = _id;
                if (this._materialAsset) {
                    var asset = assets.get(this._materialAsset);
                    if (!asset) {
                        this.material = null;
                        assets.on('add:' + this._materialAsset, this._onMaterialAdded, this);
                    } else {
                        this._bindMaterialAsset(asset);
                    }
                } else {
                    this.material = null;
                }
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "texture", {
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture === value) return;

            if (this._textureAsset) {
                var textureAsset = this._system.app.assets.get(this._textureAsset);
                if (textureAsset && textureAsset.resource !== value) {
                    this.textureAsset = null;
                }
            }

            this._texture = value;

            if (value) {

                // clear sprite asset if texture is set
                if (this._spriteAsset) {
                    this.spriteAsset = null;
                }

                // default texture just uses emissive and opacity maps
                this._renderable.setParameter("texture_emissiveMap", this._texture);
                this._renderable.setParameter("texture_opacityMap", this._texture);
                this._colorUniform[0] = this._color.r;
                this._colorUniform[1] = this._color.g;
                this._colorUniform[2] = this._color.b;
                this._renderable.setParameter("material_emissive", this._colorUniform);
                this._renderable.setParameter("material_opacity", this._color.a);
            } else {
                // clear texture params
                this._renderable.deleteParameter("texture_emissiveMap");
                this._renderable.deleteParameter("texture_opacityMap");
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "textureAsset", {
        get: function () {
            return this._textureAsset;
        },

        set: function (value) {
            var assets = this._system.app.assets;
            var _id = value;

            if (value instanceof Asset) {
                _id = value.id;
            }

            if (this._textureAsset !== _id) {
                if (this._textureAsset) {
                    assets.off('add:' + this._textureAsset, this._onTextureAdded, this);
                    var _prev = assets.get(this._textureAsset);
                    if (_prev) {
                        _prev.off("load", this._onTextureLoad, this);
                        _prev.off("change", this._onTextureChange, this);
                        _prev.off("remove", this._onTextureRemove, this);
                    }
                }

                this._textureAsset = _id;
                if (this._textureAsset) {
                    var asset = assets.get(this._textureAsset);
                    if (!asset) {
                        this.texture = null;
                        assets.on('add:' + this._textureAsset, this._onTextureAdded, this);
                    } else {
                        this._bindTextureAsset(asset);
                    }
                } else {
                    this.texture = null;
                }
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "spriteAsset", {
        get: function () {
            return this._spriteAsset;
        },
        set: function (value) {
            var assets = this._system.app.assets;
            var _id = value;

            if (value instanceof Asset) {
                _id = value.id;
            }

            if (this._spriteAsset !== _id) {
                if (this._spriteAsset) {
                    assets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
                    var _prev = assets.get(this._spriteAsset);
                    if (_prev) {
                        this._unbindSpriteAsset(_prev);
                    }
                }

                this._spriteAsset = _id;
                if (this._spriteAsset) {
                    var asset = assets.get(this._spriteAsset);
                    if (!asset) {
                        this.sprite = null;
                        assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
                    } else {
                        this._bindSpriteAsset(asset);
                    }
                } else {
                    this.sprite = null;
                }

                if (this._element) {
                    this._element.fire('set:spriteAsset', _id);
                }
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "sprite", {
        get: function () {
            return this._sprite;
        },
        set: function (value) {
            if (this._sprite === value) return;

            if (this._sprite) {
                this._unbindSprite(this._sprite);
            }

            if (this._spriteAsset) {
                var spriteAsset = this._system.app.assets.get(this._spriteAsset);
                if (spriteAsset && spriteAsset.resource !== value) {
                    this.spriteAsset = null;
                }
            }

            this._sprite = value;

            if (this._sprite) {
                this._bindSprite(this._sprite);

                // clear texture if sprite is being set
                if (this._textureAsset) {
                    this.textureAsset = null;
                }
            }

            if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
                // default texture just uses emissive and opacity maps
                this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture);
                this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture);
            } else {
                // clear texture params
                this._renderable.deleteParameter("texture_emissiveMap");
                this._renderable.deleteParameter("texture_opacityMap");
            }

            // clamp frame
            if (this._sprite) {
                this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
            }

            this._updateSprite();
        }
    });

    Object.defineProperty(ImageElement.prototype, "spriteFrame", {
        get: function () {
            return this._spriteFrame;
        },
        set: function (value) {
            var oldValue = this._spriteFrame;

            if (this._sprite) {
                // clamp frame
                this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
            } else {
                this._spriteFrame = value;
            }

            if (this._spriteFrame === oldValue) return;

            this._updateSprite();

            if (this._element) {
                this._element.fire('set:spriteFrame', value);
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "mesh", {
        get: function () {
            return this._renderable.mesh;
        },
        set: function (value) {
            // this._renderable.mesh = value;

            this._renderable.setMesh(value);
            if (this._defaultMesh === value) {
                this._renderable.setAabbFunc(null);
            } else {
                this._renderable.setAabbFunc(this._updateAabbFunc);
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "mask", {
        get: function () {
            return this._mask;
        },
        set: function (value) {
            if (this._mask !== value) {
                this._mask = value;
                this._toggleMask();
            }
        }
    });

    Object.defineProperty(ImageElement.prototype, "pixelsPerUnit", {
        get: function () {
            return this._pixelsPerUnit;
        },
        set: function (value) {
            if (this._pixelsPerUnit === value) return;

            this._pixelsPerUnit = value;
            if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
                this._updateSprite();
            }

        }
    });


    // private
    Object.defineProperty(ImageElement.prototype, "aabb", {
        get: function () {
            if (this._renderable.meshInstance) {
                return this._renderable.meshInstance.aabb;
            }
            return null;
        }
    });

    function LocalizedAsset(app) {
        EventHandler.call(this);

        this._app = app;
        app.i18n.on('set:locale', this._onSetLocale, this);

        this._autoLoad = false;
        this._disableLocalization = false;

        this._defaultAsset = null;
        this._localizedAsset = null;
    }
    LocalizedAsset.prototype = Object.create(EventHandler.prototype);
    LocalizedAsset.prototype.constructor = LocalizedAsset;

    LocalizedAsset.prototype._bindDefaultAsset = function () {
        var asset = this._app.assets.get(this._defaultAsset);
        if (!asset) {
            this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
        } else {
            this._onDefaultAssetAdd(asset);
        }
    };

    LocalizedAsset.prototype._unbindDefaultAsset = function () {
        if (!this._defaultAsset) return;

        this._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);

        var asset = this._app.assets.get(this._defaultAsset);
        if (!asset) return;

        asset.off('add:localized', this._onLocaleAdd, this);
        asset.off('remove:localized', this._onLocaleRemove, this);
        asset.off('remove', this._onDefaultAssetRemove, this);
    };

    LocalizedAsset.prototype._onDefaultAssetAdd = function (asset) {
        if (this._defaultAsset !== asset.id) return;

        asset.on('add:localized', this._onLocaleAdd, this);
        asset.on('remove:localized', this._onLocaleRemove, this);
        asset.once('remove', this._onDefaultAssetRemove, this);
    };

    LocalizedAsset.prototype._onDefaultAssetRemove = function (asset) {
        if (this._defaultAsset !== asset.id) return;
        asset.off('add:localized', this._onLocaleAdd, this);
        asset.off('remove:localized', this._onLocaleAdd, this);
        this._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);
    };

    LocalizedAsset.prototype._bindLocalizedAsset = function () {
        if (!this._autoLoad) return;

        var asset = this._app.assets.get(this._localizedAsset);
        if (!asset) return;

        asset.on("load", this._onLocalizedAssetLoad, this);
        asset.on("change", this._onLocalizedAssetChange, this);
        asset.on("remove", this._onLocalizedAssetRemove, this);

        if (asset.resource) {
            this._onLocalizedAssetLoad(asset);
        } else {
            this._app.assets.load(asset);
        }
    };

    LocalizedAsset.prototype._unbindLocalizedAsset = function () {
        var asset = this._app.assets.get(this._localizedAsset);
        if (!asset) return;

        asset.off("load", this._onLocalizedAssetLoad, this);
        asset.off("change", this._onLocalizedAssetChange, this);
        asset.off("remove", this._onLocalizedAssetRemove, this);
    };

    LocalizedAsset.prototype._onLocalizedAssetAdd = function (asset) {
        if (this._localizedAsset !== asset.id) return;

        this._bindLocalizedAsset();
    };

    LocalizedAsset.prototype._onLocalizedAssetLoad = function (asset) {
        this.fire('load', asset);
    };

    LocalizedAsset.prototype._onLocalizedAssetChange = function (asset, name, newValue, oldValue) {
        this.fire('change', asset, name, newValue, oldValue);
    };

    LocalizedAsset.prototype._onLocalizedAssetRemove = function (asset) {
        if (this._localizedAsset === asset.id) {
            this.localizedAsset = this._defaultAsset;
        }
        this.fire('remove', asset);
    };

    LocalizedAsset.prototype._onLocaleAdd = function (locale, assetId) {
        if (this._app.i18n.locale !== locale) return;

        // reset localized asset
        this._onSetLocale(locale);
    };

    LocalizedAsset.prototype._onLocaleRemove = function (locale, assetId) {
        if (this._app.i18n.locale !== locale) return;

        // reset localized asset
        this._onSetLocale(locale);
    };

    LocalizedAsset.prototype._onSetLocale = function (locale) {
        if (!this._defaultAsset) {
            this.localizedAsset = null;
            return;
        }

        var asset = this._app.assets.get(this._defaultAsset);
        if (!asset || this._disableLocalization) {
            this.localizedAsset = this._defaultAsset;
            return;
        }

        var localizedAssetId = asset.getLocalizedAssetId(locale);
        if (!localizedAssetId) {
            this.localizedAsset = this._defaultAsset;
            return;
        }

        this.localizedAsset = localizedAssetId;
    };

    LocalizedAsset.prototype.destroy = function () {
        this.defaultAsset = null;
        this._app.i18n.off('set:locale', this._onSetLocale, this);
        this.off();
    };

    Object.defineProperty(LocalizedAsset.prototype, 'defaultAsset', {
        get: function () {
            return this._defaultAsset;
        },
        set: function (value) {
            var id = value instanceof Asset ? value.id : value;

            if (this._defaultAsset === id) return;

            if (this._defaultAsset) {
                this._unbindDefaultAsset();
            }

            this._defaultAsset = id;

            if (this._defaultAsset) {
                this._bindDefaultAsset();
            }

            // reset localized asset
            this._onSetLocale(this._app.i18n.locale);
        }
    });

    Object.defineProperty(LocalizedAsset.prototype, 'localizedAsset', {
        get: function () {
            return this._localizedAsset;
        },
        set: function (value) {
            var id = value instanceof Asset ? value.id : value;
            if (this._localizedAsset === id) {
                return;
            }

            if (this._localizedAsset) {
                this._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
                this._unbindLocalizedAsset();
                this._localizedAsset = null;
            }

            this._localizedAsset = id;

            if (this._localizedAsset) {
                var asset = this._app.assets.get(this._localizedAsset);
                if (!asset) {
                    this._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);
                } else {
                    this._bindLocalizedAsset();
                }
            }
        }
    });

    Object.defineProperty(LocalizedAsset.prototype, 'autoLoad', {
        get: function () {
            return this._autoLoad;
        },
        set: function (value) {
            if (this._autoLoad === value) return;

            this._autoLoad = value;

            if (this._autoLoad && this._localizedAsset) {
                this._unbindLocalizedAsset();
                this._bindLocalizedAsset();
            }
        }
    });

    Object.defineProperty(LocalizedAsset.prototype, 'disableLocalization', {
        get: function () {
            return this._disableLocalization;
        },
        set: function (value) {
            if (this._disableLocalization === value) return;

            this._disableLocalization = value;

            // reset localized asset
            this._onSetLocale(this._app.i18n.locale);
        }
    });

    // markup scanner
    function Scanner(symbols) {
        this._symbols = symbols;
        this._index = 0;
        this._last = 0;
        this._cur = (this._symbols.length > 0) ? this._symbols[0] : null;
        this._buf = [];
        this._mode = "text";
        this._error = null;
    }

    Object.assign(Scanner.prototype, {
        // list of scanner tokens
        EOF_TOKEN: 0,
        ERROR_TOKEN: 1,
        TEXT_TOKEN: 2,
        OPEN_BRACKET_TOKEN: 3,
        CLOSE_BRACKET_TOKEN: 4,
        EQUALS_TOKEN: 5,
        STRING_TOKEN: 6,
        IDENTIFIER_TOKEN: 7,
        WHITESPACE_TOKEN: 8,
        WHITESPACE_CHARS: " \t\n\r\v\f",
        IDENTIFIER_REGEX: /[A-Z|a-z|0-9|_|-|/]/,

        // read the next token, ignore whitespace
        read: function () {
            var token = this._read();
            while (token === this.WHITESPACE_TOKEN) {
                token = this._read();
            }
            if (token !== this.EOF_TOKEN && token !== this.ERROR_TOKEN) {
                this._last = this._index;
            }
            return token;
        },

        // returns the buffer for the last returned token
        buf: function () {
            return this._buf;
        },

        // returns the index of end of the last successful token extraction
        last: function () {
            return this._last;
        },

        // return the error message
        error: function () {
            return this._error;
        },

        // print the scanner output
        debugPrint: function () {
            var tokenStrings = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
            var token = this.read();
            var result = "";
            while (true) {
                result += (result.length > 0 ? "\n" : "") +
                            tokenStrings[token] +
                            " '" + this.buf().join("") + "'";
                if (token === this.EOF_TOKEN || token === this.ERROR_TOKEN) {
                    break;
                }
                token = this.read();
            }
            return result;
        },

        // read the next token from the input stream and return the token
        _read: function () {
            this._buf = [];
            if (this._eof()) {
                return this.EOF_TOKEN;
            }
            return (this._mode === "text") ? this._text() : this._tag();
        },

        // read text block until eof or start of tag
        _text: function () {
            while (true) {
                switch (this._cur) {
                    case null:
                        // reached end of input
                        return (this._buf.length > 0) ? this.TEXT_TOKEN : this.EOF_TOKEN;
                    case "[":
                        // start of tag mode
                        this._mode = "tag";
                        return (this._buf.length > 0) ? this.TEXT_TOKEN : this._tag();
                    case "\\":
                        // handle escape sequence
                        this._next();           // skip \
                        switch (this._cur) {
                            case "[":
                                this._store();
                                break;
                            default:
                                // if we don't recognize the escape sequence, output
                                // the slash without interpretation and continue
                                this._output("\\");
                                break;
                        }
                        break;
                    default:
                        this._store();
                        break;
                }
            }
        },

        // read tag block
        _tag: function () {
            while (true) {
                switch (this._cur) {
                    case null:
                        this._error = "unexpected end of input reading tag";
                        return this.ERROR_TOKEN;
                    case "[":
                        this._store();
                        return this.OPEN_BRACKET_TOKEN;
                    case "]":
                        this._store();
                        this._mode = "text";
                        return this.CLOSE_BRACKET_TOKEN;
                    case "=":
                        this._store();
                        return this.EQUALS_TOKEN;
                    case " ":
                    case "\t":
                    case "\n":
                    case "\r":
                    case "\v":
                    case "\f":
                        return this._whitespace();
                    case "\"":
                        return this._string();
                    default:
                        if (!this._isIdentifierSymbol(this._cur)) {
                            this._error = "unrecognized character";
                            return this.ERROR_TOKEN;
                        }
                        return this._identifier();
                }
            }
        },

        _whitespace: function () {
            this._store();
            while (this.WHITESPACE_CHARS.indexOf(this._cur) !== -1) {
                this._store();
            }
            return this.WHITESPACE_TOKEN;
        },

        _string: function () {
            this._next();       // skip "
            while (true) {
                switch (this._cur) {
                    case null:
                        this._error = "unexpected end of input reading string";
                        return this.ERROR_TOKEN;
                    case "\"":
                        this._next();           // skip "
                        return this.STRING_TOKEN;
                    default:
                        this._store();
                        break;
                }
            }
        },

        _identifier: function () {
            this._store();
            while (this._cur !== null &&
                    this._isIdentifierSymbol(this._cur)) {
                this._store();
            }
            return this.IDENTIFIER_TOKEN;
        },

        _isIdentifierSymbol: function (s) {
            return s.length === 1 && (s.match(this.IDENTIFIER_REGEX) !== null);
        },

        _eof: function () {
            return this._cur === null;
        },

        _next: function () {
            if (!this._eof()) {
                this._index++;
                this._cur = (this._index < this._symbols.length) ? this._symbols[this._index] : null;
            }
            return this._cur;
        },

        _store: function () {
            this._buf.push(this._cur);
            return this._next();
        },

        _output: function (c) {
            this._buf.push(c);
        }
    });

    // markup parser
    var Parser = function (symbols) {
        this._scanner = new Scanner(symbols);
        this._error = null;
    };

    Object.assign(Parser.prototype, {
        // parse the incoming symbols placing resulting symbols in symbols
        // and tags in tags
        // tags is an array of the following structure:
        // {
        //     name: string;                    // tag name, for example 'color'
        //     value: string;                   // optional tag value, for example '#ff0000'
        //     attributes: {                    // list of attributes
        //         key: value;                  // optional key/value pairs
        //     }
        //     start: int;                      // first symbol to which this tag applies
        //     end: int;                        // last symbol to which this tag applies
        // }
        parse: function (symbols, tags) {
            while (true) {
                var token = this._scanner.read();
                switch (token) {
                    case this._scanner.EOF_TOKEN:
                        return true;
                    case this._scanner.ERROR_TOKEN:
                        return false;
                    case this._scanner.TEXT_TOKEN:
                        Array.prototype.push.apply(symbols, this._scanner.buf());
                        break;
                    case this._scanner.OPEN_BRACKET_TOKEN:
                        if (!this._parseTag(symbols, tags)) {
                            return false;
                        }
                        break;
                    default:
                        // any other tag at this point is an error
                        return false;
                }
            }
        },

        // access an error message if the parser failed
        error: function () {
            return "Error evaluating markup at #" + this._scanner.last().toString() +
                    " (" + (this._scanner.error() || this._error) + ")";
        },

        _parseTag: function (symbols, tags) {
            // first token after [ must be an identifier
            var token = this._scanner.read();
            if (token !== this._scanner.IDENTIFIER_TOKEN) {
                this._error = "expected identifier";
                return false;
            }

            var name = this._scanner.buf().join("");

            // handle close tags
            if (name[0] === "/") {
                for (var index = tags.length - 1; index >= 0; --index) {
                    if (name === "/" + tags[index].name && tags[index].end === null) {
                        tags[index].end = symbols.length;
                        token = this._scanner.read();
                        if (token !== this._scanner.CLOSE_BRACKET_TOKEN) {
                            this._error = "expected close bracket";
                            return false;
                        }
                        return true;
                    }
                }
                this._error = "failed to find matching tag";
                return false;
            }

            // else handle open tag
            var tag = {
                name: name,
                value: null,
                attributes: { },
                start: symbols.length,
                end: null
            };

            // read optional tag value
            token = this._scanner.read();
            if (token === this._scanner.EQUALS_TOKEN) {
                token = this._scanner.read();
                if (token !== this._scanner.STRING_TOKEN) {
                    this._error = "expected string";
                    return false;
                }
                tag.value = this._scanner.buf().join("");
                token = this._scanner.read();
            }

            // read optional tag attributes
            while (true) {
                switch (token) {
                    case this._scanner.CLOSE_BRACKET_TOKEN:
                        tags.push(tag);
                        return true;
                    case this._scanner.IDENTIFIER_TOKEN:
                        var identifier = this._scanner.buf().join("");
                        token = this._scanner.read();
                        if (token !== this._scanner.EQUALS_TOKEN) {
                            this._error = "expected equals";
                            return false;
                        }
                        token = this._scanner.read();
                        if (token !== this._scanner.STRING_TOKEN) {
                            this._error = "expected string";
                            return false;
                        }
                        var value = this._scanner.buf().join("");
                        tag.attributes[identifier] = value;
                        break;
                    default:
                        this._error = "expected close bracket or identifier";
                        return false;
                }
                token = this._scanner.read();
            }
        }
    });

    // copy the contents of source object into target object (like a deep version
    // of assign)
    function merge(target, source) {
        for (var key in source) {
            if (!source.hasOwnProperty(key)) {
                continue;
            }
            var value = source[key];
            if (value instanceof Object) {
                if (!target.hasOwnProperty(key)) {
                    target[key] = { };
                }
                merge(target[key], source[key]);
            } else {
                target[key] = value;
            }
        }
    }

    function combineTags(tags) {
        if (tags.length === 0) {
            return null;
        }
        var result = { };
        for (var index = 0; index < tags.length; ++index) {
            var tag = tags[index];
            var tmp = { };
            tmp[tag.name] = { value: tag.value, attributes: tag.attributes };
            merge(result, tmp);
        }
        return result;
    }

    // this function performs a simple task, but tries to do so in a relatively
    // efficient manner. given the list of tags extracted from the text and
    // ordered by start position, it calculates for each output symbol, the
    // resulting effective tags.
    // to do this we must determine which tags overlap each character and merge the
    // tags together (since tags found later in the text can override the values of
    // tags found earlier).
    // returns an array containing the tag structure (or null) for each symbol
    function resolveMarkupTags(tags, numSymbols) {
        var index;

        if (tags.length === 0) {
            return null;
        }

        // make list of tag start/end edges
        var edges = { };
        for (index = 0; index < tags.length; ++index) {
            var tag = tags[index];
            if (!edges.hasOwnProperty(tag.start)) {
                edges[tag.start] = { open: [tag], close: null };
            } else {
                if (edges[tag.start].open === null) {
                    edges[tag.start].open = [tag];
                } else {
                    edges[tag.start].open.push(tag);
                }
            }

            if (!edges.hasOwnProperty(tag.end)) {
                edges[tag.end] = { open: null, close: [tag] };
            } else {
                if (edges[tag.end].close === null) {
                    edges[tag.end].close = [tag];
                } else {
                    edges[tag.end].close.push(tag);
                }
            }
        }

        // build tag instances from open/close edges
        var tagStack = [];

        function removeTags(tags) {
            tagStack = tagStack.filter( function (tag) {
                return tags.find(function (t) {
                    return t === tag;
                }) === undefined;
            });
        }

        function addTags(tags) {
            for (var index = 0; index < tags.length; ++index) {
                tagStack.push(tags[index]);
            }
        }

        var edgeKeys = Object.keys(edges).sort( function (a, b) {
            return a - b;
        });

        var resolvedTags = [];
        for (index = 0; index < edgeKeys.length; ++index) {
            var edge = edges[edgeKeys[index]];

            // remove close tags
            if (edge.close !== null) {
                removeTags(edge.close);
            }

            // add open tags
            if (edge.open !== null) {
                addTags(edge.open);
            }

            // store the resolved tags
            resolvedTags.push( {
                start: edgeKeys[index],
                tags: combineTags(tagStack)
            } );
        }

        // assign the resolved tags per-character
        var result = [];
        var prevTag = null;
        for (index = 0; index < resolvedTags.length; ++index) {
            var resolvedTag = resolvedTags[index];
            while (result.length < resolvedTag.start) {
                result.push(prevTag ? prevTag.tags : null);
            }
            prevTag = resolvedTag;
        }
        while (result.length < numSymbols) {
            result.push(null);
        }

        return result;
    }

    // evaluate the list of symbols, extract the markup tags and return an
    // array of symbols and an array of symbol tags
    function evaluateMarkup(symbols) {
        // log scanner output
        // console.info((new Scanner(symbols)).debugPrint());

        var parser = new Parser(symbols);
        var stripped_symbols = [];
        var tags = [];

        if (!parser.parse(stripped_symbols, tags)) {
            console.warn(parser.error());
            return {
                symbols: symbols,
                tags: null
            };
        }

        // if any tags were not correctly closed, return failure
        var invalidTag = tags.find(function (t) {
            return t.end === null;
        });

        if (invalidTag) {
            console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
            return {
                symbols: symbols,
                tags: null
            };
        }

        // revolve tags per-character
        var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);

        return {
            symbols: stripped_symbols,
            tags: resolved_tags
        };
    }

    function Markup() {}

    Markup.evaluate = function (symbols) {
        return evaluateMarkup(symbols);
    };

    function MeshInfo() {
        // number of symbols
        this.count = 0;
        // number of quads created
        this.quad = 0;
        // number of quads on specific line
        this.lines = {};
        // float array for positions
        this.positions = [];
        // float array for normals
        this.normals = [];
        // float array for UVs
        this.uvs = [];
        // float array for vertex colors
        this.colors = [];
        // float array for indices
        this.indices = [];
        // pc.MeshInstance created from this MeshInfo
        this.meshInstance = null;
    }

    function TextElement(element) {
        this._element = element;
        this._system = element.system;
        this._entity = element.entity;

        // public
        this._text = "";            // the original user-defined text
        this._symbols = [];         // array of visible symbols with unicode processing and markup removed
        this._colorPalette = [];    // per-symbol color palette
        this._symbolColors = null;  // per-symbol color indexes. only set for text with markup.
        this._i18nKey = null;

        this._fontAsset = new LocalizedAsset(this._system.app);
        this._fontAsset.disableLocalization = true;
        this._fontAsset.on('load', this._onFontLoad, this);
        this._fontAsset.on('change', this._onFontChange, this);
        this._fontAsset.on('remove', this._onFontRemove, this);

        this._font = null;

        this._color = new Color(1, 1, 1, 1);
        this._colorUniform = new Float32Array(3);

        this._spacing = 1;
        this._fontSize = 32;
        this._fontMinY = 0;
        this._fontMaxY = 0;
        // the font size that is set directly by the fontSize setter
        this._originalFontSize = 32;
        this._maxFontSize = 32;
        this._minFontSize = 8;
        this._autoFitWidth = false;
        this._autoFitHeight = false;
        this._maxLines = -1;
        this._lineHeight = 32;
        this._scaledLineHeight = 32;
        this._wrapLines = false;

        this._drawOrder = 0;

        this._alignment = new Vec2(0.5, 0.5);

        this._autoWidth = true;
        this._autoHeight = true;

        this.width = 0;
        this.height = 0;

        // private
        this._node = new GraphNode();
        this._model = new Model();
        this._model.graph = this._node;
        this._entity.addChild(this._node);

        this._meshInfo = [];
        this._material = null;

        this._aabbDirty = true;
        this._aabb = new BoundingBox();

        this._noResize = false; // flag used to disable resizing events

        this._currentMaterialType = null; // save the material type (screenspace or not) to prevent overwriting
        this._maskedMaterialSrc = null; // saved material that was assigned before element was masked

        this._rtlReorder = false;
        this._unicodeConverter = false;
        this._rtl = false;              // true when the current text is RTL

        this._outlineColor = new Color(0, 0, 0, 1);
        this._outlineColorUniform = new Float32Array(4);
        this._outlineThicknessScale = 0.2; // 0.2 coefficient to map editor range of 0 - 1 to shader value
        this._outlineThickness = 0.0;

        this._shadowColor = new Color(0, 0, 0, 1);
        this._shadowColorUniform = new Float32Array(4);
        this._shadowOffsetScale = 0.005; // maps the editor scale value to shader scale
        this._shadowOffset = new Vec2(0, 0);
        this._shadowOffsetUniform = new Float32Array(2);

        this._enableMarkup = false;

        // initialize based on screen
        this._onScreenChange(this._element.screen);

        // start listening for element events
        element.on('resize', this._onParentResize, this);
        element.on('set:screen', this._onScreenChange, this);
        element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
        element.on('set:draworder', this._onDrawOrderChange, this);
        element.on('set:pivot', this._onPivotChange, this);

        this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
        this._system.app.i18n.on('data:add', this._onLocalizationData, this);
        this._system.app.i18n.on('data:remove', this._onLocalizationData, this);

        // substring render range
        this._rangeStart = 0;
        this._rangeEnd = 0;
    }

    var LINE_BREAK_CHAR = /^[\r\n]$/;
    var WHITESPACE_CHAR = /^[ \t]$/;
    var WORD_BOUNDARY_CHAR = /^[ \t\-]$/;

    Object.assign(TextElement.prototype, {
        destroy: function () {
            this._setMaterial(null); // clear material from mesh instances

            if (this._model) {
                this._element.removeModelFromLayers(this._model);
                this._model.destroy();
                this._model = null;
            }

            this._fontAsset.destroy();
            this.font = null;

            this._element.off('resize', this._onParentResize, this);
            this._element.off('set:screen', this._onScreenChange, this);
            this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
            this._element.off('set:draworder', this._onDrawOrderChange, this);
            this._element.off('set:pivot', this._onPivotChange, this);

            this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
            this._system.app.i18n.off('data:add', this._onLocalizationData, this);
            this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
        },

        _onParentResize: function (width, height) {
            if (this._noResize) return;
            if (this._font) this._updateText();
        },

        _onScreenChange: function (screen) {
            if (screen) {
                this._updateMaterial(screen.screen.screenSpace);
            } else {
                this._updateMaterial(false);
            }
        },

        _onScreenSpaceChange: function (value) {
            this._updateMaterial(value);
        },

        _onDrawOrderChange: function (order) {
            this._drawOrder = order;

            if (this._model) {
                var i;
                var len;

                for (i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    this._model.meshInstances[i].drawOrder = order;
                }
            }
        },

        _onPivotChange: function (pivot) {
            if (this._font)
                this._updateText();
        },

        _onLocaleSet: function (locale) {
            if (!this._i18nKey) return;

            // if the localized font is different
            // then the current font and the localized font
            // is not yet loaded then reset the current font and wait
            // until the localized font is loaded to see the updated text
            if (this.fontAsset) {
                var asset = this._system.app.assets.get(this.fontAsset);
                if (!asset || !asset.resource || asset.resource !== this._font) {
                    this.font = null;
                }
            }

            this._resetLocalizedText();
        },

        _onLocalizationData: function (locale, messages) {
            if (this._i18nKey && messages[this._i18nKey]) {
                this._resetLocalizedText();
            }
        },

        _resetLocalizedText: function () {
            this._setText(this._system.app.i18n.getText(this._i18nKey));
        },

        _setText: function (text) {
            if (this.unicodeConverter) {
                var unicodeConverterFunc = this._system.getUnicodeConverter();
                if (unicodeConverterFunc) {
                    text = unicodeConverterFunc(text);
                } else {
                    console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
                }
            }

            if (this._text !== text) {
                if (this._font) {
                    this._updateText(text);
                }
                this._text = text;
            }
        },

        _updateText: function (text) {
            var i;
            var len;
            var results;
            var tags;

            if (text === undefined) text = this._text;

            // get the list of symbols
            this._symbols = string.getSymbols(text);

            // handle null string
            if (this._symbols.length === 0) {
                this._symbols = [" "];
            }

            // extract markup
            if (this._enableMarkup) {
                results = Markup.evaluate(this._symbols);
                this._symbols = results.symbols;
                tags = results.tags;
            }

            // handle LTR vs RTL ordering
            if (this._rtlReorder) {
                var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
                if (rtlReorderFunc) {
                    results = rtlReorderFunc(this._symbols);

                    this._rtl = results.rtl;

                    // reorder symbols according to unicode reorder mapping
                    this._symbols = results.mapping.map(function (v) {
                        return this._symbols[v];
                    }, this);

                    // reorder tags if they exist, according to unicode reorder mapping
                    if (tags) {
                        tags = results.mapping.map(function (v) {
                            return tags[v];
                        });
                    }
                } else {
                    console.warn('Element created with rtlReorder option but no rtlReorder function registered');
                }
            } else {
                this._rtl = false;
            }

            // resolve color tags
            if (tags) {
                var paletteMap = { };

                // store fallback color in the palette
                this._colorPalette = [
                    Math.round(this._color.r * 255),
                    Math.round(this._color.g * 255),
                    Math.round(this._color.b * 255)
                ];
                this._symbolColors = [];
                paletteMap[this._color.toString(false).toLowerCase()] = 0;

                for (i = 0, len = this._symbols.length; i < len; ++i) {
                    var tag = tags[i];
                    var color = 0;

                    // get markup coloring
                    if (tag && tag.color && tag.color.value) {
                        var c = tag.color.value;

                        // resolve color dictionary names
                        // TODO: implement the dictionary of colors
                        // if (colorDict.hasOwnProperty(c)) {
                        //    c = dict[c];
                        // }

                        // convert hex color
                        if (c.length === 7 && c[0] === "#") {
                            var hex = c.substring(1).toLowerCase();

                            if (paletteMap.hasOwnProperty(hex)) {
                                // color is already in the palette
                                color = paletteMap[hex];
                            } else {
                                if (/^([0-9a-f]{2}){3}$/.test(hex)) {
                                    // new color
                                    color = this._colorPalette.length / 3;
                                    paletteMap[hex] = color;
                                    this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
                                    this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
                                    this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
                                }
                            }
                        }
                    }

                    this._symbolColors.push(color);
                }
            } else {
                // no tags, therefore no per-symbol colors
                this._colorPalette = [];
                this._symbolColors = null;
            }

            var charactersPerTexture = this._calculateCharsPerTexture();

            var removedModel = false;

            var element = this._element;
            var screenSpace = element._isScreenSpace();
            var screenCulled = element._isScreenCulled();
            var visibleFn = function (camera) {
                return element.isVisibleForCamera(camera);
            };

            for (i = 0, len = this._meshInfo.length; i < len; i++) {
                var l = charactersPerTexture[i] || 0;
                var meshInfo = this._meshInfo[i];

                if (meshInfo.count !== l) {
                    if (!removedModel) {
                        element.removeModelFromLayers(this._model);
                        removedModel = true;
                    }

                    meshInfo.count = l;
                    meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
                    meshInfo.indices.length = l * 3 * 2;
                    meshInfo.uvs.length = l * 2 * 4;
                    meshInfo.colors.length = l * 4 * 4;

                    // destroy old mesh
                    if (meshInfo.meshInstance) {
                        this._removeMeshInstance(meshInfo.meshInstance);
                        meshInfo.meshInstance.material = null;
                    }

                    // if there are no letters for this mesh continue
                    if (l === 0) {
                        meshInfo.meshInstance = null;
                        continue;
                    }

                    // set up indices and normals whose values don't change when we call _updateMeshes
                    for (var v = 0; v < l; v++) {
                        // create index and normal arrays since they don't change
                        // if the length doesn't change
                        meshInfo.indices[v * 3 * 2 + 0] = v * 4;
                        meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
                        meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
                        meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
                        meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
                        meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;

                        meshInfo.normals[v * 4 * 3 + 0] = 0;
                        meshInfo.normals[v * 4 * 3 + 1] = 0;
                        meshInfo.normals[v * 4 * 3 + 2] = -1;

                        meshInfo.normals[v * 4 * 3 + 3] = 0;
                        meshInfo.normals[v * 4 * 3 + 4] = 0;
                        meshInfo.normals[v * 4 * 3 + 5] = -1;

                        meshInfo.normals[v * 4 * 3 + 6] = 0;
                        meshInfo.normals[v * 4 * 3 + 7] = 0;
                        meshInfo.normals[v * 4 * 3 + 8] = -1;

                        meshInfo.normals[v * 4 * 3 + 9] = 0;
                        meshInfo.normals[v * 4 * 3 + 10] = 0;
                        meshInfo.normals[v * 4 * 3 + 11] = -1;
                    }

                    var mesh = createMesh(this._system.app.graphicsDevice,
                                          meshInfo.positions,
                                          {
                                              uvs: meshInfo.uvs,
                                              normals: meshInfo.normals,
                                              colors: meshInfo.colors,
                                              indices: meshInfo.indices
                                          });

                    var mi = new MeshInstance(this._node, mesh, this._material);
                    mi.name = "Text Element: " + this._entity.name;
                    mi.castShadow = false;
                    mi.receiveShadow = false;
                    mi.cull = !screenSpace;
                    mi.screenSpace = screenSpace;
                    mi.drawOrder = this._drawOrder;

                    if (screenCulled) {
                        mi.cull = true;
                        mi.isVisibleFunc = visibleFn;
                    }

                    this._setTextureParams(mi, this._font.textures[i]);
                    if (this._symbolColors) {
                        // when per-vertex coloring is present, disable material emissive color
                        this._colorUniform[0] = 1;
                        this._colorUniform[1] = 1;
                        this._colorUniform[2] = 1;
                    } else {
                        this._colorUniform[0] = this._color.r;
                        this._colorUniform[1] = this._color.g;
                        this._colorUniform[2] = this._color.b;
                    }
                    mi.setParameter("material_emissive", this._colorUniform);
                    mi.setParameter("material_opacity", this._color.a);
                    mi.setParameter("font_sdfIntensity", this._font.intensity);
                    mi.setParameter("font_pxrange", this._getPxRange(this._font));
                    mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);

                    this._outlineColorUniform[0] = this._outlineColor.r;
                    this._outlineColorUniform[1] = this._outlineColor.g;
                    this._outlineColorUniform[2] = this._outlineColor.b;
                    this._outlineColorUniform[3] = this._outlineColor.a;
                    mi.setParameter("outline_color", this._outlineColorUniform);
                    mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);

                    this._shadowColorUniform[0] = this._shadowColor.r;
                    this._shadowColorUniform[1] = this._shadowColor.g;
                    this._shadowColorUniform[2] = this._shadowColor.b;
                    this._shadowColorUniform[3] = this._shadowColor.a;
                    mi.setParameter("shadow_color", this._shadowColorUniform);
                    var ratio = this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
                    this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                    this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
                    mi.setParameter("shadow_offset", this._shadowOffsetUniform);

                    meshInfo.meshInstance = mi;

                    this._model.meshInstances.push(mi);

                }
            }

            // after creating new meshes
            // re-apply masking stencil params
            if (this._element.maskedBy) {
                this._element._setMaskedBy(this._element.maskedBy);
            }

            if (removedModel && this._element.enabled && this._entity.enabled) {
                this._element.addModelToLayers(this._model);
            }

            this._updateMeshes();

            // update render range
            this._rangeStart = 0;
            this._rangeEnd = this._symbols.length;
            this._updateRenderRange();
        },

        _removeMeshInstance: function (meshInstance) {
            var ib;
            var iblen;

            var oldMesh = meshInstance.mesh;
            if (oldMesh) {
                if (oldMesh.vertexBuffer) {
                    oldMesh.vertexBuffer.destroy();
                }

                if (oldMesh.indexBuffer) {
                    for (ib = 0, iblen = oldMesh.indexBuffer.length; ib < iblen; ib++)
                        oldMesh.indexBuffer[ib].destroy();
                }
            }

            var idx = this._model.meshInstances.indexOf(meshInstance);
            if (idx !== -1)
                this._model.meshInstances.splice(idx, 1);
        },

        _setMaterial: function (material) {
            var i;
            var len;

            this._material = material;
            if (this._model) {
                for (i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.material = material;
                }
            }
        },

        _updateMaterial: function (screenSpace) {
            var element = this._element;
            var screenCulled = element._isScreenCulled();
            var visibleFn = function (camera) {
                return element.isVisibleForCamera(camera);
            };

            var msdf = this._font && this._font.type === FONT_MSDF;
            this._material = this._system.getTextElementMaterial(screenSpace, msdf);

            if (this._model) {
                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.cull = !screenSpace;
                    mi.material = this._material;
                    mi.screenSpace = screenSpace;

                    if (screenCulled) {
                        mi.cull = true;
                        mi.isVisibleFunc = visibleFn;
                    } else {
                        mi.isVisibleFunc = null;
                    }

                }
            }
        },

        _updateMeshes: function () {
            var json = this._font.data;
            var self = this;

            var minFont = Math.min(this._minFontSize, this._maxFontSize);
            var maxFont = this._maxFontSize;

            var autoFit = this._shouldAutoFit();

            if (autoFit) {
                this._fontSize = this._maxFontSize;
            }

            var MAGIC = 32;
            var l = this._symbols.length;
            var _x = 0; // cursors
            var _y = 0;
            var _z = 0;
            var _xMinusTrailingWhitespace = 0;
            var lines = 1;
            var wordStartX = 0;
            var wordStartIndex = 0;
            var lineStartIndex = 0;
            var numWordsThisLine = 0;
            var numCharsThisLine = 0;
            var numBreaksThisLine = 0;
            var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;

            var maxLineWidth = this._element.calculatedWidth;
            if ((this.autoWidth && !splitHorizontalAnchors) || !this._wrapLines) {
                maxLineWidth = Number.POSITIVE_INFINITY;
            }

            var fontMinY = 0;
            var fontMaxY = 0;
            var scale = 1;

            var char, data, i, j, quad;

            function breakLine(symbols, lineBreakIndex, lineBreakX) {
                self._lineWidths.push(Math.abs(lineBreakX));
                // in rtl mode lineStartIndex will usually be larger than lineBreakIndex and we will
                // need to adjust the start / end indices when calling symbols.slice()
                var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
                var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
                var chars = symbols.slice(sliceStart, sliceEnd);

                // Remove line breaks from line.
                // Line breaks would only be there for the final line
                // when we reach the maxLines limit.
                // TODO: We could possibly not do this and just let lines have
                // new lines in them. Apart from being a bit weird it should not affect
                // the rendered text.
                if (numBreaksThisLine) {
                    var i = chars.length;
                    while (i-- && numBreaksThisLine > 0)  {
                        if (LINE_BREAK_CHAR.test(chars[i])) {
                            chars.splice(i, 1);
                            numBreaksThisLine--;
                        }
                    }
                }

                self._lineContents.push(chars.join(''));

                _x = 0;
                _y -= self._scaledLineHeight;
                lines++;
                numWordsThisLine = 0;
                numCharsThisLine = 0;
                numBreaksThisLine = 0;
                wordStartX = 0;
                lineStartIndex = lineBreakIndex;
            }

            var retryUpdateMeshes = true;
            while (retryUpdateMeshes) {
                retryUpdateMeshes = false;

                // if auto-fitting then scale the line height
                // according to the current fontSize value relative to the max font size
                if (autoFit) {
                    this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
                } else {
                    this._scaledLineHeight = this._lineHeight;
                }

                this.width = 0;
                this.height = 0;
                this._lineWidths = [];
                this._lineContents = [];

                _x = 0;
                _y = 0;
                _z = 0;
                _xMinusTrailingWhitespace = 0;

                lines = 1;
                wordStartX = 0;
                wordStartIndex = 0;
                lineStartIndex = 0;
                numWordsThisLine = 0;
                numCharsThisLine = 0;
                numBreaksThisLine = 0;

                scale = this._fontSize / MAGIC;

                // scale max font extents
                fontMinY = this._fontMinY * scale;
                fontMaxY = this._fontMaxY * scale;

                for (i = 0; i < this._meshInfo.length; i++) {
                    this._meshInfo[i].quad = 0;
                    this._meshInfo[i].lines = {};
                }

                // per-vertex color
                var color_r = 255;
                var color_g = 255;
                var color_b = 255;

                // In left-to-right mode we loop through the symbols from start to end.
                // In right-to-left mode we loop through the symbols from end to the beginning
                // in order to wrap lines in the correct order
                for (i = 0; i < l; i++) {
                    char = this._symbols[i];

                    var x = 0;
                    var y = 0;
                    var advance = 0;
                    var quadsize = 1;
                    var dataScale, size;

                    data = json.chars[char];

                    // use 'space' if available or first character
                    if (!data) {
                        if (json.chars[' ']) {
                            data = json.chars[' '];
                        } else {
                            for (var key in json.chars) {
                                data = json.chars[key];
                                break;
                            }
                        }
                    }

                    if (data) {
                        var kerning = 0;
                        if (numCharsThisLine > 0) {
                            var kernTable = this._font.data.kerning;
                            if (kernTable) {
                                var kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];
                                if (kernLeft) {
                                    kerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;
                                }
                            }
                        }
                        dataScale = data.scale || 1;
                        size = (data.width + data.height) / 2;
                        quadsize = scale * size / dataScale;
                        advance = (data.xadvance + kerning) * scale;
                        x = (data.xoffset - kerning) * scale;
                        y = data.yoffset * scale;
                    } else {
                        console.error("Couldn't substitute missing character: '" + char + "'");
                    }

                    var isLineBreak = LINE_BREAK_CHAR.test(char);

                    if (isLineBreak) {
                        numBreaksThisLine++;
                        if (this._maxLines < 0 || lines < this._maxLines) {
                            breakLine(this._symbols, i, _xMinusTrailingWhitespace);
                            wordStartIndex = i + 1;
                            lineStartIndex = i + 1;
                        }

                        continue;
                    }

                    var isWhitespace = WHITESPACE_CHAR.test(char);

                    var meshInfo = this._meshInfo[(data && data.map) || 0];

                    var candidateLineWidth = _x + this._spacing * advance;

                    // If we've exceeded the maximum line width, move everything from the beginning of
                    // the current word onwards down onto a new line.
                    if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
                        if (this._maxLines < 0 || lines < this._maxLines) {
                            // Handle the case where a line containing only a single long word needs to be
                            // broken onto multiple lines.
                            if (numWordsThisLine === 0) {
                                wordStartIndex = i;
                                breakLine(this._symbols, i, _xMinusTrailingWhitespace);
                            } else {
                                // Move back to the beginning of the current word.
                                var backtrack = Math.max(i - wordStartIndex, 0);
                                if (this._meshInfo.length <= 1) {
                                    meshInfo.lines[lines - 1] -= backtrack;
                                    meshInfo.quad -= backtrack;
                                } else {
                                    // We should only backtrack the quads that were in the word from this same texture
                                    // We will have to update N number of mesh infos as a result (all textures used in the word in question)
                                    var backtrackStart = wordStartIndex;
                                    var backtrackEnd = i;
                                    for (j = backtrackStart; j < backtrackEnd; j++) {
                                        var backChar = this._symbols[j];
                                        var backCharData = json.chars[backChar];
                                        var backMeshInfo = this._meshInfo[(backCharData && backCharData.map) || 0];
                                        backMeshInfo.lines[lines - 1] -= 1;
                                        backMeshInfo.quad -= 1;
                                    }
                                }

                                i -= backtrack + 1;

                                breakLine(this._symbols, wordStartIndex, wordStartX);
                                continue;
                            }
                        }
                    }

                    quad = meshInfo.quad;
                    meshInfo.lines[lines - 1] = quad;

                    var left = _x - x;
                    var right = left + quadsize;
                    var bottom = _y - y;
                    var top = bottom + quadsize;

                    if (this._rtl) {
                        // rtl text will be flipped vertically before rendering and here we
                        // account for the mis-alignment that would be introduced. shift is calculated
                        // as the difference between the glyph's left and right offset.
                        var shift = quadsize - x - this._spacing * advance - x;
                        left -= shift;
                        right -= shift;
                    }

                    meshInfo.positions[quad * 4 * 3 + 0] = left;
                    meshInfo.positions[quad * 4 * 3 + 1] = bottom;
                    meshInfo.positions[quad * 4 * 3 + 2] = _z;

                    meshInfo.positions[quad * 4 * 3 + 3] = right;
                    meshInfo.positions[quad * 4 * 3 + 4] = bottom;
                    meshInfo.positions[quad * 4 * 3 + 5] = _z;

                    meshInfo.positions[quad * 4 * 3 + 6] = right;
                    meshInfo.positions[quad * 4 * 3 + 7] = top;
                    meshInfo.positions[quad * 4 * 3 + 8] = _z;

                    meshInfo.positions[quad * 4 * 3 + 9]  = left;
                    meshInfo.positions[quad * 4 * 3 + 10] = top;
                    meshInfo.positions[quad * 4 * 3 + 11] = _z;

                    this.width = Math.max(this.width, candidateLineWidth);

                    // scale font size if autoFitWidth is true and the width is larger than the calculated width
                    var fontSize;
                    if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
                        fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
                        fontSize = math.clamp(fontSize, minFont, maxFont);
                        if (fontSize !== this._element.fontSize) {
                            this._fontSize = fontSize;
                            retryUpdateMeshes = true;
                            break;
                        }
                    }

                    this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));

                    // scale font size if autoFitHeight is true and the height is larger than the calculated height
                    if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
                        // try 1 pixel smaller for fontSize and iterate
                        fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
                        if (fontSize !== this._element.fontSize) {
                            this._fontSize = fontSize;
                            retryUpdateMeshes = true;
                            break;
                        }
                    }

                    // advance cursor (for RTL we move left)
                    _x += this._spacing * advance;

                    // For proper alignment handling when a line wraps _on_ a whitespace character,
                    // we need to keep track of the width of the line without any trailing whitespace
                    // characters. This applies to both single whitespaces and also multiple sequential
                    // whitespaces.
                    if (!isWhitespace && !isLineBreak) {
                        _xMinusTrailingWhitespace = _x;
                    }

                    var isWordBoundary = WORD_BOUNDARY_CHAR.test(char);
                    if (isWordBoundary) { // char is space, tab, or dash
                        numWordsThisLine++;
                        wordStartX = _xMinusTrailingWhitespace;
                        wordStartIndex = i + 1;
                    }

                    numCharsThisLine++;

                    var uv = this._getUv(char);

                    meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
                    meshInfo.uvs[quad * 4 * 2 + 1] = uv[1];

                    meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
                    meshInfo.uvs[quad * 4 * 2 + 3] = uv[1];

                    meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
                    meshInfo.uvs[quad * 4 * 2 + 5] = uv[3];

                    meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
                    meshInfo.uvs[quad * 4 * 2 + 7] = uv[3];

                    // set per-vertex color
                    if (this._symbolColors) {
                        var colorIdx = this._symbolColors[i] * 3;
                        color_r = this._colorPalette[colorIdx];
                        color_g = this._colorPalette[colorIdx + 1];
                        color_b = this._colorPalette[colorIdx + 2];
                    }

                    meshInfo.colors[quad * 4 * 4 + 0] = color_r;
                    meshInfo.colors[quad * 4 * 4 + 1] = color_g;
                    meshInfo.colors[quad * 4 * 4 + 2] = color_b;
                    meshInfo.colors[quad * 4 * 4 + 3] = 255;

                    meshInfo.colors[quad * 4 * 4 + 4] = color_r;
                    meshInfo.colors[quad * 4 * 4 + 5] = color_g;
                    meshInfo.colors[quad * 4 * 4 + 6] = color_b;
                    meshInfo.colors[quad * 4 * 4 + 7] = 255;

                    meshInfo.colors[quad * 4 * 4 + 8] = color_r;
                    meshInfo.colors[quad * 4 * 4 + 9] = color_g;
                    meshInfo.colors[quad * 4 * 4 + 10] = color_b;
                    meshInfo.colors[quad * 4 * 4 + 11] = 255;

                    meshInfo.colors[quad * 4 * 4 + 12] = color_r;
                    meshInfo.colors[quad * 4 * 4 + 13] = color_g;
                    meshInfo.colors[quad * 4 * 4 + 14] = color_b;
                    meshInfo.colors[quad * 4 * 4 + 15] = 255;

                    meshInfo.quad++;
                }

                if (retryUpdateMeshes) {
                    continue;
                }

                // As we only break lines when the text becomes too wide for the container,
                // there will almost always be some leftover text on the final line which has
                // not yet been pushed to _lineContents.
                if (lineStartIndex < l) {
                    breakLine(this._symbols, l, _x);
                }
            }

            // force autoWidth / autoHeight change to update width/height of element
            this._noResize = true;
            this.autoWidth = this._autoWidth;
            this.autoHeight = this._autoHeight;
            this._noResize = false;

            // offset for pivot and alignment
            var hp = this._element.pivot.x;
            var vp = this._element.pivot.y;
            var ha = this._alignment.x;
            var va = this._alignment.y;

            for (i = 0; i < this._meshInfo.length; i++) {
                if (this._meshInfo[i].count === 0) continue;

                var prevQuad = 0;
                for (var line in this._meshInfo[i].lines) {
                    var index = this._meshInfo[i].lines[line];
                    var lw = this._lineWidths[parseInt(line, 10)];
                    var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
                    var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);

                    for (quad = prevQuad; quad <= index; quad++) {
                        this._meshInfo[i].positions[quad * 4 * 3] += hoffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 3] += hoffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 6] += hoffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 9] += hoffset;

                        this._meshInfo[i].positions[quad * 4 * 3 + 1] += voffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 4] += voffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 7] += voffset;
                        this._meshInfo[i].positions[quad * 4 * 3 + 10] += voffset;
                    }

                    // flip rtl characters
                    if (this._rtl) {
                        for (quad = prevQuad; quad <= index; quad++) {
                            var idx = quad * 4 * 3;

                            // flip the entire line horizontally
                            for (var vert = 0; vert < 4; ++vert) {
                                this._meshInfo[i].positions[idx + vert * 3] =
                                    this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;
                            }

                            // flip the character horizontally
                            var tmp0 = this._meshInfo[i].positions[idx + 3];
                            var tmp1 = this._meshInfo[i].positions[idx + 6];
                            this._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];
                            this._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];
                            this._meshInfo[i].positions[idx + 0] = tmp0;
                            this._meshInfo[i].positions[idx + 9] = tmp1;
                        }
                    }

                    prevQuad = index + 1;
                }

                // update vertex buffer
                var numVertices = this._meshInfo[i].count * 4; // number of verts we allocated
                var vertMax = this._meshInfo[i].quad * 4;  // number of verts we need (usually count minus line break characters)
                var it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);
                for (var v = 0; v < numVertices; v++) {
                    if (v >= vertMax) {
                        // clear unused vertices
                        it.element[SEMANTIC_POSITION].set(0, 0, 0);
                        it.element[SEMANTIC_TEXCOORD0].set(0, 0);
                        it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
                    } else {
                        it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);
                        it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);
                        it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0],
                                                       this._meshInfo[i].colors[v * 4 + 1],
                                                       this._meshInfo[i].colors[v * 4 + 2],
                                                       this._meshInfo[i].colors[v * 4 + 3]);
                    }
                    it.next();
                }
                it.end();

                this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);

                // force update meshInstance aabb
                this._meshInfo[i].meshInstance._aabbVer = -1;
            }

            // flag text element aabb to be updated
            this._aabbDirty = true;
        },

        _onFontRender: function () {
            // if the font has been changed (e.g. canvasfont re-render)
            // re-applying the same font updates character map and ensures
            // everything is up to date.
            this.font = this._font;
        },

        _onFontLoad: function (asset) {
            if (this.font !== asset.resource) {
                this.font = asset.resource;
            }
        },

        _onFontChange: function (asset, name, _new, _old) {
            if (name === 'data') {
                this._font.data = _new;

                var maps = this._font.data.info.maps.length;
                for (var i = 0; i < maps; i++) {
                    if (!this._meshInfo[i]) continue;

                    var mi = this._meshInfo[i].meshInstance;
                    if (mi) {
                        mi.setParameter("font_sdfIntensity", this._font.intensity);
                        mi.setParameter("font_pxrange", this._getPxRange(this._font));
                        mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
                    }
                }
            }
        },

        _onFontRemove: function (asset) {

        },

        _setTextureParams: function (mi, texture) {
            if (this._font) {
                if (this._font.type === FONT_MSDF) {
                    mi.deleteParameter("texture_emissiveMap");
                    mi.deleteParameter("texture_opacityMap");
                    mi.setParameter("texture_msdfMap", texture);
                } else if (this._font.type === FONT_BITMAP) {
                    mi.deleteParameter("texture_msdfMap");
                    mi.setParameter("texture_emissiveMap", texture);
                    mi.setParameter("texture_opacityMap", texture);
                }
            }
        },

        _getPxRange: function (font) {
            // calculate pxrange from range and scale properties on a character
            var keys = Object.keys(this._font.data.chars);
            for (var i = 0; i < keys.length; i++) {
                var char = this._font.data.chars[keys[i]];
                if (char.range) {
                    return (char.scale || 1) * char.range;
                }
            }
            return 2; // default
        },

        _getUv: function (char) {
            var data = this._font.data;

            if (!data.chars[char]) {
                // missing char - return "space" if we have it
                var space = ' ';
                if (data.chars[space]) {
                    return this._getUv(space);
                }

                // otherwise - missing char
                return [0, 0, 0, 0];
            }

            var map = data.chars[char].map;
            var width = data.info.maps[map].width;
            var height = data.info.maps[map].height;

            var x = data.chars[char].x;
            var y =  data.chars[char].y;

            var x1 = x;
            var y1 = y;
            var x2 = (x + data.chars[char].width);
            var y2 = (y - data.chars[char].height);
            var edge = 1 - (data.chars[char].height / height);
            return [
                x1 / width,
                edge - (y1 / height), // bottom left

                (x2 / width),
                edge - (y2 / height)  // top right
            ];
        },

        onEnable: function () {
            this._fontAsset.autoLoad = true;

            if (this._model) {
                this._element.addModelToLayers(this._model);
            }
        },

        onDisable: function () {
            this._fontAsset.autoLoad = false;

            if (this._model) {
                this._element.removeModelFromLayers(this._model);
            }
        },

        _setStencil: function (stencilParams) {
            if (this._model) {
                var instances = this._model.meshInstances;
                for (var i = 0; i < instances.length; i++) {
                    instances[i].stencilFront = stencilParams;
                    instances[i].stencilBack = stencilParams;
                }
            }
        },

        _shouldAutoFitWidth: function () {
            return this._autoFitWidth && !this._autoWidth;
        },

        _shouldAutoFitHeight: function () {
            return this._autoFitHeight && !this._autoHeight;
        },

        _shouldAutoFit: function () {
            return this._autoFitWidth && !this._autoWidth ||
                   this._autoFitHeight && !this._autoHeight;
        },

        // calculate the number of characters per texture up to, but not including
        // the specified symbolIndex
        _calculateCharsPerTexture: function (symbolIndex) {
            var charactersPerTexture = {};

            if (symbolIndex === undefined) {
                symbolIndex = this._symbols.length;
            }

            var i, len, char, info, map;
            for (i = 0, len = symbolIndex; i < len; i++) {
                char = this._symbols[i];
                info = this._font.data.chars[char];
                if (!info) {
                    // if char is missing use 'space' or first char in map
                    info = this._font.data.chars[' '];
                    if (!info) {
                        // otherwise if space is also not present use the first character in the
                        // set
                        info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
                    }
                }

                map = info.map;
                if (!charactersPerTexture[map]) {
                    charactersPerTexture[map] = 1;
                } else {
                    charactersPerTexture[map]++;
                }
            }
            return charactersPerTexture;
        },

        _updateRenderRange: function () {
            var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
            var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);

            var i, len;
            for (i = 0, len = this._meshInfo.length; i < len; i++) {
                var start = startChars[i] || 0;
                var end = endChars[i] || 0;
                var instance = this._meshInfo[i].meshInstance;
                if (instance) {
                    var mesh = instance.mesh;
                    if (mesh) {
                        mesh.primitive[0].base = start * 3 * 2;
                        mesh.primitive[0].count = (end - start) * 3 * 2;
                    }
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (value) {
            this._i18nKey = null;
            var str = value && value.toString() || "";
            this._setText(str);
        }
    });

    Object.defineProperty(TextElement.prototype, "key", {
        get: function () {
            return this._i18nKey;
        },
        set: function (value) {
            var str = value !== null ? value.toString() : null;
            if (this._i18nKey === str) {
                return;
            }

            this._i18nKey = str;
            if (str) {
                this._fontAsset.disableLocalization = false;
                this._resetLocalizedText();
            } else {
                this._fontAsset.disableLocalization = true;
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "color", {
        get: function () {
            return this._color;
        },

        set: function (value) {
            var r = value.r;
            var g = value.g;
            var b = value.b;


            if (this._color.r === r && this._color.g === g && this._color.b === b) {
                return;
            }

            this._color.r = r;
            this._color.g = g;
            this._color.b = b;

            if (this._symbolColors) {
                // color is baked into vertices, update text
                if (this._font) {
                    this._updateText();
                }
            } else {
                this._colorUniform[0] = this._color.r;
                this._colorUniform[1] = this._color.g;
                this._colorUniform[2] = this._color.b;

                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.setParameter('material_emissive', this._colorUniform);
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "opacity", {
        get: function () {
            return this._color.a;
        },

        set: function (value) {
            if (this._color.a === value) return;

            this._color.a = value;

            if (this._model) {
                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.setParameter('material_opacity', value);
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "lineHeight", {
        get: function () {
            return this._lineHeight;
        },

        set: function (value) {
            var _prev = this._lineHeight;
            this._lineHeight = value;
            this._scaledLineHeight = value;
            if (_prev !== value && this._font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "wrapLines", {
        get: function () {
            return this._wrapLines;
        },

        set: function (value) {
            var _prev = this._wrapLines;
            this._wrapLines = value;
            if (_prev !== value && this._font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "lines", {
        get: function () {
            return this._lineContents;
        }
    });

    Object.defineProperty(TextElement.prototype, "spacing", {
        get: function () {
            return this._spacing;
        },

        set: function (value) {
            var _prev = this._spacing;
            this._spacing = value;
            if (_prev !== value && this._font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "fontSize", {
        get: function () {
            return this._fontSize;
        },

        set: function (value) {
            var _prev = this._fontSize;
            this._fontSize = value;
            this._originalFontSize = value;
            if (_prev !== value && this._font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "fontAsset", {
        get: function () {
            // getting fontAsset returns the currently used localized asset
            return this._fontAsset.localizedAsset;
        },

        set: function (value) {
            // setting the fontAsset sets the default assets which in turn
            // will set the localized asset to be actually used
            this._fontAsset.defaultAsset = value;
        }
    });

    Object.defineProperty(TextElement.prototype, "font", {
        get: function () {
            return this._font;
        },

        set: function (value) {
            var i;
            var len;

            var previousFontType;

            if (this._font) {
                previousFontType = this._font.type;

                // remove render event listener
                if (this._font.off) this._font.off('render', this._onFontRender, this);
            }

            this._font = value;

            this._fontMinY = 0;
            this._fontMaxY = 0;

            if (!value) return;

            // calculate min / max font extents from all available chars
            var json = this._font.data;
            for (var charId in json.chars) {
                var data = json.chars[charId];
                if (data.bounds) {
                    this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
                    this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
                }
            }

            // attach render event listener
            if (this._font.on) this._font.on('render', this._onFontRender, this);

            if (this._fontAsset.localizedAsset) {
                var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
                // if we're setting a font directly which doesn't match the asset
                // then clear the asset
                if (asset.resource !== this._font) {
                    this._fontAsset.defaultAsset = null;
                }
            }

            // if font type has changed we may need to get change material
            if (value.type !== previousFontType) {
                var screenSpace = this._element._isScreenSpace();
                this._updateMaterial(screenSpace);
            }

            // make sure we have as many meshInfo entries
            // as the number of font textures
            for (i = 0, len = this._font.textures.length; i < len; i++) {
                if (!this._meshInfo[i]) {
                    this._meshInfo[i] = new MeshInfo();
                } else {
                    // keep existing entry but set correct parameters to mesh instance
                    var mi = this._meshInfo[i].meshInstance;
                    if (mi) {
                        mi.setParameter("font_sdfIntensity", this._font.intensity);
                        mi.setParameter("font_pxrange", this._getPxRange(this._font));
                        mi.setParameter("font_textureWidth", this._font.data.info.maps[i].width);
                        this._setTextureParams(mi, this._font.textures[i]);
                    }
                }
            }

            // destroy any excess mesh instances
            var removedModel = false;
            for (i = this._font.textures.length; i < this._meshInfo.length; i++) {
                if (this._meshInfo[i].meshInstance) {
                    if (!removedModel) {
                        // remove model from scene so that excess mesh instances are removed
                        // from the scene as well
                        this._element.removeModelFromLayers(this._model);
                        removedModel = true;
                    }
                    this._removeMeshInstance(this._meshInfo[i].meshInstance);
                }
            }

            if (this._meshInfo.length > this._font.textures.length)
                this._meshInfo.length = this._font.textures.length;

            this._updateText();
        }
    });

    Object.defineProperty(TextElement.prototype, "alignment", {
        get: function () {
            return this._alignment;
        },

        set: function (value) {
            if (value instanceof Vec2) {
                this._alignment.set(value.x, value.y);
            } else {
                this._alignment.set(value[0], value[1]);
            }

            if (this._font)
                this._updateText();
        }
    });

    Object.defineProperty(TextElement.prototype, "autoWidth", {
        get: function () {
            return this._autoWidth;
        },

        set: function (value) {
            var old = this._autoWidth;
            this._autoWidth = value;

            // change width of element to match text width but only if the element
            // does not have split horizontal anchors
            if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
                this._element.width = this.width;
            }

            // restore fontSize if autoWidth changed
            if (old !== value) {
                var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
                if (newFontSize !== this._fontSize) {
                    this._fontSize = newFontSize;
                    if (this._font) {
                        this._updateText();
                    }
                }
            }

        }
    });

    Object.defineProperty(TextElement.prototype, "autoHeight", {
        get: function () {
            return this._autoHeight;
        },

        set: function (value) {
            var old = this._autoHeight;
            this._autoHeight = value;

            // change height of element to match text height but only if the element
            // does not have split vertical anchors
            if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
                this._element.height = this.height;
            }

            // restore fontSize if autoHeight changed
            if (old !== value) {
                var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
                if (newFontSize !== this._fontSize) {
                    this._fontSize = newFontSize;
                    if (this._font) {
                        this._updateText();
                    }
                }
            }
        }
    });


    Object.defineProperty(TextElement.prototype, "rtlReorder", {
        get: function () {
            return this._rtlReorder;
        },

        set: function (value) {
            if (this._rtlReorder !== value) {
                this._rtlReorder = value;
                if (this._font) {
                    this._updateText();
                }
            }
        }
    });


    Object.defineProperty(TextElement.prototype, "unicodeConverter", {
        get: function () {
            return this._unicodeConverter;
        },

        set: function (value) {
            if (this._unicodeConverter !== value) {
                this._unicodeConverter = value;
                this._setText(this._text);
            }
        }
    });

    // private
    Object.defineProperty(TextElement.prototype, "aabb", {
        get: function () {
            if (this._aabbDirty) {
                var initialized = false;
                for (var i = 0; i < this._meshInfo.length; i++) {
                    if (! this._meshInfo[i].meshInstance) continue;

                    if (! initialized) {
                        this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
                        initialized = true;
                    } else {
                        this._aabb.add(this._meshInfo[i].meshInstance.aabb);
                    }
                }

                this._aabbDirty = false;
            }
            return this._aabb;
        }
    });

    Object.defineProperty(TextElement.prototype, "outlineColor", {
        get: function () {
            return this._outlineColor;
        },

        set: function (value) {
            var r = (value instanceof Color) ? value.r : value[0];
            var g = (value instanceof Color) ? value.g : value[1];
            var b = (value instanceof Color) ? value.b : value[2];
            var a = (value instanceof Color) ? value.a : value[3];


            if (this._outlineColor.r === r &&
                this._outlineColor.g === g &&
                this._outlineColor.b === b &&
                this._outlineColor.a === a) {
                return;
            }

            this._outlineColor.r = r;
            this._outlineColor.g = g;
            this._outlineColor.b = b;
            this._outlineColor.a = a;

            if (this._model) {
                this._outlineColorUniform[0] = this._outlineColor.r;
                this._outlineColorUniform[1] = this._outlineColor.g;
                this._outlineColorUniform[2] = this._outlineColor.b;
                this._outlineColorUniform[3] = this._outlineColor.a;

                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.setParameter("outline_color", this._outlineColorUniform);
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "outlineThickness", {
        get: function () {
            return this._outlineThickness;
        },

        set: function (value) {
            var _prev = this._outlineThickness;
            this._outlineThickness = value;
            if (_prev !== value && this._font) {
                if (this._model) {
                    for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                        var mi = this._model.meshInstances[i];
                        mi.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
                    }
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "shadowColor", {
        get: function () {
            return this._shadowColor;
        },

        set: function (value) {
            var r = (value instanceof Color) ? value.r : value[0];
            var g = (value instanceof Color) ? value.g : value[1];
            var b = (value instanceof Color) ? value.b : value[2];
            var a = (value instanceof Color) ? value.a : value[3];


            if (this._shadowColor.r === r &&
                this._shadowColor.g === g &&
                this._shadowColor.b === b &&
                this._shadowColor.a === a) {
                return;
            }

            this._shadowColor.r = r;
            this._shadowColor.g = g;
            this._shadowColor.b = b;
            this._shadowColor.a = a;

            if (this._model) {
                this._shadowColorUniform[0] = this._shadowColor.r;
                this._shadowColorUniform[1] = this._shadowColor.g;
                this._shadowColorUniform[2] = this._shadowColor.b;
                this._shadowColorUniform[3] = this._shadowColor.a;

                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var mi = this._model.meshInstances[i];
                    mi.setParameter("shadow_color", this._shadowColorUniform);
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, "shadowOffset", {
        get: function () {
            return this._shadowOffset;
        },

        set: function (value) {
            var x = (value instanceof Vec2) ? value.x : value[0],
                y = (value instanceof Vec2) ? value.y : value[1];
            if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
                return;
            }
            this._shadowOffset.set(x, y);

            if (this._font && this._model) {
                for (var i = 0, len = this._model.meshInstances.length; i < len; i++) {
                    var ratio = this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
                    this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
                    this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
                    var mi = this._model.meshInstances[i];
                    mi.setParameter("shadow_offset", this._shadowOffsetUniform);
                }
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'minFontSize', {
        get: function () {
            return this._minFontSize;
        },
        set: function (value) {
            if (this._minFontSize === value) return;
            this._minFontSize = value;

            if (this.font && this._shouldAutoFit()) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'maxFontSize', {
        get: function () {
            return this._maxFontSize;
        },
        set: function (value) {
            if (this._maxFontSize === value) return;
            this._maxFontSize = value;

            if (this.font && this._shouldAutoFit()) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'autoFitWidth', {
        get: function () {
            return this._autoFitWidth;
        },
        set: function (value) {
            if (this._autoFitWidth === value) return;
            this._autoFitWidth = value;

            this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            if (this.font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'autoFitHeight', {
        get: function () {
            return this._autoFitHeight;
        },
        set: function (value) {
            if (this._autoFitHeight === value) return;
            this._autoFitHeight = value;

            this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            if (this.font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'maxLines', {
        get: function () {
            return this._maxLines;
        },
        set: function (value) {
            if (this._maxLines === value) return;
            if (value === null && this._maxLines === -1) return;

            this._maxLines = (value === null ? -1 : value);

            if (this.font && this._wrapLines) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'enableMarkup', {
        get: function () {
            return this._enableMarkup;
        },
        set: function (value) {
            value = !!value;
            if (this._enableMarkup === value) return;

            this._enableMarkup = value;

            if (this.font) {
                this._updateText();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'symbols', {
        get: function () {
            return this._symbols;
        }
    });

    Object.defineProperty(TextElement.prototype, 'symbolColors', {
        get: function () {
            if (this._symbolColors === null) {
                return null;
            }
            return this._symbolColors.map(function (c) {
                return this._colorPalette.slice(c * 3, c * 3 + 3);
            }, this);
        }
    });

    Object.defineProperty(TextElement.prototype, 'rtl', {
        get: function () {
            return this._rtl;
        }
    });

    Object.defineProperty(TextElement.prototype, 'rangeStart', {
        get: function () {
            return this._rangeStart;
        },
        set: function (rangeStart) {
            rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));

            if (rangeStart !== this._rangeStart) {
                this._rangeStart = rangeStart;
                this._updateRenderRange();
            }
        }
    });

    Object.defineProperty(TextElement.prototype, 'rangeEnd', {
        get: function () {
            return this._rangeEnd;
        },
        set: function (rangeEnd) {
            rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));

            if (rangeEnd !== this._rangeEnd) {
                this._rangeEnd = rangeEnd;
                this._updateRenderRange();
            }
        }
    });

    var vecA = new Vec3();
    var vecB = new Vec3();
    var matA = new Mat4();
    var matB = new Mat4();
    var matC = new Mat4();
    var matD = new Mat4();

    /**
     * @component
     * @class
     * @name pc.ElementComponent
     * @augments pc.Component
     * @classdesc Enables an Entity to be positioned using anchors and screen coordinates under a {@link pc.ScreenComponent} or under other ElementComponents.
     * Depending on its type it can be used to render images, text or just as a layout mechanism to build 2D and 3D user interfaces.
     * If the component is a descendant of a {@link pc.ScreenComponent}, then the Entity's {@link pc.Entity.setLocalPosition} is in the {@link pc.ScreenComponent}'s coordinate system.
     * @param {pc.ElementComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {string} type The type of the ElementComponent. Can be:
     *
     * * {@link pc.ELEMENTTYPE_GROUP}: The component can be used as a layout mechanism to create groups of ElementComponents e.g. panels.
     * * {@link pc.ELEMENTTYPE_IMAGE}: The component will render an image
     * * {@link pc.ELEMENTTYPE_TEXT}: The component will render text
     *
     * @property {pc.Entity} screen The Entity with a {@link pc.ScreenComponent} that this component belongs to. This is automatically set when the component is a child of a ScreenComponent.
     * @property {number} drawOrder The draw order of the component. A higher value means that the component will be rendered on top of other components.
     * @property {pc.Vec4} anchor Specifies where the left, bottom, right and top edges of the component are anchored relative to its parent. Each value
     * ranges from 0 to 1. E.g. a value of [0,0,0,0] means that the element will be anchored to the bottom left of its parent. A value of [1, 1, 1, 1] means
     * it will be anchored to the top right. A split anchor is when the left-right or top-bottom pairs of the anchor are not equal. In that case the component will be resized to cover that entire area. E.g. a value of [0,0,1,1] will make the component resize exactly as its parent.
     * @property {pc.Vec2} pivot The position of the pivot of the component relative to its anchor. Each value ranges from 0 to 1 where [0,0] is the bottom left and [1,1] is the top right.
     * @property {pc.Vec4} margin The distance from the left, bottom, right and top edges of the anchor. For example if we are using a split anchor like [0,0,1,1] and the margin is [0,0,0,0] then the component will be the same width and height as its parent.
     * @property {number} left The distance from the left edge of the anchor. Can be used in combination with a split anchor to make the component's left edge always be 'left' units away from the left.
     * @property {number} right The distance from the right edge of the anchor. Can be used in combination with a split anchor to make the component's right edge always be 'right' units away from the right.
     * @property {number} bottom The distance from the bottom edge of the anchor. Can be used in combination with a split anchor to make the component's top edge always be 'top' units away from the top.
     * @property {number} top The distance from the top edge of the anchor. Can be used in combination with a split anchor to make the component's bottom edge always be 'bottom' units away from the bottom.
     * @property {number} width The width of the element as set in the editor. Note that in some cases this may not reflect the true width at which the element is rendered, such as when the element is under the control of a {@link pc.LayoutGroupComponent}. See `calculatedWidth` in order to ensure you are reading the true width at which the element will be rendered.
     * @property {number} height The height of the element as set in the editor. Note that in some cases this may not reflect the true height at which the element is rendered, such as when the element is under the control of a {@link pc.LayoutGroupComponent}. See `calculatedHeight` in order to ensure you are reading the true height at which the element will be rendered.
     * @property {number} calculatedWidth The width at which the element will be rendered. In most cases this will be the same as `width`. However, in some cases the engine may calculate a different width for the element, such as when the element is under the control of a {@link pc.LayoutGroupComponent}. In these scenarios, `calculatedWidth` may be smaller or larger than the width that was set in the editor.
     * @property {number} calculatedHeight The height at which the element will be rendered. In most cases this will be the same as `height`. However, in some cases the engine may calculate a different height for the element, such as when the element is under the control of a {@link pc.LayoutGroupComponent}. In these scenarios, `calculatedHeight` may be smaller or larger than the height that was set in the editor.
     * @property {pc.Vec3[]} screenCorners An array of 4 {@link pc.Vec3}s that represent the bottom left, bottom right, top right and top left corners of the component relative to its parent {@link pc.ScreenComponent}.
     * @property {pc.Vec3[]} worldCorners An array of 4 {@link pc.Vec3}s that represent the bottom left, bottom right, top right and top left corners of the component in world space. Only works for 3D ElementComponents.
     * @property {pc.Vec2[]} canvasCorners An array of 4 {@link pc.Vec2}s that represent the bottom left, bottom right, top right and top left corners of the component in canvas pixels. Only works for screen space ElementComponents.
     * @property {boolean} useInput If true then the component will receive Mouse or Touch input events.
     * @property {pc.Color} color The color of the image for {@link pc.ELEMENTTYPE_IMAGE} types or the color of the text for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} opacity The opacity of the image for {@link pc.ELEMENTTYPE_IMAGE} types or the text for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {pc.Color} outlineColor The text outline effect color and opacity. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} outlineThickness The width of the text outline effect. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {pc.Color} shadowColor The text shadow effect color and opacity. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {pc.Vec2} shadowOffset The text shadow effect shift amount from original text. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} textWidth The width of the text rendered by the component. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} textHeight The height of the text rendered by the component. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} autoWidth Automatically set the width of the component to be the same as the textWidth. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} autoHeight Automatically set the height of the component to be the same as the textHeight. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} fontAsset The id of the font asset used for rendering the text. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {pc.Font} font The font used for rendering the text. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} fontSize The size of the font. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {boolean} autoFitWidth When true the font size and line height will scale so that the text fits inside the width of the Element. The font size will be scaled between minFontSize and maxFontSize. The value of autoFitWidth will be ignored if autoWidth is true.
     * @property {boolean} autoFitHeight When true the font size and line height will scale so that the text fits inside the height of the Element. The font size will be scaled between minFontSize and maxFontSize. The value of autoFitHeight will be ignored if autoHeight is true.
     * @property {number} minFontSize The minimum size that the font can scale to when autoFitWidth or autoFitHeight are true.
     * @property {number} maxFontSize The maximum size that the font can scale to when autoFitWidth or autoFitHeight are true.
     * @property {number} spacing The spacing between the letters of the text. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} lineHeight The height of each line of text. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {boolean} wrapLines Whether to automatically wrap lines based on the element width. Only works for {@link pc.ELEMENTTYPE_TEXT} types, and when autoWidth is set to false.
     * @property {number} maxLines The maximum number of lines that the Element can wrap to. Any leftover text will be appended to the last line. Set this to null to allow unlimited lines.
     * @property {pc.Vec2} alignment The horizontal and vertical alignment of the text. Values range from 0 to 1 where [0,0] is the bottom left and [1,1] is the top right.  Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {string} text The text to render. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {string} key The localization key to use to get the localized text from {@link pc.Application#i18n}. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} textureAsset The id of the texture asset to render. Only works for {@link pc.ELEMENTTYPE_IMAGE} types.
     * @property {pc.Texture} texture The texture to render. Only works for {@link pc.ELEMENTTYPE_IMAGE} types.
     * @property {number} spriteAsset The id of the sprite asset to render. Only works for {@link pc.ELEMENTTYPE_IMAGE} types which can render either a texture or a sprite.
     * @property {pc.Sprite} sprite The sprite to render. Only works for {@link pc.ELEMENTTYPE_IMAGE} types which can render either a texture or a sprite.
     * @property {number} spriteFrame The frame of the sprite to render. Only works for {@link pc.ELEMENTTYPE_IMAGE} types who have a sprite assigned.
     * @property {number} pixelsPerUnit The number of pixels that map to one PlayCanvas unit. Only works for {@link pc.ELEMENTTYPE_IMAGE} types who have a sliced sprite assigned.
     * @property {number} materialAsset The id of the material asset to use when rendering an image. Only works for {@link pc.ELEMENTTYPE_IMAGE} types.
     * @property {pc.Material} material The material to use when rendering an image. Only works for {@link pc.ELEMENTTYPE_IMAGE} types.
     * @property {pc.Vec4} rect Specifies which region of the texture to use in order to render an image. Values range from 0 to 1 and indicate u, v, width, height. Only works for {@link pc.ELEMENTTYPE_IMAGE} types.
     * @property {boolean} rtlReorder Reorder the text for RTL languages using a function registered by `app.systems.element.registerUnicodeConverter`.
     * @property {boolean} unicodeConverter Convert unicode characters using a function registered by `app.systems.element.registerUnicodeConverter`.
     * @property {number} batchGroupId Assign element to a specific batch group (see {@link pc.BatchGroup}). Default value is -1 (no group).
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this element should belong.
     * Don't push/pop/splice or modify this array, if you want to change it - set a new one instead.
     * @property {boolean} enableMarkup Flag for enabling markup processing. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} rangeStart Index of the first character to render. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     * @property {number} rangeEnd Index of the last character to render. Only works for {@link pc.ELEMENTTYPE_TEXT} types.
     */
    function ElementComponent(system, entity) {
        Component.call(this, system, entity);

        // set to true by the ElementComponentSystem while
        // the component is being initialized
        this._beingInitialized = false;

        this._anchor = new Vec4();
        this._localAnchor = new Vec4();

        this._pivot = new Vec2();

        this._width = this._calculatedWidth = 32;
        this._height = this._calculatedHeight = 32;

        this._margin = new Vec4(0, 0, -32, -32);

        // the model transform used to render
        this._modelTransform = new Mat4();

        this._screenToWorld = new Mat4();

        // transform that updates local position according to anchor values
        this._anchorTransform = new Mat4();

        this._anchorDirty = true;

        // transforms to calculate screen coordinates
        this._parentWorldTransform = new Mat4();
        this._screenTransform = new Mat4();

        // the corners of the element relative to its screen component.
        // Order is bottom left, bottom right, top right, top left
        this._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];

        // canvas-space corners of the element.
        // Order is bottom left, bottom right, top right, top left
        this._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

        // the world-space corners of the element
        // Order is bottom left, bottom right, top right, top left
        this._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];

        this._cornersDirty = true;
        this._canvasCornersDirty = true;
        this._worldCornersDirty = true;

        this.entity.on('insert', this._onInsert, this);

        this._patch();

        this.screen = null;

        this._type = ELEMENTTYPE_GROUP;

        // element types
        this._image = null;
        this._text = null;
        this._group = null;

        this._drawOrder = 0;

        // input related
        this._useInput = false;

        this._layers = [LAYERID_UI]; // assign to the default UI layer
        this._addedModels = []; // store models that have been added to layer so we can re-add when layer is changed

        this._batchGroupId = -1;
        //

        this._offsetReadAt = 0;
        this._maskOffset = 0.5;
        this._maskedBy = null; // the entity that is masking this element
    }
    ElementComponent.prototype = Object.create(Component.prototype);
    ElementComponent.prototype.constructor = ElementComponent;

    Object.assign(ElementComponent.prototype, {
        _patch: function () {
            this.entity._sync = this._sync;
            this.entity.setPosition = this._setPosition;
            this.entity.setLocalPosition = this._setLocalPosition;
        },

        _unpatch: function () {
            this.entity._sync = Entity.prototype._sync;
            this.entity.setPosition = Entity.prototype.setPosition;
            this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
        },

        _setPosition: function () {
            var position = new Vec3();
            var invParentWtm = new Mat4();

            return function (x, y, z) {
                if (!this.element.screen)
                    return Entity.prototype.setPosition.call(this, x, y, z);

                if (x instanceof Vec3) {
                    position.copy(x);
                } else {
                    position.set(x, y, z);
                }

                this.getWorldTransform(); // ensure hierarchy is up to date
                invParentWtm.copy(this.element._screenToWorld).invert();
                invParentWtm.transformPoint(position, this.localPosition);

                if (!this._dirtyLocal)
                    this._dirtifyLocal();
            };
        }(),

        _setLocalPosition: function (x, y, z) {
            if (x instanceof Vec3) {
                this.localPosition.copy(x);
            } else {
                this.localPosition.set(x, y, z);
            }

            // update margin
            var element = this.element;
            var p = this.localPosition;
            var pvt = element._pivot;
            element._margin.x = p.x - element._calculatedWidth * pvt.x;
            element._margin.z = (element._localAnchor.z - element._localAnchor.x) - element._calculatedWidth - element._margin.x;
            element._margin.y = p.y - element._calculatedHeight * pvt.y;
            element._margin.w = (element._localAnchor.w - element._localAnchor.y) - element._calculatedHeight - element._margin.y;

            if (!this._dirtyLocal)
                this._dirtifyLocal();
        },

        // this method overwrites GraphNode#sync and so operates in scope of the Entity.
        _sync: function () {
            var element = this.element;
            var screen = element.screen;

            if (screen) {

                if (element._anchorDirty) {
                    var resx = 0;
                    var resy = 0;
                    var px = 0;
                    var py = 1;

                    if (this._parent && this._parent.element) {
                        // use parent rect
                        resx = this._parent.element.calculatedWidth;
                        resy = this._parent.element.calculatedHeight;
                        px = this._parent.element.pivot.x;
                        py = this._parent.element.pivot.y;
                    } else {
                        // use screen rect
                        var resolution = screen.screen.resolution;
                        resx = resolution.x / screen.screen.scale;
                        resy = resolution.y / screen.screen.scale;
                    }

                    element._anchorTransform.setTranslate((resx * (element.anchor.x - px)), -(resy * (py - element.anchor.y)), 0);
                    element._anchorDirty = false;
                    element._calculateLocalAnchors();
                }

                // if element size is dirty
                // recalculate its size
                // WARNING: Order is important as calculateSize resets dirtyLocal
                // so this needs to run before resetting dirtyLocal to false below
                if (element._sizeDirty) {
                    element._calculateSize(false, false);
                }
            }

            if (this._dirtyLocal) {
                this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);

                // update margin
                var p = this.localPosition;
                var pvt = element._pivot;
                element._margin.x = p.x - element._calculatedWidth * pvt.x;
                element._margin.z = (element._localAnchor.z - element._localAnchor.x) - element._calculatedWidth - element._margin.x;
                element._margin.y = p.y - element._calculatedHeight * pvt.y;
                element._margin.w = (element._localAnchor.w - element._localAnchor.y) - element._calculatedHeight - element._margin.y;

                this._dirtyLocal = false;
            }

            if (!screen) {
                if (this._dirtyWorld) {
                    element._cornersDirty = true;
                    element._canvasCornersDirty = true;
                    element._worldCornersDirty = true;
                }

                return Entity.prototype._sync.call(this);
            }


            if (this._dirtyWorld) {
                if (this._parent === null) {
                    this.worldTransform.copy(this.localTransform);
                } else {
                    // transform element hierarchy
                    if (this._parent.element) {
                        element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
                    } else {
                        element._screenToWorld.copy(element._anchorTransform);
                    }

                    element._modelTransform.mul2(element._screenToWorld, this.localTransform);

                    if (screen) {
                        element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);

                        if (!screen.screen.screenSpace) {
                            element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
                        }

                        this.worldTransform.mul2(element._screenToWorld, this.localTransform);

                        // update parent world transform
                        var parentWorldTransform = element._parentWorldTransform;
                        parentWorldTransform.setIdentity();
                        var parent = this._parent;
                        if (parent && parent.element && parent !== screen) {
                            matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
                            parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
                        }

                        // update element transform
                        // rotate and scale around pivot
                        var depthOffset = vecA;
                        depthOffset.set(0, 0, this.localPosition.z);

                        var pivotOffset = vecB;
                        pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);

                        matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
                        matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
                        matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);

                        element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);

                        element._cornersDirty = true;
                        element._canvasCornersDirty = true;
                        element._worldCornersDirty = true;
                    } else {
                        this.worldTransform.copy(element._modelTransform);
                    }
                }

                this._dirtyWorld = false;
            }
        },

        _onInsert: function (parent) {
            // when the entity is reparented find a possible new screen and mask

            var result = this._parseUpToScreen();

            this.entity._dirtifyWorld();

            this._updateScreen(result.screen);

            this._dirtifyMask();
        },

        _dirtifyMask: function () {
            var current = this.entity;
            while (current) {
                // search up the hierarchy until we find an entity which has:
                // - no parent
                // - screen component on parent
                var next = current.parent;
                if ((next === null || next.screen) && current.element) {
                    if (!this.system._prerender || !this.system._prerender.length) {
                        this.system._prerender = [];
                        this.system.app.once('prerender', this._onPrerender, this);

                    }
                    var i = this.system._prerender.indexOf(this.entity);
                    if (i >= 0) {
                        this.system._prerender.splice(i, 1);
                    }
                    var j = this.system._prerender.indexOf(current);
                    if (j < 0) {
                        this.system._prerender.push(current);
                    }
                }

                current = next;
            }
        },

        _onPrerender: function () {
            for (var i = 0; i < this.system._prerender.length; i++) {
                var mask = this.system._prerender[i];

                // prevent call if element has been removed since being added
                if (mask.element) {
                    var depth = 1;
                    mask.element.syncMask(depth);
                }
            }

            this.system._prerender.length = 0;
        },

        _bindScreen: function (screen) {
            screen.on('set:resolution', this._onScreenResize, this);
            screen.on('set:referenceresolution', this._onScreenResize, this);
            screen.on('set:scaleblend', this._onScreenResize, this);
            screen.on('set:screenspace', this._onScreenSpaceChange, this);
            screen.on('remove', this._onScreenRemove, this);
        },

        _unbindScreen: function (screen) {
            screen.off('set:resolution', this._onScreenResize, this);
            screen.off('set:referenceresolution', this._onScreenResize, this);
            screen.off('set:scaleblend', this._onScreenResize, this);
            screen.off('set:screenspace', this._onScreenSpaceChange, this);
            screen.off('remove', this._onScreenRemove, this);
        },

        _updateScreen: function (screen) {
            if (this.screen && this.screen !== screen) {
                this._unbindScreen(this.screen.screen);
            }

            var previousScreen = this.screen;
            this.screen = screen;
            if (this.screen) {
                this._bindScreen(this.screen.screen);
            }

            this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

            this.fire('set:screen', this.screen, previousScreen);

            this._anchorDirty = true;

            // update all child screens
            var children = this.entity.children;
            for (var i = 0, l = children.length; i < l; i++) {
                if (children[i].element) children[i].element._updateScreen(screen);
            }

            // calculate draw order
            if (this.screen) this.screen.screen.syncDrawOrder();
        },

        syncMask: function (depth) {
            var result = this._parseUpToScreen();
            this._updateMask(result.mask, depth);
        },

        // set the maskedby property to the entity that is masking this element
        // - set the stencil buffer to check the mask value
        //   so as to only render inside the mask
        //   Note: if this entity is itself a mask the stencil params
        //   will be updated in updateMask to include masking
        _setMaskedBy: function (mask) {
            var renderableElement = this._image || this._text;

            if (mask) {
                var ref = mask.element._image._maskRef;

                var sp = new StencilParameters({
                    ref: ref,
                    func: FUNC_EQUAL
                });

                // if this is image or text, set the stencil parameters
                if (renderableElement && renderableElement._setStencil) {
                    renderableElement._setStencil(sp);
                }

                this._maskedBy = mask;
            } else {

                // remove stencil params if this is image or text
                if (renderableElement && renderableElement._setStencil) {
                    renderableElement._setStencil(null);
                }
                this._maskedBy = null;
            }
        },

        // recursively update entity's stencil params
        // to render the correct value into the stencil buffer
        _updateMask: function (currentMask, depth) {
            var i, l, sp, children;

            if (currentMask) {
                this._setMaskedBy(currentMask);

                // this element is also masking others
                if (this.mask) {
                    var ref = currentMask.element._image._maskRef;
                    sp = new StencilParameters({
                        ref: ref,
                        func: FUNC_EQUAL,
                        zpass: STENCILOP_INCREMENT
                    });
                    this._image._setStencil(sp);
                    this._image._maskRef = depth;

                    // increment counter to count mask depth
                    depth++;


                    currentMask = this.entity;
                }

                // recurse through all children
                children = this.entity.children;
                for (i = 0, l = children.length; i < l; i++) {
                    if (children[i].element) {
                        children[i].element._updateMask(currentMask, depth);
                    }
                }

                // if mask counter was increased, decrement it as we come back up the hierarchy
                if (this.mask) depth--;

            } else {
                // clearing mask
                this._setMaskedBy(null);

                if (this.mask) {
                    sp = new StencilParameters({
                        ref: depth,
                        func: FUNC_ALWAYS,
                        zpass: STENCILOP_REPLACE
                    });
                    this._image._setStencil(sp);
                    this._image._maskRef = depth;

                    // increment mask counter to count depth of masks
                    depth++;


                    currentMask = this.entity;
                }

                // recurse through all children
                children = this.entity.children;
                for (i = 0, l = children.length; i < l; i++) {
                    if (children[i].element) {
                        children[i].element._updateMask(currentMask, depth);
                    }
                }

                // decrement mask counter as we come back up the hierarchy
                if (this.mask) depth--;
            }
        },

        // search up the parent hierarchy until we reach a screen
        // this screen is the parent screen
        // also searches for masked elements to get the relevant mask
        _parseUpToScreen: function () {
            var result = {
                screen: null,
                mask: null
            };

            var parent = this.entity._parent;

            while (parent && !parent.screen) {
                if (parent.element && parent.element.mask) {
                    // mask entity
                    if (!result.mask) result.mask = parent;
                }

                parent = parent.parent;
            }
            if (parent && parent.screen) result.screen = parent;

            return result;
        },

        _onScreenResize: function (res) {
            this._anchorDirty = true;
            this._cornersDirty = true;
            this._worldCornersDirty = true;

            this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);

            this.fire('screen:set:resolution', res);
        },

        _onScreenSpaceChange: function () {
            this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
        },

        _onScreenRemove: function () {
            // if there is a screen and it is not being destroyed
            if (this.screen && !this.screen._destroying) {
                this._updateScreen(null);
            }
        },

        // store pixel positions of anchor relative to current parent resolution
        _calculateLocalAnchors: function () {
            var resx = 1000;
            var resy = 1000;
            var parent = this.entity._parent;
            if (parent && parent.element) {
                resx = parent.element.calculatedWidth;
                resy = parent.element.calculatedHeight;
            } else if (this.screen) {
                var res = this.screen.screen.resolution;
                var scale = this.screen.screen.scale;
                resx = res.x / scale;
                resy = res.y / scale;
            }

            this._localAnchor.set(
                this._anchor.x * resx,
                this._anchor.y * resy,
                this._anchor.z * resx,
                this._anchor.w * resy
            );
        },

        // internal - apply offset x,y to local position and find point in world space
        getOffsetPosition: function (x, y) {
            var p = this.entity.getLocalPosition().clone();

            p.x += x;
            p.y += y;

            this._screenToWorld.transformPoint(p, p);

            return p;
        },

        onLayersChanged: function (oldComp, newComp) {
            this.addModelToLayers(this._image ? this._image._model : this._text._model);
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);
        },

        onLayerAdded: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            if (this._image) {
                layer.addMeshInstances(this._image._model.meshInstances);
            } else if (this._text) {
                layer.addMeshInstances(this._text._model.meshInstances);
            }
        },

        onLayerRemoved: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            if (this._image) {
                layer.removeMeshInstances(this._image._model.meshInstances);
            } else if (this._text) {
                layer.removeMeshInstances(this._text._model.meshInstances);
            }
        },

        onEnable: function () {
            if (this._image) this._image.onEnable();
            if (this._text) this._text.onEnable();
            if (this._group) this._group.onEnable();

            if (this.useInput && this.system.app.elementInput) {
                this.system.app.elementInput.addElement(this);
            }

            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.on("add", this.onLayerAdded, this);
                this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
            }

            if (this._batchGroupId >= 0) {
                this.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            }

            this.fire("enableelement");
        },

        onDisable: function () {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.off("add", this.onLayerAdded, this);
                this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
            }

            if (this._image) this._image.onDisable();
            if (this._text) this._text.onDisable();
            if (this._group) this._group.onDisable();

            if (this.system.app.elementInput && this.useInput) {
                this.system.app.elementInput.removeElement(this);
            }

            if (this._batchGroupId >= 0) {
                this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            }

            this.fire("disableelement");
        },

        onRemove: function () {
            this.entity.off('insert', this._onInsert, this);
            this._unpatch();
            if (this._image) this._image.destroy();
            if (this._text) this._text.destroy();

            if (this.system.app.elementInput && this.useInput) {
                this.system.app.elementInput.removeElement(this);
            }

            // if there is a screen, update draw-order
            if (this.screen && this.screen.screen) {
                this._unbindScreen(this.screen.screen);
                this.screen.screen.syncDrawOrder();
            }

            this.off();
        },

        // recalculates
        // localAnchor, width, height, (local position is updated if anchors are split)
        // assumes these properties are up to date
        // _margin
        _calculateSize: function (propagateCalculatedWidth, propagateCalculatedHeight) {
            // can't calculate if local anchors are wrong
            if (!this.entity._parent && !this.screen) return;

            this._calculateLocalAnchors();

            var newWidth = this._absRight - this._absLeft;
            var newHeight = this._absTop - this._absBottom;

            if (propagateCalculatedWidth) {
                this._setWidth(newWidth);
            } else {
                this._setCalculatedWidth(newWidth, false);
            }

            if (propagateCalculatedHeight) {
                this._setHeight(newHeight);
            } else {
                this._setCalculatedHeight(newHeight, false);
            }

            var p = this.entity.getLocalPosition();
            p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
            p.y = this._margin.y + this._calculatedHeight * this._pivot.y;

            this.entity.setLocalPosition(p);

            this._sizeDirty = false;
        },

        // internal set width without updating margin
        _setWidth: function (w) {
            this._width = w;
            this._setCalculatedWidth(w, false);

            this.fire('set:width', this._width);
        },

        // internal set height without updating margin
        _setHeight: function (h) {
            this._height = h;
            this._setCalculatedHeight(h, false);

            this.fire('set:height', this._height);
        },

        _setCalculatedWidth: function (value, updateMargins) {
            if (Math.abs(value - this._calculatedWidth) <= 1e-4)
                return;

            this._calculatedWidth = value;
            this.entity._dirtifyLocal();

            if (updateMargins) {
                var p = this.entity.getLocalPosition();
                var pvt = this._pivot;
                this._margin.x = p.x - this._calculatedWidth * pvt.x;
                this._margin.z = (this._localAnchor.z - this._localAnchor.x) - this._calculatedWidth - this._margin.x;
            }

            this._flagChildrenAsDirty();
            this.fire('set:calculatedWidth', this._calculatedWidth);
            this.fire('resize', this._calculatedWidth, this._calculatedHeight);
        },

        _setCalculatedHeight: function (value, updateMargins) {
            if (Math.abs(value - this._calculatedHeight) <= 1e-4)
                return;

            this._calculatedHeight = value;
            this.entity._dirtifyLocal();

            if (updateMargins) {
                var p = this.entity.getLocalPosition();
                var pvt = this._pivot;
                this._margin.y = p.y - this._calculatedHeight * pvt.y;
                this._margin.w = (this._localAnchor.w - this._localAnchor.y) - this._calculatedHeight - this._margin.y;
            }

            this._flagChildrenAsDirty();
            this.fire('set:calculatedHeight', this._calculatedHeight);
            this.fire('resize', this._calculatedWidth, this._calculatedHeight);
        },

        _flagChildrenAsDirty: function () {
            var i, l;
            var c = this.entity._children;
            for (i = 0, l = c.length; i < l; i++) {
                if (c[i].element) {
                    c[i].element._anchorDirty = true;
                    c[i].element._sizeDirty = true;
                }
            }
        },

        addModelToLayers: function (model) {
            var layer;
            this._addedModels.push(model);
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.addMeshInstances(model.meshInstances);
            }
        },

        removeModelFromLayers: function (model) {
            var layer;
            var idx = this._addedModels.indexOf(model);
            if (idx >= 0) {
                this._addedModels.splice(idx, 1);
            }
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.removeMeshInstances(model.meshInstances);
            }
        },

        getMaskOffset: function () {
            // reset offset on new frame
            // we always count offset down from 0.5
            var frame = this.system.app.frame;
            if (this._offsetReadAt !== frame) {
                this._maskOffset = 0.5;
                this._offsetReadAt = frame;
            }
            var mo = this._maskOffset;
            this._maskOffset -= 0.001;
            return mo;
        },

        isVisibleForCamera: function (camera) {
            var clipL, clipR, clipT, clipB;

            if (this.maskedBy) {
                var corners = this.maskedBy.element.screenCorners;

                clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
                clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
                clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
                clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
            } else {
                var sw = this.system.app.graphicsDevice.width;
                var sh = this.system.app.graphicsDevice.height;

                var cameraWidth = camera._rect.width * sw;
                var cameraHeight = camera._rect.height * sh;
                clipL = camera._rect.x * sw;
                clipR = clipL + cameraWidth;
                clipT = (1 - camera._rect.y) * sh;
                clipB = clipT - cameraHeight;
            }

            var hitCorners = this.screenCorners;

            var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
            var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
            var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
            var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));

            if (right < clipL ||
                left > clipR ||
                bottom > clipT ||
                top < clipB) {
                return false;
            }

            return true;
        },

        _isScreenSpace: function () {
            if (this.screen && this.screen.screen) {
                return this.screen.screen.screenSpace;
            }

            return false;
        },

        _isScreenCulled: function () {
            if (this.screen && this.screen.screen) {
                return this.screen.screen.cull;
            }

            return false;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "type", {
        get: function () {
            return this._type;
        },

        set: function (value) {
            if (value !== this._type) {
                this._type = value;

                if (this._image) {
                    this._image.destroy();
                    this._image = null;
                }
                if (this._text) {
                    this._text.destroy();
                    this._text = null;
                }

                if (value === ELEMENTTYPE_IMAGE) {
                    this._image = new ImageElement(this);
                } else if (value === ELEMENTTYPE_TEXT) {
                    this._text = new TextElement(this);
                }
            }
        }
    });

    Object.defineProperty(ElementComponent.prototype, "layers", {
        get: function () {
            return this._layers;
        },

        set: function (value) {
            var i, j, layer;

            if (this._addedModels.length) {
                for (i = 0; i < this._layers.length; i++) {
                    layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
                    if (layer) {
                        for (j = 0; j < this._addedModels.length; j++) {
                            layer.removeMeshInstances(this._addedModels[j].meshInstances);
                        }
                    }
                }
            }

            this._layers = value;

            if (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;

            for (i = 0; i < this._layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
                if (layer) {
                    for (j = 0; j < this._addedModels.length; j++) {
                        layer.addMeshInstances(this._addedModels[j].meshInstances);
                    }
                }
            }
        }
    });

    Object.defineProperty(ElementComponent.prototype, "drawOrder", {
        get: function () {
            return this._drawOrder;
        },

        set: function (value) {
            var priority = 0;
            if (this.screen) {
                priority = this.screen.screen.priority;
            }

            if (value > 0xFFFFFF) {
                value = 0xFFFFFF;
            }

            // screen priority is stored in the top 8 bits
            this._drawOrder = (priority << 24) + value;
            this.fire('set:draworder', this._drawOrder);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_absLeft", {
        get: function () {
            return this._localAnchor.x + this._margin.x;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_absRight", {
        get: function () {
            return this._localAnchor.z - this._margin.z;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_absTop", {
        get: function () {
            return this._localAnchor.w - this._margin.w;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_absBottom", {
        get: function () {
            return this._localAnchor.y + this._margin.y;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "margin", {
        get: function () {
            return this._margin;
        },

        set: function (value) {
            this._margin.copy(value);
            this._calculateSize(true, true);
            this.fire('set:margin', this._margin);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "left", {
        get: function () {
            return this._margin.x;
        },

        set: function (value) {
            this._margin.x = value;
            var p = this.entity.getLocalPosition();
            var wr = this._absRight;
            var wl = this._localAnchor.x + value;
            this._setWidth(wr - wl);

            p.x = value + this._calculatedWidth * this._pivot.x;
            this.entity.setLocalPosition(p);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "right", {
        get: function () {
            return this._margin.z;
        },

        set: function (value) {
            this._margin.z = value;

            // update width
            var p = this.entity.getLocalPosition();
            var wl = this._absLeft;
            var wr = this._localAnchor.z - value;
            this._setWidth(wr - wl);

            // update position
            p.x = (this._localAnchor.z - this._localAnchor.x) - value - (this._calculatedWidth * (1 - this._pivot.x));
            this.entity.setLocalPosition(p);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "top", {
        get: function () {
            return this._margin.w;
        },

        set: function (value) {
            this._margin.w = value;
            var p = this.entity.getLocalPosition();
            var wb = this._absBottom;
            var wt = this._localAnchor.w - value;
            this._setHeight(wt - wb);

            p.y = (this._localAnchor.w - this._localAnchor.y) - value - this._calculatedHeight * (1 - this._pivot.y);
            this.entity.setLocalPosition(p);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "bottom", {
        get: function () {
            return this._margin.y;
        },

        set: function (value) {
            this._margin.y = value;
            var p = this.entity.getLocalPosition();
            var wt = this._absTop;
            var wb = this._localAnchor.y + value;
            this._setHeight(wt - wb);

            p.y = value + this._calculatedHeight * this._pivot.y;
            this.entity.setLocalPosition(p);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "width", {
        get: function () {
            return this._width;
        },

        set: function (value) {
            this._width = value;

            if (!this._hasSplitAnchorsX) {
                this._setCalculatedWidth(value, true);
            }

            this.fire('set:width', this._width);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "height", {
        get: function () {
            return this._height;
        },

        set: function (value) {
            this._height = value;

            if (!this._hasSplitAnchorsY) {
                this._setCalculatedHeight(value, true);
            }

            this.fire('set:height', this._height);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "calculatedWidth", {
        get: function () {
            return this._calculatedWidth;
        },

        set: function (value) {
            this._setCalculatedWidth(value, true);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "calculatedHeight", {
        get: function () {
            return this._calculatedHeight;
        },

        set: function (value) {
            this._setCalculatedHeight(value, true);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "pivot", {
        get: function () {
            return this._pivot;
        },

        set: function (value) {
            var prevX = this._pivot.x;
            var prevY = this._pivot.y;

            if (value instanceof Vec2) {
                this._pivot.set(value.x, value.y);
            } else {
                this._pivot.set(value[0], value[1]);
            }

            var mx = this._margin.x + this._margin.z;
            var dx = this._pivot.x - prevX;
            this._margin.x += mx * dx;
            this._margin.z -= mx * dx;

            var my = this._margin.y + this._margin.w;
            var dy = this._pivot.y - prevY;
            this._margin.y += my * dy;
            this._margin.w -= my * dy;

            this._anchorDirty = true;
            this._cornersDirty = true;
            this._worldCornersDirty = true;

            this._calculateSize(false, false);

            // we need to flag children as dirty too
            // in order for them to update their position
            this._flagChildrenAsDirty();

            this.fire('set:pivot', this._pivot);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "anchor", {
        get: function () {
            return this._anchor;
        },

        set: function (value) {

            if (value instanceof Vec4) {
                this._anchor.set(value.x, value.y, value.z, value.w);
            } else {
                this._anchor.set(value[0], value[1], value[2], value[3]);
            }

            if (!this.entity._parent && !this.screen) {
                this._calculateLocalAnchors();
            } else {
                this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            }

            this._anchorDirty = true;

            if (!this.entity._dirtyLocal)
                this.entity._dirtifyLocal();

            this.fire('set:anchor', this._anchor);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsX", {
        get: function () {
            return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "_hasSplitAnchorsY", {
        get: function () {
            return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "aabb", {
        get: function () {
            if (this._image) return this._image.aabb;
            if (this._text) return this._text.aabb;

            return null;
        }
    });

    // Returns the 4 corners of the element relative to its screen component.
    // Only works for elements that have a screen.
    // Order is bottom left, bottom right, top right, top left.
    Object.defineProperty(ElementComponent.prototype, 'screenCorners', {
        get: function () {
            if (!this._cornersDirty || !this.screen)
                return this._screenCorners;

            var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];

            // init corners
            this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
            this._screenCorners[1].set(this._absRight, this._absBottom, 0);
            this._screenCorners[2].set(this._absRight, this._absTop, 0);
            this._screenCorners[3].set(this._absLeft, this._absTop, 0);

            // transform corners to screen space
            var screenSpace = this.screen.screen.screenSpace;
            for (var i = 0; i < 4; i++) {
                this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
                if (screenSpace)
                    this._screenCorners[i].scale(this.screen.screen.scale);

                if (parentBottomLeft) {
                    this._screenCorners[i].add(parentBottomLeft);
                }
            }

            this._cornersDirty = false;
            this._canvasCornersDirty = true;
            this._worldCornersDirty = true;

            return this._screenCorners;

        }
    });

    // Returns the 4 corners of the element in canvas pixel space.
    // Only works for 2D elements.
    // Order of the corners is bottom left, bottom right, top right, top left.
    Object.defineProperty(ElementComponent.prototype, 'canvasCorners', {
        get: function () {
            if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace)
                return this._canvasCorners;

            var device = this.system.app.graphicsDevice;
            var screenCorners = this.screenCorners;
            var sx = device.canvas.clientWidth / device.width;
            var sy = device.canvas.clientHeight / device.height;

            // scale screen corners to canvas size and reverse y
            for (var i = 0; i < 4; i++) {
                this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
            }

            this._canvasCornersDirty = false;

            return this._canvasCorners;
        }
    });

    // Returns the 4 corners of the element in world space. Only works
    // for 3D elements as the corners of 2D elements in world space will
    // always depend on the camera that is rendering them. Order of the corners is
    // bottom left, bottom right, top right, top left
    Object.defineProperty(ElementComponent.prototype, 'worldCorners', {
        get: function () {
            if (!this._worldCornersDirty) {
                return this._worldCorners;
            }

            if (this.screen) {
                var screenCorners = this.screenCorners;

                if (!this.screen.screen.screenSpace) {
                    matA.copy(this.screen.screen._screenMatrix);

                    // flip screen matrix along the horizontal axis
                    matA.data[13] = -matA.data[13];

                    // create transform that brings screen corners to world space
                    matA.mul2(this.screen.getWorldTransform(), matA);

                    // transform screen corners to world space
                    for (var i = 0; i < 4; i++) {
                        matA.transformPoint(screenCorners[i], this._worldCorners[i]);
                    }
                }
            } else {
                var localPos = this.entity.getLocalPosition();

                // rotate and scale around pivot
                matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
                matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
                matC.setTranslate(localPos.x, localPos.y, localPos.z);

                matD.copy(this.entity.parent.getWorldTransform());
                matD.mul(matC).mul(matB).mul(matA);

                // bottom left
                vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
                matD.transformPoint(vecA, this._worldCorners[0]);

                // bottom right
                vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
                matD.transformPoint(vecA, this._worldCorners[1]);

                // top right
                vecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
                matD.transformPoint(vecA, this._worldCorners[2]);

                // top left
                vecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
                matD.transformPoint(vecA, this._worldCorners[3]);
            }


            this._worldCornersDirty = false;

            return this._worldCorners;

        }
    });

    Object.defineProperty(ElementComponent.prototype, "textWidth", {
        get: function () {
            return this._text ? this._text.width : 0;
        }
    });

    Object.defineProperty(ElementComponent.prototype, "textHeight", {
        get: function () {
            return this._text ? this._text.height : 0;
        }
    });


    Object.defineProperty(ElementComponent.prototype, "useInput", {
        get: function () {
            return this._useInput;
        },
        set: function (value) {
            if (this._useInput === value)
                return;

            this._useInput = value;

            if (this.system.app.elementInput) {
                if (value) {
                    if (this.enabled && this.entity.enabled) {
                        this.system.app.elementInput.addElement(this);
                    }
                } else {
                    this.system.app.elementInput.removeElement(this);
                }
            }

            this.fire('set:useInput', value);
        }
    });

    Object.defineProperty(ElementComponent.prototype, "batchGroupId", {
        get: function () {
            return this._batchGroupId;
        },
        set: function (value) {
            if (this._batchGroupId === value)
                return;

            if (this.entity.enabled && this._batchGroupId >= 0) {
                this.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            }

            if (this.entity.enabled && value >= 0) {
                this.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);
            }

            if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
                // re-add model to scene, in case it was removed by batching
                if (this._image && this._image._renderable.model) {
                    this.addModelToLayers(this._image._renderable.model);
                } else if (this._text && this._text._model) {
                    this.addModelToLayers(this._text._model);
                }
            }

            this._batchGroupId = value;
        }
    });

    // read-only, get the entity that is currently masking this element
    Object.defineProperty(ElementComponent.prototype, "maskedBy", {
        get: function () {
            return this._maskedBy;
        }
    });

    var _define = function (name) {
        Object.defineProperty(ElementComponent.prototype, name, {
            get: function () {
                if (this._text) {
                    return this._text[name];
                } else if (this._image) {
                    return this._image[name];
                }
                return null;
            },
            set: function (value) {
                if (this._text) {
                    this._text[name] = value;
                } else if (this._image) {
                    this._image[name] = value;
                }
            }
        });
    };

    _define("fontSize");
    _define("minFontSize");
    _define("maxFontSize");
    _define("maxLines");
    _define("autoFitWidth");
    _define("autoFitHeight");
    _define("color");
    _define("font");
    _define("fontAsset");
    _define("spacing");
    _define("lineHeight");
    _define("wrapLines");
    _define("lines");
    _define("alignment");
    _define("autoWidth");
    _define("autoHeight");
    _define("rtlReorder");
    _define("unicodeConverter");
    _define("text");
    _define("key");
    _define("texture");
    _define("textureAsset");
    _define("material");
    _define("materialAsset");
    _define("sprite");
    _define("spriteAsset");
    _define("spriteFrame");
    _define("pixelsPerUnit");
    _define("opacity");
    _define("rect");
    _define("mask");
    _define("outlineColor");
    _define("outlineThickness");
    _define("shadowColor");
    _define("shadowOffset");
    _define("enableMarkup");
    _define("rangeStart");
    _define("rangeEnd");

    function ElementComponentData() {
        this.enabled = true;
    }

    var _schema$7 = ['enabled'];

    /**
     * @class
     * @name pc.ElementComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.ElementComponent}s.
     * @param {pc.Application} app - The application.
     */
    function ElementComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'element';

        this.ComponentType = ElementComponent;
        this.DataType = ElementComponentData;

        this.schema = _schema$7;
        this._unicodeConverter = null;
        this._rtlReorder = null;

        // default texture - make white so we can tint it with emissive color
        this._defaultTexture = new Texture(app.graphicsDevice, { width: 1, height: 1, format: PIXELFORMAT_R8_G8_B8_A8 });
        this._defaultTexture.name = 'element-system';
        var pixels = this._defaultTexture.lock();
        var pixelData = new Uint8Array(4);
        pixelData[0] = 255.0;
        pixelData[1] = 255.0;
        pixelData[2] = 255.0;
        pixelData[3] = 255.0;
        pixels.set(pixelData);
        this._defaultTexture.unlock();

        // image element materials created on demand by getImageElementMaterial()
        this.defaultImageMaterial = null;
        this.defaultImage9SlicedMaterial = null;
        this.defaultImage9TiledMaterial = null;
        this.defaultImageMaskMaterial = null;
        this.defaultImage9SlicedMaskMaterial = null;
        this.defaultImage9TiledMaskMaterial = null;
        this.defaultScreenSpaceImageMaterial = null;
        this.defaultScreenSpaceImage9SlicedMaterial = null;
        this.defaultScreenSpaceImage9TiledMaterial = null;
        this.defaultScreenSpaceImageMask9SlicedMaterial = null;
        this.defaultScreenSpaceImageMask9TiledMaterial = null;
        this.defaultScreenSpaceImageMaskMaterial = null;

        // text element materials created on demand by getTextElementMaterial()
        this.defaultTextMaterial = null;
        this.defaultBitmapTextMaterial = null;
        this.defaultScreenSpaceTextMaterial = null;
        this.defaultScreenSpaceBitmapTextMaterial = null;

        this.defaultImageMaterials = [];

        this.on('beforeremove', this.onRemoveComponent, this);
    }
    ElementComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ElementComponentSystem.prototype.constructor = ElementComponentSystem;

    Component._buildAccessors(ElementComponent.prototype, _schema$7);

    Object.assign(ElementComponentSystem.prototype, {
        destroy: function () {
            this._defaultTexture.destroy();
        },

        initializeComponentData: function (component, data, properties) {
            component._beingInitialized = true;

            if (data.anchor !== undefined) {
                if (data.anchor instanceof Vec4) {
                    component.anchor.copy(data.anchor);
                } else {
                    component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
                }
            }

            if (data.pivot !== undefined) {
                if (data.pivot instanceof Vec2) {
                    component.pivot.copy(data.pivot);
                } else {
                    component.pivot.set(data.pivot[0], data.pivot[1]);
                }
            }

            var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
            var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
            var _marginChange = false;
            var color;

            if (data.margin !== undefined) {
                if (data.margin instanceof Vec4) {
                    component.margin.copy(data.margin);
                } else {
                    component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
                }

                _marginChange = true;
            }

            if (data.left !== undefined) {
                component._margin.x = data.left;
                _marginChange = true;
            }
            if (data.bottom !== undefined) {
                component._margin.y = data.bottom;
                _marginChange = true;
            }
            if (data.right !== undefined) {
                component._margin.z = data.right;
                _marginChange = true;
            }
            if (data.top !== undefined) {
                component._margin.w = data.top;
                _marginChange = true;
            }
            if (_marginChange) {
                // force update
                component.margin = component._margin;
            }

            var shouldForceSetAnchor = false;

            if (data.width !== undefined && !splitHorAnchors) {
                // force update
                component.width = data.width;
            } else if (splitHorAnchors) {
                shouldForceSetAnchor = true;
            }
            if (data.height !== undefined && !splitVerAnchors) {
                // force update
                component.height = data.height;
            } else if (splitVerAnchors) {
                shouldForceSetAnchor = true;
            }

            if (shouldForceSetAnchor) {
                /* eslint-disable no-self-assign */
                // force update
                component.anchor = component.anchor;
                /* eslint-enable no-self-assign */
            }

            if (data.enabled !== undefined) {
                component.enabled = data.enabled;
            }

            if (data.useInput !== undefined) {
                component.useInput = data.useInput;
            }

            component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

            if (data.layers && type(data.layers) === 'array') {
                component.layers = data.layers.slice(0);
            }

            component.type = data.type;
            if (component.type === ELEMENTTYPE_IMAGE) {
                if (data.rect !== undefined) {
                    component.rect = data.rect;
                }
                if (data.color !== undefined) {
                    color = data.color;
                    if (! (color instanceof Color)) {
                        color = new Color(data.color[0], data.color[1], data.color[2]);
                    }
                    component.color = color;
                }

                if (data.opacity !== undefined) component.opacity = data.opacity;
                if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
                if (data.texture) component.texture = data.texture;
                if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
                if (data.sprite) component.sprite = data.sprite;
                if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
                if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
                if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
                if (data.material) component.material = data.material;

                if (data.mask !== undefined) {
                    component.mask = data.mask;
                }
            } else if (component.type === ELEMENTTYPE_TEXT) {
                if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
                if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
                if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
                if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
                if (data.text !== null && data.text !== undefined) {
                    component.text = data.text;
                } else if (data.key !== null && data.key !== undefined) {
                    component.key = data.key;
                }
                if (data.color !== undefined) {
                    color = data.color;
                    if (! (color instanceof Color)) {
                        color = new Color(color[0], color[1], color[2]);
                    }
                    component.color = color;
                }
                if (data.opacity !== undefined) {
                    component.opacity = data.opacity;
                }
                if (data.spacing !== undefined) component.spacing = data.spacing;
                if (data.fontSize !== undefined) {
                    component.fontSize = data.fontSize;
                    if (!data.lineHeight) component.lineHeight = data.fontSize;
                }
                if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
                if (data.maxLines !== undefined) component.maxLines = data.maxLines;
                if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
                if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
                if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
                if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
                if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
                if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
                if (data.font !== undefined) component.font = data.font;
                if (data.alignment !== undefined) component.alignment = data.alignment;
                if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
                if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
                if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
                if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
                if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
            }


            // find screen
            // do this here not in constructor so that component is added to the entity
            var result = component._parseUpToScreen();
            if (result.screen) {
                component._updateScreen(result.screen);
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);

            component._beingInitialized = false;

            if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
                component._image._updateMesh(component._image.mesh);
            }
        },

        onRemoveComponent: function (entity, component) {
            component.onRemove();
        },

        cloneComponent: function (entity, clone) {
            var source = entity.element;

            var data = {
                enabled: source.enabled,
                width: source.width,
                height: source.height,
                anchor: source.anchor.clone(),
                pivot: source.pivot.clone(),
                margin: source.margin.clone(),
                alignment: source.alignment && source.alignment.clone() || source.alignment,
                autoWidth: source.autoWidth,
                autoHeight: source.autoHeight,
                type: source.type,
                rect: source.rect && source.rect.clone() || source.rect,
                rtlReorder: source.rtlReorder,
                unicodeConverter: source.unicodeConverter,
                materialAsset: source.materialAsset,
                material: source.material,
                color: source.color && source.color.clone() || source.color,
                opacity: source.opacity,
                textureAsset: source.textureAsset,
                texture: source.texture,
                spriteAsset: source.spriteAsset,
                sprite: source.sprite,
                spriteFrame: source.spriteFrame,
                pixelsPerUnit: source.pixelsPerUnit,
                spacing: source.spacing,
                lineHeight: source.lineHeight,
                wrapLines: source.wrapLines,
                layers: source.layers,
                fontSize: source.fontSize,
                minFontSize: source.minFontSize,
                maxFontSize: source.maxFontSize,
                autoFitWidth: source.autoFitWidth,
                autoFitHeight: source.autoFitHeight,
                maxLines: source.maxLines,
                fontAsset: source.fontAsset,
                font: source.font,
                useInput: source.useInput,
                batchGroupId: source.batchGroupId,
                mask: source.mask,
                outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
                outlineThickness: source.outlineThickness,
                shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
                shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
                enableMarkup: source.enableMarkup
            };

            if (source.key !== undefined && source.key !== null) {
                data.key = source.key;
            } else {
                data.text = source.text;
            }

            return this.addComponent(clone, data);
        },

        getTextElementMaterial: function (screenSpace, msdf) {
            if (screenSpace) {
                if (msdf) {
                    if (!this.defaultScreenSpaceTextMaterial) {
                        this.defaultScreenSpaceTextMaterial = new StandardMaterial();
                        this.defaultScreenSpaceTextMaterial.name = "defaultScreenSpaceTextMaterial";
                        this.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;
                        this.defaultScreenSpaceTextMaterial.useLighting = false;
                        this.defaultScreenSpaceTextMaterial.useGammaTonemap = false;
                        this.defaultScreenSpaceTextMaterial.useFog = false;
                        this.defaultScreenSpaceTextMaterial.useSkybox = false;
                        this.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
                        this.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);
                        this.defaultScreenSpaceTextMaterial.opacity = 0.5;
                        this.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;
                        this.defaultScreenSpaceTextMaterial.depthWrite = false;
                        this.defaultScreenSpaceTextMaterial.depthTest = false;
                        this.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;
                        this.defaultScreenSpaceTextMaterial.update();
                    }
                    return this.defaultScreenSpaceTextMaterial;
                }
                if (!this.defaultScreenSpaceBitmapTextMaterial) {
                    this.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();
                    this.defaultScreenSpaceBitmapTextMaterial.name = "defaultScreenSpaceBitmapTextMaterial";
                    this.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5); // set to non-(1,1,1) so that tint is actually applied
                    this.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;
                    this.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;
                    this.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;
                    this.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;
                    this.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';
                    this.defaultScreenSpaceBitmapTextMaterial.useLighting = false;
                    this.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;
                    this.defaultScreenSpaceBitmapTextMaterial.useFog = false;
                    this.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;
                    this.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
                    this.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
                    this.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;
                    this.defaultScreenSpaceBitmapTextMaterial.depthTest = false;
                    this.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;
                    this.defaultScreenSpaceBitmapTextMaterial.update();
                }
                return this.defaultScreenSpaceBitmapTextMaterial;

            }
            if (msdf) {
                if (!this.defaultTextMaterial) {
                    this.defaultTextMaterial = new StandardMaterial();
                    this.defaultTextMaterial.name = "defaultTextMaterial";
                    this.defaultTextMaterial.msdfMap = this._defaultTexture;
                    this.defaultTextMaterial.useLighting = false;
                    this.defaultTextMaterial.useGammaTonemap = false;
                    this.defaultTextMaterial.useFog = false;
                    this.defaultTextMaterial.useSkybox = false;
                    this.defaultTextMaterial.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
                    this.defaultTextMaterial.emissive.set(1, 1, 1);
                    this.defaultTextMaterial.opacity = 0.5;
                    this.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;
                    this.defaultTextMaterial.depthWrite = false;
                    this.defaultTextMaterial.emissiveVertexColor = true;
                    this.defaultTextMaterial.update();
                }
                return this.defaultTextMaterial;
            }
            if (!this.defaultBitmapTextMaterial) {
                this.defaultBitmapTextMaterial = new StandardMaterial();
                this.defaultBitmapTextMaterial.name = "defaultBitmapTextMaterial";
                this.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);  // set to non-(1,1,1) so that tint is actually applied
                this.defaultBitmapTextMaterial.emissiveTint = true;
                this.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;
                this.defaultBitmapTextMaterial.opacity = 0.5;
                this.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;
                this.defaultBitmapTextMaterial.opacityMapChannel = 'a';
                this.defaultBitmapTextMaterial.useLighting = false;
                this.defaultBitmapTextMaterial.useGammaTonemap = false;
                this.defaultBitmapTextMaterial.useFog = false;
                this.defaultBitmapTextMaterial.useSkybox = false;
                this.defaultBitmapTextMaterial.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
                this.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;
                this.defaultBitmapTextMaterial.depthWrite = false;
                this.defaultBitmapTextMaterial.emissiveVertexColor = true;
                this.defaultBitmapTextMaterial.update();
            }
            return this.defaultBitmapTextMaterial;


        },

        _createBaseImageMaterial: function () {
            var material = new StandardMaterial();

            material.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
            material.emissive.set(0.5, 0.5, 0.5); // use non-white to compile shader correctly
            material.emissiveMap = this._defaultTexture;
            material.emissiveTint = true;
            material.opacityMap = this._defaultTexture;
            material.opacityMapChannel = "a";
            material.opacityTint = true;
            material.opacity = 0; // use non-1 opacity to compile shader correctly
            material.useLighting = false;
            material.useGammaTonemap = false;
            material.useFog = false;
            material.useSkybox = false;
            material.blendType = BLEND_PREMULTIPLIED;
            material.depthWrite = false;

            return material;
        },

        getImageElementMaterial: function (screenSpace, mask, nineSliced, nineSliceTiled) {
            /* eslint-disable no-else-return */
            if (screenSpace) {
                if (mask) {
                    if (nineSliced) {
                        if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
                            this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
                            this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial";
                            this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
                            this.defaultScreenSpaceImageMask9SlicedMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
                        }
                        return this.defaultScreenSpaceImageMask9SlicedMaterial;
                    } else if (nineSliceTiled) {
                        if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
                            this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
                            this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial";
                            this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
                            this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
                            this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
                            this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
                            this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
                            this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
                            this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
                            this.defaultScreenSpaceImageMask9TiledMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
                        }
                        return this.defaultScreenSpaceImageMask9TiledMaterial;
                    } else {
                        if (!this.defaultScreenSpaceImageMaskMaterial) {
                            this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
                            this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial";
                            this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
                            this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
                            this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
                            this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
                            this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
                            this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
                            this.defaultScreenSpaceImageMaskMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
                        }
                        return this.defaultScreenSpaceImageMaskMaterial;
                    }
                } else {
                    if (nineSliced) {
                        if (!this.defaultScreenSpaceImage9SlicedMaterial) {
                            this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
                            this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial";
                            this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
                            this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
                            this.defaultScreenSpaceImage9SlicedMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
                        }
                        return this.defaultScreenSpaceImage9SlicedMaterial;
                    } else if (nineSliceTiled) {
                        if (!this.defaultScreenSpaceImage9TiledMaterial) {
                            this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
                            this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial";
                            this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
                            this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
                            this.defaultScreenSpaceImage9TiledMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
                        }

                        return this.defaultScreenSpaceImage9TiledMaterial;
                    } else {
                        if (!this.defaultScreenSpaceImageMaterial) {
                            this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
                            this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial";
                            this.defaultScreenSpaceImageMaterial.depthTest = false;
                            this.defaultScreenSpaceImageMaterial.update();

                            this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
                        }
                        return this.defaultScreenSpaceImageMaterial;
                    }
                }
            } else {
                if (mask) {
                    if (nineSliced) {
                        if (!this.defaultImage9SlicedMaskMaterial) {
                            this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
                            this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial";
                            this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
                            this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
                            this.defaultImage9SlicedMaskMaterial.redWrite = false;
                            this.defaultImage9SlicedMaskMaterial.greenWrite = false;
                            this.defaultImage9SlicedMaskMaterial.blueWrite = false;
                            this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
                            this.defaultImage9SlicedMaskMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
                        }
                        return this.defaultImage9SlicedMaskMaterial;
                    } else if (nineSliceTiled) {
                        if (!this.defaultImage9TiledMaskMaterial) {
                            this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
                            this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial";
                            this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
                            this.defaultImage9TiledMaskMaterial.alphaTest = 1;
                            this.defaultImage9TiledMaskMaterial.redWrite = false;
                            this.defaultImage9TiledMaskMaterial.greenWrite = false;
                            this.defaultImage9TiledMaskMaterial.blueWrite = false;
                            this.defaultImage9TiledMaskMaterial.alphaWrite = false;
                            this.defaultImage9TiledMaskMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
                        }
                        return this.defaultImage9TiledMaskMaterial;
                    } else {
                        if (!this.defaultImageMaskMaterial) {
                            this.defaultImageMaskMaterial = this._createBaseImageMaterial();
                            this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial";
                            this.defaultImageMaskMaterial.alphaTest = 1;
                            this.defaultImageMaskMaterial.redWrite = false;
                            this.defaultImageMaskMaterial.greenWrite = false;
                            this.defaultImageMaskMaterial.blueWrite = false;
                            this.defaultImageMaskMaterial.alphaWrite = false;
                            this.defaultImageMaskMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
                        }
                        return this.defaultImageMaskMaterial;
                    }
                } else {
                    if (nineSliced) {
                        if (!this.defaultImage9SlicedMaterial) {
                            this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
                            this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial";
                            this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
                            this.defaultImage9SlicedMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
                        }
                        return this.defaultImage9SlicedMaterial;
                    } else if (nineSliceTiled) {
                        if (!this.defaultImage9TiledMaterial) {
                            this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
                            this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial";
                            this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
                            this.defaultImage9TiledMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
                        }
                        return this.defaultImage9TiledMaterial;
                    } else {
                        if (!this.defaultImageMaterial) {
                            this.defaultImageMaterial = this._createBaseImageMaterial();
                            this.defaultImageMaterial.name = "defaultImageMaterial";
                            this.defaultImageMaterial.update();

                            this.defaultImageMaterials.push(this.defaultImageMaterial);
                        }
                        return this.defaultImageMaterial;
                    }
                }
            }
            /* eslint-enable no-else-return */
        },

        registerUnicodeConverter: function (func) {
            this._unicodeConverter = func;
        },

        registerRtlReorder: function (func) {
            this._rtlReorder = func;
        },

        getUnicodeConverter: function () {
            return this._unicodeConverter;
        },

        getRtlReorder: function () {
            return this._rtlReorder;
        }
    });

    /**
     * @component
     * @class
     * @name pc.LayoutChildComponent
     * @augments pc.Component
     * @description Create a new LayoutChildComponent.
     * @classdesc A LayoutChildComponent enables the Entity to control the sizing applied to it by its parent {@link pc.LayoutGroupComponent}.
     * @param {pc.LayoutChildComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {number} minWidth The minimum width the element should be rendered at.
     * @property {number} minHeight The minimum height the element should be rendered at.
     * @property {number} maxWidth The maximum width the element should be rendered at.
     * @property {number} maxHeight The maximum height the element should be rendered at.
     * @property {number} fitWidthProportion The amount of additional horizontal space that the element should take up, if necessary to satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into account the proportion values of other siblings.
     * @property {number} fitHeightProportion The amount of additional vertical space that the element should take up, if necessary to satisfy a Stretch/Shrink fitting calculation. This is specified as a proportion, taking into account the proportion values of other siblings.
     * @property {number} excludeFromLayout If set to true, the child will be excluded from all layout calculations.
     */
    function LayoutChildComponent(system, entity) {
        Component.call(this, system, entity);

        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = null;
        this._maxHeight = null;
        this._fitWidthProportion = 0;
        this._fitHeightProportion = 0;
        this._excludeFromLayout = false;
    }
    LayoutChildComponent.prototype = Object.create(Component.prototype);
    LayoutChildComponent.prototype.constructor = LayoutChildComponent;

    function defineResizeProperty(name) {
        var _name = '_' + name;

        Object.defineProperty(LayoutChildComponent.prototype, name, {
            get: function () {
                return this[_name];
            },

            set: function (value) {
                if (this[_name] !== value) {
                    this[_name] = value;
                    this.fire('resize');
                }
            }
        });
    }

    defineResizeProperty('minWidth');
    defineResizeProperty('minHeight');
    defineResizeProperty('maxWidth');
    defineResizeProperty('maxHeight');
    defineResizeProperty('fitWidthProportion');
    defineResizeProperty('fitHeightProportion');
    defineResizeProperty('excludeFromLayout');

    function LayoutChildComponentData() {
        this.enabled = true;
    }

    var _schema$8 = ['enabled'];

    /**
     * @class
     * @name pc.LayoutChildComponentSystem
     * @augments pc.ComponentSystem
     * @description Create a new LayoutChildComponentSystem.
     * @classdesc Manages creation of {@link pc.LayoutChildComponent}s.
     * @param {pc.Application} app - The application.
     */
    var LayoutChildComponentSystem = function LayoutChildComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'layoutchild';

        this.ComponentType = LayoutChildComponent;
        this.DataType = LayoutChildComponentData;

        this.schema = _schema$8;
    };
    LayoutChildComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    LayoutChildComponentSystem.prototype.constructor = LayoutChildComponentSystem;

    Component._buildAccessors(LayoutChildComponent.prototype, _schema$8);

    Object.assign(LayoutChildComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            if (data.enabled !== undefined) component.enabled = data.enabled;
            if (data.minWidth !== undefined) component.minWidth = data.minWidth;
            if (data.minHeight !== undefined) component.minHeight = data.minHeight;
            if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
            if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
            if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
            if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
            if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var layoutChild = entity.layoutchild;

            return this.addComponent(clone, {
                enabled: layoutChild.enabled,
                minWidth: layoutChild.minWidth,
                minHeight: layoutChild.minHeight,
                maxWidth: layoutChild.maxWidth,
                maxHeight: layoutChild.maxHeight,
                fitWidthProportion: layoutChild.fitWidthProportion,
                fitHeightProportion: layoutChild.fitHeightProportion,
                excludeFromLayout: layoutChild.excludeFromLayout
            });
        }
    });

    /**
     * @constant
     * @type {number}
     * @name pc.FITTING_NONE
     * @description Disable all fitting logic.
     */
    var FITTING_NONE = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.FITTING_STRETCH
     * @description Stretch child elements to fit the parent container.
     */
    var FITTING_STRETCH = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.FITTING_SHRINK
     * @description Shrink child elements to fit the parent container.
     */
    var FITTING_SHRINK = 2;
    /**
     * @constant
     * @type {number}
     * @name pc.FITTING_BOTH
     * @description Apply both STRETCH and SHRINK fitting logic where applicable.
     */
    var FITTING_BOTH = 3;

    /**
     * @private
     * @class
     * @name pc.LayoutCalculator
     * @classdesc Used to manage layout calculations for {@link pc.LayoutGroupComponent}s.
     */
    function LayoutCalculator() {}

    var AXIS_MAPPINGS = {};

    AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
        axis: 'x',
        size: 'width',
        calculatedSize: 'calculatedWidth',
        minSize: 'minWidth',
        maxSize: 'maxWidth',
        fitting: 'widthFitting',
        fittingProportion: 'fitWidthProportion'
    };

    AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
        axis: 'y',
        size: 'height',
        calculatedSize: 'calculatedHeight',
        minSize: 'minHeight',
        maxSize: 'maxHeight',
        fitting: 'heightFitting',
        fittingProportion: 'fitHeightProportion'
    };

    var OPPOSITE_ORIENTATION = {};
    OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
    OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;

    var PROPERTY_DEFAULTS = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Number.POSITIVE_INFINITY,
        maxHeight: Number.POSITIVE_INFINITY,
        width: null,
        height: null,
        fitWidthProportion: 0,
        fitHeightProportion: 0
    };

    var FITTING_ACTION = {
        NONE: 'NONE',
        APPLY_STRETCHING: 'APPLY_STRETCHING',
        APPLY_SHRINKING: 'APPLY_SHRINKING'
    };

    var availableSpace = new Vec2();

    // The layout logic is largely identical for the horizontal and vertical orientations,
    // with the exception of a few bits of swizzling re the primary and secondary axes to
    // use etc. This function generates a calculator for a given orientation, with each of
    // the swizzled properties conveniently placed in closure scope.
    function createCalculator(orientation) {
        var options;

        // Choose which axes to operate on based on the orientation that we're using. For
        // brevity as they are used a lot, these are shortened to just 'a' and 'b', which
        // represent the primary and secondary axes.
        var a = AXIS_MAPPINGS[orientation];
        var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];

        // Calculates the left/top extent of an element based on its position and pivot value
        function minExtentA(element, size) {return -size[a.size] * element.pivot[a.axis]; }  // eslint-disable-line
        function minExtentB(element, size) { return -size[b.size] * element.pivot[b.axis]; } // eslint-disable-line

        // Calculates the right/bottom extent of an element based on its position and pivot value
        function maxExtentA(element, size) { return  size[a.size] * (1 - element.pivot[a.axis]); } // eslint-disable-line

        function calculateAll(allElements, layoutOptions) {
            allElements = allElements.filter(shouldIncludeInLayout);
            options = layoutOptions;

            availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
            availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;

            resetAnchors(allElements);

            var lines = reverseLinesIfRequired(splitLines(allElements));
            var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
            var positions = calculateBasePositions(lines, sizes);

            applyAlignmentAndPadding(lines, sizes, positions);
            applySizesAndPositions(lines, sizes, positions);

            return createLayoutInfo(lines);
        }

        function shouldIncludeInLayout(element) {
            var layoutChildComponent = element.entity.layoutchild;

            return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
        }

        // Setting the anchors of child elements to anything other than 0,0,0,0 results
        // in positioning that is hard to reason about for the user. Forcing the anchors
        // to 0,0,0,0 gives us more predictable positioning, and also has the benefit of
        // ensuring that the element is not in split anchors mode on either axis.
        function resetAnchors(allElements) {
            for (var i = 0; i < allElements.length; ++i) {
                var element = allElements[i];
                var anchor = element.anchor;

                if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
                    element.anchor = Vec4.ZERO;
                }
            }
        }

        // Returns a 2D array of elements broken down into lines, based on the size of
        // each element and whether the `wrap` property is set.
        function splitLines(allElements) {
            if (!options.wrap) {
                // If wrapping is disabled, we just put all elements into a single line.
                return [allElements];
            }

            var lines = [[]];
            var sizes = getElementSizeProperties(allElements);
            var runningSize = 0;
            var allowOverrun = (options[a.fitting] === FITTING_SHRINK);

            for (var i = 0; i < allElements.length; ++i) {
                if (lines[lines.length - 1].length > 0) {
                    runningSize += options.spacing[a.axis];
                }

                var idealElementSize = sizes[i][a.size];
                runningSize += idealElementSize;

                // For the None, Stretch and Both fitting modes, we should break to a new
                // line before we overrun the available space in the container.
                if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
                    runningSize = idealElementSize;
                    lines.push([]);
                }

                lines[lines.length - 1].push(allElements[i]);

                // For the Shrink fitting mode, we should break to a new line immediately
                // after we've overrun the available space in the container.
                if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
                    runningSize = 0;
                    lines.push([]);
                }
            }

            return lines;
        }

        function reverseLinesIfRequired(lines) {
            var reverseAxisA = (options.orientation === ORIENTATION_HORIZONTAL && options.reverseX) ||
                               (options.orientation === ORIENTATION_VERTICAL   && options.reverseY);

            var reverseAxisB = (options.orientation === ORIENTATION_HORIZONTAL && options.reverseY) ||
                               (options.orientation === ORIENTATION_VERTICAL   && options.reverseX);

            if (reverseAxisA) {
                for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                    if (reverseAxisA) {
                        lines[lineIndex].reverse();
                    }
                }
            }

            if (reverseAxisB) {
                lines.reverse();
            }

            return lines;
        }

        // Calculate the required size for each element along axis A, based on the requested
        // fitting mode.
        function calculateSizesOnAxisA(lines) {
            var sizesAllLines = [];

            for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                var line = lines[lineIndex];
                var sizesThisLine = getElementSizeProperties(line);
                var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
                var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);

                if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
                    stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
                } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
                    shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
                }

                sizesAllLines.push(sizesThisLine);
            }

            return sizesAllLines;
        }

        // Calculate the required size for each element on axis B, based on the requested
        // fitting mode.
        function calculateSizesOnAxisB(lines, sizesAllLines) {
            var largestElementsForEachLine = [];
            var largestSizesForEachLine = [];
            var elementIndex;
            var lineIndex;
            var line;

            // Find the largest element on each line.
            for (lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                line = lines[lineIndex];
                line.largestElement = null;
                line.largestSize = { width: Number.NEGATIVE_INFINITY, height: Number.NEGATIVE_INFINITY };

                // Find the largest element on this line.
                for (elementIndex = 0; elementIndex < line.length; ++elementIndex) {
                    var sizesThisElement = sizesAllLines[lineIndex][elementIndex];

                    if (sizesThisElement[b.size] > line.largestSize[b.size]) {
                        line.largestElement = line[elementIndex];
                        line.largestSize = sizesThisElement;
                    }
                }

                largestElementsForEachLine.push(line.largestElement);
                largestSizesForEachLine.push(line.largestSize);
            }

            // Calculate line heights using the largest element on each line.
            var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
            var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);

            if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
                stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
            } else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
                shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
            }

            // Calculate sizes for other elements based on the height of the line they're on.
            for (lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                line = lines[lineIndex];

                for (elementIndex = 0; elementIndex < line.length; ++elementIndex) {
                    var sizesForThisElement = sizesAllLines[lineIndex][elementIndex];
                    var currentSize = sizesForThisElement[b.size];
                    var availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];
                    var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);

                    if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
                        sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
                    } else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
                        sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
                    }
                }
            }

            return sizesAllLines;
        }

        function determineFittingAction(fittingMode, currentSize, availableSize) {
            switch (fittingMode) {
                case FITTING_NONE:
                    return FITTING_ACTION.NONE;

                case FITTING_STRETCH:
                    if (currentSize < availableSize) {
                        return FITTING_ACTION.APPLY_STRETCHING;
                    }

                    return FITTING_ACTION.NONE;

                case FITTING_SHRINK:
                    if (currentSize >= availableSize) {
                        return FITTING_ACTION.APPLY_SHRINKING;
                    }

                    return FITTING_ACTION.NONE;

                case FITTING_BOTH:
                    if (currentSize < availableSize) {
                        return FITTING_ACTION.APPLY_STRETCHING;
                    } else if (currentSize >= availableSize) {
                        return FITTING_ACTION.APPLY_SHRINKING;
                    }

                    return FITTING_ACTION.NONE;

                default:
                    throw new Error('Unrecognized fitting mode: ' + fittingMode);
            }
        }

        function calculateTotalSpace(sizes, axis) {
            var totalSizes = sumValues(sizes, axis.size);
            var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];

            return totalSizes + totalSpacing;
        }

        function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
            var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
            var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
            var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);

            // Start by working out how much we have to stretch the child elements by
            // in total in order to fill the available space in the container
            var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;

            for (var i = 0; i < sizesThisLine.length; ++i) {
                // As some elements may have a maximum size defined, we might not be
                // able to scale all elements by the ideal amount necessary in order
                // to fill the available space. To account for this, we run through
                // the elements in ascending order of their maximum size, redistributing
                // any remaining space to the other elements that are more able to
                // make use of it.
                var index = ascendingMaxSizeOrder[i];

                // Work out how much we ideally want to stretch this element by, based
                // on the amount of space remaining and the fitting proportion value that
                // was specified.
                var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
                var targetSize = sizesThisLine[index][axis.size] + targetIncrease;

                // Work out how much we're actually able to stretch this element by,
                // based on its maximum size, and apply the result.
                var maxSize = sizesThisLine[index][axis.maxSize];
                var actualSize = Math.min(targetSize, maxSize);

                sizesThisLine[index][axis.size] = actualSize;

                // Work out how much of the total undershoot value we've just used,
                // and decrement the remaining value by this much.
                var actualIncrease = Math.max(targetSize - actualSize, 0);
                var appliedIncrease = targetIncrease - actualIncrease;

                remainingUndershoot -= appliedIncrease;
            }
        }

        // This loop is very similar to the one in stretchSizesToFitContainer() above,
        // but with some awkward inversions and use of min as opposed to max etc that
        // mean a more generalized version would probably be harder to read/debug than
        // just having a small amount of duplication.
        function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
            var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
            var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
            var inverseFittingProportions = invertNormalizedValues(fittingProportions);
            var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);

            var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];

            for (var i = 0; i < sizesThisLine.length; ++i) {
                var index = descendingMinSizeOrder[i];

                // Similar to the stretch calculation above, we calculate the ideal
                // size reduction value for this element based on its fitting proportion.
                // However, note that we're using the inverse of the fitting value, as
                // using the regular value would mean that an element with a fitting
                // value of, say, 0.4, ends up rendering very small when shrinking is
                // being applied. Using the inverse means that the balance of sizes
                // between elements is similar for both the Stretch and Shrink modes.
                var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
                var targetSize = sizesThisLine[index][axis.size] - targetReduction;

                var minSize = sizesThisLine[index][axis.minSize];
                var actualSize = Math.max(targetSize, minSize);

                sizesThisLine[index][axis.size] = actualSize;

                var actualReduction = Math.max(actualSize - targetSize, 0);
                var appliedReduction = targetReduction - actualReduction;

                remainingOvershoot -= appliedReduction;
            }
        }

        function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
            var proportion = fittingProportions[index];
            var sumOfRemainingProportions = fittingProportionSums[index];

            if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
                return remainingAdjustment;
            }

            return remainingAdjustment * proportion / sumOfRemainingProportions;
        }

        // Calculate base positions based on the element sizes and spacing.
        function calculateBasePositions(lines, sizes) {
            var cursor = {};
            cursor[a.axis] = 0;
            cursor[b.axis] = 0;

            lines[a.size] = Number.NEGATIVE_INFINITY;

            var positionsAllLines = [];

            for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                var line = lines[lineIndex];

                if (line.length === 0) {
                    return;
                }

                var positionsThisLine = [];
                var sizesThisLine = sizes[lineIndex];

                // Distribute elements along the line
                for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
                    var element = line[elementIndex];
                    var sizesThisElement = sizesThisLine[elementIndex];

                    cursor[b.axis] -= minExtentB(element, sizesThisElement);
                    cursor[a.axis] -= minExtentA(element, sizesThisElement);

                    positionsThisLine[elementIndex] = {};
                    positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
                    positionsThisLine[elementIndex][b.axis] = cursor[b.axis];

                    cursor[b.axis] += minExtentB(element, sizesThisElement);
                    cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
                }

                // Record the size of the overall line
                line[a.size] = cursor[a.axis] - options.spacing[a.axis];
                line[b.size] = line.largestSize[b.size];

                // Keep track of the longest line
                lines[a.size] = Math.max(lines[a.size], line[a.size]);

                // Move the cursor to the next line
                cursor[a.axis] = 0;
                cursor[b.axis] += line[b.size] + options.spacing[b.axis];

                positionsAllLines.push(positionsThisLine);
            }

            // Record the size of the full set of lines
            lines[b.size] = cursor[b.axis] - options.spacing[b.axis];

            return positionsAllLines;
        }

        // Adjust base positions to account for the requested alignment and padding.
        function applyAlignmentAndPadding(lines, sizes, positions) {
            var alignmentA = options.alignment[a.axis];
            var alignmentB = options.alignment[b.axis];

            var paddingA = options.padding[a.axis];
            var paddingB = options.padding[b.axis];

            for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                var line = lines[lineIndex];
                var sizesThisLine = sizes[lineIndex];
                var positionsThisLine = positions[lineIndex];

                var axisAOffset = (availableSpace[a.axis] - line[a.size])  * alignmentA + paddingA;
                var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;

                for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
                    var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];

                    positionsThisLine[elementIndex][a.axis] += axisAOffset;
                    positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
                }
            }
        }

        // Applies the final calculated sizes and positions back to elements themselves.
        function applySizesAndPositions(lines, sizes, positions) {
            for (var lineIndex = 0; lineIndex < lines.length; ++lineIndex) {
                var line = lines[lineIndex];
                var sizesThisLine = sizes[lineIndex];
                var positionsThisLine = positions[lineIndex];

                for (var elementIndex = 0; elementIndex < line.length; ++elementIndex) {
                    var element = line[elementIndex];

                    element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
                    element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];

                    if (options.orientation === ORIENTATION_HORIZONTAL) {
                        element.entity.setLocalPosition(
                            positionsThisLine[elementIndex][a.axis],
                            positionsThisLine[elementIndex][b.axis],
                            element.entity.getLocalPosition().z
                        );
                    } else {
                        element.entity.setLocalPosition(
                            positionsThisLine[elementIndex][b.axis],
                            positionsThisLine[elementIndex][a.axis],
                            element.entity.getLocalPosition().z
                        );
                    }
                }
            }
        }

        function createLayoutInfo(lines) {
            var layoutWidth = lines.width;
            var layoutHeight = lines.height;

            var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
            var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;

            return {
                bounds: new Vec4(
                    xOffset,
                    yOffset,
                    layoutWidth,
                    layoutHeight
                )
            };
        }

        // Reads all size-related properties for each element and applies some basic
        // sanitization to ensure that minWidth is greater than 0, maxWidth is greater
        // than minWidth, etc.
        function getElementSizeProperties(elements) {
            var sizeProperties = [];

            for (var i = 0; i < elements.length; ++i) {
                var element = elements[i];
                var minWidth  = Math.max(getProperty(element, 'minWidth'), 0);
                var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
                var maxWidth  = Math.max(getProperty(element, 'maxWidth'), minWidth);
                var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
                var width  = clamp(getProperty(element, 'width'), minWidth, maxWidth);
                var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
                var fitWidthProportion  = getProperty(element, 'fitWidthProportion');
                var fitHeightProportion = getProperty(element, 'fitHeightProportion');

                sizeProperties.push({
                    minWidth: minWidth,
                    minHeight: minHeight,
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    width: width,
                    height: height,
                    fitWidthProportion: fitWidthProportion,
                    fitHeightProportion: fitHeightProportion
                });
            }

            return sizeProperties;
        }

        // When reading an element's width/height, minWidth/minHeight etc, we have to look in
        // a few different places in order. This is because the presence of a LayoutChildComponent
        // on each element is optional, and each property value also has a set of fallback defaults
        // to be used in cases where no value is specified.
        function getProperty(element, propertyName) {
            var layoutChildComponent = element.entity.layoutchild;

            // First attempt to get the value from the element's LayoutChildComponent, if present.
            if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
                return layoutChildComponent[propertyName];
            } else if (element[propertyName] !== undefined) {
                return element[propertyName];
            }

            return PROPERTY_DEFAULTS[propertyName];
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function sumValues(items, propertyName) {
            return items.reduce(function (accumulator, current) {
                return accumulator + current[propertyName];
            }, 0);
        }

        function getNormalizedValues(items, propertyName) {
            var sum = sumValues(items, propertyName);
            var normalizedValues = [];
            var numItems = items.length;
            var i;

            if (sum === 0) {
                for (i = 0; i < numItems; ++i) {
                    normalizedValues.push(1 / numItems);
                }
            } else {
                for (i = 0; i < numItems; ++i) {
                    normalizedValues.push(items[i][propertyName] / sum);
                }
            }

            return normalizedValues;
        }

        function invertNormalizedValues(values) {
            // Guard against divide by zero error in the inversion calculation below
            if (values.length === 1) {
                return [1];
            }

            var invertedValues = [];
            var numValues = values.length;

            for (var i = 0; i < numValues; ++i) {
                invertedValues.push((1 - values[i]) / (numValues - 1));
            }

            return invertedValues;
        }

        function getTraversalOrder(items, orderBy, descending) {
            items.forEach(assignIndex);

            return items
                .slice()
                .sort(function (itemA, itemB) {
                    return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
                })
                .map(getIndex);
        }

        function assignIndex(item, index) {
            item.index = index;
        }

        function getIndex(item) {
            return item.index;
        }

        // Returns a new array containing the sums of the values in the original array,
        // running from right to left.
        // For example, given: [0.2, 0.2, 0.3, 0.1, 0.2]
        // Will return:        [1.0, 0.8, 0.6, 0.3, 0.2]
        function createSumArray(values, order) {
            var sumArray = [];
            sumArray[order[values.length - 1]] = values[order[values.length - 1]];

            for (var i = values.length - 2; i >= 0; --i) {
                sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
            }

            return sumArray;
        }

        return calculateAll;
    }

    var CALCULATE_FNS = {};
    CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
    CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);

    Object.assign(LayoutCalculator.prototype, {
        calculateLayout: function (elements, options) {
            var calculateFn = CALCULATE_FNS[options.orientation];

            if (!calculateFn) {
                throw new Error('Unrecognized orientation value: ' + options.orientation);
            } else {
                return calculateFn(elements, options);
            }
        }
    });

    /**
     * @component
     * @class
     * @name pc.LayoutGroupComponent
     * @augments pc.Component
     * @description Create a new LayoutGroupComponent.
     * @classdesc A LayoutGroupComponent enables the Entity to position and scale child
     * {@link pc.ElementComponent}s according to configurable layout rules.
     * @param {pc.LayoutGroupComponentSystem} system - The ComponentSystem that created
     * this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {number} orientation Whether the layout should run horizontally or
     * vertically. Can be:
     *
     * * {@link pc.ORIENTATION_HORIZONTAL}
     * * {@link pc.ORIENTATION_VERTICAL}
     *
     * Defaults to pc.ORIENTATION_HORIZONTAL.
     * @property {boolean} reverseX Reverses the order of children along the x axis.
     * Defaults to false.
     * @property {boolean} reverseY Reverses the order of children along the y axis.
     * Defaults to true.
     * @property {pc.Vec2} alignment Specifies the horizontal and vertical alignment of
     * child elements. Values range from 0 to 1 where [0, 0] is the bottom left and
     * [1, 1] is the top right. Defaults to [0, 1].
     * @property {pc.Vec4} padding Padding to be applied inside the container before
     * positioning any children. Specified as left, bottom, right and top values.
     * Defaults to [0, 0, 0, 0] (no padding).
     * @property {pc.Vec2} spacing Spacing to be applied between each child element.
     * Defaults to [0, 0] (no spacing).
     * @property {number} widthFitting Fitting logic to be applied when positioning and
     * scaling child elements. Can be:
     *
     * * {@link pc.FITTING_NONE}: Child elements will be rendered at their natural size.
     * * {@link pc.FITTING_STRETCH}: When the natural size of all child elements does not
     * fill the width of the container, children will be stretched to fit. The rules for how
     * each child will be stretched are outlined below:
     *   1. Sum the {@link pc.LayoutChildComponent#fitWidthProportion} values of each child
     * and normalize so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If there is space remaining in the container, distribute it to each child based
     * on the normalized {@link pc.LayoutChildComponent#fitWidthProportion} values, but do
     * not exceed the {@link pc.LayoutChildComponent#maxWidth} of each child.
     * * {@link pc.FITTING_SHRINK}: When the natural size of all child elements overflows the
     * width of the container, children will be shrunk to fit. The rules for how each child
     * will be stretched are outlined below:
     *   1. Sum the {@link pc.LayoutChildComponent#fitWidthProportion} values of each child
     * and normalize so that all values sum to 1.
     *   2. Apply the natural width of each child.
     *   3. If the new total width of all children exceeds the available space of the
     * container, reduce each child's width proportionally based on the normalized {@link
     * pc.LayoutChildComponent#fitWidthProportion} values, but do not exceed the {@link
     * pc.LayoutChildComponent#minWidth} of each child.
     * * {@link pc.FITTING_BOTH}: Applies both STRETCH and SHRINK logic as necessary.
     *
     * Defaults to pc.FITTING_NONE.
     * @property {number} heightFitting Identical to {@link pc.LayoutGroupComponent#widthFitting}
     * but for the Y axis. Defaults to pc.FITTING_NONE.
     * @property {boolean} wrap Whether or not to wrap children onto a new row/column when the
     * size of the container is exceeded. Defaults to false, which means that children will be
     * be rendered in a single row (horizontal orientation) or column (vertical orientation).
     * Note that setting wrap to true makes it impossible for the {@link pc.FITTING_BOTH}
     * fitting mode to operate in any logical manner. For this reason, when wrap is true, a
     * {@link pc.LayoutGroupComponent#widthFitting} or {@link pc.LayoutGroupComponent#heightFitting}
     * mode of {@link pc.FITTING_BOTH} will be coerced to {@link pc.FITTING_STRETCH}.
     */
    function LayoutGroupComponent(system, entity) {
        Component.call(this, system, entity);

        this._orientation = ORIENTATION_HORIZONTAL;
        this._reverseX = false;
        this._reverseY = true;
        this._alignment = new Vec2(0, 1);
        this._padding = new Vec4();
        this._spacing = new Vec2();
        this._widthFitting = FITTING_NONE;
        this._heightFitting = FITTING_NONE;
        this._wrap = false;
        this._layoutCalculator = new LayoutCalculator();

        // Listen for the group container being resized
        this._listenForReflowEvents(this.entity, 'on');

        // Listen to existing children being resized
        this.entity.children.forEach(function (child) {
            this._listenForReflowEvents(child, 'on');
        }.bind(this));

        // Listen to newly added children being resized
        this.entity.on('childinsert', this._onChildInsert, this);
        this.entity.on('childremove', this._onChildRemove, this);

        // Listen for ElementComponents and LayoutChildComponents being added
        // to self or to children - covers cases where they are not already
        // present at the point when this component is constructed.
        system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
        system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
        system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
        system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
    }
    LayoutGroupComponent.prototype = Object.create(Component.prototype);
    LayoutGroupComponent.prototype.constructor = LayoutGroupComponent;

    Object.assign(LayoutGroupComponent.prototype, {
        _isSelfOrChild: function (entity) {
            return (entity === this.entity) || (this.entity.children.indexOf(entity) !== -1);
        },

        _listenForReflowEvents: function (target, onOff) {
            if (target.element) {
                target.element[onOff]('enableelement', this._scheduleReflow, this);
                target.element[onOff]('disableelement', this._scheduleReflow, this);
                target.element[onOff]('resize', this._scheduleReflow, this);
                target.element[onOff]('set:pivot', this._scheduleReflow, this);
            }

            if (target.layoutchild) {
                target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
                target.layoutchild[onOff]('resize', this._scheduleReflow, this);
            }
        },

        _onElementOrLayoutComponentAdd: function (entity) {
            if (this._isSelfOrChild(entity)) {
                this._listenForReflowEvents(entity, 'on');
                this._scheduleReflow();
            }
        },

        _onElementOrLayoutComponentRemove: function (entity) {
            if (this._isSelfOrChild(entity)) {
                this._listenForReflowEvents(entity, 'off');
                this._scheduleReflow();
            }
        },

        _onChildInsert: function (child) {
            this._listenForReflowEvents(child, 'on');
            this._scheduleReflow();
        },

        _onChildRemove: function (child) {
            this._listenForReflowEvents(child, 'off');
            this._scheduleReflow();
        },

        _scheduleReflow: function () {
            if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
                this.system.scheduleReflow(this);
            }
        },

        reflow: function () {
            var container = getElement(this.entity);
            var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);

            if (!container || elements.length === 0) {
                return;
            }

            var containerWidth = Math.max(container.calculatedWidth, 0);
            var containerHeight = Math.max(container.calculatedHeight, 0);

            var options = {
                orientation: this._orientation,
                reverseX: this._reverseX,
                reverseY: this._reverseY,
                alignment: this._alignment,
                padding: this._padding,
                spacing: this._spacing,
                widthFitting: this._widthFitting,
                heightFitting: this._heightFitting,
                wrap: this._wrap,
                containerSize: new Vec2(containerWidth, containerHeight)
            };

            // In order to prevent recursive reflow (i.e. whereby setting the size of
            // a child element triggers another reflow on the next frame, and so on)
            // we flag that a reflow is currently in progress.
            this._isPerformingReflow = true;
            var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
            this._isPerformingReflow = false;

            this.fire('reflow', layoutInfo);
        },

        onEnable: function () {
            this._scheduleReflow();
        },

        onRemove: function () {
            this.entity.off('childinsert', this._onChildInsert, this);
            this.entity.off('childremove', this._onChildRemove, this);

            this._listenForReflowEvents(this.entity, 'off');

            this.entity.children.forEach(function (child) {
                this._listenForReflowEvents(child, 'off');
            }.bind(this));

            this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
            this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
            this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
        }
    });

    function getElement(entity) {
        return entity.element;
    }

    function isEnabledAndHasEnabledElement(entity) {
        return entity.enabled && entity.element && entity.element.enabled;
    }

    function defineReflowSchedulingProperty(name) {
        var _name = '_' + name;

        Object.defineProperty(LayoutGroupComponent.prototype, name, {
            get: function () {
                return this[_name];
            },

            set: function (value) {
                if (this[_name] !== value) {
                    this[_name] = value;
                    this._scheduleReflow();
                }
            }
        });
    }

    defineReflowSchedulingProperty('orientation');
    defineReflowSchedulingProperty('reverseX');
    defineReflowSchedulingProperty('reverseY');
    defineReflowSchedulingProperty('alignment');
    defineReflowSchedulingProperty('padding');
    defineReflowSchedulingProperty('spacing');
    defineReflowSchedulingProperty('widthFitting');
    defineReflowSchedulingProperty('heightFitting');
    defineReflowSchedulingProperty('wrap');

    function LayoutGroupComponentData() {
        this.enabled = true;
    }

    var _schema$9 = ['enabled'];

    var MAX_ITERATIONS = 100;

    /**
     * @class
     * @name pc.LayoutGroupComponentSystem
     * @augments pc.ComponentSystem
     * @description Create a new LayoutGroupComponentSystem.
     * @classdesc Manages creation of {@link pc.LayoutGroupComponent}s.
     * @param {pc.Application} app - The application.
     */
    function LayoutGroupComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'layoutgroup';

        this.ComponentType = LayoutGroupComponent;
        this.DataType = LayoutGroupComponentData;

        this.schema = _schema$9;

        this._reflowQueue = [];

        this.on('beforeremove', this._onRemoveComponent, this);

        // Perform reflow when running in the engine
        ComponentSystem.bind('postUpdate', this._onPostUpdate, this);
    }
    LayoutGroupComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    LayoutGroupComponentSystem.prototype.constructor = LayoutGroupComponentSystem;

    Component._buildAccessors(LayoutGroupComponent.prototype, _schema$9);

    Object.assign(LayoutGroupComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            if (data.enabled !== undefined) component.enabled = data.enabled;
            if (data.orientation !== undefined) component.orientation = data.orientation;
            if (data.reverseX !== undefined) component.reverseX = data.reverseX;
            if (data.reverseY !== undefined) component.reverseY = data.reverseY;
            if (data.alignment !== undefined) {
                if (data.alignment instanceof Vec2){
                    component.alignment.copy(data.alignment);
                } else {
                    component.alignment.set(data.alignment[0], data.alignment[1]);
                }

                /* eslint-disable no-self-assign */
                // force update
                component.alignment = component.alignment;
                /* eslint-enable no-self-assign */
            }
            if (data.padding !== undefined) {
                if (data.padding instanceof Vec4){
                    component.padding.copy(data.padding);
                } else {
                    component.padding.set(data.padding[0], data.padding[1], data.padding[2], data.padding[3]);
                }

                /* eslint-disable no-self-assign */
                // force update
                component.padding = component.padding;
                /* eslint-enable no-self-assign */
            }
            if (data.spacing !== undefined) {
                if (data.spacing instanceof Vec2){
                    component.spacing.copy(data.spacing);
                } else {
                    component.spacing.set(data.spacing[0], data.spacing[1]);
                }

                /* eslint-disable no-self-assign */
                // force update
                component.spacing = component.spacing;
                /* eslint-enable no-self-assign */
            }
            if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
            if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
            if (data.wrap !== undefined) component.wrap = data.wrap;

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var layoutGroup = entity.layoutgroup;

            return this.addComponent(clone, {
                enabled: layoutGroup.enabled,
                orientation: layoutGroup.orientation,
                reverseX: layoutGroup.reverseX,
                reverseY: layoutGroup.reverseY,
                alignment: layoutGroup.alignment,
                padding: layoutGroup.padding,
                spacing: layoutGroup.spacing,
                widthFitting: layoutGroup.widthFitting,
                heightFitting: layoutGroup.heightFitting,
                wrap: layoutGroup.wrap
            });
        },

        scheduleReflow: function (component) {
            if (this._reflowQueue.indexOf(component) === -1) {
                this._reflowQueue.push(component);
            }
        },

        _onPostUpdate: function () {
            this._processReflowQueue();
        },

        _processReflowQueue: function () {
            if (this._reflowQueue.length === 0) {
                return;
            }

            var iterationCount = 0;

            while (this._reflowQueue.length > 0) {
                // Create a copy of the queue to sort and process. If processing the reflow of any
                // layout groups results in additional groups being pushed to the queue, they will
                // be processed on the next iteration of the while loop.
                var queue = this._reflowQueue.slice();
                this._reflowQueue.length = 0;

                // Sort in ascending order of depth within the graph (i.e. outermost first), so that
                // any layout groups which are children of other layout groups will always have their
                // new size set before their own reflow is calculated.
                queue.sort(function (componentA, componentB) {
                    return (componentA.entity.graphDepth - componentB.entity.graphDepth);
                });

                for (var i = 0; i < queue.length; ++i) {
                    queue[i].reflow();
                }

                if (++iterationCount >= MAX_ITERATIONS) {
                    console.warn('Max reflow iterations limit reached, bailing.');
                    break;
                }
            }
        },

        _onRemoveComponent: function (entity, component) {
            component.onRemove();
        }
    });

    var spotCenter = new Vec3();
    var spotEndPoint = new Vec3();
    var tmpVec = new Vec3();

    var chanId = { r: 0, g: 1, b: 2, a: 3 };

    /**
     * @private
     * @class
     * @name pc.Light
     * @classdesc A light.
     */
    var Light = function Light() {
        // Light properties (defaults)
        this._type = LIGHTTYPE_DIRECTIONAL;
        this._color = new Color(0.8, 0.8, 0.8);
        this._intensity = 1;
        this._castShadows = false;
        this.enabled = false;
        this.mask = 1;
        this.isStatic = false;
        this.key = 0;
        this.bakeDir = true;

        // Point and spot properties
        this.attenuationStart = 10;
        this.attenuationEnd = 10;
        this._falloffMode = 0;
        this._shadowType = SHADOW_PCF3;
        this._vsmBlurSize = 11;
        this.vsmBlurMode = BLUR_GAUSSIAN;
        this.vsmBias = 0.01 * 0.25;
        this._cookie = null; // light cookie texture (2D for spot, cubemap for point)
        this.cookieIntensity = 1;
        this._cookieFalloff = true;
        this._cookieChannel = "rgb";
        this._cookieTransform = null; // 2d rotation/scale matrix (spot only)
        this._cookieTransformUniform = new Float32Array(4);
        this._cookieOffset = null; // 2d position offset (spot only)
        this._cookieOffsetUniform = new Float32Array(2);
        this._cookieTransformSet = false;
        this._cookieOffsetSet = false;

        // Spot properties
        this._innerConeAngle = 40;
        this._outerConeAngle = 45;

        // Cache of light property data in a format more friendly for shader uniforms
        this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
        var c = Math.pow(this._finalColor[0], 2.2);
        this._linearFinalColor = new Float32Array([c, c, c]);

        this._position = new Vec3(0, 0, 0);
        this._direction = new Vec3(0, 0, 0);
        this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
        this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);

        // Shadow mapping resources
        this._shadowCamera = null;
        this._shadowMatrix = new Mat4();
        this.shadowDistance = 40;
        this._shadowResolution = 1024;
        this.shadowBias = -0.0005;
        this._normalOffsetBias = 0.0;
        this.shadowUpdateMode = SHADOWUPDATE_REALTIME;

        this._scene = null;
        this._node = null;
        this._rendererParams = [];

        this._isVsm = false;
        this._isPcf = true;
        this._cacheShadowMap = false;
        this._isCachedShadowMap = false;

        this._visibleLength = [0]; // lengths of passes in culledList
        this._visibleList = [[]]; // culled mesh instances per pass (1 for spot, 6 for point, cameraCount for directional)
        this._visibleCameraSettings = []; // camera settings used in each directional light pass
    };

    Object.assign(Light.prototype, {
        destroy: function () {
            this._destroyShadowMap();
        },

        /**
         * @private
         * @function
         * @name pc.Light#clone
         * @description Duplicates a light node but does not 'deep copy' the hierarchy.
         * @returns {pc.Light} A cloned Light.
         */
        clone: function () {
            var clone = new Light();

            // Clone Light properties
            clone.type = this._type;
            clone.setColor(this._color);
            clone.intensity = this._intensity;
            clone.castShadows = this.castShadows;
            clone.enabled = this.enabled;

            // Point and spot properties
            clone.attenuationStart = this.attenuationStart;
            clone.attenuationEnd = this.attenuationEnd;
            clone.falloffMode = this._falloffMode;
            clone.shadowType = this._shadowType;
            clone.vsmBlurSize = this._vsmBlurSize;
            clone.vsmBlurMode = this.vsmBlurMode;
            clone.vsmBias = this.vsmBias;
            clone.shadowUpdateMode = this.shadowUpdateMode;
            clone.mask = this.mask;

            // Spot properties
            clone.innerConeAngle = this._innerConeAngle;
            clone.outerConeAngle = this._outerConeAngle;

            // Shadow properties
            clone.shadowBias = this.shadowBias;
            clone.normalOffsetBias = this._normalOffsetBias;
            clone.shadowResolution = this._shadowResolution;
            clone.shadowDistance = this.shadowDistance;

            // Cookies properties
            // clone.cookie = this._cookie;
            // clone.cookieIntensity = this.cookieIntensity;
            // clone.cookieFalloff = this._cookieFalloff;
            // clone.cookieChannel = this._cookieChannel;
            // clone.cookieTransform = this._cookieTransform;
            // clone.cookieOffset = this._cookieOffset;

            return clone;
        },

        getColor: function () {
            return this._color;
        },

        getBoundingSphere: function (sphere) {
            if (this._type === LIGHTTYPE_SPOT) {
                var range = this.attenuationEnd;
                var angle = this._outerConeAngle;
                var f = Math.cos(angle * math.DEG_TO_RAD);
                var node = this._node;

                spotCenter.copy(node.up);
                spotCenter.scale(-range * 0.5 * f);
                spotCenter.add(node.getPosition());
                sphere.center = spotCenter;

                spotEndPoint.copy(node.up);
                spotEndPoint.scale(-range);

                tmpVec.copy(node.right);
                tmpVec.scale(Math.sin(angle * math.DEG_TO_RAD) * range);
                spotEndPoint.add(tmpVec);

                sphere.radius = spotEndPoint.length() * 0.5;

            } else if (this._type === LIGHTTYPE_POINT) {
                sphere.center = this._node.getPosition();
                sphere.radius = this.attenuationEnd;
            }
        },

        getBoundingBox: function (box) {
            if (this._type === LIGHTTYPE_SPOT) {
                var range = this.attenuationEnd;
                var angle = this._outerConeAngle;
                var node = this._node;

                var scl = Math.abs( Math.sin(angle * math.DEG_TO_RAD) * range );

                box.center.set(0, -range * 0.5, 0);
                box.halfExtents.set(scl, range * 0.5, scl);

                box.setFromTransformedAabb(box, node.getWorldTransform());

            } else if (this._type === LIGHTTYPE_POINT) {
                box.center.copy(this._node.getPosition());
                box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
            }
        },

        _updateFinalColor: function () {
            var color = this._color;
            var r = color.r;
            var g = color.g;
            var b = color.b;

            var i = this._intensity;

            var finalColor = this._finalColor;
            var linearFinalColor = this._linearFinalColor;

            finalColor[0] = r * i;
            finalColor[1] = g * i;
            finalColor[2] = b * i;
            if (i >= 1) {
                linearFinalColor[0] = Math.pow(r, 2.2) * i;
                linearFinalColor[1] = Math.pow(g, 2.2) * i;
                linearFinalColor[2] = Math.pow(b, 2.2) * i;
            } else {
                linearFinalColor[0] = Math.pow(finalColor[0], 2.2);
                linearFinalColor[1] = Math.pow(finalColor[1], 2.2);
                linearFinalColor[2] = Math.pow(finalColor[2], 2.2);
            }
        },

        setColor: function () {
            var r, g, b;
            if (arguments.length === 1) {
                r = arguments[0].r;
                g = arguments[0].g;
                b = arguments[0].b;
            } else if (arguments.length === 3) {
                r = arguments[0];
                g = arguments[1];
                b = arguments[2];
            }

            this._color.set(r, g, b);

            this._updateFinalColor();
        },

        _destroyShadowMap: function () {
            if (this._shadowCamera) {
                if (!this._isCachedShadowMap) {
                    var rt = this._shadowCamera.renderTarget;
                    var i;
                    if (rt) {
                        if (rt.length) {
                            for (i = 0; i < rt.length; i++) {
                                if (rt[i].colorBuffer) rt[i].colorBuffer.destroy();
                                rt[i].destroy();
                            }
                        } else {
                            if (rt.colorBuffer) rt.colorBuffer.destroy();
                            if (rt.depthBuffer) rt.depthBuffer.destroy();
                            rt.destroy();
                        }
                    }
                }
                this._shadowCamera.renderTarget = null;
                this._shadowCamera = null;
                this._shadowCubeMap = null;
                if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
                    this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
                }
            }
        },

        updateShadow: function () {
            if (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {
                this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
            }
        },

        updateKey: function () {
            // Key definition:
            // Bit
            // 31      : sign bit (leave)
            // 29 - 30 : type
            // 28      : cast shadows
            // 25 - 27 : shadow type
            // 23 - 24 : falloff mode
            // 22      : normal offset bias
            // 21      : cookie
            // 20      : cookie falloff
            // 18 - 19 : cookie channel R
            // 16 - 17 : cookie channel G
            // 14 - 15 : cookie channel B
            // 12      : cookie transform
            var key =
                   (this._type                                << 29) |
                   ((this._castShadows ? 1 : 0)               << 28) |
                   (this._shadowType                          << 25) |
                   (this._falloffMode                         << 23) |
                   ((this._normalOffsetBias !== 0.0 ? 1 : 0)  << 22) |
                   ((this._cookie ? 1 : 0)                    << 21) |
                   ((this._cookieFalloff ? 1 : 0)             << 20) |
                   (chanId[this._cookieChannel.charAt(0)]     << 18) |
                   ((this._cookieTransform ? 1 : 0)           << 12);

            if (this._cookieChannel.length === 3) {
                key |= (chanId[this._cookieChannel.charAt(1)] << 16);
                key |= (chanId[this._cookieChannel.charAt(2)] << 14);
            }

            if (key !== this.key && this._scene !== null) {
                this._scene.layers._dirtyLights = true;
            }

            this.key = key;
        }
    });

    Object.defineProperty(Light.prototype, 'type', {
        get: function () {
            return this._type;
        },
        set: function (value) {
            if (this._type === value)
                return;

            this._type = value;
            this._destroyShadowMap();
            this.updateKey();

            var stype = this._shadowType;
            this._shadowType = null;
            this.shadowType = stype; // refresh shadow type; switching from direct/spot to point and back may change it
        }
    });

    Object.defineProperty(Light.prototype, 'shadowType', {
        get: function () {
            return this._shadowType;
        },
        set: function (value) {
            if (this._shadowType === value)
                return;

            var device = Application.getApplication().graphicsDevice;

            if (this._type === LIGHTTYPE_POINT)
                value = SHADOW_PCF3; // VSM or HW PCF for point lights is not supported yet

            if (value === SHADOW_PCF5 && !device.webgl2) {
                value = SHADOW_PCF3; // fallback from HW PCF to old PCF
            }

            if (value === SHADOW_VSM32 && !device.textureFloatRenderable) // fallback from vsm32 to vsm16
                value = SHADOW_VSM16;

            if (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) // fallback from vsm16 to vsm8
                value = SHADOW_VSM8;

            this._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;
            this._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;

            this._shadowType = value;
            this._destroyShadowMap();
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'castShadows', {
        get: function () {
            return this._castShadows && this.mask !== MASK_LIGHTMAP && this.mask !== 0;
        },
        set: function (value) {
            if (this._castShadows === value)
                return;

            this._castShadows = value;
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'shadowResolution', {
        get: function () {
            return this._shadowResolution;
        },
        set: function (value) {
            if (this._shadowResolution === value)
                return;

            var device = Application.getApplication().graphicsDevice;
            if (this._type === LIGHTTYPE_POINT) {
                value = Math.min(value, device.maxCubeMapSize);
            } else {
                value = Math.min(value, device.maxTextureSize);
            }
            this._shadowResolution = value;
        }
    });

    Object.defineProperty(Light.prototype, 'vsmBlurSize', {
        get: function () {
            return this._vsmBlurSize;
        },
        set: function (value) {
            if (this._vsmBlurSize === value)
                return;

            if (value % 2 === 0) value++; // don't allow even size
            this._vsmBlurSize = value;
        }
    });

    Object.defineProperty(Light.prototype, 'normalOffsetBias', {
        get: function () {
            return this._normalOffsetBias;
        },
        set: function (value) {
            if (this._normalOffsetBias === value)
                return;

            if ((!this._normalOffsetBias && value) || (this._normalOffsetBias && !value)) {
                this.updateKey();
            }
            this._normalOffsetBias = value;
        }
    });

    Object.defineProperty(Light.prototype, 'falloffMode', {
        get: function () {
            return this._falloffMode;
        },
        set: function (value) {
            if (this._falloffMode === value)
                return;

            this._falloffMode = value;
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'innerConeAngle', {
        get: function () {
            return this._innerConeAngle;
        },
        set: function (value) {
            if (this._innerConeAngle === value)
                return;

            this._innerConeAngle = value;
            this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
        }
    });

    Object.defineProperty(Light.prototype, 'outerConeAngle', {
        get: function () {
            return this._outerConeAngle;
        },
        set: function (value) {
            if (this._outerConeAngle === value)
                return;

            this._outerConeAngle = value;
            this._outerConeAngleCos = Math.cos(value * Math.PI / 180);
        }
    });

    Object.defineProperty(Light.prototype, 'intensity', {
        get: function () {
            return this._intensity;
        },
        set: function (value) {
            if (this._intensity !== value) {
                this._intensity = value;
                this._updateFinalColor();
            }
        }
    });

    Object.defineProperty(Light.prototype, 'cookie', {
        get: function () {
            return this._cookie;
        },
        set: function (value) {
            if (this._cookie === value)
                return;

            this._cookie = value;
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'cookieFalloff', {
        get: function () {
            return this._cookieFalloff;
        },
        set: function (value) {
            if (this._cookieFalloff === value)
                return;

            this._cookieFalloff = value;
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'cookieChannel', {
        get: function () {
            return this._cookieChannel;
        },
        set: function (value) {
            if (this._cookieChannel === value)
                return;

            if (value.length < 3) {
                var chr = value.charAt(value.length - 1);
                var addLen = 3 - value.length;
                for (var i = 0; i < addLen; i++)
                    value += chr;
            }
            this._cookieChannel = value;
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'cookieTransform', {
        get: function () {
            return this._cookieTransform;
        },
        set: function (value) {
            if (this._cookieTransform === value)
                return;

            this._cookieTransform = value;
            this._cookieTransformSet = !!value;
            if (value && !this._cookieOffset) {
                this.cookieOffset = new Vec2(); // using transform forces using offset code
                this._cookieOffsetSet = false;
            }
            this.updateKey();
        }
    });

    Object.defineProperty(Light.prototype, 'cookieOffset', {
        get: function () {
            return this._cookieOffset;
        },
        set: function (value) {
            if (this._cookieOffset === value)
                return;

            var xformNew = !!(this._cookieTransformSet || value);
            if (xformNew && !value && this._cookieOffset) {
                this._cookieOffset.set(0, 0);
            } else {
                this._cookieOffset = value;
            }
            this._cookieOffsetSet = !!value;
            if (value && !this._cookieTransform) {
                this.cookieTransform = new Vec4(1, 1, 0, 0); // using offset forces using matrix code
                this._cookieTransformSet = false;
            }
            this.updateKey();
        }
    });

    /**
     * @component
     * @class
     * @name pc.LightComponent
     * @augments pc.Component
     * @classdesc The Light Component enables the Entity to light the scene. There are three types
     * of light: directional, point and spot. Directional lights are global in that they are
     * considered to be infinitely far away and light the entire scene. Point and spot lights
     * are local in that they have a position and a range. A spot light is a specialization of
     * a point light where light is emitted in a cone rather than in all directions. Lights
     * also have the ability to cast shadows to add realism to your scenes.
     * @description Creates a new Light Component.
     * @param {pc.LightComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @example
     * // Add a pc.LightComponent to an entity
     * var entity = new pc.Entity();
     * entity.addComponent('light', {
     *     type: "point",
     *     color: new pc.Color(1, 0, 0),
     *     range: 10
     * });
     * @example
     * // Get the pc.LightComponent on an entity
     * var lightComponent = entity.light;
     * @example
     * // Update a property on a light component
     * entity.light.range = 20;
     * @property {string} type The type of light. Can be:
     * * "directional": A light that is infinitely far away and lights the entire scene from one direction.
     * * "point": A light that illuminates in all directions from a point.
     * * "spot": A light that illuminates in all directions from a point and is bounded by a cone.
     * Defaults to "directional".
     * @property {pc.Color} color The Color of the light. The alpha component of the color is
     * ignored. Defaults to white (1, 1, 1).
     * @property {number} intensity The brightness of the light. Defaults to 1.
     * @property {boolean} castShadows If enabled the light will cast shadows. Defaults to false.
     * @property {number} shadowDistance The distance from the viewpoint beyond which shadows
     * are no longer rendered. Affects directional lights only. Defaults to 40.
     * @property {number} shadowResolution The size of the texture used for the shadow map.
     * Valid sizes are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.
     * @property {number} shadowBias The depth bias for tuning the appearance of the shadow
     * mapping generated by this light. Defaults to 0.05.
     * @property {number} normalOffsetBias Normal offset depth bias. Defaults to 0.
     * @property {number} range The range of the light. Affects point and spot lights only.
     * Defaults to 10.
     * @property {number} innerConeAngle The angle at which the spotlight cone starts
     * to fade off. The angle is specified in degrees. Affects spot lights only. Defaults
     * to 40.
     * @property {number} outerConeAngle The angle at which the spotlight cone has faded
     * to nothing. The angle is specified in degrees. Affects spot lights only. Defaults
     * to 45.
     * @property {number} falloffMode Controls the rate at which a light attentuates from
     * its position. Can be:
     * * {@link pc.LIGHTFALLOFF_LINEAR}: Linear.
     * * {@link pc.LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.
     * Affects point and spot lights only. Defaults to pc.LIGHTFALLOFF_LINEAR.
     * @property {number} mask Defines a mask to determine which {@link pc.MeshInstance}s are
     * lit by this light. Defaults to 1.
     * @property {boolean} affectDynamic If enabled the light will affect non-lightmapped objects
     * @property {boolean} affectLightmapped If enabled the light will affect lightmapped objects
     * @property {boolean} bake If enabled the light will be rendered into lightmaps
     * @property {boolean} bakeDir If enabled and bake=true, the light's direction will contribute to directional lightmaps.
     * Be aware, that directional lightmap is an approximation and can only hold single direction per pixel.
     * Intersecting multiple lights with bakeDir=true may lead to incorrect look of specular/bump-mapping in the area of intersection.
     * The error is not always visible though, and highly scene-dependent.
     * @property {number} shadowUpdateMode Tells the renderer how often shadows must be updated for this light. Options:
     * * {@link pc.SHADOWUPDATE_NONE}: Don't render shadows.
     * * {@link pc.SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches to pc.SHADOWUPDATE_NONE).
     * * {@link pc.SHADOWUPDATE_REALTIME}: Render shadows every frame (default).
     * @property {number} shadowType Type of shadows being rendered by this light. Options:
     * * {@link pc.SHADOW_PCF3}: Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
     * * {@link pc.SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.
     * * {@link pc.SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.
     * * {@link pc.SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.
     * * {@link pc.SHADOW_PCF5}: Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires WebGL2. Falls back to pc.SHADOW_PCF3 on WebGL 1.0.
     * @property {number} vsmBlurMode Blurring mode for variance shadow maps:
     * * {@link pc.BLUR_BOX}: Box filter.
     * * {@link pc.BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.
     * @property {number} vsmBlurSize Number of samples used for blurring a variance shadow map. Only uneven numbers work, even are incremented. Minimum value is 1, maximum is 25.
     * @property {number} cookieAsset Asset that has texture that will be assigned to cookie internally once asset resource is available.
     * @property {pc.Texture} cookie Projection texture. Must be 2D for spot and cubemap for point (ignored if incorrect type is used).
     * @property {number} cookieIntensity Projection texture intensity (default is 1).
     * @property {boolean} cookieFalloff Toggle normal spotlight falloff when projection texture is used. When set to false, spotlight will work like a pure texture projector (only fading with distance). Default is false.
     * @property {string} cookieChannel Color channels of the projection texture to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {number} cookieAngle Angle for spotlight cookie rotation.
     * @property {pc.Vec2} cookieScale Spotlight cookie scale.
     * @property {pc.Vec2} cookieOffset Spotlight cookie position offset.
     * @property {boolean} isStatic Mark light as non-movable (optimization)
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this light should belong.
     * Don't push/pop/splice or modify this array, if you want to change it - set a new one instead.
     */
    function LightComponent(system, entity) {
        Component.call(this, system, entity);

        this._cookieAsset = null;
        this._cookieAssetId = null;
        this._cookieAssetAdd = false;
        this._cookieMatrix = null;
    }
    LightComponent.prototype = Object.create(Component.prototype);
    LightComponent.prototype.constructor = LightComponent;

    var _props = [];
    var _propsDefault = [];

    var _defineProperty = function (name, defaultValue, setFunc, skipEqualsCheck) {
        var c = LightComponent.prototype;
        _props.push(name);
        _propsDefault.push(defaultValue);

        Object.defineProperty(c, name, {
            get: function () {
                return this.data[name];
            },
            set: function (value) {
                var data = this.data;
                var oldValue = data[name];
                if (!skipEqualsCheck && oldValue === value) return;
                data[name] = value;
                if (setFunc) setFunc.call(this, value, oldValue);
            },
            configurable: true
        });
    };

    var _defineProps = function () {
        _defineProperty("enabled", true, function (newValue, oldValue) {
            this.onSetEnabled(null, oldValue, newValue);
        });
        _defineProperty("light", null);
        _defineProperty("type", 'directional', function (newValue, oldValue) {
            this.system.changeType(this, oldValue, newValue);
            // refresh light properties because changing the type does not reset the
            // light properties
            this.refreshProperties();
        });
        _defineProperty("color", new Color(1, 1, 1), function (newValue, oldValue) {
            this.light.setColor(newValue);
        }, true);
        _defineProperty("intensity", 1, function (newValue, oldValue) {
            this.light.intensity = newValue;
        });
        _defineProperty("castShadows", false, function (newValue, oldValue) {
            this.light.castShadows = newValue;
        });
        _defineProperty("shadowDistance", 40, function (newValue, oldValue) {
            this.light.shadowDistance = newValue;
        });
        _defineProperty("shadowResolution", 1024, function (newValue, oldValue) {
            this.light.shadowResolution = newValue;
        });
        _defineProperty("shadowBias", 0.05, function (newValue, oldValue) {
            this.light.shadowBias = -0.01 * newValue;
        });
        _defineProperty("normalOffsetBias", 0, function (newValue, oldValue) {
            this.light.normalOffsetBias = newValue;
        });
        _defineProperty("range", 10, function (newValue, oldValue) {
            this.light.attenuationEnd = newValue;
        });
        _defineProperty("innerConeAngle", 40, function (newValue, oldValue) {
            this.light.innerConeAngle = newValue;
        });
        _defineProperty("outerConeAngle", 45, function (newValue, oldValue) {
            this.light.outerConeAngle = newValue;
        });
        _defineProperty("falloffMode", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {
            this.light.falloffMode = newValue;
        });
        _defineProperty("shadowType", SHADOW_PCF3, function (newValue, oldValue) {
            this.light.shadowType = newValue;
        });
        _defineProperty("vsmBlurSize", 11, function (newValue, oldValue) {
            this.light.vsmBlurSize = newValue;
        });
        _defineProperty("vsmBlurMode", BLUR_GAUSSIAN, function (newValue, oldValue) {
            this.light.vsmBlurMode = newValue;
        });
        _defineProperty("vsmBias", 0.01 * 0.25, function (newValue, oldValue) {
            this.light.vsmBias = newValue;
        });
        _defineProperty("cookieAsset", null, function (newValue, oldValue) {
            if (this._cookieAssetId && ((newValue instanceof Asset && newValue.id === this._cookieAssetId) || newValue === this._cookieAssetId))
                return;

            this.onCookieAssetRemove();
            this._cookieAssetId = null;

            if (newValue instanceof Asset) {
                this.data.cookieAsset = newValue.id;
                this._cookieAssetId = newValue.id;
                this.onCookieAssetAdd(newValue);
            } else if (typeof newValue === 'number') {
                this._cookieAssetId = newValue;
                var asset = this.system.app.assets.get(newValue);
                if (asset) {
                    this.onCookieAssetAdd(asset);
                } else {
                    this._cookieAssetAdd = true;
                    this.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
                }
            }
        });
        _defineProperty("cookie", null, function (newValue, oldValue) {
            this.light.cookie = newValue;
        });
        _defineProperty("cookieIntensity", 1, function (newValue, oldValue) {
            this.light.cookieIntensity = newValue;
        });
        _defineProperty("cookieFalloff", true, function (newValue, oldValue) {
            this.light.cookieFalloff = newValue;
        });
        _defineProperty("cookieChannel", "rgb", function (newValue, oldValue) {
            this.light.cookieChannel = newValue;
        });
        _defineProperty("cookieAngle", 0, function (newValue, oldValue) {
            if (newValue !== 0 || this.cookieScale !== null) {
                if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
                var scx = 1;
                var scy = 1;
                if (this.cookieScale) {
                    scx = this.cookieScale.x;
                    scy = this.cookieScale.y;
                }
                var c = Math.cos(newValue * math.DEG_TO_RAD);
                var s = Math.sin(newValue * math.DEG_TO_RAD);
                this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
                this.light.cookieTransform = this._cookieMatrix;
            } else {
                this.light.cookieTransform = null;
            }
        });
        _defineProperty("cookieScale", null, function (newValue, oldValue) {
            if (newValue !== null || this.cookieAngle !== 0) {
                if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
                var scx = newValue.x;
                var scy = newValue.y;
                var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
                var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
                this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
                this.light.cookieTransform = this._cookieMatrix;
            } else {
                this.light.cookieTransform = null;
            }
        }, true);
        _defineProperty("cookieOffset", null, function (newValue, oldValue) {
            this.light.cookieOffset = newValue;
        }, true);
        _defineProperty("shadowUpdateMode", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {
            this.light.shadowUpdateMode = newValue;
        });
        _defineProperty("mask", 1, function (newValue, oldValue) {
            this.light.mask = newValue;
        });
        _defineProperty("affectDynamic", true, function (newValue, oldValue) {
            if (newValue) {
                this.light.mask |= MASK_DYNAMIC;
            } else {
                this.light.mask &= ~MASK_DYNAMIC;
            }
        });
        _defineProperty("affectLightmapped", false, function (newValue, oldValue) {
            if (newValue) {
                this.light.mask |= MASK_BAKED;
                if (this.bake) this.light.mask &= ~MASK_LIGHTMAP;
            } else {
                this.light.mask &= ~MASK_BAKED;
                if (this.bake) this.light.mask |= MASK_LIGHTMAP;
            }
        });
        _defineProperty("bake", false, function (newValue, oldValue) {
            if (newValue) {
                this.light.mask |= MASK_LIGHTMAP;
                if (this.affectLightmapped) this.light.mask &= ~MASK_BAKED;
            } else {
                this.light.mask &= ~MASK_LIGHTMAP;
                if (this.affectLightmapped) this.light.mask |= MASK_BAKED;
            }
        });
        _defineProperty("bakeDir", true, function (newValue, oldValue) {
            this.light.bakeDir = newValue;
        });
        _defineProperty("isStatic", false, function (newValue, oldValue) {
            this.light.isStatic = newValue;
        });
        _defineProperty("layers", [LAYERID_WORLD], function (newValue, oldValue) {
            var i, layer;
            for (i = 0; i < oldValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
                if (!layer) continue;
                layer.removeLight(this);
            }
            for (i = 0; i < newValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(newValue[i]);
                if (!layer) continue;
                if (this.enabled && this.entity.enabled) {
                    layer.addLight(this);
                }
            }
        });
    };
    _defineProps();


    Object.assign(LightComponent.prototype, {

        addLightToLayers: function () {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.addLight(this);
            }
        },

        removeLightFromLayers: function () {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.removeLight(this);
            }
        },

        onLayersChanged: function (oldComp, newComp) {
            if (this.enabled && this.entity.enabled) {
                this.addLightToLayers();
            }
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);
        },

        onLayerAdded: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            if (this.enabled && this.entity.enabled) {
                layer.addLight(this);
            }
        },

        onLayerRemoved: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.removeLight(this);
        },

        refreshProperties: function () {
            var name;
            for (var i = 0; i < _props.length; i++) {
                name = _props[i];

                /* eslint-disable no-self-assign */
                this[name] = this[name];
                /* eslint-enable no-self-assign */
            }
            if (this.enabled && this.entity.enabled)
                this.onEnable();
        },

        updateShadow: function () {
            this.light.updateShadow();
        },

        onCookieAssetSet: function () {
            var forceLoad = false;

            if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
                this._cookieAsset.loadFaces = true;
                forceLoad = true;
            }

            if (!this._cookieAsset.resource || forceLoad)
                this.system.app.assets.load(this._cookieAsset);

            if (this._cookieAsset.resource)
                this.onCookieAssetLoad();
        },

        onCookieAssetAdd: function (asset) {
            if (this._cookieAssetId !== asset.id)
                return;

            this._cookieAsset = asset;

            if (this.light.enabled)
                this.onCookieAssetSet();

            this._cookieAsset.on('load', this.onCookieAssetLoad, this);
            this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
        },

        onCookieAssetLoad: function () {
            if (!this._cookieAsset || !this._cookieAsset.resource)
                return;

            this.cookie = this._cookieAsset.resource;
        },

        onCookieAssetRemove: function () {
            if (!this._cookieAssetId)
                return;

            if (this._cookieAssetAdd) {
                this.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);
                this._cookieAssetAdd = false;
            }

            if (this._cookieAsset) {
                this._cookieAsset.off('load', this.onCookieAssetLoad, this);
                this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
                this._cookieAsset = null;
            }

            this.cookie = null;
        },

        onEnable: function () {
            this.light.enabled = true;

            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.on("add", this.onLayerAdded, this);
                this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
            }

            if (this.enabled && this.entity.enabled) {
                this.addLightToLayers();
            }

            if (this._cookieAsset && !this.cookie)
                this.onCookieAssetSet();
        },

        onDisable: function () {
            this.light.enabled = false;

            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.off("add", this.onLayerAdded, this);
                this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
            }

            this.removeLightFromLayers();
        },

        onRemove: function () {
            // destroy light node
            this.light.destroy();
            // remove cookie asset events
            this.cookieAsset = null;
        }

    });

    var _lightProps = _props;
    var _lightPropsDefault = _propsDefault;

    function LightComponentData() {
        var _props = _lightProps;
        var _propsDefault = _lightPropsDefault;
        var value;
        for (var i = 0; i < _props.length; i++) {
            value = _propsDefault[i];
            if (value && value.clone) {
                this[_props[i]] = value.clone();
            } else {
                this[_props[i]] = value;
            }
        }
    }

    /**
     * @class
     * @name pc.LightComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc A Light Component is used to dynamically light the scene.
     * @description Create a new LightComponentSystem.
     * @param {pc.Application} app - The application.
     */
    var lightTypes = {
        'directional': LIGHTTYPE_DIRECTIONAL,
        'point': LIGHTTYPE_POINT,
        'spot': LIGHTTYPE_SPOT
    };

    function LightComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'light';
        this.description = "Enables the Entity to emit light.";

        this.ComponentType = LightComponent;
        this.DataType = LightComponentData;

        this.on('beforeremove', this._onRemoveComponent, this);
    }
    LightComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    LightComponentSystem.prototype.constructor = LightComponentSystem;

    Object.assign(LightComponentSystem.prototype, {
        initializeComponentData: function (component, _data) {
            var properties = _lightProps;

            // duplicate because we're modifying the data
            var data = {};
            for (var i = 0, len = properties.length; i < len; i++) {
                var property = properties[i];
                data[property] = _data[property];
            }

            if (!data.type)
                data.type = component.data.type;

            component.data.type = data.type;

            if (data.layers && type(data.layers) === 'array') {
                data.layers = data.layers.slice(0);
            }

            if (data.color && type(data.color) === 'array')
                data.color = new Color(data.color[0], data.color[1], data.color[2]);

            if (data.cookieOffset && data.cookieOffset instanceof Array)
                data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);

            if (data.cookieScale && data.cookieScale instanceof Array)
                data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);

            if (data.enable) {
                console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
                data.enabled = data.enable;
            }

            var light = new Light();
            light.type = lightTypes[data.type];
            light._node = component.entity;
            light._scene = this.app.scene;
            component.data.light = light;

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        _onRemoveComponent: function (entity, component) {
            component.onRemove();
        },

        cloneComponent: function (entity, clone) {
            var light = entity.light;

            var data = [];
            var name;
            var _props = _lightProps;
            for (var i = 0; i < _props.length; i++) {
                name = _props[i];
                if (name === "light") continue;
                if (light[name] && light[name].clone) {
                    data[name] = light[name].clone();
                } else {
                    data[name] = light[name];
                }
            }

            this.addComponent(clone, data);
        },

        changeType: function (component, oldValue, newValue) {
            if (oldValue !== newValue) {
                component.light.type = lightTypes[newValue];
            }
        }
    });

    /**
     * @component
     * @class
     * @name pc.ModelComponent
     * @augments pc.Component
     * @classdesc Enables an Entity to render a model or a primitive shape. This Component attaches additional model
     * geometry in to the scene graph below the Entity.
     * @description Create a new ModelComponent.
     * @param {pc.ModelComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {string} type The type of the model. Can be one of the following:
     * * "asset": The component will render a model asset
     * * "box": The component will render a box (1 unit in each dimension)
     * * "capsule": The component will render a capsule (radius 0.5, height 2)
     * * "cone": The component will render a cone (radius 0.5, height 1)
     * * "cylinder": The component will render a cylinder (radius 0.5, height 1)
     * * "plane": The component will render a plane (1 unit in each dimension)
     * * "sphere": The component will render a sphere (radius 0.5)
     * @property {pc.Asset|number} asset The asset for the model (only applies to models of type 'asset') - can also be an asset id.
     * @property {boolean} castShadows If true, this model will cast shadows for lights that have shadow casting enabled.
     * @property {boolean} receiveShadows If true, shadows will be cast on this model.
     * @property {pc.Material} material The material {@link pc.Material} that will be used to render the model. Setting
     * this property will apply the material to all mesh instances of the model.
     * @property {pc.Asset|number} materialAsset The material {@link pc.Asset} that will be used to render the model (not used on models of type 'asset').
     * @property {pc.Model} model The model that is added to the scene graph. It can be not set or loaded, so will return null.
     * @property {object} mapping A dictionary that holds material overrides for each mesh instance. Only applies to model
     * components of type 'asset'. The mapping contains pairs of mesh instance index - material asset id.
     * @property {boolean} castShadowsLightmap If true, this model will cast shadows when rendering lightmaps.
     * @property {boolean} lightmapped If true, this model will be lightmapped after using lightmapper.bake().
     * @property {number} lightmapSizeMultiplier Lightmap resolution multiplier.
     * @property {boolean} isStatic Mark model as non-movable (optimization).
     * @property {pc.MeshInstance[]} meshInstances An array of meshInstances contained in the component's model. If model is not set or loaded for component it will return null.
     * @property {number} batchGroupId Assign model to a specific batch group (see {@link pc.BatchGroup}). Default value is -1 (no group).
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this model should belong.
     * Don't push/pop/splice or modify this array, if you want to change it - set a new one instead.
     */
    function ModelComponent(system, entity)   {
        Component.call(this, system, entity);

        // this.enabled = true;
        this._type = 'asset';

        // model asset
        this._asset = null;
        this._model = null;

        this._mapping = {};

        this._castShadows = true;
        this._receiveShadows = true;

        this._materialAsset = null;
        this._material = system.defaultMaterial;

        this._castShadowsLightmap = true;
        this._lightmapped = false;
        this._lightmapSizeMultiplier = 1;
        this._isStatic = false;

        this._layers = [LAYERID_WORLD]; // assign to the default world layer
        this._batchGroupId = -1;

        this._area = null;

        this._assetOld = 0;
        this._materialEvents = null;
        this._dirtyModelAsset = false;
        this._dirtyMaterialAsset = false;

        this._clonedModel = false;


        entity.on('remove', this.onRemoveChild, this);
        entity.on('insert', this.onInsertChild, this);
    }
    ModelComponent.prototype = Object.create(Component.prototype);
    ModelComponent.prototype.constructor = ModelComponent;

    Object.assign(ModelComponent.prototype, {
        setVisible: function (visible) {
            console.warn("WARNING: setVisible: Function is deprecated. Set enabled property instead.");
            this.enabled = visible;
        },

        addModelToLayers: function () {
            var layer;
            var layers = this.system.app.scene.layers;

            for (var i = 0; i < this._layers.length; i++) {
                layer = layers.getLayerById(this._layers[i]);
                if (!layer) continue;
                layer.addMeshInstances(this.meshInstances);
            }
        },

        removeModelFromLayers: function () {
            var layer;
            var layers = this.system.app.scene.layers;

            for (var i = 0; i < this._layers.length; i++) {
                layer = layers.getLayerById(this._layers[i]);
                if (!layer) continue;
                layer.removeMeshInstances(this.meshInstances);
            }
        },

        onRemoveChild: function () {
            if (this._model)
                this.removeModelFromLayers();
        },

        onInsertChild: function () {
            if (this._model && this.enabled && this.entity.enabled)
                this.addModelToLayers();
        },

        onRemove: function () {
            if (this.type === 'asset') {
                this.asset = null;
            } else {
                this.model = null;
            }
            this.materialAsset = null;
            this._unsetMaterialEvents();

            this.entity.off('remove', this.onRemoveChild, this);
            this.entity.off('insert', this.onInsertChild, this);
        },

        onLayersChanged: function (oldComp, newComp) {
            this.addModelToLayers();
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);
        },

        onLayerAdded: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.addMeshInstances(this.meshInstances);
        },

        onLayerRemoved: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.removeMeshInstances(this.meshInstances);
        },

        _setMaterialEvent: function (index, event, id, handler) {
            var evt = event + ':' + id;
            this.system.app.assets.on(evt, handler, this);

            if (!this._materialEvents)
                this._materialEvents = [];

            if (!this._materialEvents[index])
                this._materialEvents[index] = { };

            this._materialEvents[index][evt] = {
                id: id,
                handler: handler
            };
        },

        _unsetMaterialEvents: function () {
            var assets = this.system.app.assets;
            var events = this._materialEvents;
            if (!events)
                return;

            for (var i = 0, len = events.length; i < len; i++) {
                if (!events[i]) continue;
                var evt = events[i];
                for (var key in evt) {
                    assets.off(key, evt[key].handler, this);
                }
            }

            this._materialEvents = null;
        },

        _getAssetByIdOrPath: function (idOrPath) {
            var asset = null;
            var isPath = isNaN(parseInt(idOrPath, 10));

            // get asset by id or url
            if (!isPath) {
                asset = this.system.app.assets.get(idOrPath);
            } else if (this.asset) {
                var url = this._getMaterialAssetUrl(idOrPath);
                if (url)
                    asset = this.system.app.assets.getByUrl(url);
            }

            return asset;
        },

        _getMaterialAssetUrl: function (path) {
            if (!this.asset) return null;

            var modelAsset = this.system.app.assets.get(this.asset);

            return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
        },

        _loadAndSetMeshInstanceMaterial: function (materialAsset, meshInstance, index) {
            var assets = this.system.app.assets;

            if (!materialAsset)
                return;

            if (materialAsset.resource) {
                meshInstance.material = materialAsset.resource;

                this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
                    meshInstance.material = this.system.defaultMaterial;
                });
            } else {
                this._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {
                    meshInstance.material = asset.resource;

                    this._setMaterialEvent(index, 'remove', materialAsset.id, function () {
                        meshInstance.material = this.system.defaultMaterial;
                    });
                });

                if (this.enabled && this.entity.enabled)
                    assets.load(materialAsset);
            }
        },

        onEnable: function () {
            var app = this.system.app;
            var scene = app.scene;

            scene.on("set:layers", this.onLayersChanged, this);
            if (scene.layers) {
                scene.layers.on("add", this.onLayerAdded, this);
                scene.layers.on("remove", this.onLayerRemoved, this);
            }

            var isAsset = (this._type === 'asset');

            var asset;
            if (this._model) {
                this.addModelToLayers();
            } else if (isAsset && this._asset) {
                // bind and load model asset if necessary
                asset = app.assets.get(this._asset);
                if (asset && asset.resource !== this._model) {
                    this._bindModelAsset(asset);
                }
            }

            if (this._materialAsset) {
                // bind and load material asset if necessary
                asset = app.assets.get(this._materialAsset);
                if (asset && asset.resource !== this._material) {
                    this._bindMaterialAsset(asset);
                }
            }

            if (isAsset) {
                // bind mapped assets
                // TODO: replace
                if (this._mapping) {
                    for (var index in this._mapping) {
                        if (this._mapping[index]) {
                            asset = this._getAssetByIdOrPath(this._mapping[index]);
                            if (asset && !asset.resource) {
                                app.assets.load(asset);
                            }
                        }
                    }
                }
            }

            if (this._batchGroupId >= 0) {
                app.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
            }
        },

        onDisable: function () {
            var app = this.system.app;
            var scene = app.scene;

            scene.off("set:layers", this.onLayersChanged, this);
            if (scene.layers) {
                scene.layers.off("add", this.onLayerAdded, this);
                scene.layers.off("remove", this.onLayerRemoved, this);
            }

            if (this._batchGroupId >= 0) {
                app.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
            }

            if (this._model) {
                this.removeModelFromLayers();
            }
        },

        /**
         * @function
         * @name pc.ModelComponent#hide
         * @description Stop rendering model without removing it from the scene hierarchy.
         * This method sets the {@link pc.MeshInstance#visible} property of every MeshInstance in the model to false
         * Note, this does not remove the model or mesh instances from the scene hierarchy or draw call list.
         * So the model component still incurs some CPU overhead.
         * @example
         * this.timer = 0;
         * this.visible = true;
         * // ...
         * // blink model every 0.1 seconds
         * this.timer += dt;
         * if (this.timer > 0.1) {
         *     if (!this.visible) {
         *         this.entity.model.show();
         *         this.visible = true;
         *     } else {
         *         this.entity.model.hide();
         *         this.visible = false;
         *     }
         *     this.timer = 0;
         * }
         */
        hide: function () {
            if (this._model) {
                var i, l;
                var instances = this._model.meshInstances;
                for (i = 0, l = instances.length; i < l; i++) {
                    instances[i].visible = false;
                }
            }
        },

        /**
         * @function
         * @name pc.ModelComponent#show
         * @description Enable rendering of the model if hidden using {@link pc.ModelComponent#hide}.
         * This method sets all the {@link pc.MeshInstance#visible} property on all mesh instances to true.
         */
        show: function () {
            if (this._model) {
                var i, l;
                var instances = this._model.meshInstances;
                for (i = 0, l = instances.length; i < l; i++) {
                    instances[i].visible = true;
                }
            }
        },

        // NEW

        _bindMaterialAsset: function (asset) {
            asset.on('load', this._onMaterialAssetLoad, this);
            asset.on('unload', this._onMaterialAssetUnload, this);
            asset.on('remove', this._onMaterialAssetRemove, this);
            asset.on('change', this._onMaterialAssetChange, this);

            if (asset.resource) {
                this._onMaterialAssetLoad(asset);
            } else {
                // don't trigger an asset load unless the component is enabled
                if (!this.enabled || !this.entity.enabled) return;
                this.system.app.assets.load(asset);
            }
        },

        _unbindMaterialAsset: function (asset) {
            asset.off('load', this._onMaterialAssetLoad, this);
            asset.off('unload', this._onMaterialAssetUnload, this);
            asset.off('remove', this._onMaterialAssetRemove, this);
            asset.off('change', this._onMaterialAssetChange, this);
        },

        _onMaterialAssetAdd: function (asset) {
            this.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);
            if (this._materialAsset === asset.id) {
                this._bindMaterialAsset(asset);
            }
        },

        _onMaterialAssetLoad: function (asset) {
            this._setMaterial(asset.resource);
        },

        _onMaterialAssetUnload: function (asset) {
            this._setMaterial(this.system.defaultMaterial);
        },

        _onMaterialAssetRemove: function (asset) {
            this._onMaterialAssetUnload(asset);
        },

        _onMaterialAssetChange: function (asset) {
        },

        _bindModelAsset: function (asset) {
            this._unbindModelAsset(asset);

            asset.on('load', this._onModelAssetLoad, this);
            asset.on('unload', this._onModelAssetUnload, this);
            asset.on('change', this._onModelAssetChange, this);
            asset.on('remove', this._onModelAssetRemove, this);

            if (asset.resource) {
                this._onModelAssetLoad(asset);
            } else {
                // don't trigger an asset load unless the component is enabled
                if (!this.enabled || !this.entity.enabled) return;

                this.system.app.assets.load(asset);
            }
        },

        _unbindModelAsset: function (asset) {
            asset.off('load', this._onModelAssetLoad, this);
            asset.off('unload', this._onModelAssetUnload, this);
            asset.off('change', this._onModelAssetChange, this);
            asset.off('remove', this._onModelAssetRemove, this);
        },

        _onModelAssetAdded: function (asset) {
            this.system.app.assets.off('add:' + asset.id, this._onModelAssetAdd, this);
            if (asset.id === this._asset) {
                this._bindModelAsset(asset);
            }
        },

        _onModelAssetLoad: function (asset) {
            this.model = asset.resource.clone();
            this._clonedModel = true;
        },

        _onModelAssetUnload: function (asset) {
            this.model = null;
        },

        _onModelAssetChange: function (asset, attr, _new, _old) {
            if (attr === 'data') {
                this.mapping = this._mapping;
            }
        },

        _onModelAssetRemove: function (asset) {
            this.model = null;
        },

        _setMaterial: function (material) {
            if (this._material === material)
                return;

            this._material = material;

            var model = this._model;
            if (model && this._type !== 'asset') {
                var meshInstances = model.meshInstances;
                for (var i = 0, len = meshInstances.length; i < len; i++) {
                    meshInstances[i].material = material;
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "meshInstances", {
        get: function () {
            if (!this._model)
                return null;

            return this._model.meshInstances;
        },
        set: function (value) {
            if (!this._model)
                return;

            this._model.meshInstances = value;
        }
    });

    Object.defineProperty(ModelComponent.prototype, "type", {
        get: function () {
            return this._type;
        },

        set: function (value) {
            if (this._type === value) return;

            var mesh = null;

            this._area = null;

            this._type = value;

            if (value === 'asset') {
                if (this._asset !== null) {
                    this._bindModelAsset(this._asset);
                } else {
                    this.model = null;
                }
            } else {
                var system = this.system;
                var gd = system.app.graphicsDevice;

                switch (value) {
                    case 'box':
                        if (!system.box) {
                            system.box = createBox(gd, {
                                halfExtents: new Vec3(0.5, 0.5, 0.5)
                            });
                        }
                        mesh = system.box;
                        this._area = { x: 2, y: 2, z: 2, uv: (2.0 / 3) };
                        break;
                    case 'capsule':
                        if (!system.capsule) {
                            system.capsule = createCapsule(gd, {
                                radius: 0.5,
                                height: 2
                            });
                        }
                        mesh = system.capsule;
                        this._area = { x: (Math.PI * 2), y: Math.PI, z: (Math.PI * 2), uv: (1.0 / 3 + ((1.0 / 3) / 3) * 2) };
                        break;
                    case 'cone':
                        if (!system.cone) {
                            system.cone = createCone(gd, {
                                baseRadius: 0.5,
                                peakRadius: 0,
                                height: 1
                            });
                        }
                        mesh = system.cone;
                        this._area = { x: 2.54, y: 2.54, z: 2.54, uv: (1.0 / 3 + (1.0 / 3) / 3) };
                        break;
                    case 'cylinder':
                        if (!system.cylinder) {
                            system.cylinder = createCylinder(gd, {
                                radius: 0.5,
                                height: 1
                            });
                        }
                        mesh = system.cylinder;
                        this._area = { x: Math.PI, y: (0.79 * 2), z: Math.PI, uv: (1.0 / 3 + ((1.0 / 3) / 3) * 2) };
                        break;
                    case 'plane':
                        if (!system.plane) {
                            system.plane = createPlane(gd, {
                                halfExtents: new Vec2(0.5, 0.5),
                                widthSegments: 1,
                                lengthSegments: 1
                            });
                        }
                        mesh = system.plane;
                        this._area = { x: 0, y: 1, z: 0, uv: 1 };
                        break;
                    case 'sphere':
                        if (!system.sphere) {
                            system.sphere = createSphere(gd, {
                                radius: 0.5
                            });
                        }
                        mesh = system.sphere;
                        this._area = { x: Math.PI, y: Math.PI, z: Math.PI, uv: 1 };
                        break;
                    default:
                        throw new Error("Invalid model type: " + value);
                }

                var node = new GraphNode();

                var model = new Model();
                model.graph = node;

                model.meshInstances = [new MeshInstance(node, mesh, this._material)];

                if (system._inTools)
                    model.generateWireframe();

                this.model = model;
                this._asset = null;
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "asset", {
        get: function () {
            return this._asset;
        },

        set: function (value) {
            var assets = this.system.app.assets;
            var _id = value;

            if (value instanceof Asset) {
                _id = value.id;
            }

            if (this._asset !== _id) {
                if (this._asset) {
                    // remove previous asset
                    assets.off('add:' + this._asset, this._onModelAssetAdded, this);
                    var _prev = assets.get(this._asset);
                    if (_prev) {
                        this._unbindModelAsset(_prev);
                    }
                }

                this._asset = _id;

                if (this._asset) {
                    var asset = assets.get(this._asset);
                    if (!asset) {
                        this.model = null;
                        assets.on('add:' + this._asset, this._onModelAssetAdded, this);
                    } else {
                        this._bindModelAsset(asset);
                    }
                } else {
                    this.model = null;
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "model", {
        get: function () {
            return this._model;
        },

        set: function (value) {
            var i;

            if (this._model === value)
                return;

            // return if the model has been flagged as immutable
            if (value && value._immutable) {
                return;
            }

            if (this._model) {
                this._model._immutable = false;

                this.removeModelFromLayers();
                this.entity.removeChild(this._model.getGraph());
                delete this._model._entity;

                if (this._clonedModel) {
                    this._model.destroy();
                    this._clonedModel = false;
                }
            }

            this._model = value;

            if (this._model) {
                // flag the model as being assigned to a component
                this._model._immutable = true;

                var meshInstances = this._model.meshInstances;

                for (i = 0; i < meshInstances.length; i++) {
                    meshInstances[i].castShadow = this._castShadows;
                    meshInstances[i].receiveShadow = this._receiveShadows;
                    meshInstances[i].isStatic = this._isStatic;
                }

                this.lightmapped = this._lightmapped; // update meshInstances

                this.entity.addChild(this._model.graph);

                if (this.enabled && this.entity.enabled) {
                    this.addModelToLayers();
                }

                // Store the entity that owns this model
                this._model._entity = this.entity;

                // Update any animation component
                if (this.entity.animation)
                    this.entity.animation.setModel(this._model);

                // trigger event handler to load mapping
                // for new model
                if (this.type === 'asset') {
                    this.mapping = this._mapping;
                } else {
                    this._unsetMaterialEvents();
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "lightmapped", {
        get: function () {
            return this._lightmapped;
        },
        set: function (value) {
            if (value === this._lightmapped) return;

            var i, m, mask;

            this._lightmapped = value;

            if (this._model) {
                var rcv = this._model.meshInstances;
                if (value) {
                    for (i = 0; i < rcv.length; i++) {
                        m = rcv[i];
                        mask = m.mask;
                        m.mask = (mask | MASK_BAKED) & ~(MASK_DYNAMIC | MASK_LIGHTMAP);
                    }
                } else {
                    for (i = 0; i < rcv.length; i++) {
                        m = rcv[i];
                        m.deleteParameter("texture_lightMap");
                        m.deleteParameter("texture_dirLightMap");
                        m._shaderDefs &= ~SHADERDEF_LM;
                        mask = m.mask;
                        m.mask = (mask | MASK_DYNAMIC) & ~(MASK_BAKED | MASK_LIGHTMAP);
                    }
                }
            }
        }
    });


    Object.defineProperty(ModelComponent.prototype, "castShadows", {
        get: function () {
            return this._castShadows;
        },

        set: function (value) {
            if (this._castShadows === value) return;

            var layer;
            var i;
            var model = this._model;

            if (model) {
                var layers = this.layers;
                var scene = this.system.app.scene;
                if (this._castShadows && !value) {
                    for (i = 0; i < layers.length; i++) {
                        layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                        if (!layer) continue;
                        layer.removeShadowCasters(model.meshInstances);
                    }
                }

                var meshInstances = model.meshInstances;
                for (i = 0; i < meshInstances.length; i++) {
                    meshInstances[i].castShadow = value;
                }

                if (!this._castShadows && value) {
                    for (i = 0; i < layers.length; i++) {
                        layer = scene.layers.getLayerById(layers[i]);
                        if (!layer) continue;
                        layer.addShadowCasters(model.meshInstances);
                    }
                }
            }

            this._castShadows = value;
        }
    });

    Object.defineProperty(ModelComponent.prototype, 'receiveShadows', {
        get: function () {
            return this._receiveShadows;
        },

        set: function (value) {
            if (this._receiveShadows === value) return;

            this._receiveShadows = value;

            if (this._model) {
                var meshInstances = this._model.meshInstances;
                for (var i = 0, len = meshInstances.length; i < len; i++) {
                    meshInstances[i].receiveShadow = value;
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "castShadowsLightmap", {
        get: function () {
            return this._castShadowsLightmap;
        },

        set: function (value) {
            this._castShadowsLightmap = value;
        }
    });

    Object.defineProperty(ModelComponent.prototype, "lightmapSizeMultiplier", {
        get: function () {
            return this._lightmapSizeMultiplier;
        },

        set: function (value) {
            this._lightmapSizeMultiplier = value;
        }
    });


    Object.defineProperty(ModelComponent.prototype, "isStatic", {
        get: function () {
            return this._isStatic;
        },

        set: function (value) {
            if (this._isStatic === value) return;

            this._isStatic = value;

            var i, m;
            if (this._model) {
                var rcv = this._model.meshInstances;
                for (i = 0; i < rcv.length; i++) {
                    m = rcv[i];
                    m.isStatic = value;
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "layers", {
        get: function () {
            return this._layers;
        },

        set: function (value) {
            var i, layer;
            var layers = this.system.app.scene.layers;

            if (this.meshInstances) {
                // remove all meshinstances from old layers
                for (i = 0; i < this._layers.length; i++) {
                    layer = layers.getLayerById(this._layers[i]);
                    if (!layer) continue;
                    layer.removeMeshInstances(this.meshInstances);
                }
            }

            // set the layer list
            this._layers.length = 0;
            for (i = 0; i < value.length; i++) {
                this._layers[i] = value[i];
            }

            // don't add into layers until we're enabled
            if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;

            // add all mesh instances to new layers
            for (i = 0; i < this._layers.length; i++) {
                layer = layers.getLayerById(this._layers[i]);
                if (!layer) continue;
                layer.addMeshInstances(this.meshInstances);
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "batchGroupId", {
        get: function () {
            return this._batchGroupId;
        },

        set: function (value) {
            if (this._batchGroupId === value) return;

            var batcher = this.system.app.batcher;
            if (this.entity.enabled && this._batchGroupId >= 0) {
                batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
            }
            if (this.entity.enabled && value >= 0) {
                batcher.insert(BatchGroup.MODEL, value, this.entity);
            }

            if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
                // re-add model to scene, in case it was removed by batching
                this.addModelToLayers();
            }

            this._batchGroupId = value;
        }
    });

    Object.defineProperty(ModelComponent.prototype, "materialAsset", {
        get: function () {
            return this._materialAsset;
        },

        set: function (value) {
            var _id = value;
            if (value instanceof Asset) {
                _id = value.id;
            }

            var assets = this.system.app.assets;

            if (_id !== this._materialAsset) {
                if (this._materialAsset) {
                    assets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
                    var _prev = assets.get(this._materialAsset);
                    if (_prev) {
                        this._unbindMaterialAsset(_prev);
                    }
                }

                this._materialAsset = _id;

                if (this._materialAsset) {
                    var asset = assets.get(this._materialAsset);
                    if (!asset) {
                        this._setMaterial(this.system.defaultMaterial);
                        assets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);
                    } else {
                        this._bindMaterialAsset(asset);
                    }
                } else {
                    this._setMaterial(this.system.defaultMaterial);
                }
            }
        }
    });

    Object.defineProperty(ModelComponent.prototype, "material", {
        get: function () {
            return this._material;
        },

        set: function (value) {
            if (this._material === value)
                return;

            this.materialAsset = null;

            this._setMaterial(value);
        }
    });

    Object.defineProperty(ModelComponent.prototype, "mapping", {
        get: function () {
            return this._mapping;
        },

        set: function (value) {
            if (this._type !== 'asset')
                return;

            // unsubscribe from old events
            this._unsetMaterialEvents();

            // can't have a null mapping
            if (!value)
                value = {};

            this._mapping = value;

            if (!this._model) return;

            var meshInstances = this._model.meshInstances;
            var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
            var assetMapping = modelAsset ? modelAsset.data.mapping : null;
            var asset = null;

            for (var i = 0, len = meshInstances.length; i < len; i++) {
                if (value[i] !== undefined) {
                    if (value[i]) {
                        asset = this.system.app.assets.get(value[i]);
                        this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
                    } else {
                        meshInstances[i].material = this.system.defaultMaterial;
                    }
                } else if (assetMapping) {
                    if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
                        if (assetMapping[i].material !== undefined) {
                            asset = this.system.app.assets.get(assetMapping[i].material);
                        } else if (assetMapping[i].path !== undefined) {
                            var url = this._getMaterialAssetUrl(assetMapping[i].path);
                            if (url) {
                                asset = this.system.app.assets.getByUrl(url);
                            }
                        }
                        this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
                    } else {
                        meshInstances[i].material = this.system.defaultMaterial;
                    }
                }
            }
        }
    });

    function ModelComponentData() {
        this.enabled = true;
    }

    var _schema$a = [
        'enabled'
    ];

    /**
     * @class
     * @name pc.ModelComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Allows an Entity to render a model or a primitive shape like a box,
     * capsule, sphere, cylinder, cone etc.
     * @description Create a new ModelComponentSystem.
     * @param {pc.Application} app - The Application.
     */
    function ModelComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'model';
        this.description = "Renders a 3D model at the location of the Entity.";

        this.ComponentType = ModelComponent;
        this.DataType = ModelComponentData;

        this.schema = _schema$a;

        this.box = null;
        this.capsule = null;
        this.cone = null;
        this.cylinder = null;
        this.plane = null;
        this.sphere = null;

        this.defaultMaterial = app.scene.defaultMaterial;

        this.on('beforeremove', this.onRemove, this);
    }
    ModelComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ModelComponentSystem.prototype.constructor = ModelComponentSystem;

    Component._buildAccessors(ModelComponent.prototype, _schema$a);

    Object.assign(ModelComponentSystem.prototype, {
        initializeComponentData: function (component, _data, properties) {
            // order matters here
            properties = [
                'material',
                'materialAsset',
                'asset',
                'castShadows',
                'receiveShadows',
                'castShadowsLightmap',
                'lightmapped',
                'lightmapSizeMultiplier',
                'type',
                'mapping',
                'layers',
                'isStatic',
                'batchGroupId'
            ];

            if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
                _data.batchGroupId = -1;
            }

            // duplicate layer list
            if (_data.layers && _data.layers.length) {
                _data.layers = _data.layers.slice(0);
            }

            for (var i = 0; i < properties.length; i++) {
                if (_data.hasOwnProperty(properties[i])) {
                    component[properties[i]] = _data[properties[i]];
                }
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, _data, ['enabled']);
        },

        cloneComponent: function (entity, clone) {
            var data = {
                type: entity.model.type,
                asset: entity.model.asset,
                castShadows: entity.model.castShadows,
                receiveShadows: entity.model.receiveShadows,
                castShadowsLightmap: entity.model.castShadowsLightmap,
                lightmapped: entity.model.lightmapped,
                lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
                isStatic: entity.model.isStatic,
                enabled: entity.model.enabled,
                layers: entity.model.layers,
                batchGroupId: entity.model.batchGroupId,
                mapping: extend({}, entity.model.mapping)
            };

            // if original has a different material
            // than the assigned materialAsset then make sure we
            // clone that one instead of the materialAsset one
            var materialAsset = entity.model.materialAsset;
            if (!(materialAsset instanceof Asset) && materialAsset != null) {
                materialAsset = this.app.assets.get(materialAsset);
            }

            var material = entity.model.material;
            if (!material ||
                material === this.defaultMaterial ||
                !materialAsset ||
                material === materialAsset.resource) {

                data.materialAsset = materialAsset;
            }

            var component = this.addComponent(clone, data);

            // clone the original model if the original model component is of type asset but
            // has no specified asset
            if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
                component.model = entity.model.model.clone();
                component._clonedModel = true;
            }

            if (!data.materialAsset)
                component.material = material;

            // TODO: we should copy all relevant meshinstance properties here
            if (entity.model.model) {
                var meshInstances = entity.model.model.meshInstances;
                var meshInstancesClone = component.model.meshInstances;
                for (var i = 0; i < meshInstances.length; i++) {
                    meshInstancesClone[i].mask = meshInstances[i].mask;
                    meshInstancesClone[i].material = meshInstances[i].material;
                    meshInstancesClone[i].layer = meshInstances[i].layer;
                    meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
                }
            }
        },

        onRemove: function (entity, component) {
            component.onRemove();
        }
    });

    // properties that do not need rebuilding the particle system
    var SIMPLE_PROPERTIES = [
        'emitterExtents',
        'emitterRadius',
        'emitterExtentsInner',
        'emitterRadiusInner',
        'loop',
        'initialVelocity',
        'animSpeed',
        'normalMap',
        'particleNormal'
    ];

    // properties that need rebuilding the particle system
    var COMPLEX_PROPERTIES = [
        'numParticles',
        'lifetime',
        'rate',
        'rate2',
        'startAngle',
        'startAngle2',
        'lighting',
        'halfLambert',
        'intensity',
        'wrap',
        'wrapBounds',
        'depthWrite',
        'noFog',
        'sort',
        'stretch',
        'alignToMotion',
        'preWarm',
        'emitterShape',
        'animTilesX',
        'animTilesY',
        'animStartFrame',
        'animNumFrames',
        'animNumAnimations',
        'animIndex',
        'randomizeAnimIndex',
        'animLoop',
        'colorMap',
        'localSpace',
        'orientation'
    ];

    var GRAPH_PROPERTIES = [
        'scaleGraph',
        'scaleGraph2',

        'colorGraph',
        'colorGraph2',

        'alphaGraph',
        'alphaGraph2',

        'velocityGraph',
        'velocityGraph2',

        'localVelocityGraph',
        'localVelocityGraph2',

        'rotationSpeedGraph',
        'rotationSpeedGraph2',

        'radialSpeedGraph',
        'radialSpeedGraph2'
    ];

    var ASSET_PROPERTIES = [
        'colorMapAsset',
        'normalMapAsset',
        'meshAsset'
    ];

    var depthLayer$1;

    /**
     * @component
     * @class
     * @name pc.ParticleSystemComponent
     * @augments pc.Component
     * @classdesc Used to simulate particles and produce renderable particle mesh on either CPU or GPU.
     * GPU simulation is generally much faster than its CPU counterpart, because it avoids slow CPU-GPU synchronization and takes advantage of many GPU cores.
     * However, it requires client to support reasonable uniform count, reading from multiple textures in vertex shader and OES_texture_float extension, including rendering into float textures.
     * Most mobile devices fail to satisfy these requirements, so it's not recommended to simulate thousands of particles on them. GPU version also can't sort particles, so enabling sorting forces CPU mode too.
     * Particle rotation is specified by a single angle parameter: default billboard particles rotate around camera facing axis, while mesh particles rotate around 2 different view-independent axes.
     * Most of the simulation parameters are specified with pc.Curve or pc.CurveSet. Curves are interpolated based on each particle's lifetime, therefore parameters are able to change over time.
     * Most of the curve parameters can also be specified by 2 minimum/maximum curves, this way each particle will pick a random value in-between.
     * @description Create a new ParticleSystemComponent.
     * @param {pc.ParticleSystemComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity this Component is attached to.
     * @property {boolean} autoPlay Controls whether the particle system plays automatically on creation. If set to false, it is necessary to call {@link pc.ParticleSystemComponent#play} for the particle system to play. Defaults to true.
     * @property {boolean} loop Enables or disables respawning of particles.
     * @property {boolean} preWarm If enabled, the particle system will be initialized as though it had already completed a full cycle. This only works with looping particle systems.
     * @property {boolean} lighting If enabled, particles will be lit by ambient and directional lights.
     * @property {boolean} halfLambert Enabling Half Lambert lighting avoids particles looking too flat in shadowed areas. It is a completely non-physical lighting model but can give more pleasing visual results.
     * @property {boolean} alignToMotion Orient particles in their direction of motion.
     * @property {boolean} depthWrite If enabled, the particles will write to the depth buffer. If disabled, the depth buffer is left unchanged and particles will be guaranteed to overwrite one another in the order in which they are rendered.
     * @property {boolean} noFog Disable fogging.
     * @property {boolean} localSpace Binds particles to emitter transformation rather then world space.
     * @property {number} numParticles Maximum number of simulated particles.
     * @property {number} rate Minimal interval in seconds between particle births.
     * @property {number} rate2 Maximal interval in seconds between particle births.
     * @property {number} startAngle Minimal initial Euler angle of a particle.
     * @property {number} startAngle2 Maximal initial Euler angle of a particle.
     * @property {number} lifetime The length of time in seconds between a particle's birth and its death.
     * @property {number} stretch A value in world units that controls the amount by which particles are stretched based on their velocity. Particles are stretched from their center towards their previous position.
     * @property {number} intensity Color multiplier.
     * @property {boolean} animLoop Controls whether the sprite sheet animation plays once or loops continuously.
     * @property {number} animTilesX Number of horizontal tiles in the sprite sheet.
     * @property {number} animTilesY Number of vertical tiles in the sprite sheet.
     * @property {number} animNumAnimations Number of sprite sheet animations contained within the current sprite sheet. The number of animations multiplied by number of frames should be a value less than animTilesX multiplied by animTilesY.
     * @property {number} animNumFrames Number of sprite sheet frames in the current sprite sheet animation. The number of animations multiplied by number of frames should be a value less than animTilesX multiplied by animTilesY.
     * @property {number} animStartFrame The sprite sheet frame that the animation should begin playing from. Indexed from the start of the current animation.
     * @property {number} animIndex When animNumAnimations is greater than 1, the sprite sheet animation index determines which animation the particle system should play.
     * @property {number} randomizeAnimIndex Each particle emitted by the system will play a random animation from the sprite sheet, up to animNumAnimations.
     * @property {number} animSpeed Sprite sheet animation speed. 1 = particle lifetime, 2 = twice during lifetime etc...
     * @property {number} depthSoftening Controls fading of particles near their intersections with scene geometry. This effect, when it's non-zero, requires scene depth map to be rendered. Multiple depth-dependent effects can share the same map, but if you only use it for particles, bear in mind that it can double engine draw calls.
     * @property {number} initialVelocity Defines magnitude of the initial emitter velocity. Direction is given by emitter shape.
     * @property {pc.Vec3} emitterExtents (Only for EMITTERSHAPE_BOX) The extents of a local space bounding box within which particles are spawned at random positions.
     * @property {pc.Vec3} emitterExtentsInner (Only for EMITTERSHAPE_BOX) The exception of extents of a local space bounding box within which particles are not spawned. Aligned to the center of EmitterExtents.
     * @property {number} emitterRadius (Only for EMITTERSHAPE_SPHERE) The radius within which particles are spawned at random positions.
     * @property {number} emitterRadiusInner (Only for EMITTERSHAPE_SPHERE) The inner radius within which particles are not spawned.
     * @property {pc.Vec3} wrapBounds The half extents of a world space box volume centered on the owner entity's position. If a particle crosses the boundary of one side of the volume, it teleports to the opposite side.
     * @property {pc.Asset} colorMapAsset The {@link pc.Asset} used to set the colorMap.
     * @property {pc.Asset} normalMapAsset The {@link pc.Asset} used to set the normalMap.
     * @property {pc.Asset} meshAsset The {@link pc.Asset} used to set the mesh.
     * @property {pc.Texture} colorMap The color map texture to apply to all particles in the system. If no texture is assigned, a default spot texture is used.
     * @property {pc.Texture} normalMap The normal map texture to apply to all particles in the system. If no texture is assigned, an approximate spherical normal is calculated for each vertex.
     * @property {number} emitterShape Shape of the emitter. Defines the bounds inside which particles are spawned. Also affects the direction of initial velocity.
     *
     * * {@link pc.EMITTERSHAPE_BOX}: Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
     * * {@link pc.EMITTERSHAPE_SPHERE}: Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the center.
     *
     * @property {number} sort Sorting mode. Forces CPU simulation, so be careful.
     *
     * * {@link pc.PARTICLESORT_NONE}: No sorting, particles are drawn in arbitary order. Can be simulated on GPU.
     * * {@link pc.PARTICLESORT_DISTANCE}: Sorting based on distance to the camera. CPU only.
     * * {@link pc.PARTICLESORT_NEWER_FIRST}: Newer particles are drawn first. CPU only.
     * * {@link pc.PARTICLESORT_OLDER_FIRST}: Older particles are drawn first. CPU only.
     *
     * @property {pc.Mesh} mesh Triangular mesh to be used as a particle. Only first vertex/index buffer is used. Vertex buffer must contain local position at first 3 floats of each vertex.
     * @property {number} blend Controls how particles are blended when being written to the currently active render target.
     * Can be:
     *
     * * {@link pc.BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is equivalent to enabling a source blend mode of pc.BLENDMODE_SRC_ALPHA and a destination blend mode of pc.BLENDMODE_ONE_MINUS_SRC_ALPHA.
     * * {@link pc.BLEND_NONE}: Disable blending.
     * * {@link pc.BLEND_PREMULTIPLIED}: Similar to pc.BLEND_NORMAL expect the source fragment is assumed to have already been multiplied by the source alpha value.
     * * {@link pc.BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_ADDITIVEALPHA}: Same as pc.BLEND_ADDITIVE except the source RGB is multiplied by the source alpha.
     *
     * @property {number} orientation Sorting mode. Forces CPU simulation, so be careful.
     *
     * * {@link pc.PARTICLEORIENTATION_SCREEN}: Particles are facing camera.
     * * {@link pc.PARTICLEORIENTATION_WORLD}: User defines world space normal (particleNormal) to set planes orientation.
     * * {@link pc.PARTICLEORIENTATION_EMITTER}: Similar to previous, but the normal is affected by emitter(entity) transformation.
     *
     * @property {pc.Vec3} particleNormal (Only for PARTICLEORIENTATION_WORLD and PARTICLEORIENTATION_EMITTER) The exception of extents of a local space bounding box within which particles are not spawned. Aligned to the center of EmitterExtents.
     * @property {pc.CurveSet} localVelocityGraph Velocity relative to emitter over lifetime.
     * @property {pc.CurveSet} localVelocityGraph2 If not null, particles pick random values between localVelocityGraph and localVelocityGraph2.
     * @property {pc.CurveSet} velocityGraph World-space velocity over lifetime.
     * @property {pc.CurveSet} velocityGraph2 If not null, particles pick random values between velocityGraph and velocityGraph2.
     * @property {pc.CurveSet} colorGraph Color over lifetime.
     * @property {pc.Curve} rotationSpeedGraph Rotation speed over lifetime.
     * @property {pc.Curve} rotationSpeedGraph2 If not null, particles pick random values between rotationSpeedGraph and rotationSpeedGraph2.
     * @property {pc.Curve} radialSpeedGraph Radial speed over lifetime, velocity vector points from emitter origin to particle pos.
     * @property {pc.Curve} radialSpeedGraph2 If not null, particles pick random values between radialSpeedGraph and radialSpeedGraph2.
     * @property {pc.Curve} scaleGraph Scale over lifetime.
     * @property {pc.Curve} scaleGraph2 If not null, particles pick random values between scaleGraph and scaleGraph2.
     * @property {pc.Curve} alphaGraph Alpha over lifetime.
     * @property {pc.Curve} alphaGraph2 If not null, particles pick random values between alphaGraph and alphaGraph2.
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this particle system should belong.
     * Don't push/pop/splice or modify this array, if you want to change it - set a new one instead.
     */
    var ParticleSystemComponent = function ParticleSystemComponent(system, entity) {
        Component.call(this, system, entity);

        this.on("set_colorMapAsset", this.onSetColorMapAsset, this);
        this.on("set_normalMapAsset", this.onSetNormalMapAsset, this);
        this.on("set_meshAsset", this.onSetMeshAsset, this);
        this.on("set_mesh", this.onSetMesh, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_blendType", this.onSetBlendType, this);
        this.on("set_depthSoftening", this.onSetDepthSoftening, this);
        this.on("set_layers", this.onSetLayers, this);

        SIMPLE_PROPERTIES.forEach(function (prop) {
            this.on('set_' + prop, this.onSetSimpleProperty, this);
        }.bind(this));

        COMPLEX_PROPERTIES.forEach(function (prop) {
            this.on('set_' + prop, this.onSetComplexProperty, this);
        }.bind(this));

        GRAPH_PROPERTIES.forEach(function (prop) {
            this.on('set_' + prop, this.onSetGraphProperty, this);
        }.bind(this));

        this._requestedDepth = false;
    };
    ParticleSystemComponent.prototype = Object.create(Component.prototype);
    ParticleSystemComponent.prototype.constructor = ParticleSystemComponent;

    Object.assign(ParticleSystemComponent.prototype, {
        addModelToLayers: function () {
            if (!this.data.model) return;
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.addMeshInstances(this.data.model.meshInstances);
                this.emitter._layer = layer;
            }
        },

        removeModelFromLayers: function (model) {
            if (!this.data.model) return;
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.removeMeshInstances(this.data.model.meshInstances);
            }
        },

        onSetLayers: function (name, oldValue, newValue) {
            if (!this.data.model) return;
            var i, layer;
            for (i = 0; i < oldValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
                if (!layer) continue;
                layer.removeMeshInstances(this.data.model.meshInstances);
            }
            if (!this.enabled || !this.entity.enabled) return;
            for (i = 0; i < newValue.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(newValue[i]);
                if (!layer) continue;
                layer.addMeshInstances(this.data.model.meshInstances);
            }
        },

        onLayersChanged: function (oldComp, newComp) {
            this.addModelToLayers();
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);
        },

        onLayerAdded: function (layer) {
            if (!this.data.model) return;
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.addMeshInstances(this.data.model.meshInstances);
        },

        onLayerRemoved: function (layer) {
            if (!this.data.model) return;
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.removeMeshInstances(this.data.model.meshInstances);
        },

        _bindColorMapAsset: function (asset) {
            asset.on('load', this._onColorMapAssetLoad, this);
            asset.on('unload', this._onColorMapAssetUnload, this);
            asset.on('remove', this._onColorMapAssetRemove, this);
            asset.on('change', this._onColorMapAssetChange, this);

            if (asset.resource) {
                this._onColorMapAssetLoad(asset);
            } else {
                // don't trigger an asset load unless the component is enabled
                if (!this.enabled || !this.entity.enabled) return;
                this.system.app.assets.load(asset);
            }
        },

        _unbindColorMapAsset: function (asset) {
            asset.off('load', this._onColorMapAssetLoad, this);
            asset.off('unload', this._onColorMapAssetUnload, this);
            asset.off('remove', this._onColorMapAssetRemove, this);
            asset.off('change', this._onColorMapAssetChange, this);
        },

        _onColorMapAssetLoad: function (asset) {
            this.colorMap = asset.resource;
        },

        _onColorMapAssetUnload: function (asset) {
            this.colorMap = null;
        },

        _onColorMapAssetRemove: function (asset) {
            this._onColorMapAssetUnload(asset);
        },

        _onColorMapAssetChange: function (asset) {
        },

        onSetColorMapAsset: function (name, oldValue, newValue) {
            var self = this;
            var asset;
            var assets = this.system.app.assets;
            if (oldValue) {
                asset = assets.get(oldValue);
                if (asset) {
                    this._unbindColorMapAsset(asset);
                }
            }

            if (newValue) {
                if (newValue instanceof Asset) {
                    this.data.colorMapAsset = newValue.id;
                    newValue = newValue.id;
                }

                asset = assets.get(newValue);
                if (asset) {
                    self._bindColorMapAsset(asset);
                } else {
                    assets.once("add:" + newValue, function (asset) {
                        self._bindColorMapAsset(asset);
                    });
                }
            } else {
                this.colorMap = null;
            }
        },

        _bindNormalMapAsset: function (asset) {
            asset.on('load', this._onNormalMapAssetLoad, this);
            asset.on('unload', this._onNormalMapAssetUnload, this);
            asset.on('remove', this._onNormalMapAssetRemove, this);
            asset.on('change', this._onNormalMapAssetChange, this);

            if (asset.resource) {
                this._onNormalMapAssetLoad(asset);
            } else {
                // don't trigger an asset load unless the component is enabled
                if (!this.enabled || !this.entity.enabled) return;
                this.system.app.assets.load(asset);
            }
        },

        _unbindNormalMapAsset: function (asset) {
            asset.off('load', this._onNormalMapAssetLoad, this);
            asset.off('unload', this._onNormalMapAssetUnload, this);
            asset.off('remove', this._onNormalMapAssetRemove, this);
            asset.off('change', this._onNormalMapAssetChange, this);
        },

        _onNormalMapAssetLoad: function (asset) {
            this.normalMap = asset.resource;
        },

        _onNormalMapAssetUnload: function (asset) {
            this.normalMap = null;
        },

        _onNormalMapAssetRemove: function (asset) {
            this._onNormalMapAssetUnload(asset);
        },

        _onNormalMapAssetChange: function (asset) {
        },

        onSetNormalMapAsset: function (name, oldValue, newValue) {
            var self = this;
            var asset;
            var assets = this.system.app.assets;

            if (oldValue) {
                asset = assets.get(oldValue);
                if (asset) {
                    this._unbindNormalMapAsset(asset);
                }
            }

            if (newValue) {
                if (newValue instanceof Asset) {
                    this.data.normalMapAsset = newValue.id;
                    newValue = newValue.id;
                }

                asset = assets.get(newValue);
                if (asset) {
                    self._bindNormalMapAsset(asset);
                } else {
                    assets.once("add:" + newValue, function (asset) {
                        self._bindNormalMapAsset(asset);
                    });
                }
            } else {
                this.normalMap = null;
            }
        },

        _bindMeshAsset: function (asset) {
            asset.on('load', this._onMeshAssetLoad, this);
            asset.on('unload', this._onMeshAssetUnload, this);
            asset.on('remove', this._onMeshAssetRemove, this);
            asset.on('change', this._onMeshAssetChange, this);

            if (asset.resource) {
                this._onMeshAssetLoad(asset);
            } else {
                // don't trigger an asset load unless the component is enabled
                if (!this.enabled || !this.entity.enabled) return;
                this.system.app.assets.load(asset);
            }
        },

        _unbindMeshAsset: function (asset) {
            asset.off('load', this._onMeshAssetLoad, this);
            asset.off('unload', this._onMeshAssetUnload, this);
            asset.off('remove', this._onMeshAssetRemove, this);
            asset.off('change', this._onMeshAssetChange, this);
        },

        _onMeshAssetLoad: function (asset) {
            this._onMeshChanged(asset.resource);
        },

        _onMeshAssetUnload: function (asset) {
            this.mesh = null;
        },

        _onMeshAssetRemove: function (asset) {
            this._onMeshAssetUnload(asset);
        },

        _onMeshAssetChange: function (asset) {
        },

        onSetMeshAsset: function (name, oldValue, newValue) {
            var asset;
            var assets = this.system.app.assets;

            if (oldValue) {
                asset = assets.get(oldValue);
                if (asset) {
                    this._unbindMeshAsset(asset);
                }
            }

            if (newValue) {
                if (newValue instanceof Asset) {
                    this.data.meshAsset = newValue.id;
                    newValue = newValue.id;
                }

                asset = assets.get(newValue);
                if (asset) {
                    this._bindMeshAsset(asset);

                    if (asset.resource) {
                        this._onMeshChanged(asset.resource);
                    } else {
                        assets.load(asset);
                    }
                }
            } else {
                this._onMeshChanged(null);
            }
        },

        onSetMesh: function (name, oldValue, newValue) {
            // hack this for now
            // if the value being set is null, an asset or an asset id, then assume we are
            // setting the mesh asset, which will in turn update the mesh
            if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
                this.meshAsset = newValue;
            } else {
                this._onMeshChanged(newValue);
            }
        },

        _onMeshChanged: function (mesh) {
            if (mesh && !(mesh instanceof Mesh)) {
                // if mesh is a pc.Model, use the first meshInstance
                if (mesh.meshInstances[0]) {
                    mesh = mesh.meshInstances[0].mesh;
                } else {
                    mesh = null;
                }
            }

            this.data.mesh = mesh;

            if (this.emitter) {
                this.emitter.mesh = mesh;
                this.emitter.resetMaterial();
                this.rebuild();
            }
        },

        onSetLoop: function (name, oldValue, newValue) {
            if (this.emitter) {
                this.emitter[name] = newValue;
                this.emitter.resetTime();
            }
        },

        onSetBlendType: function (name, oldValue, newValue) {
            if (this.emitter) {
                this.emitter[name] = newValue;
                this.emitter.material.blendType = newValue;
                this.emitter.resetMaterial();
                this.rebuild();
            }
        },

        _requestDepth: function () {
            if (this._requestedDepth) return;
            if (!depthLayer$1) depthLayer$1 = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
            if (depthLayer$1) {
                depthLayer$1.incrementCounter();
                this._requestedDepth = true;
            }
        },

        _releaseDepth: function () {
            if (!this._requestedDepth) return;
            if (depthLayer$1) {
                depthLayer$1.decrementCounter();
                this._requestedDepth = false;
            }
        },

        onSetDepthSoftening: function (name, oldValue, newValue) {
            if (oldValue !== newValue) {
                if (newValue) {
                    if (this.enabled && this.entity.enabled) this._requestDepth();
                    if (this.emitter) this.emitter[name] = newValue;
                } else {
                    if (this.enabled && this.entity.enabled) this._releaseDepth();
                    if (this.emitter) this.emitter[name] = newValue;
                }
                if (this.emitter) {
                    this.reset();
                    this.emitter.resetMaterial();
                    this.rebuild();
                }
            }
        },

        onSetSimpleProperty: function (name, oldValue, newValue) {
            if (this.emitter) {
                this.emitter[name] = newValue;
                this.emitter.resetMaterial();
            }
        },

        onSetComplexProperty: function (name, oldValue, newValue) {
            if (this.emitter) {
                this.emitter[name] = newValue;
                this.emitter.resetMaterial();
                this.rebuild();
                this.reset();
            }
        },

        onSetGraphProperty: function (name, oldValue, newValue) {
            if (this.emitter) {
                this.emitter[name] = newValue;
                this.emitter.rebuildGraphs();
                this.emitter.resetMaterial();
            }
        },


        onEnable: function () {
            // get data store once
            var data = this.data;

            // load any assets that haven't been loaded yet
            for (var i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {
                var asset = data[ASSET_PROPERTIES[i]];
                if (asset) {
                    if (!(asset instanceof Asset)) {
                        var id = parseInt(asset, 10);
                        if (id >= 0) {
                            asset = this.system.app.assets.get(asset);
                        } else {
                            continue;
                        }
                    }

                    if (asset && !asset.resource) {
                        this.system.app.assets.load(asset);
                    }
                }
            }

            if (!this.emitter) {
                var mesh = data.mesh;

                // mesh might be an asset id of an asset
                // that hasn't been loaded yet
                if (!(mesh instanceof Mesh))
                    mesh = null;

                this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
                    numParticles: data.numParticles,
                    emitterExtents: data.emitterExtents,
                    emitterExtentsInner: data.emitterExtentsInner,
                    emitterRadius: data.emitterRadius,
                    emitterRadiusInner: data.emitterRadiusInner,
                    emitterShape: data.emitterShape,
                    initialVelocity: data.initialVelocity,
                    wrap: data.wrap,
                    localSpace: data.localSpace,
                    wrapBounds: data.wrapBounds,
                    lifetime: data.lifetime,
                    rate: data.rate,
                    rate2: data.rate2,

                    orientation: data.orientation,
                    particleNormal: data.particleNormal,

                    animTilesX: data.animTilesX,
                    animTilesY: data.animTilesY,
                    animStartFrame: data.animStartFrame,
                    animNumFrames: data.animNumFrames,
                    animNumAnimations: data.animNumAnimations,
                    animIndex: data.animIndex,
                    randomizeAnimIndex: data.randomizeAnimIndex,
                    animSpeed: data.animSpeed,
                    animLoop: data.animLoop,

                    startAngle: data.startAngle,
                    startAngle2: data.startAngle2,

                    scaleGraph: data.scaleGraph,
                    scaleGraph2: data.scaleGraph2,

                    colorGraph: data.colorGraph,
                    colorGraph2: data.colorGraph2,

                    alphaGraph: data.alphaGraph,
                    alphaGraph2: data.alphaGraph2,

                    localVelocityGraph: data.localVelocityGraph,
                    localVelocityGraph2: data.localVelocityGraph2,

                    velocityGraph: data.velocityGraph,
                    velocityGraph2: data.velocityGraph2,

                    rotationSpeedGraph: data.rotationSpeedGraph,
                    rotationSpeedGraph2: data.rotationSpeedGraph2,

                    radialSpeedGraph: data.radialSpeedGraph,
                    radialSpeedGraph2: data.radialSpeedGraph2,

                    colorMap: data.colorMap,
                    normalMap: data.normalMap,
                    loop: data.loop,
                    preWarm: data.preWarm,
                    sort: data.sort,
                    stretch: data.stretch,
                    alignToMotion: data.alignToMotion,
                    lighting: data.lighting,
                    halfLambert: data.halfLambert,
                    intensity: data.intensity,
                    depthSoftening: data.depthSoftening,
                    scene: this.system.app.scene,
                    mesh: mesh,
                    depthWrite: data.depthWrite,
                    noFog: data.noFog,
                    node: this.entity,
                    blendType: data.blendType
                });

                this.emitter.meshInstance.node = this.entity;

                this.psys = new Model();
                this.psys.graph = this.entity;
                this.psys.emitter = this.emitter;
                this.psys.meshInstances = [this.emitter.meshInstance];
                data.model = this.psys;
                this.emitter.psys = this.psys;

                if (!data.autoPlay) {
                    this.pause();
                    this.emitter.meshInstance.visible = false;
                }
            }

            if (data.model && this.emitter.colorMap) {
                this.addModelToLayers();
            }

            this.system.app.scene.on("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.on("add", this.onLayerAdded, this);
                this.system.app.scene.layers.on("remove", this.onLayerRemoved, this);
            }

            if (this.enabled && this.entity.enabled && data.depthSoftening) {
                this._requestDepth();
            }
        },

        onDisable: function () {
            this.system.app.scene.off("set:layers", this.onLayersChanged, this);
            if (this.system.app.scene.layers) {
                this.system.app.scene.layers.off("add", this.onLayerAdded, this);
                this.system.app.scene.layers.off("remove", this.onLayerRemoved, this);
            }

            if (this.data.model) {
                this.removeModelFromLayers();
                if (this.data.depthSoftening) this._releaseDepth();
            }

            if (this.emitter) {
                // clear camera as it isn't updated while disabled and we don't want to hold
                // onto old reference
                this.emitter.camera = null;
            }
        },

        onBeforeRemove: function () {
            if (this.enabled) {
                this.enabled = false;
            }

            var data = this.data;
            if (data.model) {
                this.entity.removeChild(data.model.getGraph());
                data.model.destroy();
                data.model = null;
            }

            if (this.emitter) {
                this.emitter.destroy();
                this.emitter = null;
            }

            // clear all asset properties to remove any event listeners
            for (var i = 0; i < ASSET_PROPERTIES.length; i++) {
                var prop = ASSET_PROPERTIES[i];

                if (data[prop]) {
                    this[prop] = null;
                }
            }

            this.off();
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#reset
         * @description Resets particle state, doesn't affect playing.
         */
        reset: function () {
            if (this.emitter) {
                this.emitter.reset();
            }
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#stop
         * @description Disables the emission of new particles, lets existing to finish their simulation.
         */
        stop: function () {
            if (this.emitter) {
                this.emitter.loop = false;
                this.emitter.resetTime();
                this.emitter.addTime(0, true);
            }
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#pause
         * @description Freezes the simulation.
         */
        pause: function () {
            this.data.paused = true;
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#unpause
         * @description Unfreezes the simulation.
         */
        unpause: function () {
            this.data.paused = false;
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#play
         * @description Enables/unfreezes the simulation.
         */
        play: function () {
            this.data.paused = false;
            if (this.emitter) {
                this.emitter.meshInstance.visible = true;
                this.emitter.loop = this.data.loop;
                this.emitter.resetTime();
            }
        },

        /**
         * @function
         * @name pc.ParticleSystemComponent#isPlaying
         * @description Checks if simulation is in progress.
         * @returns {boolean} True if the particle system is currently playing and false otherwise.
         */
        isPlaying: function () {
            if (this.data.paused) {
                return false;
            }
            if (this.emitter && this.emitter.loop) {
                return true;
            }

            // possible bug here what happens if the non looping emitter
            // was paused in the meantime?
            return Date.now() <= this.emitter.endTime;
        },

        /**
         * @private
         * @function
         * @name pc.ParticleSystemComponent#rebuild
         * @description Rebuilds all data used by this particle system.
         */
        rebuild: function () {
            var enabled = this.enabled;
            this.enabled = false;
            if (this.emitter) {
                this.emitter.rebuild(); // worst case: required to rebuild buffers/shaders
                this.emitter.meshInstance.node = this.entity;
                this.data.model.meshInstances = [this.emitter.meshInstance];
            }
            this.enabled = enabled;
        }
    });

    function ParticleSystemComponentData() {
        this.numParticles = 1;                  // Amount of particles allocated (max particles = max GL texture width at this moment)
        this.rate = 1;                          // Emission rate
        this.rate2 = null;
        this.startAngle = 0;
        this.startAngle2 = null;
        this.lifetime = 50;                     // Particle lifetime
        this.emitterExtents = new Vec3();       // Spawn point divergence
        this.emitterExtentsInner = new Vec3();
        this.emitterRadius = 0;
        this.emitterRadiusInner = 0;
        this.emitterShape = EMITTERSHAPE_BOX;
        this.initialVelocity = 0;
        this.wrapBounds = new Vec3();
        this.localSpace = false;
        this.colorMap = null;
        this.colorMapAsset = null;
        this.normalMap = null;
        this.normalMapAsset = null;
        this.loop = true;
        this.preWarm = false;
        this.sort = 0;                          // Sorting mode: 0 = none, 1 = by distance, 2 = by life, 3 = by -life;   Forces CPU mode if not 0
        this.mode = PARTICLEMODE_GPU;
        this.scene = null;
        this.lighting = false;
        this.halfLambert = false;            // Uses half-lambert lighting instead of Lambert
        this.intensity = 1;
        this.stretch = 0.0;
        this.alignToMotion = false;
        this.depthSoftening = 0;
        this.meshAsset = null;
        this.mesh = null;                       // Mesh to be used as particle. Vertex buffer is supposed to hold vertex position in first 3 floats of each vertex
                                                // Leave undefined to use simple quads
        this.depthWrite = false;
        this.noFog = false;

        this.orientation = PARTICLEORIENTATION_SCREEN;
        this.particleNormal = new Vec3(0, 1, 0);

        this.animTilesX = 1;
        this.animTilesY = 1;
        this.animStartFrame = 0;
        this.animNumFrames = 1;
        this.animNumAnimations = 1;
        this.animIndex = 0;
        this.randomizeAnimIndex = false;
        this.animSpeed = 1;
        this.animLoop = true;

        // Time-dependent parameters
        this.scaleGraph = null;
        this.scaleGraph2 = null;

        this.colorGraph = null;
        this.colorGraph2 = null;

        this.alphaGraph = null;
        this.alphaGraph2 = null;

        this.localVelocityGraph = null;
        this.localVelocityGraph2 = null;

        this.velocityGraph = null;
        this.velocityGraph2 = null;

        this.rotationSpeedGraph = null;
        this.rotationSpeedGraph2 = null;

        this.radialSpeedGraph = null;
        this.radialSpeedGraph2 = null;

        this.blendType = BLEND_NORMAL;

        this.model = null;

        this.enabled = true;

        this.paused = false;

        this.autoPlay = true;

        this.layers = [LAYERID_WORLD]; // assign to the default world layer
    }

    var _schema$b = [
        'enabled',
        'autoPlay',
        'numParticles',
        'lifetime',
        'rate',
        'rate2',
        'startAngle',
        'startAngle2',
        'loop',
        'preWarm',
        'lighting',
        'halfLambert',
        'intensity',
        'depthWrite',
        'noFog',
        'depthSoftening',
        'sort',
        'blendType',
        'stretch',
        'alignToMotion',
        'emitterShape',
        'emitterExtents',
        'emitterExtentsInner',
        'emitterRadius',
        'emitterRadiusInner',
        'initialVelocity',
        'wrap',
        'wrapBounds',
        'localSpace',
        'colorMapAsset',
        'normalMapAsset',
        'mesh',
        'meshAsset',
        'orientation',
        'particleNormal',
        'localVelocityGraph',
        'localVelocityGraph2',
        'velocityGraph',
        'velocityGraph2',
        'rotationSpeedGraph',
        'rotationSpeedGraph2',
        'radialSpeedGraph',
        'radialSpeedGraph2',
        'scaleGraph',
        'scaleGraph2',
        'colorGraph',
        'colorGraph2',
        'alphaGraph',
        'alphaGraph2',
        'colorMap',
        'normalMap',
        'animTilesX',
        'animTilesY',
        'animStartFrame',
        'animNumFrames',
        'animNumAnimations',
        'animIndex',
        'randomizeAnimIndex',
        'animSpeed',
        'animLoop',
        'layers'
    ];

    /**
     * @class
     * @name pc.ParticleSystemComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Allows an Entity to render a particle system.
     * @description Create a new ParticleSystemComponentSystem.
     * @param {pc.Application} app - The Application.
     */
    function ParticleSystemComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'particlesystem';
        this.description = "Updates and renders particle system in the scene.";

        this.ComponentType = ParticleSystemComponent;
        this.DataType = ParticleSystemComponentData;

        this.schema = _schema$b;

        this.propertyTypes = {
            emitterExtents: 'vec3',
            emitterExtentsInner: 'vec3',
            particleNormal: 'vec3',
            wrapBounds: 'vec3',
            localVelocityGraph: 'curveset',
            localVelocityGraph2: 'curveset',
            velocityGraph: 'curveset',
            velocityGraph2: 'curveset',
            colorGraph: 'curveset',
            colorGraph2: 'curveset',
            alphaGraph: 'curve',
            alphaGraph2: 'curve',
            rotationSpeedGraph: 'curve',
            rotationSpeedGraph2: 'curve',
            radialSpeedGraph: 'curve',
            radialSpeedGraph2: 'curve',
            scaleGraph: 'curve',
            scaleGraph2: 'curve'
        };

        this.on('beforeremove', this.onBeforeRemove, this);
        ComponentSystem.bind('update', this.onUpdate, this);
    }
    ParticleSystemComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ParticleSystemComponentSystem.prototype.constructor = ParticleSystemComponentSystem;

    Component._buildAccessors(ParticleSystemComponent.prototype, _schema$b);

    Object.assign(ParticleSystemComponentSystem.prototype, {

        initializeComponentData: function (component, _data, properties) {
            var data = {};

            properties = [];
            var types = this.propertyTypes;
            var t;

            // we store the mesh asset id as "mesh" (it should be "meshAsset")
            // this re-maps "mesh" into "meshAsset" if it is an asset or an asset id
            if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
                // migrate into meshAsset property
                _data.meshAsset = _data.mesh;
                delete _data.mesh;
            }

            for (var prop in _data) {
                if (_data.hasOwnProperty(prop)) {
                    properties.push(prop);
                    // duplicate input data as we are modifying it
                    data[prop] = _data[prop];
                }

                if (types[prop] === 'vec3') {
                    if (type(data[prop]) === 'array') {
                        data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
                    }
                } else if (types[prop] === 'curve') {
                    if (!(data[prop] instanceof Curve)) {
                        t = data[prop].type;
                        data[prop] = new Curve(data[prop].keys);
                        data[prop].type = t;
                    }
                } else if (types[prop] === 'curveset') {
                    if (!(data[prop] instanceof CurveSet)) {
                        t = data[prop].type;
                        data[prop] = new CurveSet(data[prop].keys);
                        data[prop].type = t;
                    }
                }

                // duplicate layer list
                if (data.layers && type(data.layers) === 'array') {
                    data.layers = data.layers.slice(0);
                }
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var source = entity.particlesystem.data;
            var schema = this.schema;

            var data = {};

            for (var i = 0, len = schema.length; i < len; i++) {
                var prop = schema[i];
                var sourceProp = source[prop];
                if (sourceProp instanceof Vec3 ||
                    sourceProp instanceof Curve ||
                    sourceProp instanceof CurveSet) {

                    sourceProp = sourceProp.clone();
                    data[prop] = sourceProp;
                } else if (prop === "layers") {
                    data.layers = source.layers.slice(0);
                } else {
                    if (sourceProp !== null && sourceProp !== undefined) {
                        data[prop] = sourceProp;
                    }
                }
            }

            return this.addComponent(clone, data);
        },

        onUpdate: function (dt) {
            var components = this.store;
            var numSteps, i, j, c;
            var stats = this.app.stats.particles;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    c = components[id];
                    var entity = c.entity;
                    var data = c.data;

                    if (data.enabled && entity.enabled) {
                        var emitter = data.model.emitter;
                        if (!emitter.meshInstance.visible) continue;

                        // Bake ambient and directional lighting into one ambient cube
                        // TODO: only do if lighting changed
                        // TODO: don't do for every emitter
                        if (emitter.lighting) {
                            var layer, lightCube;
                            var layers = data.layers;
                            for (i = 0; i < layers.length; i++) {
                                layer = this.app.scene.layers.getLayerById(layers[i]);
                                if (!layer) continue;

                                if (!layer._lightCube) {
                                    layer._lightCube = new Float32Array(6 * 3);
                                }
                                lightCube = layer._lightCube;
                                for (i = 0; i < 6; i++) {
                                    lightCube[i * 3] = this.app.scene.ambientLight.r;
                                    lightCube[i * 3 + 1] = this.app.scene.ambientLight.g;
                                    lightCube[i * 3 + 2] = this.app.scene.ambientLight.b;
                                }
                                var dirs = layer._sortedLights[LIGHTTYPE_DIRECTIONAL];
                                for (j = 0; j < dirs.length; j++) {
                                    for (c = 0; c < 6; c++) {
                                        var weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;
                                        lightCube[c * 3] += dirs[j]._color.r * weight;
                                        lightCube[c * 3 + 1] += dirs[j]._color.g * weight;
                                        lightCube[c * 3 + 2] += dirs[j]._color.b * weight;
                                    }
                                }
                            }
                            emitter.constantLightCube.setValue(lightCube); // ?
                        }

                        if (!data.paused) {
                            emitter.simTime += dt;
                            if (emitter.simTime > emitter.fixedTimeStep) {
                                numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
                                emitter.simTime -= numSteps * emitter.fixedTimeStep;
                            }
                            if (numSteps) {
                                numSteps = Math.min(numSteps, emitter.maxSubSteps);
                                for (i = 0; i < numSteps; i++) {
                                    emitter.addTime(emitter.fixedTimeStep, false);
                                }
                                stats._updatesPerFrame += numSteps;
                                stats._frameTime += emitter._addTimeTime;
                                emitter._addTimeTime = 0;
                            }
                            emitter.finishFrame();
                        }
                    }
                }
            }
        },

        onBeforeRemove: function (entity, component) {
            component.onBeforeRemove();
        }
    });

    function AllocatePool(constructor, size) {
        this._constructor = constructor;
        this._pool = [];
        this._count = 0;

        this._resize(size);
    }

    Object.assign(AllocatePool.prototype, {
        _resize: function (size) {
            if (size > this._pool.length) {
                for (var i = this._pool.length; i < size; i++) {
                    this._pool[i] = new this._constructor();
                }
            }
        },

        allocate: function () {
            if (this._count >= this._pool.length) {
                this._resize(this._pool.length * 2);
            }
            return this._pool[this._count++];
        },

        freeAll: function () {
            this._count = 0;
        }
    });

    // Shared math variable to avoid excessive allocation
    var ammoTransform$1;
    var ammoVec1$1, ammoVec2, ammoQuat$1, ammoOrigin;

    /**
     * @component
     * @class
     * @name pc.RigidBodyComponent
     * @augments pc.Component
     * @classdesc The rigidbody component, when combined with a {@link pc.CollisionComponent}, allows your
     * entities to be simulated using realistic physics.
     * A rigidbody component will fall under gravity and collide with other rigid bodies. Using scripts, you
     * can apply forces and impulses to rigid bodies.
     * @description Create a new RigidBodyComponent.
     * @param {pc.RigidBodyComponentSystem} system - The ComponentSystem that created this component.
     * @param {pc.Entity} entity - The entity this component is attached to.
     * @property {number} mass The mass of the body. This is only relevant for {@link pc.BODYTYPE_DYNAMIC}
     * bodies, other types have infinite mass. Defaults to 1.
     * @property {pc.Vec3} linearVelocity Defines the speed of the body in a given direction.
     * @property {pc.Vec3} angularVelocity Defines the rotational speed of the body around each world axis.
     * @property {number} linearDamping Controls the rate at which a body loses linear velocity over time.
     * Defaults to 0.
     * @property {number} angularDamping Controls the rate at which a body loses angular velocity over time.
     * Defaults to 0.
     * @property {pc.Vec3} linearFactor Scaling factor for linear movement of the body in each axis. Only
     * valid for rigid bodies of type pc.BODYTYPE_DYNAMIC. Defaults to 1 in all axes.
     * @property {pc.Vec3} angularFactor Scaling factor for angular movement of the body in each axis. Only
     * valid for rigid bodies of type pc.BODYTYPE_DYNAMIC. Defaults to 1 in all axes.
     * @property {number} friction The friction value used when contacts occur between two bodies. A higher
     * value indicates more friction. Should be set in the range 0 to 1. Defaults to 0.5.
     * @property {number} restitution Influences the amount of energy lost when two rigid bodies collide. The
     * calculation multiplies the restitution values for both colliding bodies. A multiplied value of 0 means
     * that all energy is lost in the collision while a value of 1 means that no energy is lost. Should be
     * set in the range 0 to 1. Defaults to 0.
     * @property {number} group The collision group this body belongs to. Combine the group and the mask to
     * prevent bodies colliding with each other. Defaults to 1.
     * @property {number} mask The collision mask sets which groups this body collides with. It is a bitfield
     * of 16 bits, the first 8 bits are reserved for engine use. Defaults to 65535.
     * @property {string} type The rigid body type determines how the body is simulated. Can be:
     *
     * * {@link pc.BODYTYPE_STATIC}: infinite mass and cannot move.
     * * {@link pc.BODYTYPE_DYNAMIC}: simulated according to applied forces.
     * * {@link pc.BODYTYPE_KINEMATIC}: infinite mass and does not respond to forces but can still be moved
     * by setting their velocity or position.
     *
     * Defaults to pc.BODYTYPE_STATIC.
     */
    function RigidBodyComponent(system, entity) {
        Component.call(this, system, entity);

        // Lazily create shared variable
        if (typeof Ammo !== 'undefined' && !ammoTransform$1) {
            ammoTransform$1 = new Ammo.btTransform();
            ammoVec1$1 = new Ammo.btVector3();
            ammoVec2 = new Ammo.btVector3();
            ammoQuat$1 = new Ammo.btQuaternion();
            ammoOrigin = new Ammo.btVector3(0, 0, 0);
        }

        this.on('set_mass', this.onSetMass, this);
        this.on('set_linearDamping', this.onSetLinearDamping, this);
        this.on('set_angularDamping', this.onSetAngularDamping, this);
        this.on('set_linearFactor', this.onSetLinearFactor, this);
        this.on('set_angularFactor', this.onSetAngularFactor, this);
        this.on('set_friction', this.onSetFriction, this);
        this.on('set_restitution', this.onSetRestitution, this);
        this.on('set_type', this.onSetType, this);
        this.on('set_group', this.onSetGroupOrMask, this);
        this.on('set_mask', this.onSetGroupOrMask, this);

        this.on('set_body', this.onSetBody, this);

        this._linearVelocity = new Vec3(0, 0, 0);
        this._angularVelocity = new Vec3(0, 0, 0);
    }
    RigidBodyComponent.prototype = Object.create(Component.prototype);
    RigidBodyComponent.prototype.constructor = RigidBodyComponent;

    // Events Documentation
    /**
     * @event
     * @name pc.RigidBodyComponent#contact
     * @description The 'contact' event is fired when a contact occurs between two rigid bodies.
     * @param {pc.ContactResult} result - Details of the contact between the two rigid bodies.
     */

    /**
     * @event
     * @name pc.RigidBodyComponent#collisionstart
     * @description The 'collisionstart' event is fired when two rigid bodies start touching.
     * @param {pc.ContactResult} result - Details of the contact between the two rigid bodies.
     */

    /**
     * @event
     * @name pc.RigidBodyComponent#collisionend
     * @description The 'collisionend' event is fired two rigid-bodies stop touching.
     * @param {pc.Entity} other - The {@link pc.Entity} that stopped touching this rigid body.
     */

    /**
     * @event
     * @name pc.RigidBodyComponent#triggerenter
     * @description The 'triggerenter' event is fired when a rigid body enters a trigger volume.
     * @param {pc.Entity} other - The {@link pc.Entity} with trigger volume that this rigidbody entered.
     */

    /**
     * @event
     * @name pc.RigidBodyComponent#triggerleave
     * @description The 'triggerleave' event is fired when a rigid body exits a trigger volume.
     * @param {pc.Entity} other - The {@link pc.Entity} with trigger volume that this rigidbody exited.
     */

    Object.defineProperty(RigidBodyComponent.prototype, "linearVelocity", {
        get: function () {
            var body = this.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                var vel = body.getLinearVelocity();
                this._linearVelocity.set(vel.x(), vel.y(), vel.z());
            }
            return this._linearVelocity;
        },
        set: function (lv) {
            var body = this.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                body.activate();

                ammoVec1$1.setValue(lv.x, lv.y, lv.z);
                body.setLinearVelocity(ammoVec1$1);

                this._linearVelocity.copy(lv);
            }
        }
    });

    Object.defineProperty(RigidBodyComponent.prototype, "angularVelocity", {
        get: function () {
            var body = this.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                var vel = body.getAngularVelocity();
                this._angularVelocity.set(vel.x(), vel.y(), vel.z());
            }
            return this._angularVelocity;
        },
        set: function (av) {
            var body = this.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                body.activate();

                ammoVec1$1.setValue(av.x, av.y, av.z);
                body.setAngularVelocity(ammoVec1$1);

                this._angularVelocity.copy(av);
            }
        }
    });

    Object.assign(RigidBodyComponent.prototype, {
        /**
         * @private
         * @function
         * @name pc.RigidBodyComponent#createBody
         * @description If the Entity has a Collision shape attached then create a rigid body using this shape. This method destroys the existing body.
         */
        createBody: function () {
            var entity = this.entity;
            var shape;

            if (entity.collision) {
                shape = entity.collision.shape;

                // if a trigger was already created from the collision system
                // destroy it
                if (entity.trigger) {
                    entity.trigger.destroy();
                    delete entity.trigger;
                }
            }

            if (shape) {
                if (this.body)
                    this.system.onRemove(this.entity, this);

                var mass = this.type === BODYTYPE_DYNAMIC ? this.mass : 0;

                this._getEntityTransform(ammoTransform$1);

                var body = this.system.createBody(mass, shape, ammoTransform$1);

                body.setRestitution(this.restitution);
                body.setFriction(this.friction);
                body.setDamping(this.linearDamping, this.angularDamping);

                if (this.type === BODYTYPE_DYNAMIC) {
                    var linearFactor = this.linearFactor;
                    ammoVec1$1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
                    body.setLinearFactor(ammoVec1$1);

                    var angularFactor = this.angularFactor;
                    ammoVec1$1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
                    body.setAngularFactor(ammoVec1$1);
                } else if (this.type === BODYTYPE_KINEMATIC) {
                    body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
                    body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
                }

                body.entity = entity;

                entity.rigidbody.body = body;

                if (this.enabled && this.entity.enabled) {
                    this.enableSimulation();
                }
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#isActive
         * @description Returns true if the rigid body is currently actively being simulated. I.e. Not 'sleeping'.
         * @returns {boolean} True if the body is active.
         */
        isActive: function () {
            var body = this.body;
            return body ? body.isActive() : false;
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#activate
         * @description Forcibly activate the rigid body simulation. Only affects rigid bodies of
         * type pc.BODYTYPE_DYNAMIC.
         */
        activate: function () {
            var body = this.body;
            if (body) {
                body.activate();
            }
        },

        enableSimulation: function () {
            if (this.entity.collision && this.entity.collision.enabled && !this.data.simulationEnabled) {
                var body = this.body;
                if (body) {
                    this.system.addBody(body, this.group, this.mask);

                    switch (this.type) {
                        case BODYTYPE_DYNAMIC:
                            this.system._dynamic.push(this);
                            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
                            this.syncEntityToBody();
                            break;
                        case BODYTYPE_KINEMATIC:
                            this.system._kinematic.push(this);
                            body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
                            break;
                        case BODYTYPE_STATIC:
                            body.forceActivationState(BODYSTATE_ACTIVE_TAG);
                            this.syncEntityToBody();
                            break;
                    }

                    if (this.entity.collision.type === 'compound') {
                        this.system._compounds.push(this.entity.collision);
                    }

                    body.activate();

                    this.data.simulationEnabled = true;
                }
            }
        },

        disableSimulation: function () {
            var body = this.body;
            if (body && this.data.simulationEnabled) {
                var idx;

                idx = this.system._compounds.indexOf(this.entity.collision);
                if (idx > -1) {
                    this.system._compounds.splice(idx, 1);
                }

                idx = this.system._dynamic.indexOf(this);
                if (idx > -1) {
                    this.system._dynamic.splice(idx, 1);
                }

                idx = this.system._kinematic.indexOf(this);
                if (idx > -1) {
                    this.system._kinematic.splice(idx, 1);
                }

                this.system.removeBody(body);

                // set activation state to disable simulation to avoid body.isActive() to return
                // true even if it's not in the dynamics world
                body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);

                this.data.simulationEnabled = false;
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#applyForce
         * @description Apply an force to the body at a point. By default, the force is applied at the origin of the
         * body. However, the force can be applied at an offset this point by specifying a world space vector from
         * the body's origin to the point of application. This function has two valid signatures. You can either
         * specify the force (and optional relative point) via 3D-vector or numbers.
         * @param {pc.Vec3|number} x - A 3-dimensional vector representing the force in world-space or
         * the x-component of the force in world-space.
         * @param {pc.Vec3|number} [y] - An optional 3-dimensional vector representing the relative point at
         * which to apply the impulse in world-space or the y-component of the force in world-space.
         * @param {number} [z] - The z-component of the force in world-space.
         * @param {number} [px] - The x-component of a world-space offset from the body's position where the force is applied.
         * @param {number} [py] - The y-component of a world-space offset from the body's position where the force is applied.
         * @param {number} [pz] - The z-component of a world-space offset from the body's position where the force is applied.
         * @example
         * // Apply an approximation of gravity at the body's center
         * this.entity.rigidbody.applyForce(0, -10, 0);
         * @example
         * // Apply an approximation of gravity at 1 unit down the world Z from the center of the body
         * this.entity.rigidbody.applyForce(0, -10, 0, 0, 0, 1);
         * @example
         * // Apply a force at the body's center
         * // Calculate a force vector pointing in the world space direction of the entity
         * var force = this.entity.forward.clone().scale(100);
         *
         * // Apply the force
         * this.entity.rigidbody.applyForce(force);
         * @example
         * // Apply a force at some relative offset from the body's center
         * // Calculate a force vector pointing in the world space direction of the entity
         * var force = this.entity.forward.clone().scale(100);
         *
         * // Calculate the world space relative offset
         * var relativePos = new pc.Vec3();
         * var childEntity = this.entity.findByName('Engine');
         * relativePos.sub2(childEntity.getPosition(), this.entity.getPosition());
         *
         * // Apply the force
         * this.entity.rigidbody.applyForce(force, relativePos);
         */
        applyForce: function () {
            var x, y, z;
            var px, py, pz;
            switch (arguments.length) {
                case 1:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    break;
                case 2:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    px = arguments[1].x;
                    py = arguments[1].y;
                    pz = arguments[1].z;
                    break;
                case 3:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    break;
                case 6:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    px = arguments[3];
                    py = arguments[4];
                    pz = arguments[5];
                    break;
            }
            var body = this.body;
            if (body) {
                body.activate();
                ammoVec1$1.setValue(x, y, z);
                if (px !== undefined) {
                    ammoVec2.setValue(px, py, pz);
                    body.applyForce(ammoVec1$1, ammoVec2);
                } else {
                    body.applyForce(ammoVec1$1, ammoOrigin);
                }

            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#applyTorque
         * @description Apply torque (rotational force) to the body. This function has two valid signatures.
         * You can either specify the torque force with a 3D-vector or with 3 numbers.
         * @param {pc.Vec3|number} x - A 3-dimensional vector representing the torque force in world-space or
         * the x-component of the torque force in world-space.
         * @param {number} [y] - The y-component of the torque force in world-space.
         * @param {number} [z] - The z-component of the torque force in world-space.
         * @example
         * // Apply via vector
         * var torque = new pc.Vec3(0, 10, 0);
         * entity.rigidbody.applyTorque(torque);
         * @example
         * // Apply via numbers
         * entity.rigidbody.applyTorque(0, 10, 0);
         */
        applyTorque: function () {
            var x, y, z;
            switch (arguments.length) {
                case 1:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    break;
                case 3:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    break;
                default:
                    return;
            }
            var body = this.body;
            if (body) {
                body.activate();
                ammoVec1$1.setValue(x, y, z);
                body.applyTorque(ammoVec1$1);
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#applyImpulse
         * @description Apply an impulse (instantaneous change of velocity) to the body at a point.
         * This function has two valid signatures. You can either specify the impulse (and optional relative
         * point) via 3D-vector or numbers.
         * @param {pc.Vec3|number} x - A 3-dimensional vector representing the impulse in world-space or
         * the x-component of the impulse in world-space.
         * @param {pc.Vec3|number} [y] - An optional 3-dimensional vector representing the relative point at
         * which to apply the impulse in the local-space of the entity or the y-component of the impulse to
         * apply in world-space.
         * @param {number} [z] - The z-component of the impulse to apply in world-space.
         * @param {number} [px=0] - The x-component of the point at which to apply the impulse in the local-space of the entity.
         * @param {number} [py=0] - The y-component of the point at which to apply the impulse in the local-space of the entity.
         * @param {number} [pz=0] - The z-component of the point at which to apply the impulse in the local-space of the entity.
         * @example
         * // Apply an impulse along the world-space positive y-axis at the entity's position.
         * var impulse = new pc.Vec3(0, 10, 0);
         * entity.rigidbody.applyImpulse(impulse);
         * @example
         * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
         * // z-axis of the entity's local-space.
         * var impulse = new pc.Vec3(0, 10, 0);
         * var relativePoint = new pc.Vec3(0, 0, 1);
         * entity.rigidbody.applyImpulse(impulse, relativePoint);
         * @example
         * // Apply an impulse along the world-space positive y-axis at the entity's position.
         * entity.rigidbody.applyImpulse(0, 10, 0);
         * @example
         * // Apply an impulse along the world-space positive y-axis at 1 unit down the positive
         * // z-axis of the entity's local-space.
         * entity.rigidbody.applyImpulse(0, 10, 0, 0, 0, 1);
         */
        applyImpulse: function () {
            var x, y, z;
            var px, py, pz;
            switch (arguments.length) {
                case 1:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    break;
                case 2:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    px = arguments[1].x;
                    py = arguments[1].y;
                    pz = arguments[1].z;
                    break;
                case 3:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    break;
                case 6:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    px = arguments[3];
                    py = arguments[4];
                    pz = arguments[5];
                    break;
                default:
                    return;
            }
            var body = this.body;
            if (body) {
                body.activate();
                ammoVec1$1.setValue(x, y, z);
                if (px !== undefined) {
                    ammoVec2.setValue(px, py, pz);
                    body.applyImpulse(ammoVec1$1, ammoVec2);
                } else {
                    body.applyImpulse(ammoVec1$1, ammoOrigin);
                }
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#applyTorqueImpulse
         * @description Apply a torque impulse (rotational force applied instantaneously) to the body.
         * This function has two valid signatures. You can either specify the torque force with a 3D-vector
         * or with 3 numbers.
         * @param {pc.Vec3|number} x - A 3-dimensional vector representing the torque impulse in world-space or
         * the x-component of the torque impulse in world-space.
         * @param {number} [y] - The y-component of the torque impulse in world-space.
         * @param {number} [z] - The z-component of the torque impulse in world-space.
         * @example
         * // Apply via vector
         * var torque = new pc.Vec3(0, 10, 0);
         * entity.rigidbody.applyTorqueImpulse(torque);
         * @example
         * // Apply via numbers
         * entity.rigidbody.applyTorqueImpulse(0, 10, 0);
         */
        applyTorqueImpulse: function () {
            var x, y, z;
            switch (arguments.length) {
                case 1:
                    x = arguments[0].x;
                    y = arguments[0].y;
                    z = arguments[0].z;
                    break;
                case 3:
                    x = arguments[0];
                    y = arguments[1];
                    z = arguments[2];
                    break;
                default:
                    return;
            }
            var body = this.body;
            if (body) {
                body.activate();
                ammoVec1$1.setValue(x, y, z);
                body.applyTorqueImpulse(ammoVec1$1);
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#isStatic
         * @description Returns true if the rigid body is of type {@link pc.BODYTYPE_STATIC}.
         * @returns {boolean} True if static.
         */
        isStatic: function () {
            return (this.type === BODYTYPE_STATIC);
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#isStaticOrKinematic
         * @description Returns true if the rigid body is of type {@link pc.BODYTYPE_STATIC} or {@link pc.BODYTYPE_KINEMATIC}.
         * @returns {boolean} True if static or kinematic.
         */
        isStaticOrKinematic: function () {
            return (this.type === BODYTYPE_STATIC || this.type === BODYTYPE_KINEMATIC);
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#isKinematic
         * @description Returns true if the rigid body is of type {@link pc.BODYTYPE_KINEMATIC}.
         * @returns {boolean} True if kinematic.
         */
        isKinematic: function () {
            return (this.type === BODYTYPE_KINEMATIC);
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponent#_getEntityTransform
         * @description Writes an entity transform into an Ammo.btTransform but ignoring scale.
         * @param {object} transform - The ammo transform to write the entity transform to.
         */
        _getEntityTransform: function (transform) {
            var pos = this.entity.getPosition();
            var rot = this.entity.getRotation();

            ammoVec1$1.setValue(pos.x, pos.y, pos.z);
            ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);

            transform.setOrigin(ammoVec1$1);
            transform.setRotation(ammoQuat$1);
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponent#syncEntityToBody
         * @description Set the rigid body transform to be the same as the Entity transform.
         * This must be called after any Entity transformation functions (e.g. {@link pc.Entity#setPosition}) are called
         * in order to update the rigid body to match the Entity.
         */
        syncEntityToBody: function () {
            var body = this.data.body;
            if (body) {
                this._getEntityTransform(ammoTransform$1);

                body.setWorldTransform(ammoTransform$1);

                if (this.type === BODYTYPE_KINEMATIC) {
                    var motionState = body.getMotionState();
                    if (motionState) {
                        motionState.setWorldTransform(ammoTransform$1);
                    }
                }
                body.activate();
            }
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponent#_updateDynamic
         * @description Sets an entity's transform to match that of the world transformation
         * matrix of a dynamic rigid body's motion state.
         */
        _updateDynamic: function () {
            var body = this.data.body;

            // If a dynamic body is frozen, we can assume its motion state transform is
            // the same is the entity world transform
            if (body.isActive()) {
                // Update the motion state. Note that the test for the presence of the motion
                // state is technically redundant since the engine creates one for all bodies.
                var motionState = body.getMotionState();
                if (motionState) {
                    motionState.getWorldTransform(ammoTransform$1);

                    var p = ammoTransform$1.getOrigin();
                    var q = ammoTransform$1.getRotation();
                    this.entity.setPosition(p.x(), p.y(), p.z());
                    this.entity.setRotation(q.x(), q.y(), q.z(), q.w());
                }
            }
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponent#_updateKinematic
         * @description Writes the entity's world transformation matrix into the motion state
         * of a kinematic body.
         */
        _updateKinematic: function () {
            var body = this.data.body;
            var motionState = body.getMotionState();
            if (motionState) {
                this._getEntityTransform(ammoTransform$1);
                motionState.setWorldTransform(ammoTransform$1);
            }
        },

        /**
         * @function
         * @name pc.RigidBodyComponent#teleport
         * @description Teleport an entity to a new world-space position, optionally setting orientation. This function
         * should only be called for rigid bodies that are dynamic. This function has three valid signatures.
         * The first takes a 3-dimensional vector for the position and an optional 3-dimensional vector for Euler rotation.
         * The second takes a 3-dimensional vector for the position and an optional quaternion for rotation.
         * The third takes 3 numbers for the position and an optional 3 numbers for Euler rotation.
         * @param {pc.Vec3|number} x - A 3-dimensional vector holding the new position or the new position x-coordinate.
         * @param {pc.Vec3|pc.Quat|number} y - A 3-dimensional vector or quaternion holding the new rotation or the new
         * position y-coordinate.
         * @param {number} [z] - The new position z-coordinate.
         * @param {number} [rx] - The new Euler x-angle value.
         * @param {number} [ry] - The new Euler y-angle value.
         * @param {number} [rz] - The new Euler z-angle value.
         * @example
         * // Teleport the entity to the origin
         * entity.rigidbody.teleport(pc.Vec3.ZERO);
         * @example
         * // Teleport the entity to the origin
         * entity.rigidbody.teleport(0, 0, 0);
         * @example
         * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
         * var position = new pc.Vec3(1, 2, 3);
         * entity.rigidbody.teleport(position, pc.Vec3.ZERO);
         * @example
         * // Teleport the entity to world-space coordinate [1, 2, 3] and reset orientation
         * entity.rigidbody.teleport(1, 2, 3, 0, 0, 0);
         */
        teleport: function () {
            if (arguments.length < 3) {
                if (arguments[0]) {
                    this.entity.setPosition(arguments[0]);
                }
                if (arguments[1]) {
                    if (arguments[1] instanceof Quat) {
                        this.entity.setRotation(arguments[1]);
                    } else {
                        this.entity.setEulerAngles(arguments[1]);
                    }

                }
            } else {
                if (arguments.length === 6) {
                    this.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);
                }
                this.entity.setPosition(arguments[0], arguments[1], arguments[2]);
            }
            this.syncEntityToBody();
        },

        onEnable: function () {
            if (!this.body) {
                this.createBody();
            }

            this.enableSimulation();
        },

        onDisable: function () {
            this.disableSimulation();
        },

        onSetMass: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                var enabled = this.enabled && this.entity.enabled;
                if (enabled) {
                    this.disableSimulation();
                }

                // calculateLocalInertia writes local inertia to ammoVec1 here...
                body.getCollisionShape().calculateLocalInertia(newValue, ammoVec1$1);
                // ...and then writes the calculated local inertia to the body
                body.setMassProps(newValue, ammoVec1$1);
                body.updateInertiaTensor();

                if (enabled) {
                    this.enableSimulation();
                }
            }
        },

        onSetLinearDamping: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body) {
                body.setDamping(newValue, this.data.angularDamping);
            }
        },

        onSetAngularDamping: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body) {
                body.setDamping(this.data.linearDamping, newValue);
            }
        },

        onSetLinearFactor: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                ammoVec1$1.setValue(newValue.x, newValue.y, newValue.z);
                body.setLinearFactor(ammoVec1$1);
            }
        },

        onSetAngularFactor: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body && this.type === BODYTYPE_DYNAMIC) {
                ammoVec1$1.setValue(newValue.x, newValue.y, newValue.z);
                body.setAngularFactor(ammoVec1$1);
            }
        },

        onSetFriction: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body) {
                body.setFriction(newValue);
            }
        },

        onSetRestitution: function (name, oldValue, newValue) {
            var body = this.data.body;
            if (body) {
                body.setRestitution(newValue);
            }
        },

        onSetType: function (name, oldValue, newValue) {
            if (newValue !== oldValue) {
                this.disableSimulation();

                // set group and mask to defaults for type
                if (newValue === BODYTYPE_DYNAMIC) {
                    this.data.group = BODYGROUP_DYNAMIC;
                    this.data.mask = BODYMASK_ALL;
                } else if (newValue === BODYTYPE_KINEMATIC) {
                    this.data.group = BODYGROUP_KINEMATIC;
                    this.data.mask = BODYMASK_ALL;
                } else {
                    this.data.group = BODYGROUP_STATIC;
                    this.data.mask = BODYMASK_NOT_STATIC;
                }

                // Create a new body
                this.createBody();
            }
        },

        onSetGroupOrMask: function (name, oldValue, newValue) {
            if (newValue !== oldValue) {
                // re-enabling simulation adds rigidbody back into world with new masks
                var isEnabled = this.enabled && this.entity.enabled;
                if (isEnabled) {
                    this.disableSimulation();
                    this.enableSimulation();
                }
            }
        },

        onSetBody: function (name, oldValue, newValue) {
            if (this.body && this.data.simulationEnabled) {
                this.body.activate();
            }
        }
    });

    /**
     * @private
     * @class
     * @name pc.RigidBodyComponentData
     * @augments pc.ComponentData
     * @classdesc Contains data for the RigidBodyComponent.
     * @description Create a new data structure for a RigidBodyComponent.
     */
    function RigidBodyComponentData() {
        this.enabled = true;
        this.mass = 1;
        this.linearDamping = 0;
        this.angularDamping = 0;
        this.linearFactor = new Vec3(1, 1, 1);
        this.angularFactor = new Vec3(1, 1, 1);

        this.friction = 0.5;
        this.restitution = 0;

        this.type = BODYTYPE_STATIC;

        this.group = BODYGROUP_STATIC;
        this.mask = BODYMASK_NOT_STATIC;

        // Non-serialized properties
        this.body = null;
        this.simulationEnabled = false;
    }

    var ammoRayStart, ammoRayEnd;

    var collisions = {};
    var frameCollisions = {};

    /**
     * @class
     * @name pc.RaycastResult
     * @classdesc Object holding the result of a successful raycast hit.
     * @description Create a new RaycastResult.
     * @param {pc.Entity} entity - The entity that was hit.
     * @param {pc.Vec3} point - The point at which the ray hit the entity in world space.
     * @param {pc.Vec3} normal - The normal vector of the surface where the ray hit in world space.
     * @property {pc.Entity} entity The entity that was hit.
     * @property {pc.Vec3} point The point at which the ray hit the entity in world space.
     * @property {pc.Vec3} normal The normal vector of the surface where the ray hit in world space.
     */
    function RaycastResult(entity, point, normal) {
        this.entity = entity;
        this.point = point;
        this.normal = normal;
    }

    /**
     * @class
     * @name pc.SingleContactResult
     * @classdesc Object holding the result of a contact between two rigid bodies.
     * @description Create a new SingleContactResult.
     * @param {pc.Entity} a - The first entity involved in the contact.
     * @param {pc.Entity} b - The second entity involved in the contact.
     * @param {pc.ContactPoint} contactPoint - The contact point between the two entities.
     * @property {pc.Entity} a The first entity involved in the contact.
     * @property {pc.Entity} b The second entity involved in the contact.
     * @property {pc.Vec3} localPointA The point on Entity A where the contact occurred, relative to A.
     * @property {pc.Vec3} localPointB The point on Entity B where the contact occurred, relative to B.
     * @property {pc.Vec3} pointA The point on Entity A where the contact occurred, in world space.
     * @property {pc.Vec3} pointB The point on Entity B where the contact occurred, in world space.
     * @property {pc.Vec3} normal The normal vector of the contact on Entity B, in world space.
     */
    function SingleContactResult(a, b, contactPoint) {
        if (arguments.length === 0) {
            this.a = null;
            this.b = null;
            this.localPointA = new Vec3();
            this.localPointB = new Vec3();
            this.pointA = new Vec3();
            this.pointB = new Vec3();
            this.normal = new Vec3();
        } else {
            this.a = a;
            this.b = b;
            this.localPointA = contactPoint.localPoint;
            this.localPointB = contactPoint.localPointOther;
            this.pointA = contactPoint.point;
            this.pointB = contactPoint.pointOther;
            this.normal = contactPoint.normal;
        }
    }

    /**
     * @class
     * @name pc.ContactPoint
     * @classdesc Object holding the result of a contact between two Entities.
     * @description Create a new ContactPoint.
     * @param {pc.Vec3} localPoint - The point on the entity where the contact occurred, relative to the entity.
     * @param {pc.Vec3} localPointOther - The point on the other entity where the contact occurred, relative to the other entity.
     * @param {pc.Vec3} point - The point on the entity where the contact occurred, in world space.
     * @param {pc.Vec3} pointOther - The point on the other entity where the contact occurred, in world space.
     * @param {pc.Vec3} normal - The normal vector of the contact on the other entity, in world space.
     * @property {pc.Vec3} localPoint The point on the entity where the contact occurred, relative to the entity.
     * @property {pc.Vec3} localPointOther The point on the other entity where the contact occurred, relative to the other entity.
     * @property {pc.Vec3} point The point on the entity where the contact occurred, in world space.
     * @property {pc.Vec3} pointOther The point on the other entity where the contact occurred, in world space.
     * @property {pc.Vec3} normal The normal vector of the contact on the other entity, in world space.
     */
    function ContactPoint(localPoint, localPointOther, point, pointOther, normal) {
        if (arguments.length === 0) {
            this.localPoint = new Vec3();
            this.localPointOther = new Vec3();
            this.point = new Vec3();
            this.pointOther = new Vec3();
            this.normal = new Vec3();
        } else {
            this.localPoint = localPoint;
            this.localPointOther = localPointOther;
            this.point = point;
            this.pointOther = pointOther;
            this.normal = normal;
        }
    }

    /**
     * @class
     * @name pc.ContactResult
     * @classdesc Object holding the result of a contact between two Entities.
     * @description Create a new ContactResult.
     * @param {pc.Entity} other - The entity that was involved in the contact with this entity.
     * @param {pc.ContactPoint[]} contacts - An array of ContactPoints with the other entity.
     * @property {pc.Entity} other The entity that was involved in the contact with this entity.
     * @property {pc.ContactPoint[]} contacts An array of ContactPoints with the other entity.
     */
    function ContactResult(other, contacts) {
        this.other = other;
        this.contacts = contacts;
    }

    // Events Documentation
    /**
     * @event
     * @name pc.RigidBodyComponentSystem#contact
     * @description Fired when a contact occurs between two rigid bodies.
     * @param {pc.SingleContactResult} result - Details of the contact between the two bodies.
     */

    var _schema$c = [
        'enabled',
        'type',
        'mass',
        'linearDamping',
        'angularDamping',
        'linearFactor',
        'angularFactor',
        'friction',
        'restitution',
        'group',
        'mask',
        'body'
    ];

    /**
     * @class
     * @name pc.RigidBodyComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc The RigidBodyComponentSystem maintains the dynamics world for simulating rigid bodies,
     * it also controls global values for the world such as gravity. Note: The RigidBodyComponentSystem
     * is only valid if 3D Physics is enabled in your application. You can enable this in the application
     * settings for your project.
     * @description Create a new RigidBodyComponentSystem.
     * @param {pc.Application} app - The Application.
     * @property {pc.Vec3} gravity The world space vector representing global gravity in the physics simulation.
     * Defaults to [0, -9.81, 0] which is an approximation of the gravitational force on Earth.
     */
    function RigidBodyComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'rigidbody';
        this.description = "Adds the entity to the scene's physical simulation.";
        this._stats = app.stats.frame;

        this.ComponentType = RigidBodyComponent;
        this.DataType = RigidBodyComponentData;

        this.contactPointPool = null;
        this.contactResultPool = null;
        this.singleContactResultPool = null;

        this.schema = _schema$c;

        this.maxSubSteps = 10;
        this.fixedTimeStep = 1 / 60;
        this.gravity = new Vec3(0, -9.81, 0);

        // Arrays of pc.RigidBodyComponents filtered on body type
        this._dynamic = [];
        this._kinematic = [];
        this._triggers = [];
        this._compounds = [];

        this.on('beforeremove', this.onBeforeRemove, this);
        this.on('remove', this.onRemove, this);
    }
    RigidBodyComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    RigidBodyComponentSystem.prototype.constructor = RigidBodyComponentSystem;

    Component._buildAccessors(RigidBodyComponent.prototype, _schema$c);

    Object.assign(RigidBodyComponentSystem.prototype, {
        onLibraryLoaded: function () {
            // Create the Ammo physics world
            if (typeof Ammo !== 'undefined') {
                this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
                this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
                this.overlappingPairCache = new Ammo.btDbvtBroadphase();
                this.solver = new Ammo.btSequentialImpulseConstraintSolver();
                this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);

                if (this.dynamicsWorld.setInternalTickCallback) {
                    var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
                    this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
                }

                // Lazily create temp vars
                ammoRayStart = new Ammo.btVector3();
                ammoRayEnd = new Ammo.btVector3();

                this.contactPointPool = new AllocatePool(ContactPoint, 1);
                this.contactResultPool = new AllocatePool(ContactResult, 1);
                this.singleContactResultPool = new AllocatePool(SingleContactResult, 1);

                ComponentSystem.bind('update', this.onUpdate, this);
            } else {
                // Unbind the update function if we haven't loaded Ammo by now
                ComponentSystem.unbind('update', this.onUpdate, this);
            }
        },

        initializeComponentData: function (component, _data, properties) {
            properties = ['enabled', 'mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'restitution', 'type', 'group', 'mask'];

            // duplicate the input data because we are modifying it
            var data = {};
            for (var i = 0, len = properties.length; i < len; i++) {
                var property = properties[i];
                data[property] = _data[property];
            }

            // backwards compatibility
            if (_data.bodyType) {
                data.type = _data.bodyType;
            }

            if (data.linearFactor && type(data.linearFactor) === 'array') {
                data.linearFactor = new Vec3(data.linearFactor[0], data.linearFactor[1], data.linearFactor[2]);
            }
            if (data.angularFactor && type(data.angularFactor) === 'array') {
                data.angularFactor = new Vec3(data.angularFactor[0], data.angularFactor[1], data.angularFactor[2]);
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            // create new data block for clone
            var data = {
                enabled: entity.rigidbody.enabled,
                mass: entity.rigidbody.mass,
                linearDamping: entity.rigidbody.linearDamping,
                angularDamping: entity.rigidbody.angularDamping,
                linearFactor: [entity.rigidbody.linearFactor.x, entity.rigidbody.linearFactor.y, entity.rigidbody.linearFactor.z],
                angularFactor: [entity.rigidbody.angularFactor.x, entity.rigidbody.angularFactor.y, entity.rigidbody.angularFactor.z],
                friction: entity.rigidbody.friction,
                restitution: entity.rigidbody.restitution,
                type: entity.rigidbody.type,
                group: entity.rigidbody.group,
                mask: entity.rigidbody.mask
            };

            this.addComponent(clone, data);
        },

        onBeforeRemove: function (entity, component) {
            if (component.enabled) {
                component.enabled = false;
            }
        },

        onRemove: function (entity, data) {
            var body = data.body;
            if (body) {
                this.removeBody(body);
                this.destroyBody(body);

                data.body = null;
            }
        },

        addBody: function (body, group, mask) {
            if (group !== undefined && mask !== undefined) {
                this.dynamicsWorld.addRigidBody(body, group, mask);
            } else {
                this.dynamicsWorld.addRigidBody(body);
            }
        },

        removeBody: function (body) {
            this.dynamicsWorld.removeRigidBody(body);
        },

        createBody: function (mass, shape, transform) {
            var localInertia = new Ammo.btVector3(0, 0, 0);
            if (mass !== 0) {
                shape.calculateLocalInertia(mass, localInertia);
            }

            var motionState = new Ammo.btDefaultMotionState(transform);
            var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            var body = new Ammo.btRigidBody(bodyInfo);
            Ammo.destroy(bodyInfo);
            Ammo.destroy(localInertia);

            return body;
        },

        destroyBody: function (body) {
            // The motion state needs to be destroyed explicitly (if present)
            var motionState = body.getMotionState();
            if (motionState) {
                Ammo.destroy(motionState);
            }
            Ammo.destroy(body);
        },

        /**
         * @function
         * @name pc.RigidBodyComponentSystem#raycastFirst
         * @description Raycast the world and return the first entity the ray hits. Fire a ray into the world from start to end,
         * if the ray hits an entity with a collision component, it returns a {@link pc.RaycastResult}, otherwise returns null.
         * @param {pc.Vec3} start - The world space point where the ray starts.
         * @param {pc.Vec3} end - The world space point where the ray ends.
         * @returns {pc.RaycastResult} The result of the raycasting or null if there was no hit.
         */
        raycastFirst: function (start, end) {
            var result = null;

            ammoRayStart.setValue(start.x, start.y, start.z);
            ammoRayEnd.setValue(end.x, end.y, end.z);
            var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);

            this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
            if (rayCallback.hasHit()) {
                var collisionObj = rayCallback.get_m_collisionObject();
                var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
                if (body) {
                    var point = rayCallback.get_m_hitPointWorld();
                    var normal = rayCallback.get_m_hitNormalWorld();

                    result = new RaycastResult(
                        body.entity,
                        new Vec3(point.x(), point.y(), point.z()),
                        new Vec3(normal.x(), normal.y(), normal.z())
                    );

                    // keeping for backwards compatibility
                    if (arguments.length > 2) {

                        var callback = arguments[2];
                        callback(result);
                    }
                }
            }

            Ammo.destroy(rayCallback);

            return result;
        },

        /**
         * @function
         * @name pc.RigidBodyComponentSystem#raycastAll
         * @description Raycast the world and return all entities the ray hits. It returns an array
         * of {@link pc.RaycastResult}, one for each hit. If no hits are detected, the returned
         * array will be of length 0.
         * @param {pc.Vec3} start - The world space point where the ray starts.
         * @param {pc.Vec3} end - The world space point where the ray ends.
         * @returns {pc.RaycastResult[]} An array of raycast hit results (0 length if there were no hits).
         */
        raycastAll: function (start, end) {

            var results = [];

            ammoRayStart.setValue(start.x, start.y, start.z);
            ammoRayEnd.setValue(end.x, end.y, end.z);
            var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);

            this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
            if (rayCallback.hasHit()) {
                var collisionObjs = rayCallback.get_m_collisionObjects();
                var points = rayCallback.get_m_hitPointWorld();
                var normals = rayCallback.get_m_hitNormalWorld();

                var numHits = collisionObjs.size();
                for (var i = 0; i < numHits; i++) {
                    var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
                    if (body) {
                        var point = points.at(i);
                        var normal = normals.at(i);
                        var result = new RaycastResult(
                            body.entity,
                            new Vec3(point.x(), point.y(), point.z()),
                            new Vec3(normal.x(), normal.y(), normal.z())
                        );
                        results.push(result);
                    }
                }
            }

            Ammo.destroy(rayCallback);

            return results;
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponentSystem#_storeCollision
         * @description Stores a collision between the entity and other in the contacts map and returns true if it is a new collision.
         * @param {pc.Entity} entity - The entity.
         * @param {pc.Entity} other - The entity that collides with the first entity.
         * @returns {boolean} True if this is a new collision, false otherwise.
         */
        _storeCollision: function (entity, other) {
            var isNewCollision = false;
            var guid = entity.getGuid();

            collisions[guid] = collisions[guid] || { others: [], entity: entity };

            if (collisions[guid].others.indexOf(other) < 0) {
                collisions[guid].others.push(other);
                isNewCollision = true;
            }

            frameCollisions[guid] = frameCollisions[guid] || { others: [], entity: entity };
            frameCollisions[guid].others.push(other);

            return isNewCollision;
        },

        _createContactPointFromAmmo: function (contactPoint) {
            var localPointA = contactPoint.get_m_localPointA();
            var localPointB = contactPoint.get_m_localPointB();
            var positionWorldOnA = contactPoint.getPositionWorldOnA();
            var positionWorldOnB = contactPoint.getPositionWorldOnB();
            var normalWorldOnB = contactPoint.get_m_normalWorldOnB();

            var contact = this.contactPointPool.allocate();
            contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
            contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
            contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
            contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
            contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
            return contact;
        },

        _createReverseContactPointFromAmmo: function (contactPoint) {
            var localPointA = contactPoint.get_m_localPointA();
            var localPointB = contactPoint.get_m_localPointB();
            var positionWorldOnA = contactPoint.getPositionWorldOnA();
            var positionWorldOnB = contactPoint.getPositionWorldOnB();
            var normalWorldOnB = contactPoint.get_m_normalWorldOnB();

            var contact = this.contactPointPool.allocate();
            contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
            contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
            contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
            contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
            contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
            return contact;
        },

        _createSingleContactResult: function (a, b, contactPoint) {
            var result = this.singleContactResultPool.allocate();

            result.a = a;
            result.b = b;
            result.localPointA = contactPoint.localPoint;
            result.localPointB = contactPoint.localPointOther;
            result.pointA = contactPoint.point;
            result.pointB = contactPoint.pointOther;
            result.normal = contactPoint.normal;

            return result;
        },

        _createContactResult: function (other, contacts) {
            var result = this.contactResultPool.allocate();
            result.other = other;
            result.contacts = contacts;
            return result;
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponentSystem#_cleanOldCollisions
         * @description Removes collisions that no longer exist from the collisions list and fires collisionend events to the
         * related entities.
         */
        _cleanOldCollisions: function () {
            for (var guid in collisions) {
                if (collisions.hasOwnProperty(guid)) {
                    var frameCollision = frameCollisions[guid];
                    var collision = collisions[guid];
                    var entity = collision.entity;
                    var entityCollision = entity.collision;
                    var entityRigidbody = entity.rigidbody;
                    var others = collision.others;
                    var length = others.length;
                    var i = length;
                    while (i--) {
                        var other = others[i];
                        // if the contact does not exist in the current frame collisions then fire event
                        if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
                            // remove from others list
                            others.splice(i, 1);

                            if (entity.trigger) {
                                // handle a trigger entity
                                if (entityCollision) {
                                    entityCollision.fire("triggerleave", other);
                                }
                                if (other.rigidbody) {
                                    other.rigidbody.fire('triggerleave', entity);
                                }
                            } else if (!other.trigger) {
                                // suppress events if the other entity is a trigger
                                if (entityRigidbody) {
                                    entityRigidbody.fire("collisionend", other);
                                }
                                if (entityCollision) {
                                    entityCollision.fire("collisionend", other);
                                }
                            }
                        }
                    }

                    if (others.length === 0) {
                        delete collisions[guid];
                    }
                }
            }
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponentSystem#_hasContactEvent
         * @description Returns true if the entity has a contact event attached and false otherwise.
         * @param {object} entity - Entity to test.
         * @returns {boolean} True if the entity has a contact and false otherwise.
         */
        _hasContactEvent: function (entity) {
            var c = entity.collision;
            if (c && (c.hasEvent("collisionstart") || c.hasEvent("collisionend") || c.hasEvent("contact"))) {
                return true;
            }

            var r = entity.rigidbody;
            return r && (r.hasEvent("collisionstart") || r.hasEvent("collisionend") || r.hasEvent("contact"));
        },

        /**
         * @private
         * @function
         * @name pc.RigidBodyComponentSystem#_checkForCollisions
         * @description Checks for collisions and fires collision events
         * @param {number} world - The pointer to the dynamics world that invoked this callback.
         * @param {number} timeStep - The amount of simulation time processed in the last simulation tick.
         */
        _checkForCollisions: function (world, timeStep) {
            var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);

            // Check for collisions and fire callbacks
            var dispatcher = dynamicsWorld.getDispatcher();
            var numManifolds = dispatcher.getNumManifolds();

            frameCollisions = {};

            // loop through the all contacts and fire events
            for (var i = 0; i < numManifolds; i++) {
                var manifold = dispatcher.getManifoldByIndexInternal(i);

                var body0 = manifold.getBody0();
                var body1 = manifold.getBody1();

                var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
                var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);

                var e0 = wb0.entity;
                var e1 = wb1.entity;

                // check if entity is null - TODO: investigate when this happens
                if (!e0 || !e1) {
                    continue;
                }

                var flags0 = wb0.getCollisionFlags();
                var flags1 = wb1.getCollisionFlags();

                var numContacts = manifold.getNumContacts();
                var forwardContacts = [];
                var reverseContacts = [];
                var newCollision, e0Events, e1Events, e0BodyEvents, e1BodyEvents;

                if (numContacts > 0) {
                    // don't fire contact events for triggers
                    if ((flags0 & BODYFLAG_NORESPONSE_OBJECT) ||
                        (flags1 & BODYFLAG_NORESPONSE_OBJECT)) {

                        e0Events = e0.collision && (e0.collision.hasEvent("triggerenter") || e0.collision.hasEvent("triggerleave"));
                        e1Events = e1.collision && (e1.collision.hasEvent("triggerenter") || e1.collision.hasEvent("triggerleave"));
                        e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent("triggerenter") || e0.rigidbody.hasEvent("triggerleave"));
                        e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent("triggerenter") || e1.rigidbody.hasEvent("triggerleave"));

                        // fire triggerenter events for triggers
                        if (e0Events) {
                            newCollision = this._storeCollision(e0, e1);
                            if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
                                e0.collision.fire("triggerenter", e1);
                            }
                        }

                        if (e1Events) {
                            newCollision = this._storeCollision(e1, e0);
                            if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
                                e1.collision.fire("triggerenter", e0);
                            }
                        }

                        // fire triggerenter events for rigidbodies
                        if (e0BodyEvents) {
                            if (! newCollision) {
                                newCollision = this._storeCollision(e1, e0);
                            }

                            if (newCollision) {
                                e0.rigidbody.fire("triggerenter", e1);
                            }
                        }

                        if (e1BodyEvents) {
                            if (! newCollision) {
                                newCollision = this._storeCollision(e0, e1);
                            }

                            if (newCollision) {
                                e1.rigidbody.fire("triggerenter", e0);
                            }
                        }
                    } else {
                        e0Events = this._hasContactEvent(e0);
                        e1Events = this._hasContactEvent(e1);
                        var globalEvents = this.hasEvent("contact");

                        if (globalEvents || e0Events || e1Events) {
                            for (var j = 0; j < numContacts; j++) {
                                var btContactPoint = manifold.getContactPoint(j);

                                var contactPoint = this._createContactPointFromAmmo(btContactPoint);
                                var reverseContactPoint = null;
                                if (e0Events || e1Events) {
                                    reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
                                    forwardContacts.push(contactPoint);
                                    reverseContacts.push(reverseContactPoint);
                                }

                                if (globalEvents) {
                                    // fire global contact event for every contact
                                    var result = this._createSingleContactResult(e0, e1, contactPoint);
                                    this.fire("contact", result);
                                }
                            }

                            if (e0Events) {
                                var forwardResult = this._createContactResult(e1, forwardContacts);
                                newCollision = this._storeCollision(e0, e1);

                                if (e0.collision) {
                                    e0.collision.fire("contact", forwardResult);
                                    if (newCollision) {
                                        e0.collision.fire("collisionstart", forwardResult);
                                    }
                                }

                                if (e0.rigidbody) {
                                    e0.rigidbody.fire("contact", forwardResult);
                                    if (newCollision) {
                                        e0.rigidbody.fire("collisionstart", forwardResult);
                                    }
                                }
                            }

                            if (e1Events) {
                                var reverseResult = this._createContactResult(e0, reverseContacts);
                                newCollision = this._storeCollision(e1, e0);

                                if (e1.collision) {
                                    e1.collision.fire("contact", reverseResult);
                                    if (newCollision) {
                                        e1.collision.fire("collisionstart", reverseResult);
                                    }
                                }

                                if (e1.rigidbody) {
                                    e1.rigidbody.fire("contact", reverseResult);
                                    if (newCollision) {
                                        e1.rigidbody.fire("collisionstart", reverseResult);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // check for collisions that no longer exist and fire events
            this._cleanOldCollisions();

            // Reset contact pools
            this.contactPointPool.freeAll();
            this.contactResultPool.freeAll();
            this.singleContactResultPool.freeAll();
        },

        onUpdate: function (dt) {
            var i, len;


            // Check to see whether we need to update gravity on the dynamics world
            var gravity = this.dynamicsWorld.getGravity();
            if (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {
                gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
                this.dynamicsWorld.setGravity(gravity);
            }

            var triggers = this._triggers;
            for (i = 0, len = triggers.length; i < len; i++) {
                triggers[i].updateTransform();
            }

            var compounds = this._compounds;
            for (i = 0, len = compounds.length; i < len; i++) {
                compounds[i]._updateCompound();
            }

            // Update all kinematic bodies based on their current entity transform
            var kinematic = this._kinematic;
            for (i = 0, len = kinematic.length; i < len; i++) {
                kinematic[i]._updateKinematic();
            }

            // Step the physics simulation
            this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);

            // Update the transforms of all entities referencing a dynamic body
            var dynamic = this._dynamic;
            for (i = 0, len = dynamic.length; i < len; i++) {
                dynamic[i]._updateDynamic();
            }

            if (!this.dynamicsWorld.setInternalTickCallback)
                this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);

        },

        destroy: function () {
            if (typeof Ammo !== 'undefined') {
                Ammo.destroy(this.dynamicsWorld);
                Ammo.destroy(this.solver);
                Ammo.destroy(this.overlappingPairCache);
                Ammo.destroy(this.dispatcher);
                Ammo.destroy(this.collisionConfiguration);
                this.dynamicsWorld = null;
                this.solver = null;
                this.overlappingPairCache = null;
                this.dispatcher = null;
                this.collisionConfiguration = null;
            }
        }
    });

    /**
     * @constant
     * @type {string}
     * @name pc.SCALEMODE_NONE
     * @description Always use the application's resolution as the resolution for the {@link pc.ScreenComponent}.
     */
    var SCALEMODE_NONE = "none";
    /**
     * @constant
     * @type {string}
     * @name pc.SCALEMODE_BLEND
     * @description Scale the {@link pc.ScreenComponent} when the application's resolution is different than the ScreenComponent's referenceResolution.
     */
    var SCALEMODE_BLEND = "blend";

    /**
     * @component
     * @class
     * @name pc.ScreenComponent
     * @augments pc.Component
     * @classdesc A ScreenComponent enables the Entity to render child {@link pc.ElementComponent}s using anchors and positions in the ScreenComponent's space.
     * @description Create a new ScreenComponent.
     * @param {pc.ScreenComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {boolean} screenSpace If true then the ScreenComponent will render its child {@link pc.ElementComponent}s in screen space instead of world space. Enable this to create 2D user interfaces.
     * @property {boolean} cull If true then elements inside this screen will be not be rendered when outside of the screen (only valid when screenSpace is true).
     * @property {string} scaleMode Can either be {@link pc.SCALEMODE_NONE} or {@link pc.SCALEMODE_BLEND}. See the description of referenceResolution for more information.
     * @property {number} scaleBlend A value between 0 and 1 that is used when scaleMode is equal to {@link pc.SCALEMODE_BLEND}. Scales the ScreenComponent with width as a reference (when value is 0), the height as a reference (when value is 1) or anything in between.
     * @property {pc.Vec2} resolution The width and height of the ScreenComponent. When screenSpace is true the resolution will always be equal to {@link pc.GraphicsDevice#width} x {@link pc.GraphicsDevice#height}.
     * @property {pc.Vec2} referenceResolution The resolution that the ScreenComponent is designed for. This is only taken into account when screenSpace is true and scaleMode is {@link pc.SCALEMODE_BLEND}. If the actual resolution is different then the ScreenComponent will be scaled according to the scaleBlend value.
     */
    function ScreenComponent(system, entity) {
        Component.call(this, system, entity);

        this._resolution = new Vec2(640, 320);
        this._referenceResolution = new Vec2(640, 320);
        this._scaleMode = SCALEMODE_NONE;
        this.scale = 1;
        this._scaleBlend = 0.5;

        // priority determines the order in which screens components are rendered
        // priority is set into the top 8 bits of the drawOrder property in an element
        this._priority = 0;

        this._screenSpace = false;
        this.cull = this._screenSpace;
        this._screenMatrix = new Mat4();

        system.app.graphicsDevice.on("resizecanvas", this._onResize, this);
    }
    ScreenComponent.prototype = Object.create(Component.prototype);
    ScreenComponent.prototype.constructor = ScreenComponent;

    var _transform = new Mat4();

    Object.assign(ScreenComponent.prototype, {
        /**
         * @function
         * @name pc.ScreenComponent#syncDrawOrder
         * @description Set the drawOrder of each child {@link pc.ElementComponent}
         * so that ElementComponents which are last in the hierarchy are rendered on top.
         * Draw Order sync is queued and will be updated by the next update loop.
         */
        syncDrawOrder: function () {
            this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
        },

        _recurseDrawOrderSync: function (e, i) {
            if (!(e instanceof Entity)) {
                return i;
            }

            if (e.element) {
                var prevDrawOrder = e.element.drawOrder;
                e.element.drawOrder = i++;

                if (e.element._batchGroupId >= 0 && prevDrawOrder != e.element.drawOrder) {
                    this.system.app.batcher.markGroupDirty(e.element._batchGroupId);
                }
            }

            var children = e.children;
            for (var j = 0; j < children.length; j++) {
                i = this._recurseDrawOrderSync(children[j], i);
            }

            return i;
        },

        _processDrawOrderSync: function () {
            var i = 1;

            this._recurseDrawOrderSync(this.entity, i);

            // fire internal event after all screen hierarchy is synced
            this.fire('syncdraworder');
        },

        _calcProjectionMatrix: function () {
            var left;
            var right;
            var bottom;
            var top;
            var near = 1;
            var far = -1;

            var w = this._resolution.x / this.scale;
            var h = this._resolution.y / this.scale;

            left = 0;
            right = w;
            bottom = -h;
            top = 0;

            this._screenMatrix.setOrtho(left, right, bottom, top, near, far);

            if (!this._screenSpace) {
                _transform.setScale(0.5 * w, 0.5 * h, 1);
                this._screenMatrix.mul2(_transform, this._screenMatrix);
            }
        },

        _updateScale: function () {
            this.scale = this._calcScale(this._resolution, this.referenceResolution);
        },

        _calcScale: function (resolution, referenceResolution) {
            // Using log of scale values
            // This produces a nicer outcome where if you have a xscale = 2 and yscale = 0.5
            // the combined scale is 1 for an even blend
            var lx = Math.log2(resolution.x / referenceResolution.x);
            var ly = Math.log2(resolution.y / referenceResolution.y);
            return Math.pow(2, (lx * (1 - this._scaleBlend) + ly * this._scaleBlend));
        },

        _onResize: function (width, height) {
            if (this._screenSpace) {
                this._resolution.set(width, height);
                this.resolution = this._resolution; // force update
            }
        },

        onRemove: function () {
            this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this);
            this.fire('remove');

            // remove all events used by elements
            this.off();
        }
    });

    Object.defineProperty(ScreenComponent.prototype, "resolution", {
        set: function (value) {
            if (!this._screenSpace) {
                this._resolution.set(value.x, value.y);
            } else {
                // ignore input when using screenspace.
                this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            }

            this._updateScale();

            this._calcProjectionMatrix();

            if (!this.entity._dirtyLocal)
                this.entity._dirtifyLocal();

            this.fire("set:resolution", this._resolution);
        },
        get: function () {
            return this._resolution;
        }
    });

    Object.defineProperty(ScreenComponent.prototype, "referenceResolution", {
        set: function (value) {
            this._referenceResolution.set(value.x, value.y);
            this._updateScale();
            this._calcProjectionMatrix();

            if (!this.entity._dirtyLocal)
                this.entity._dirtifyLocal();

            this.fire("set:referenceresolution", this._resolution);
        },
        get: function () {
            if (this._scaleMode === SCALEMODE_NONE) {
                return this._resolution;
            }
            return this._referenceResolution;

        }
    });

    Object.defineProperty(ScreenComponent.prototype, "screenSpace", {
        set: function (value) {
            this._screenSpace = value;
            if (this._screenSpace) {
                this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            }
            this.resolution = this._resolution; // force update either way

            if (!this.entity._dirtyLocal)
                this.entity._dirtifyLocal();

            this.fire('set:screenspace', this._screenSpace);
        },
        get: function () {
            return this._screenSpace;
        }
    });


    Object.defineProperty(ScreenComponent.prototype, "scaleMode", {
        set: function (value) {
            if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
                value = SCALEMODE_NONE;
            }

            // world space screens do not support scale modes
            if (!this._screenSpace && value !== SCALEMODE_NONE) {
                value = SCALEMODE_NONE;
            }

            this._scaleMode = value;
            this.resolution = this._resolution; // force update
            this.fire("set:scalemode", this._scaleMode);
        },
        get: function () {
            return this._scaleMode;
        }
    });

    Object.defineProperty(ScreenComponent.prototype, "scaleBlend", {
        set: function (value) {
            this._scaleBlend = value;
            this._updateScale();
            this._calcProjectionMatrix();

            if (!this.entity._dirtyLocal)
                this.entity._dirtifyLocal();

            this.fire("set:scaleblend", this._scaleBlend);
        },
        get: function () {
            return this._scaleBlend;
        }
    });

    Object.defineProperty(ScreenComponent.prototype, "priority", {
        get: function () {
            return this._priority;
        },

        set: function (value) {
            if (value > 0xFF) {
                value = 0xFF;
            }

            this._priority = value;
        }
    });

    function ScreenComponentData() {
        this.enabled = true;
    }

    var _schema$d = ['enabled'];

    /**
     * @class
     * @name pc.ScreenComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.ScreenComponent}s.
     * @description Create a new ScreenComponentSystem.
     * @param {pc.Application} app - The application.
     */
    function ScreenComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'screen';

        this.ComponentType = ScreenComponent;
        this.DataType = ScreenComponentData;

        this.schema = _schema$d;

        this.windowResolution = new Vec2();

        // queue of callbacks
        this._drawOrderSyncQueue = new IndexedList();

        this.app.graphicsDevice.on("resizecanvas", this._onResize, this);

        ComponentSystem.bind('update', this._onUpdate, this);

        this.on('beforeremove', this.onRemoveComponent, this);
    }
    ScreenComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ScreenComponentSystem.prototype.constructor = ScreenComponentSystem;

    Component._buildAccessors(ScreenComponent.prototype, _schema$d);

    Object.assign(ScreenComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            if (data.priority !== undefined) component.priority = data.priority;
            if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
            component.cull = component.screenSpace;
            if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
            if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
            if (data.resolution !== undefined) {
                if (data.resolution instanceof Vec2){
                    component._resolution.copy(data.resolution);
                } else {
                    component._resolution.set(data.resolution[0], data.resolution[1]);
                }
                component.resolution = component._resolution;
            }
            if (data.referenceResolution !== undefined) {
                if (data.referenceResolution instanceof Vec2){
                    component._referenceResolution.copy(data.referenceResolution);
                } else {
                    component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
                }
                component.referenceResolution = component._referenceResolution;
            }

            // queue up a draw order sync
            component.syncDrawOrder();
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        destroy: function () {
            this.off();
            this.app.graphicsDevice.off("resizecanvas", this._onResize, this);
        },

        _onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
            }
        },

        _onResize: function (width, height) {
            this.windowResolution.x = width;
            this.windowResolution.y = height;
        },

        cloneComponent: function (entity, clone) {
            var screen = entity.screen;

            return this.addComponent(clone, {
                enabled: screen.enabled,
                screenSpace: screen.screenSpace,
                scaleMode: screen.scaleMode,
                resolution: screen.resolution.clone(),
                referenceResolution: screen.referenceResolution.clone()
            });
        },

        onRemoveComponent: function (entity, component) {
            component.onRemove();
        },

        processDrawOrderSyncQueue: function () {
            var list = this._drawOrderSyncQueue.list();

            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                item.callback.call(item.scope);
            }
            this._drawOrderSyncQueue.clear();
        },

        queueDrawOrderSync: function (id, fn, scope) {
            // first queued sync this frame
            // attach an event listener
            if (!this._drawOrderSyncQueue.list().length) {
                this.app.once('prerender', this.processDrawOrderSyncQueue, this);
            }

            if (!this._drawOrderSyncQueue.has(id)) {
                this._drawOrderSyncQueue.push(id, {
                    callback: fn,
                    scope: scope
                });
            }
        }
    });

    var components = ['x', 'y', 'z', 'w'];

    var rawToValue = function (app, args, value, old) {
        var i;

        switch (args.type) {
            case 'boolean':
                return !!value;
            case 'number':
                if (typeof value === 'number') {
                    return value;
                } else if (typeof value === 'string') {
                    var v = parseInt(value, 10);
                    if (isNaN(v)) return null;
                    return v;
                } else if (typeof value === 'boolean') {
                    return 0 + value;
                }
                return null;
            case 'json':
                if (typeof value === 'object') {
                    return value;
                }
                try {
                    return JSON.parse(value);
                } catch (ex) {
                    return null;
                }
            case 'asset':
                if (value instanceof Asset) {
                    return value;
                } else if (typeof value === 'number') {
                    return app.assets.get(value) || null;
                } else if (typeof value === 'string') {
                    return app.assets.get(parseInt(value, 10)) || null;
                }
                return null;
            case 'entity':
                if (value instanceof GraphNode) {
                    return value;
                } else if (typeof value === 'string') {
                    return app.getEntityFromIndex(value);
                }
                return null;
            case 'rgb':
            case 'rgba':
                if (value instanceof Color) {
                    if (old instanceof Color) {
                        old.copy(value);
                        return old;
                    }
                    return value.clone();
                } else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
                    for (i = 0; i < value.length; i++) {
                        if (typeof value[i] !== 'number')
                            return null;
                    }
                    if (!old) old = new Color();

                    old.r = value[0];
                    old.g = value[1];
                    old.b = value[2];
                    old.a = (value.length === 3) ? 1 : value[3];

                    return old;
                } else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {
                    if (!old)
                        old = new Color();

                    old.fromString(value);
                    return old;
                }
                return null;
            case 'vec2':
            case 'vec3':
            case 'vec4':
                var len = parseInt(args.type.slice(3), 10);

                if (value instanceof pc['Vec' + len]) {
                    if (old instanceof pc['Vec' + len]) {
                        old.copy(value);
                        return old;
                    }
                    return value.clone();
                } else if (value instanceof Array && value.length === len) {
                    for (i = 0; i < value.length; i++) {
                        if (typeof value[i] !== 'number')
                            return null;
                    }
                    if (!old) old = new pc['Vec' + len]();

                    for (i = 0; i < len; i++)
                        old[components[i]] = value[i];

                    return old;
                }
                return null;
            case 'curve':
                if (value) {
                    var curve;
                    if (value instanceof Curve || value instanceof CurveSet) {
                        curve = value.clone();
                    } else {
                        var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
                        curve = new CurveType(value.keys);
                        curve.type = value.type;
                    }
                    return curve;
                }
                break;
        }

        return value;
    };


    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @class
     * @name pc.ScriptAttributes
     * @classdesc Container of Script Attribute definitions. Implements an interface to add/remove attributes and store their definition for a {@link pc.ScriptType}.
     * Note: An instance of pc.ScriptAttributes is created automatically by each {@link pc.ScriptType}.
     * @param {Class<pc.ScriptType>} scriptType - Script Type that attributes relate to.
     */
    /* eslint-enable jsdoc/no-undefined-types */
    function ScriptAttributes(scriptType) {
        this.scriptType = scriptType;
        this.index = { };
    }

    /**
     * @function
     * @name pc.ScriptAttributes#add
     * @description Add Attribute.
     * @param {string} name - Name of an attribute.
     * @param {object} args - Object with Arguments for an attribute.
     * @param {("boolean"|"number"|"string"|"json"|"asset"|"entity"|"rgb"|"rgba"|"vec2"|"vec3"|"vec4"|"curve")} args.type - Type of an attribute value.
     * @param {*} [args.default] - Default attribute value.
     * @param {string} [args.title] - Title for Editor's for field UI.
     * @param {string} [args.description] - Description for Editor's for field UI.
     * @param {string|string[]} [args.placeholder] - Placeholder for Editor's for field UI.
     * For multi-field types, such as vec2, vec3, and others use array of strings.
     * @param {boolean} [args.array] - If attribute can hold single or multiple values.
     * @param {number} [args.size] - If attribute is array, maximum number of values can be set.
     * @param {number} [args.min] - Minimum value for type 'number', if max and min defined, slider will be rendered in Editor's UI.
     * @param {number} [args.max] - Maximum value for type 'number', if max and min defined, slider will be rendered in Editor's UI.
     * @param {number} [args.precision] - Level of precision for field type 'number' with floating values.
     * @param {number} [args.step] - Step value for type 'number'. The amount used to increment the value when using the arrow keys in the Editor's UI.
     * @param {string} [args.assetType] - Name of asset type to be used in 'asset' type attribute picker in Editor's UI, defaults to '*' (all).
     * @param {string[]} [args.curves] - List of names for Curves for field type 'curve'.
     * @param {string} [args.color] - String of color channels for Curves for field type 'curve', can be any combination of `rgba` characters.
     * Defining this property will render Gradient in Editor's field UI.
     * @param {object[]} [args.enum] - List of fixed choices for field, defined as array of objects, where key in object is a title of an option.
     * @example
     * PlayerController.attributes.add('fullName', {
     *     type: 'string'
     * });
     * @example
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     * @example
     * PlayerController.attributes.add('resolution', {
     *     type: 'number',
     *     default: 32,
     *     enum: [
     *         { '32x32': 32 },
     *         { '64x64': 64 },
     *         { '128x128': 128 }
     *     ]
     * });
     */
    ScriptAttributes.prototype.add = function (name, args) {
        if (this.index[name]) {
            return;
        } else if (createScript.reservedAttributes[name]) {
            return;
        }

        this.index[name] = args;

        Object.defineProperty(this.scriptType.prototype, name, {
            get: function () {
                return this.__attributes[name];
            },
            set: function (raw) {
                var old = this.__attributes[name];

                // convert to appropriate type
                if (args.array) {
                    this.__attributes[name] = [];
                    if (raw) {
                        var i;
                        var len;
                        for (i = 0, len = raw.length; i < len; i++) {
                            this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
                        }
                    }
                } else {
                    this.__attributes[name] = rawToValue(this.app, args, raw, old);
                }

                this.fire('attr', name, this.__attributes[name], old);
                this.fire('attr:' + name, this.__attributes[name], old);
            }
        });
    };

    /**
     * @function
     * @name pc.ScriptAttributes#remove
     * @description Remove Attribute.
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if removed or false if not defined.
     * @example
     * PlayerController.attributes.remove('fullName');
     */
    ScriptAttributes.prototype.remove = function (name) {
        if (!this.index[name])
            return false;

        delete this.index[name];
        delete this.scriptType.prototype[name];
        return true;
    };

    /**
     * @function
     * @name pc.ScriptAttributes#has
     * @description Detect if Attribute is added.
     * @param {string} name - Name of an attribute.
     * @returns {boolean} True if Attribute is defined.
     * @example
     * if (PlayerController.attributes.has('fullName')) {
     *     // attribute fullName is defined
     * }
     */
    ScriptAttributes.prototype.has = function (name) {
        return !!this.index[name];
    };

    /**
     * @function
     * @name pc.ScriptAttributes#get
     * @description Get object with attribute arguments.
     * Note: Changing argument properties will not affect existing Script Instances.
     * @param {string} name - Name of an attribute.
     * @returns {?object} Arguments with attribute properties.
     * @example
     * // changing default value for an attribute 'fullName'
     * var attr = PlayerController.attributes.get('fullName');
     * if (attr) attr.default = 'Unknown';
     */
    ScriptAttributes.prototype.get = function (name) {
        return this.index[name] || null;
    };

    var funcNameRegex = new RegExp('^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*');

    /**
     * @class
     * @name pc.ScriptType
     * @augments pc.EventHandler
     * @classdesc Represents the type of a script. It is returned by {@link pc.createScript}.
     * Also referred to as Script Type.
     *
     * The type is to be extended using its JavaScript prototype. There is a **list of methods**
     * that will be executed by the engine on instances of this type, such as:
     *
     * * initialize
     * * postInitialize
     * * update
     * * postUpdate
     * * swap
     *
     * **initialize** and **postInitialize** - are called if defined when script is about to run
     * for the first time - postInitialize will run after all initialize methods are executed in
     * the same tick or enabling chain of actions.
     *
     * **update** and **postUpdate** - methods are called if defined for enabled (running state)
     * scripts on each tick.
     *
     * **swap** - This method will be called when a {@link pc.ScriptType} that already exists in
     * the registry gets redefined. If the new {@link pc.ScriptType} has a `swap` method in its
     * prototype, then it will be executed to perform hot-reload at runtime.
     * @property {pc.Application} app The {@link pc.Application} that the instance of this type
     * belongs to.
     * @property {pc.Entity} entity The {@link pc.Entity} that the instance of this type belongs to.
     * @property {boolean} enabled True if the instance of this type is in running state. False
     * when script is not running, because the Entity or any of its parents are disabled or the
     * Script Component is disabled or the Script Instance is disabled. When disabled no update
     * methods will be called on each tick. initialize and postInitialize methods will run once
     * when the script instance is in `enabled` state during app tick.
     * @param {object} args - The input arguments object
     * @param {pc.Application} args.app - The {@link pc.Application} that is running the script
     * @param {pc.Entity} args.entity - The {@link pc.Entity} that the script is attached to
     *
     */
    function ScriptType(args) {
        EventHandler.call(this);

        var script = this.constructor; // get script type, i.e. function (class)


        this.app = args.app;
        this.entity = args.entity;
        this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
        this._enabledOld = this.enabled;
        this.__destroyed = false;
        this.__attributes = { };
        this.__attributesRaw = args.attributes || { }; // need at least an empty object to make sure default attributes are initialized
        this.__scriptType = script;

        // the order in the script component that the
        // methods of this script instance will run relative to
        // other script instances in the component
        this.__executionOrder = -1;
    }
    ScriptType.prototype = Object.create(EventHandler.prototype);
    ScriptType.prototype.constructor = ScriptType;

    /**
     * @private
     * @readonly
     * @static
     * @name pc.ScriptType.__name
     * @type {string}
     * @description Name of a Script Type.
     */
    ScriptType.__name = null; // Will be assigned when calling createScript or registerScript.

    ScriptType.__getScriptName = function (constructorFn) {
        if (typeof constructorFn !== 'function') return undefined;
        if ('name' in Function.prototype) return constructorFn.name;
        if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
        var match = ("" + constructorFn).match(funcNameRegex);
        return match ? match[1] : undefined;
    };

    /**
     * @field
     * @static
     * @readonly
     * @name pc.ScriptType.scriptName
     * @type {string|null}
     * @description Name of a Script Type
     */
    Object.defineProperty(ScriptType, 'scriptName', {
        get: function () {
            return this.__name;
        }
    });

    /**
     * @field
     * @static
     * @readonly
     * @name pc.ScriptType.attributes
     * @type {pc.ScriptAttributes}
     * @description The interface to define attributes for Script Types. Refer to {@link pc.ScriptAttributes}.
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.attributes.add('speed', {
     *     type: 'number',
     *     title: 'Speed',
     *     placeholder: 'km/h',
     *     default: 22.2
     * });
     */
    Object.defineProperty(ScriptType, 'attributes', {
        get: function () {
            if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
            return this.__attributes;
        }
    });

    // initialize attributes
    ScriptType.prototype.__initializeAttributes = function (force) {
        if (!force && !this.__attributesRaw)
            return;

        // set attributes values
        for (var key in this.__scriptType.attributes.index) {
            if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
                this[key] = this.__attributesRaw[key];
            } else if (!this.__attributes.hasOwnProperty(key)) {
                if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
                    this[key] = this.__scriptType.attributes.index[key].default;
                } else {
                    this[key] = null;
                }
            }
        }

        this.__attributesRaw = null;
    };

    /**
     * @readonly
     * @static
     * @function
     * @name pc.ScriptType.extend
     * @param {object} methods - Object with methods, where key - is name of method, and value - is function.
     * @description Shorthand function to extend Script Type prototype with list of methods.
     * @example
     * var PlayerController = pc.createScript('playerController');
     *
     * PlayerController.extend({
     *     initialize: function () {
     *         // called once on initialize
     *     },
     *     update: function (dt) {
     *         // called each tick
     *     }
     * });
     */
    ScriptType.extend = function (methods) {
        for (var key in methods) {
            if (!methods.hasOwnProperty(key))
                continue;

            this.prototype[key] = methods[key];
        }
    };

    /**
     * @function
     * @name pc.ScriptType#[initialize]
     * @description Called when script is about to run for the first time.
     */

    /**
     * @function
     * @name pc.ScriptType#[postInitialize]
     * @description Called after all initialize methods are executed in the same tick or enabling chain of actions.
     */

    /**
     * @function
     * @name pc.ScriptType#[update]
     * @description Called for enabled (running state) scripts on each tick.
     * @param {number} dt - The delta time in seconds since the last frame.
     */

    /**
     * @function
     * @name pc.ScriptType#[postUpdate]
     * @description Called for enabled (running state) scripts on each tick, after update.
     * @param {number} dt - The delta time in seconds since the last frame.
     */

    /**
     * @function
     * @name pc.ScriptType#[swap]
     * @description Called when a ScriptType that already exists in the registry
     * gets redefined. If the new ScriptType has a `swap` method in its prototype,
     * then it will be executed to perform hot-reload at runtime.
     */

    /**
     * @event
     * @name pc.ScriptType#enable
     * @description Fired when a script instance becomes enabled.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('enable', function () {
     *         // Script Instance is now enabled
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#disable
     * @description Fired when a script instance becomes disabled.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('disable', function () {
     *         // Script Instance is now disabled
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#state
     * @description Fired when a script instance changes state to enabled or disabled.
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('state', function (enabled) {
     *         console.log('Script Instance is now ' + (enabled ? 'enabled' : 'disabled'));
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#destroy
     * @description Fired when a script instance is destroyed and removed from component.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('destroy', function () {
     *         // no more part of an entity
     *         // good place to cleanup entity from destroyed script
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#attr
     * @description Fired when any script attribute has been changed.
     * @param {string} name - Name of attribute.
     * @param {object} value - New value.
     * @param {object} valueOld - Old value.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('attr', function (name, value, valueOld) {
     *         console.log(name + ' been changed from ' + valueOld + ' to ' + value);
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#attr:[name]
     * @description Fired when a specific script attribute has been changed.
     * @param {object} value - New value.
     * @param {object} valueOld - Old value.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('attr:speed', function (value, valueOld) {
     *         console.log('speed been changed from ' + valueOld + ' to ' + value);
     *     });
     * };
     */

    /**
     * @event
     * @name pc.ScriptType#error
     * @description Fired when a script instance had an exception. The script instance will be automatically disabled.
     * @param {Error} err - Native JavaScript Error object with details of error.
     * @param {string} method - The method of the script instance that the exception originated from.
     * @example
     * PlayerController.prototype.initialize = function () {
     *     this.on('error', function (err, method) {
     *         // caught an exception
     *         console.log(err.stack);
     *     });
     * };
     */

    Object.defineProperty(ScriptType.prototype, 'enabled', {
        get: function () {
            return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
        },
        set: function (value) {
            this._enabled = !!value;

            if (this.enabled === this._enabledOld) return;

            this._enabledOld = this.enabled;
            this.fire(this.enabled ? 'enable' : 'disable');
            this.fire('state', this.enabled);

            // initialize script if not initialized yet and script is enabled
            if (!this._initialized && this.enabled) {
                this._initialized = true;

                this.__initializeAttributes(true);

                if (this.initialize)
                    this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);
            }

            // post initialize script if not post initialized yet and still enabled
            // (initilize might have disabled the script so check this.enabled again)
            // Warning: Do not do this if the script component is currently being enabled
            // because in this case post initialize must be called after all the scripts
            // in the script component have been initialized first
            if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
                this._postInitialized = true;

                if (this.postInitialize)
                    this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);
            }
        }
    });

    /* eslint-disable jsdoc/no-undefined-types */
    /**
     * @static
     * @function
     * @name pc.createScript
     * @description Create and register a new {@link pc.ScriptType}.
     * It returns new class type (constructor function), which is auto-registered to {@link pc.ScriptRegistry} using it's name.
     * This is the main interface to create Script Types, to define custom logic using JavaScript, that is used to create interaction for entities.
     * @param {string} name - Unique Name of a Script Type.
     * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
     * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
     * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
     * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
     * @param {pc.Application} [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to add a script to.
     * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
     * @returns {Class<pc.ScriptType>} A class type (constructor function) that inherits {@link pc.ScriptType},
     * which the developer is meant to further extend by adding attributes and prototype methods.
     * @example
     * var Turning = pc.createScript('turn');
     *
     * // define `speed` attribute that is available in Editor UI
     * Turning.attributes.add('speed', {
     *     type: 'number',
     *     default: 180,
     *     placeholder: 'deg/s'
     * });
     *
     * // runs every tick
     * Turning.prototype.update = function (dt) {
     *     this.entity.rotate(0, this.speed * dt, 0);
     * };
     */
    /* eslint-enable jsdoc/no-undefined-types */
    function createScript(name, app) {
        if (script.legacy) {
            return null;
        }

        if (createScript.reservedScripts[name])
            throw new Error('script name: \'' + name + '\' is reserved, please change script name');

        var scriptType = function (args) {
            ScriptType.call(this, args);
        };

        scriptType.prototype = Object.create(ScriptType.prototype);
        scriptType.prototype.constructor = scriptType;

        scriptType.extend = ScriptType.extend;
        scriptType.attributes = new ScriptAttributes(scriptType);

        registerScript(scriptType, name, app);
        return scriptType;
    }

    /* eslint-disable jsdoc/no-undefined-types */
    /* eslint-disable jsdoc/check-examples */
    /**
     * @static
     * @function
     * @name pc.registerScript
     * @description Register a existing class type as a Script Type to {@link pc.ScriptRegistry}.
     * Useful when defining a ES6 script class that extends {@link pc.ScriptType} (see example).
     * @param {Class<pc.ScriptType>} script - The existing class type (constructor function) to be registered as a Script Type.
     * Class must extend {@link pc.ScriptType} (see example). Please note: A class created using {@link pc.createScript} is auto-registered,
     * and should therefore not be pass into {@link pc.registerScript} (which would result in swapping out all related script instances).
     * @param {string} [name] - Optional unique name of the Script Type. By default it will use the same name as the existing class.
     * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
     * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
     * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
     * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
     * @param {pc.Application} [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to register the script type to.
     * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
     * @example
     * // define a ES6 script class
     * class PlayerController extends pc.ScriptType {
     *
     *     initialize() {
     *         // called once on initialize
     *     }
     *
     *     update(dt) {
     *         // called each tick
     *     }
     * }
     *
     * // register the class as a script
     * pc.registerScript(PlayerController);
     *
     * // declare script attributes (Must be after pc.registerScript())
     * PlayerController.attributes.add('attribute1', {type: 'number'});
     */
    /* eslint-enable jsdoc/check-examples */
    /* eslint-enable jsdoc/no-undefined-types */
    function registerScript(script, name, app) {
        if (script.legacy) {
            return;
        }

        if (typeof script !== 'function')
            throw new Error('script class: \'' + script + '\' must be a constructor function (i.e. class).');

        if (!(script.prototype instanceof ScriptType))
            throw new Error('script class: \'' + ScriptType.__getScriptName(script) + '\' does not extend pc.ScriptType.');

        name = name || script.__name || ScriptType.__getScriptName(script);

        if (createScript.reservedScripts[name])
            throw new Error('script name: \'' + name + '\' is reserved, please change script name');

        script.__name = name;

        // add to scripts registry
        var registry = app ? app.scripts : Application.getApplication().scripts;
        registry.add(script);

        ScriptHandler._push(script);
    }

    // reserved scripts
    createScript.reservedScripts = [
        'system', 'entity', 'create', 'destroy', 'swap', 'move',
        'scripts', '_scripts', '_scriptsIndex', '_scriptsData',
        'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange',
        '_onSetEnabled', '_checkState', '_onBeforeRemove',
        '_onInitializeAttributes', '_onInitialize', '_onPostInitialize',
        '_onUpdate', '_onPostUpdate',
        '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent'
    ];
    var reservedScripts = { };
    var i;
    for (i = 0; i < createScript.reservedScripts.length; i++)
        reservedScripts[createScript.reservedScripts[i]] = 1;
    createScript.reservedScripts = reservedScripts;


    // reserved script attribute names
    createScript.reservedAttributes = [
        'app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed',
        '__attributes', '__attributesRaw', '__scriptType', '__executionOrder',
        '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent'
    ];
    var reservedAttributes = { };
    for (i = 0; i < createScript.reservedAttributes.length; i++)
        reservedAttributes[createScript.reservedAttributes[i]] = 1;
    createScript.reservedAttributes = reservedAttributes;

    /**
     * @private
     * @class
     * @name pc.SortedLoopArray
     * @classdesc Helper class used to hold an array of items in a specific order. This array is safe to modify
     * while we loop through it. The class assumes that it holds objects that need to be sorted based on
     * one of their fields.
     * @param {object} args - Arguments.
     * @param {string} args.sortBy - The name of the field that each element in the array is going to be sorted by.
     * @property {number} loopIndex The current index used to loop through the array. This gets modified if we
     * add or remove elements from the array while looping. See the example to see how to loop through this array.
     * @property {number} length The number of elements in the array.
     * @property {object[]} items The internal array that holds the actual array elements.
     * @example
     * var array = new pc.SortedLoopArray({ sortBy: 'priority' });
     * array.insert(item); // adds item to the right slot based on item.priority
     * array.append(item); // adds item to the end of the array
     * array.remove(item); // removes item from array
     * for (array.loopIndex = 0; array.loopIndex < array.length; array.loopIndex++) {
     *   // do things with array elements
     *   // safe to remove and add elements into the array while looping
     * }
     */

    function SortedLoopArray(args) {
        this._sortBy = args.sortBy;
        this.items = [];
        this.length = 0;
        this.loopIndex = -1;
        this._sortHandler = this._doSort.bind(this);
    }

    /**
     * @private
     * @function
     * @name pc.SortedLoopArray#_binarySearch
     * @description Searches for the right spot to insert the specified item.
     * @param {object} item - The item.
     * @returns {number} The index where to insert the item.
     */
    SortedLoopArray.prototype._binarySearch = function (item) {
        var left = 0;
        var right = this.items.length - 1;
        var search = item[this._sortBy];

        var middle;
        var current;
        while (left <= right) {
            middle = Math.floor((left + right) / 2);
            current = this.items[middle][this._sortBy];
            if (current <= search) {
                left = middle + 1;
            } else if (current > search) {
                right = middle - 1;
            }
        }

        return left;
    };

    SortedLoopArray.prototype._doSort = function (a, b) {
        var sortBy = this._sortBy;
        return a[sortBy] - b[sortBy];
    };

    /**
     * @private
     * @function
     * @name pc.SortedLoopArray#insert
     * @description Inserts the specified item into the array at the right
     * index based on the 'sortBy' field passed into the constructor. This
     * also adjusts the loopIndex accordingly.
     * @param {object} item - The item to insert.
     */
    SortedLoopArray.prototype.insert = function (item) {
        var index = this._binarySearch(item);
        this.items.splice(index, 0, item);
        this.length++;
        if (this.loopIndex >= index) {
            this.loopIndex++;
        }
    };

    /**
     * @private
     * @function
     * @name pc.SortedLoopArray#append
     * @description Appends the specified item to the end of the array. Faster than insert()
     * as it does not binary search for the right index. This also adjusts
     * the loopIndex accordingly.
     * @param {object} item - The item to append.
     */
    SortedLoopArray.prototype.append = function (item) {
        this.items.push(item);
        this.length++;
    };

    /**
     * @private
     * @function
     * @name pc.SortedLoopArray#remove
     * @description Removes the specified item from the array.
     * @param {object} item - The item to remove.
     */
    SortedLoopArray.prototype.remove = function (item) {
        var idx = this.items.indexOf(item);
        if (idx < 0) return;

        this.items.splice(idx, 1);
        this.length--;
        if (this.loopIndex >= idx) {
            this.loopIndex--;
        }
    };

    /**
     * @private
     * @function
     * @name pc.SortedLoopArray#sort
     * @description Sorts elements in the array based on the 'sortBy' field
     * passed into the constructor. This also updates the loopIndex
     * if we are currently looping.
     * WARNING: Be careful if you are sorting while iterating because if after
     * sorting the array element that you are currently processing is moved
     * behind other elements then you might end up iterating over elements more than once!
     */
    SortedLoopArray.prototype.sort = function () {
        // get current item pointed to by loopIndex
        var current = (this.loopIndex >= 0 ? this.items[this.loopIndex] : null);
        // sort
        this.items.sort(this._sortHandler);
        // find new loopIndex
        if (current !== null) {
            this.loopIndex = this.items.indexOf(current);
        }
    };

    /**
     * @component
     * @class
     * @name pc.ScriptComponent
     * @augments pc.Component
     * @classdesc The ScriptComponent allows you to extend the functionality of an Entity by attaching your own Script Types defined in JavaScript files
     * to be executed with access to the Entity. For more details on scripting see <a href="//developer.playcanvas.com/user-manual/scripting/">Scripting</a>.
     * @param {pc.ScriptComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {pc.ScriptType[]} scripts An array of all script instances attached to an entity. This Array shall not be modified by developer.
     */
    function ScriptComponent(system, entity) {
        Component.call(this, system, entity);

        // holds all script instances for this component
        this._scripts = [];
        // holds all script instances with an update method
        this._updateList = new SortedLoopArray({ sortBy: '__executionOrder' });
        // holds all script instances with a postUpdate method
        this._postUpdateList = new SortedLoopArray({ sortBy: '__executionOrder' });

        this._scriptsIndex = {};
        this._destroyedScripts = [];
        this._destroyed = false;
        this._scriptsData = null;
        this._oldState = true;

        // override default 'enabled' property of base pc.Component
        // because this is faster
        this._enabled = true;

        // whether this component is currently being enabled
        this._beingEnabled = false;
        // if true then we are currently looping through
        // script instances. This is used to prevent a scripts array
        // from being modified while a loop is being executed
        this._isLoopingThroughScripts = false;

        // the order that this component will be updated
        // by the script system. This is set by the system itself.
        this._executionOrder = -1;

        this.on('set_enabled', this._onSetEnabled, this);
    }
    ScriptComponent.prototype = Object.create(Component.prototype);
    ScriptComponent.prototype.constructor = ScriptComponent;

    ScriptComponent.scriptMethods = {
        initialize: 'initialize',
        postInitialize: 'postInitialize',
        update: 'update',
        postUpdate: 'postUpdate',
        swap: 'swap'
    };

    /**
     * @event
     * @name pc.ScriptComponent#enable
     * @description Fired when Component becomes enabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @example
     * entity.script.on('enable', function () {
     *     // component is enabled
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#disable
     * @description Fired when Component becomes disabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @example
     * entity.script.on('disable', function () {
     *     // component is disabled
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#state
     * @description Fired when Component changes state to enabled or disabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * entity.script.on('state', function (enabled) {
     *     // component changed state
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#remove
     * @description Fired when Component is removed from entity.
     * @example
     * entity.script.on('remove', function () {
     *     // entity has no more script component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#create
     * @description Fired when a script instance is created and attached to component.
     * @param {string} name - The name of the Script Type.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been created.
     * @example
     * entity.script.on('create', function (name, scriptInstance) {
     *     // new script instance added to component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#create:[name]
     * @description Fired when a script instance is created and attached to component.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been created.
     * @example
     * entity.script.on('create:playerController', function (scriptInstance) {
     *     // new script instance 'playerController' is added to component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#destroy
     * @description Fired when a script instance is destroyed and removed from component.
     * @param {string} name - The name of the Script Type.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been destroyed.
     * @example
     * entity.script.on('destroy', function (name, scriptInstance) {
     *     // script instance has been destroyed and removed from component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#destroy:[name]
     * @description Fired when a script instance is destroyed and removed from component.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been destroyed.
     * @example
     * entity.script.on('destroy:playerController', function (scriptInstance) {
     *     // script instance 'playerController' has been destroyed and removed from component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#move
     * @description Fired when a script instance is moved in component.
     * @param {string} name - The name of the Script Type.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been moved.
     * @param {number} ind - New position index.
     * @param {number} indOld - Old position index.
     * @example
     * entity.script.on('move', function (name, scriptInstance, ind, indOld) {
     *     // script instance has been moved in component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#move:[name]
     * @description Fired when a script instance is moved in component.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that has been moved.
     * @param {number} ind - New position index.
     * @param {number} indOld - Old position index.
     * @example
     * entity.script.on('move:playerController', function (scriptInstance, ind, indOld) {
     *     // script instance 'playerController' has been moved in component
     * });
     */

    /**
     * @event
     * @name pc.ScriptComponent#error
     * @description Fired when a script instance had an exception.
     * @param {pc.ScriptType} scriptInstance - The instance of the {@link pc.ScriptType} that raised the exception.
     * @param {Error} err - Native JS Error object with details of an error.
     * @param {string} method - The method of the script instance that the exception originated from.
     * @example
     * entity.script.on('error', function (scriptInstance, err, method) {
     *     // script instance caught an exception
     * });
     */

    Object.assign(ScriptComponent.prototype, {
        onEnable: function () {
            this._beingEnabled = true;
            this._checkState();

            if (!this.entity._beingEnabled) {
                this.onPostStateChange();
            }

            this._beingEnabled = false;
        },

        onDisable: function () {
            this._checkState();
        },

        onPostStateChange: function () {
            var script;

            var wasLooping = this._beginLooping();

            for (var i = 0, len = this.scripts.length; i < len; i++) {
                script = this.scripts[i];

                if (script._initialized && !script._postInitialized && script.enabled) {
                    script._postInitialized = true;

                    if (script.postInitialize)
                        this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);
                }
            }

            this._endLooping(wasLooping);
        },

        // Sets isLoopingThroughScripts to false and returns
        // its previous value
        _beginLooping: function () {
            var looping = this._isLoopingThroughScripts;
            this._isLoopingThroughScripts = true;
            return looping;
        },

        // Restores isLoopingThroughScripts to the specified parameter
        // If all loops are over then remove destroyed scripts form the _scripts array
        _endLooping: function (wasLoopingBefore) {
            this._isLoopingThroughScripts = wasLoopingBefore;
            if (!this._isLoopingThroughScripts) {
                this._removeDestroyedScripts();
            }
        },

        // We also need this handler because it is fired
        // when value === old instead of onEnable and onDisable
        // which are only fired when value !== old
        _onSetEnabled: function (prop, old, value) {
            this._beingEnabled = true;
            this._checkState();
            this._beingEnabled = false;
        },

        _checkState: function () {
            var state = this.enabled && this.entity.enabled;
            if (state === this._oldState)
                return;

            this._oldState = state;

            this.fire(state ? 'enable' : 'disable');
            this.fire('state', state);

            if (state) {
                this.system._addComponentToEnabled(this);
            } else {
                this.system._removeComponentFromEnabled(this);
            }

            var wasLooping = this._beginLooping();

            var script;
            for (var i = 0, len = this.scripts.length; i < len; i++) {
                script = this.scripts[i];
                script.enabled = script._enabled;
            }

            this._endLooping(wasLooping);
        },

        _onBeforeRemove: function () {
            this.fire('remove');

            var wasLooping = this._beginLooping();

            // destroy all scripts
            for (var i = 0; i < this.scripts.length; i++) {
                var script = this.scripts[i];
                if (!script) continue;

                this.destroy(script.__scriptType.__name);
            }

            this._endLooping(wasLooping);
        },

        _removeDestroyedScripts: function () {
            var len = this._destroyedScripts.length;
            if (!len) return;

            var i;
            for (i = 0; i < len; i++) {
                var script = this._destroyedScripts[i];
                this._removeScriptInstance(script);
            }

            this._destroyedScripts.length = 0;

            // update execution order for scripts
            this._resetExecutionOrder(0, this._scripts.length);
        },

        _onInitializeAttributes: function () {
            for (var i = 0, len = this.scripts.length; i < len; i++)
                this.scripts[i].__initializeAttributes();
        },

        _scriptMethod: function (script, method, arg) {
                script[method](arg);
        },

        _onInitialize: function () {
            var script, scripts = this._scripts;

            var wasLooping = this._beginLooping();

            for (var i = 0, len = scripts.length; i < len; i++) {
                script = scripts[i];
                if (!script._initialized && script.enabled) {
                    script._initialized = true;
                    if (script.initialize)
                        this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);
                }
            }

            this._endLooping(wasLooping);
        },

        _onPostInitialize: function () {
            this.onPostStateChange();
        },

        _onUpdate: function (dt) {
            var self = this;
            var list = self._updateList;
            if (! list.length) return;

            var script;

            var wasLooping = self._beginLooping();

            for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
                script = list.items[list.loopIndex];
                if (script.enabled) {
                    self._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);
                }
            }

            self._endLooping(wasLooping);
        },

        _onPostUpdate: function (dt) {
            var self = this;
            var list = self._postUpdateList;
            if (! list.length) return;

            var wasLooping = self._beginLooping();

            var script;

            for (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {
                script = list.items[list.loopIndex];
                if (script.enabled) {
                    self._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);
                }
            }

            self._endLooping(wasLooping);
        },

        /**
         * @private
         * @function
         * @description Inserts script instance into the scripts array at the specified index. Also inserts the script
         * into the update list if it has an update method and the post update list if it has a postUpdate method.
         * @param {object} scriptInstance - The script instance.
         * @param {number} index - The index where to insert the script at. If -1 then append it at the end.
         * @param {number} scriptsLength - The length of the scripts array.
         */
        _insertScriptInstance: function (scriptInstance, index, scriptsLength) {
            if (index === -1) {
                // append script at the end and set execution order
                this._scripts.push(scriptInstance);
                scriptInstance.__executionOrder = scriptsLength;

                // append script to the update list if it has an update method
                if (scriptInstance.update) {
                    this._updateList.append(scriptInstance);
                }

                // add script to the postUpdate list if it has a postUpdate method
                if (scriptInstance.postUpdate) {
                    this._postUpdateList.append(scriptInstance);
                }
            } else {
                // insert script at index and set execution order
                this._scripts.splice(index, 0, scriptInstance);
                scriptInstance.__executionOrder = index;

                // now we also need to update the execution order of all
                // the script instances that come after this script
                this._resetExecutionOrder(index + 1, scriptsLength + 1);

                // insert script to the update list if it has an update method
                // in the right order
                if (scriptInstance.update) {
                    this._updateList.insert(scriptInstance);
                }

                // insert script to the postUpdate list if it has a postUpdate method
                // in the right order
                if (scriptInstance.postUpdate) {
                    this._postUpdateList.insert(scriptInstance);
                }
            }
        },

        _removeScriptInstance: function (scriptInstance) {
            var idx = this._scripts.indexOf(scriptInstance);
            if (idx === -1) return idx;

            this._scripts.splice(idx, 1);

            if (scriptInstance.update) {
                this._updateList.remove(scriptInstance);
            }

            if (scriptInstance.postUpdate) {
                this._postUpdateList.remove(scriptInstance);
            }

            return idx;
        },

        _resetExecutionOrder: function (startIndex, scriptsLength) {
            for (var i = startIndex; i < scriptsLength; i++) {
                this._scripts[i].__executionOrder = i;
            }
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @function
         * @name pc.ScriptComponent#has
         * @description Detect if script is attached to an entity.
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @returns {boolean} If script is attached to an entity.
         * @example
         * if (entity.script.has('playerController')) {
         *     // entity has script
         * }
         */
        /* eslint-enable jsdoc/no-undefined-types */
        has: function (nameOrType) {
            if (typeof nameOrType === 'string') {
                return !!this._scriptsIndex[nameOrType];
            }

            if (!nameOrType) return false;
            var scriptType = nameOrType;
            var scriptName = scriptType.__name;
            var scriptData = this._scriptsIndex[scriptName];
            var scriptInstance = scriptData && scriptData.instance;
            return scriptInstance instanceof scriptType; // will return false if scriptInstance undefined
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @function
         * @name pc.ScriptComponent#get
         * @description Get a script instance (if attached).
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @returns {pc.ScriptType|null} If script is attached, the instance is returned. Otherwise null is returned.
         * @example
         * var controller = entity.script.get('playerController');
         */
        /* eslint-enable jsdoc/no-undefined-types */
        get: function (nameOrType) {
            if (typeof nameOrType === 'string') {
                var data = this._scriptsIndex[nameOrType];
                return data ? data.instance : null;
            }

            if (!nameOrType) return null;
            var scriptType = nameOrType;
            var scriptName = scriptType.__name;
            var scriptData = this._scriptsIndex[scriptName];
            var scriptInstance = scriptData && scriptData.instance;
            return scriptInstance instanceof scriptType ? scriptInstance : null;
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @function
         * @name pc.ScriptComponent#create
         * @description Create a script instance and attach to an entity script component.
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @param {object} [args] - Object with arguments for a script.
         * @param {boolean} [args.enabled] - If script instance is enabled after creation. Defaults to true.
         * @param {object} [args.attributes] - Object with values for attributes (if any), where key is name of an attribute.
         * @param {boolean} [args.preloading] - If script instance is created during preload. If true, script and attributes must be initialized manually. Defaults to false.
         * @param {number} [args.ind] - The index where to insert the script instance at. Defaults to -1, which means append it at the end.
         * @returns {pc.ScriptType} Returns an instance of a {@link pc.ScriptType} if successfully attached to an entity,
         * or null if it failed because a script with a same name has already been added
         * or if the {@link pc.ScriptType} cannot be found by name in the {@link pc.ScriptRegistry}.
         * @example
         * entity.script.create('playerController', {
         *     attributes: {
         *         speed: 4
         *     }
         * });
         */
        /* eslint-enable jsdoc/no-undefined-types */
        create: function (nameOrType, args) {
            var self = this;
            args = args || { };

            var scriptType = nameOrType;
            var scriptName = nameOrType;

            // shorthand using script name
            if (typeof scriptType === 'string') {
                scriptType = this.system.app.scripts.get(scriptType);
            } else if (scriptType) {
                scriptName = scriptType.__name;
            }

            if (scriptType) {
                if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
                    // create script instance
                    var scriptInstance = new scriptType({
                        app: this.system.app,
                        entity: this.entity,
                        enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
                        attributes: args.attributes
                    });

                    var len = this._scripts.length;
                    var ind = -1;
                    if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind)
                        ind = args.ind;

                    this._insertScriptInstance(scriptInstance, ind, len);

                    this._scriptsIndex[scriptName] = {
                        instance: scriptInstance,
                        onSwap: function () {
                            self.swap(scriptName);
                        }
                    };

                    this[scriptName] = scriptInstance;

                    if (!args.preloading)
                        scriptInstance.__initializeAttributes();

                    this.fire('create', scriptName, scriptInstance);
                    this.fire('create:' + scriptName, scriptInstance);

                    this.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);

                    if (!args.preloading) {

                        if (scriptInstance.enabled && !scriptInstance._initialized) {
                            scriptInstance._initialized = true;

                            if (scriptInstance.initialize)
                                this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);
                        }

                        if (scriptInstance.enabled && !scriptInstance._postInitialized) {
                            scriptInstance._postInitialized = true;
                            if (scriptInstance.postInitialize)
                                this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);
                        }
                    }


                    return scriptInstance;
                }

                console.warn('script \'' + scriptName + '\' is already added to entity \'' + this.entity.name + '\'');
            } else {
                this._scriptsIndex[scriptName] = {
                    awaiting: true,
                    ind: this._scripts.length
                };

                console.warn('script \'' + scriptName + '\' is not found, awaiting it to be added to registry');
            }

            return null;
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @function
         * @name pc.ScriptComponent#destroy
         * @description Destroy the script instance that is attached to an entity.
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @returns {boolean} If it was successfully destroyed.
         * @example
         * entity.script.destroy('playerController');
         */
        /* eslint-enable jsdoc/no-undefined-types */
        destroy: function (nameOrType) {
            var scriptName = nameOrType;
            var scriptType = nameOrType;

            // shorthand using script name
            if (typeof scriptType === 'string') {
                scriptType = this.system.app.scripts.get(scriptType);
            } else if (scriptType) {
                scriptName = scriptType.__name;
            }

            var scriptData = this._scriptsIndex[scriptName];
            delete this._scriptsIndex[scriptName];
            if (!scriptData) return false;

            var scriptInstance = scriptData.instance;
            if (scriptInstance && !scriptInstance._destroyed) {
                scriptInstance.enabled = false;
                scriptInstance._destroyed = true;

                // if we are not currently looping through our scripts
                // then it's safe to remove the script
                if (!this._isLoopingThroughScripts) {
                    var ind = this._removeScriptInstance(scriptInstance);
                    if (ind >= 0) {
                        this._resetExecutionOrder(ind, this._scripts.length);
                    }
                } else {
                    // otherwise push the script in _destroyedScripts and
                    // remove it from _scripts when the loop is over
                    this._destroyedScripts.push(scriptInstance);
                }
            }

            // remove swap event
            this.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);

            delete this[scriptName];

            this.fire('destroy', scriptName, scriptInstance || null);
            this.fire('destroy:' + scriptName, scriptInstance || null);

            if (scriptInstance)
                scriptInstance.fire('destroy');

            return true;
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @private
         * @function
         * @name pc.ScriptComponent#swap
         * @description Swap the script instance.
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @returns {boolean} If it was successfully swapped.
         */
        /* eslint-enable jsdoc/no-undefined-types */
        swap: function (nameOrType) {
            var scriptName = nameOrType;
            var scriptType = nameOrType;

            // shorthand using script name
            if (typeof scriptType === 'string') {
                scriptType = this.system.app.scripts.get(scriptType);
            } else if (scriptType) {
                scriptName = scriptType.__name;
            }

            var old = this._scriptsIndex[scriptName];
            if (!old || !old.instance) return false;

            var scriptInstanceOld = old.instance;
            var ind = this._scripts.indexOf(scriptInstanceOld);

            var scriptInstance = new scriptType({
                app: this.system.app,
                entity: this.entity,
                enabled: scriptInstanceOld.enabled,
                attributes: scriptInstanceOld.__attributes
            });

            if (!scriptInstance.swap)
                return false;

            scriptInstance.__initializeAttributes();

            // add to component
            this._scripts[ind] = scriptInstance;
            this._scriptsIndex[scriptName].instance = scriptInstance;
            this[scriptName] = scriptInstance;

            // set execution order and make sure we update
            // our update and postUpdate lists
            scriptInstance.__executionOrder = ind;
            if (scriptInstanceOld.update) {
                this._updateList.remove(scriptInstanceOld);
            }
            if (scriptInstanceOld.postUpdate) {
                this._postUpdateList.remove(scriptInstanceOld);
            }

            if (scriptInstance.update) {
                this._updateList.insert(scriptInstance);
            }
            if (scriptInstance.postUpdate) {
                this._postUpdateList.insert(scriptInstance);
            }

            this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);

            this.fire('swap', scriptName, scriptInstance);
            this.fire('swap:' + scriptName, scriptInstance);

            return true;
        },

        /**
         * @function
         * @private
         * @name pc.ScriptComponent#resolveDuplicatedEntityReferenceProperties
         * @description When an entity is cloned and it has entity script attributes that point
         * to other entities in the same subtree that is cloned, then we want the new script attributes to point
         * at the cloned entities. This method remaps the script attributes for this entity and it assumes that this
         * entity is the result of the clone operation.
         * @param {pc.ScriptComponent} oldScriptComponent - The source script component that belongs to the entity that was being cloned.
         * @param {object} duplicatedIdsMap - A dictionary with guid-entity values that contains the entities that were cloned.
         */
        resolveDuplicatedEntityReferenceProperties: function (oldScriptComponent, duplicatedIdsMap) {
            var newScriptComponent = this.entity.script;

            // for each script in the old compononent
            for (var scriptName in oldScriptComponent._scriptsIndex) {
                // get the script type from the script registry
                var scriptType = this.system.app.scripts.get(scriptName);
                if (! scriptType) {
                    continue;
                }

                // get the script from the component's index
                var script = oldScriptComponent._scriptsIndex[scriptName];
                if (! script || ! script.instance) {
                    continue;
                }

                // if __attributesRaw exists then it means that the new entity
                // has not yet initialized its attributes so put the new guid in there,
                // otherwise it means that the attributes have already been initialized
                // so convert the new guid to an entity
                // and put it in the new attributes
                var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
                var newAttributes = newScriptComponent[scriptName].__attributes;
                if (! newAttributesRaw && ! newAttributes) {
                    continue;
                }

                // get the old script attributes from the instance
                var oldAttributes = script.instance.__attributes;
                for (var attributeName in oldAttributes) {
                    if (! oldAttributes[attributeName]) {
                        continue;
                    }

                    // get the attribute definition from the script type
                    var attribute = scriptType.attributes.get(attributeName);
                    if (! attribute || attribute.type !== 'entity') {
                        continue;
                    }

                    if (attribute.array) {
                        // handle entity array attribute
                        var oldGuidArray = oldAttributes[attributeName];
                        var len = oldGuidArray.length;
                        if (! len) {
                            continue;
                        }

                        var newGuidArray = oldGuidArray.slice();
                        for (var i = 0; i < len; i++) {
                            var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
                            if (duplicatedIdsMap[guid]) {
                                // if we are using attributesRaw then use the guid otherwise use the entity
                                newGuidArray[i] = newAttributesRaw ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
                            }
                        }

                        if (newAttributesRaw) {
                            newAttributesRaw[attributeName] = newGuidArray;
                        } else {
                            newAttributes[attributeName] = newGuidArray;
                        }
                    } else {
                        // handle regular entity attribute
                        var oldGuid = oldAttributes[attributeName];
                        if (oldGuid instanceof Entity) {
                            oldGuid = oldGuid.getGuid();
                        } else if (typeof oldGuid !== 'string') {
                            continue;
                        }

                        if (duplicatedIdsMap[oldGuid]) {
                            if (newAttributesRaw) {
                                newAttributesRaw[attributeName] = duplicatedIdsMap[oldGuid].getGuid();
                            } else {
                                newAttributes[attributeName] = duplicatedIdsMap[oldGuid];
                            }
                        }

                    }
                }
            }
        },

        /* eslint-disable jsdoc/no-undefined-types */
        /**
         * @function
         * @name pc.ScriptComponent#move
         * @description Move script instance to different position to alter update order of scripts within entity.
         * @param {string|Class<pc.ScriptType>} nameOrType - The name or type of {@link pc.ScriptType}.
         * @param {number} ind - New position index.
         * @returns {boolean} If it was successfully moved.
         * @example
         * entity.script.move('playerController', 0);
         */
        /* eslint-enable jsdoc/no-undefined-types */
        move: function (nameOrType, ind) {
            var len = this._scripts.length;
            if (ind >= len || ind < 0)
                return false;

            var scriptType = nameOrType;
            var scriptName = nameOrType;

            if (typeof scriptName !== 'string') {
                scriptName = nameOrType.__name;
            } else {
                scriptType = null;
            }

            var scriptData = this._scriptsIndex[scriptName];
            if (!scriptData || !scriptData.instance)
                return false;

            // if script type specified, make sure instance of said type
            var scriptInstance = scriptData.instance;
            if (scriptType && !(scriptInstance instanceof scriptType))
                return false;

            var indOld = this._scripts.indexOf(scriptInstance);
            if (indOld === -1 || indOld === ind)
                return false;

            // move script to another position
            this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);

            // reset execution order for scripts and re-sort update and postUpdate lists
            this._resetExecutionOrder(0, len);
            this._updateList.sort();
            this._postUpdateList.sort();

            this.fire('move', scriptName, scriptInstance, ind, indOld);
            this.fire('move:' + scriptName, scriptInstance, ind, indOld);

            return true;
        }
    });

    Object.defineProperty(ScriptComponent.prototype, 'enabled', {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            var oldValue = this._enabled;
            this._enabled = value;
            this.fire('set', 'enabled', oldValue, value);
        }
    });

    Object.defineProperty(ScriptComponent.prototype, 'scripts', {
        get: function () {
            return this._scripts;
        },
        set: function (value) {
            this._scriptsData = value;

            for (var key in value) {
                if (!value.hasOwnProperty(key))
                    continue;

                var script = this._scriptsIndex[key];
                if (script) {
                    // existing script

                    // enabled
                    if (typeof value[key].enabled === 'boolean')
                        script.enabled = !!value[key].enabled;

                    // attributes
                    if (typeof value[key].attributes === 'object') {
                        for (var attr in value[key].attributes) {
                            if (createScript.reservedAttributes[attr])
                                continue;

                            if (!script.__attributes.hasOwnProperty(attr)) {
                                // new attribute
                                var scriptType = this.system.app.scripts.get(key);
                                if (scriptType)
                                    scriptType.attributes.add(attr, { });
                            }

                            // update attribute
                            script[attr] = value[key].attributes[attr];
                        }
                    }
                } else {
                    // TODO scripts2
                    // new script
                    console.log(this.order);
                }
            }
        }
    });

    function ScriptComponentData() {
        this.enabled = true;
    }

    var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
    var METHOD_INITIALIZE = '_onInitialize';
    var METHOD_POST_INITIALIZE = '_onPostInitialize';
    var METHOD_UPDATE = '_onUpdate';
    var METHOD_POST_UPDATE = '_onPostUpdate';

    // Ever-increasing integer used as the
    // execution order of new script components.
    // We are using an ever-increasing number and not
    // the order of the script component in the components
    // array because if we ever remove components from the array
    // we would have to re-calculate the execution order for all subsequent
    // script components in the array every time, which would be slow
    var executionOrderCounter = 0;

    /**
     * @class
     * @name pc.ScriptComponentSystem
     * @augments pc.ComponentSystem
     * @description Create a new ScriptComponentSystem.
     * @classdesc Allows scripts to be attached to an Entity and executed.
     * @param {pc.Application} app - The application.
     */
    function ScriptComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'script';

        this.ComponentType = ScriptComponent;
        this.DataType = ScriptComponentData;

        // list of all entities script components
        // we are using pc.SortedLoopArray because it is
        // safe to modify while looping through it
        this._components = new SortedLoopArray({
            sortBy: '_executionOrder'
        });

        // holds all the enabled script components
        // (whose entities are also enabled). We are using pc.SortedLoopArray
        // because it is safe to modify while looping through it. This array often
        // change during update and postUpdate loops as entities and components get
        // enabled or disabled
        this._enabledComponents = new SortedLoopArray({
            sortBy: '_executionOrder'
        });


        // if true then we are currently preloading scripts
        this.preloading = true;

        this.on('beforeremove', this._onBeforeRemove, this);
        ComponentSystem.bind('initialize', this._onInitialize, this);
        ComponentSystem.bind('postInitialize', this._onPostInitialize, this);
        ComponentSystem.bind('update', this._onUpdate, this);
        ComponentSystem.bind('postUpdate', this._onPostUpdate, this);
    }
    ScriptComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ScriptComponentSystem.prototype.constructor = ScriptComponentSystem;

    Object.assign(ScriptComponentSystem.prototype, {
        initializeComponentData: function (component, data) {
            // Set execution order to an ever-increasing number
            // and add to the end of the components array.
            component._executionOrder = executionOrderCounter++;
            this._components.append(component);

            // check we don't overflow executionOrderCounter
            if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
                this._resetExecutionOrder();
            }

            component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
            // if enabled then add this component to the end of the enabledComponents array
            // Note, we should be OK to just append this to the end instead of using insert()
            // which will search for the right slot to insert the component based on execution order,
            // because the execution order of this script should be larger than all the others in the
            // enabledComponents array since it was just added.
            if (component.enabled && component.entity.enabled) {
                this._enabledComponents.append(component);
            }

            if (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {
                component._scriptsData = data.scripts;

                for (var i = 0; i < data.order.length; i++) {
                    component.create(data.order[i], {
                        enabled: data.scripts[data.order[i]].enabled,
                        attributes: data.scripts[data.order[i]].attributes,
                        preloading: this.preloading
                    });
                }
            }
        },

        cloneComponent: function (entity, clone) {
            var i, key;
            var order = [];
            var scripts = { };

            for (i = 0; i < entity.script._scripts.length; i++) {
                var scriptInstance = entity.script._scripts[i];
                var scriptName = scriptInstance.__scriptType.__name;
                order.push(scriptName);

                var attributes = { };
                for (key in scriptInstance.__attributes)
                    attributes[key] = scriptInstance.__attributes[key];

                scripts[scriptName] = {
                    enabled: scriptInstance._enabled,
                    attributes: attributes
                };
            }

            for (key in entity.script._scriptsIndex) {
                if (key.awaiting) {
                    order.splice(key.ind, 0, key);
                }
            }

            var data = {
                enabled: entity.script.enabled,
                order: order,
                scripts: scripts
            };

            return this.addComponent(clone, data);
        },

        _resetExecutionOrder: function () {
            executionOrderCounter = 0;
            for (var i = 0, len = this._components.length; i < len; i++) {
                this._components.items[i]._executionOrder = executionOrderCounter++;
            }
        },

        _callComponentMethod: function (components, name, dt) {
            for (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {
                components.items[components.loopIndex][name](dt);
            }
        },

        _onInitialize: function () {
            this.preloading = false;

            // initialize attributes on all components
            this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);

            // call onInitialize on enabled components
            this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
        },

        _onPostInitialize: function () {
            // call onPostInitialize on enabled components
            this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
        },

        _onUpdate: function (dt) {
            // call onUpdate on enabled components
            this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
        },

        _onPostUpdate: function (dt) {
            // call onPostUpdate on enabled components
            this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
        },

        // inserts the component into the enabledComponents array
        // which finds the right slot based on component._executionOrder
        _addComponentToEnabled: function (component)  {
            this._enabledComponents.insert(component);
        },

        // removes the component from the enabledComponents array
        _removeComponentFromEnabled: function (component) {
            this._enabledComponents.remove(component);
        },

        _onBeforeRemove: function (entity, component) {
            var ind = this._components.items.indexOf(component);
            if (ind >= 0) {
                component._onBeforeRemove();
            }

            this._removeComponentFromEnabled(component);

            // remove from components array
            this._components.remove(component);
        }
    });

    function ScriptLegacyComponent(system, entity) {
        Component.call(this, system, entity);

        this.on("set_scripts", this.onSetScripts, this);
    }
    ScriptLegacyComponent.prototype = Object.create(Component.prototype);
    ScriptLegacyComponent.prototype.constructor = ScriptLegacyComponent;

    Object.assign(ScriptLegacyComponent.prototype, {
        send: function (name, functionName) {
            console.warn("DEPRECATED: ScriptLegacyComponent.send() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
            var args = makeArray(arguments).slice(2);
            var instances = this.entity.script.instances;
            var fn;

            if (instances && instances[name]) {
                fn = instances[name].instance[functionName];
                if (fn) {
                    return fn.apply(instances[name].instance, args);
                }

            }
        },

        onEnable: function () {
            // if the scripts of the component have been loaded
            // then call the appropriate methods on the component
            if (this.data.areScriptsLoaded && !this.system.preloading) {
                if (!this.data.initialized) {
                    this.system._initializeScriptComponent(this);
                } else {
                    this.system._enableScriptComponent(this);
                }

                if (!this.data.postInitialized) {
                    this.system._postInitializeScriptComponent(this);
                }
            }
        },

        onDisable: function () {
            this.system._disableScriptComponent(this);
        },

        onSetScripts: function (name, oldValue, newValue) {
            if (!this.system._inTools || this.runInTools) {
                // if we only need to update script attributes then update them and return
                if (this._updateScriptAttributes(oldValue, newValue)) {
                    return;
                }

                // disable the script first
                if (this.enabled) {
                    this.system._disableScriptComponent(this);
                }

                this.system._destroyScriptComponent(this);

                this.data.areScriptsLoaded = false;

                // get the urls
                var scripts = newValue;
                var urls = scripts.map(function (s) {
                    return s.url;
                });

                // try to load the scripts synchronously first
                if (this._loadFromCache(urls)) {
                    return;
                }

                // not all scripts are in the cache so load them asynchronously
                this._loadScripts(urls);
            }
        },

        // Check if only script attributes need updating in which
        // case just update the attributes and return otherwise return false
        _updateScriptAttributes: function (oldValue, newValue) {
            var onlyUpdateAttributes = true;

            if (oldValue.length !== newValue.length) {
                onlyUpdateAttributes = false;
            } else {
                var i, len = newValue.length;
                for (i = 0; i < len; i++) {
                    if (oldValue[i].url !== newValue[i].url) {
                        onlyUpdateAttributes = false;
                        break;
                    }
                }
            }

            if (onlyUpdateAttributes) {
                for (var key in this.instances) {
                    if (this.instances.hasOwnProperty(key)) {
                        this.system._updateAccessors(this.entity, this.instances[key]);
                    }
                }
            }

            return onlyUpdateAttributes;
        },

        // Load each url from the cache synchronously. If one of the urls is not in the cache
        // then stop and return false.
        _loadFromCache: function (urls) {
            var i, len;
            var cached = [];

            var prefix = this.system.app._scriptPrefix || "";
            var regex = /^http(s)?:\/\//i;

            for (i = 0, len = urls.length; i < len; i++) {
                var url = urls[i];
                if (!regex.test(url)) {
                    url = path.join(prefix, url);
                }

                var type = this.system.app.loader.getFromCache(url, 'script');

                // if we cannot find the script in the cache then return and load
                // all scripts with the resource loader
                if (!type) {
                    return false;
                }

                cached.push(type);
            }

            for (i = 0, len = cached.length; i < len; i++) {
                var ScriptType = cached[i];

                // check if this is a regular JS file
                if (ScriptType === true) {
                    continue;
                }

                // ScriptType may be null if the script component is loading an ordinary JavaScript lib rather than a PlayCanvas script
                // Make sure that script component hasn't been removed since we started loading
                if (ScriptType && this.entity.script) {
                    // Make sure that we haven't already instantiated another identical script while loading
                    // e.g. if you do addComponent, removeComponent, addComponent, in quick succession
                    if (!this.entity.script.instances[ScriptType._pcScriptName]) {
                        var instance = new ScriptType(this.entity);
                        this.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);
                    }
                }
            }

            if (this.data) {
                this.data.areScriptsLoaded = true;
            }

            // We only need to initialize after preloading is complete
            // During preloading all scripts are initialized after everything is loaded
            if (!this.system.preloading) {
                this.system.onInitialize(this.entity);
                this.system.onPostInitialize(this.entity);
            }

            return true;
        },

        _loadScripts: function (urls) {
            var count = urls.length;

            var prefix = this.system.app._scriptPrefix || "";

            urls.forEach(function (url) {
                var _url = null;
                var _unprefixed = null;
                // support absolute URLs (for now)
                if (url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://")) {
                    _unprefixed = url;
                    _url = url;
                } else {
                    _unprefixed = url;
                    _url = path.join(prefix, url);
                }
                this.system.app.loader.load(_url, "script", function (err, ScriptType) {
                    count--;
                    if (!err) {
                        // ScriptType is null if the script is not a PlayCanvas script
                        if (ScriptType && this.entity.script) {
                            if (!this.entity.script.instances[ScriptType._pcScriptName]) {
                                var instance = new ScriptType(this.entity);
                                this.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);
                            }
                        }
                    } else {
                        console.error(err);
                    }
                    if (count === 0) {
                        this.data.areScriptsLoaded = true;

                        // We only need to initialize after preloading is complete
                        // During preloading all scripts are initialized after everything is loaded
                        if (!this.system.preloading) {
                            this.system.onInitialize(this.entity);
                            this.system.onPostInitialize(this.entity);
                        }
                    }
                }.bind(this));
            }.bind(this));
        }
    });

    function ScriptLegacyComponentData() {
        // serialized
        this.scripts = [];
        this.enabled = true;

        // not serialized
        this.instances = {};
        this._instances = {};
        this.runInTools = false;
        this.attributes = {};
        this.initialized = false;
        this.postInitialized = false;
        this.areScriptsLoaded = false;
    }

    var _schema$e = [
        'enabled',
        'scripts',
        'instances',
        'runInTools'
    ];

    var INITIALIZE = "initialize";
    var POST_INITIALIZE = "postInitialize";
    var UPDATE = "update";
    var POST_UPDATE = "postUpdate";
    var FIXED_UPDATE = "fixedUpdate";
    var TOOLS_UPDATE = "toolsUpdate";
    var ON_ENABLE = 'onEnable';
    var ON_DISABLE = 'onDisable';

    var ScriptLegacyComponentSystem = function ScriptLegacyComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'script';
        this.description = "Allows the Entity to run JavaScript fragments to implement custom behavior.";

        this.ComponentType = ScriptLegacyComponent;
        this.DataType = ScriptLegacyComponentData;
        this.schema = _schema$e;

        // used by application during preloading phase to ensure scripts aren't
        // initialized until everything is loaded
        this.preloading = false;

        // arrays to cache script instances for fast iteration
        this.instancesWithUpdate = [];
        this.instancesWithFixedUpdate = [];
        this.instancesWithPostUpdate = [];
        this.instancesWithToolsUpdate = [];

        this.on('beforeremove', this.onBeforeRemove, this);
        ComponentSystem.bind(INITIALIZE, this.onInitialize, this);
        ComponentSystem.bind(POST_INITIALIZE, this.onPostInitialize, this);
        ComponentSystem.bind(UPDATE, this.onUpdate, this);
        ComponentSystem.bind(FIXED_UPDATE, this.onFixedUpdate, this);
        ComponentSystem.bind(POST_UPDATE, this.onPostUpdate, this);
        ComponentSystem.bind(TOOLS_UPDATE, this.onToolsUpdate, this);
    };
    ScriptLegacyComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ScriptLegacyComponentSystem.prototype.constructor = ScriptLegacyComponentSystem;

    Component._buildAccessors(ScriptLegacyComponent.prototype, _schema$e);

    Object.assign(ScriptLegacyComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['runInTools', 'enabled', 'scripts'];

            // convert attributes array to dictionary
            if (data.scripts && data.scripts.length) {
                data.scripts.forEach(function (script) {
                    if (script.attributes && type(script.attributes) === 'array') {
                        var dict = {};
                        for (var i = 0; i < script.attributes.length; i++) {
                            dict[script.attributes[i].name] = script.attributes[i];
                        }

                        script.attributes = dict;
                    }
                });
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            // overridden to make sure urls list is duplicated
            var src = this.store[entity.getGuid()];
            var data = {
                runInTools: src.data.runInTools,
                scripts: [],
                enabled: src.data.enabled
            };

            // manually clone scripts so that we don't clone attributes with pc.extend
            // which will result in a stack overflow when extending 'entity' script attributes
            var scripts = src.data.scripts;
            for (var i = 0, len = scripts.length; i < len; i++) {
                var attributes = scripts[i].attributes;
                if (attributes) {
                    delete scripts[i].attributes;
                }

                data.scripts.push(extend({}, scripts[i]));

                if (attributes) {
                    data.scripts[i].attributes = this._cloneAttributes(attributes);
                    scripts[i].attributes = attributes;
                }
            }

            return this.addComponent(clone, data);
        },

        onBeforeRemove: function (entity, component) {
            // if the script component is enabled
            // call onDisable on all its instances first
            if (component.enabled) {
                this._disableScriptComponent(component);
            }

            // then call destroy on all the script instances
            this._destroyScriptComponent(component);
        },

        onInitialize: function (root) {
            this._registerInstances(root);

            if (root.enabled) {
                if (root.script && root.script.enabled) {
                    this._initializeScriptComponent(root.script);
                }

                var children = root._children;
                var i, len = children.length;
                for (i = 0; i < len; i++) {
                    if (children[i] instanceof Entity) {
                        this.onInitialize(children[i]);
                    }
                }
            }
        },

        onPostInitialize: function (root) {
            if (root.enabled) {
                if (root.script && root.script.enabled) {
                    this._postInitializeScriptComponent(root.script);
                }

                var children = root._children;
                var i, len = children.length;
                for (i = 0; i < len; i++) {
                    if (children[i] instanceof Entity) {
                        this.onPostInitialize(children[i]);
                    }
                }
            }
        },

        _callInstancesMethod: function (script, method) {
            var instances = script.data.instances;
            for (var name in instances) {
                if (instances.hasOwnProperty(name)) {
                    var instance = instances[name].instance;
                    if (instance[method]) {
                        instance[method]();
                    }
                }
            }
        },

        _initializeScriptComponent: function (script) {
            this._callInstancesMethod(script, INITIALIZE);
            script.data.initialized = true;

            // check again if the script and the entity are enabled
            // in case they got disabled during initialize
            if (script.enabled && script.entity.enabled) {
                this._enableScriptComponent(script);
            }
        },

        _enableScriptComponent: function (script) {
            this._callInstancesMethod(script, ON_ENABLE);
        },

        _disableScriptComponent: function (script) {
            this._callInstancesMethod(script, ON_DISABLE);
        },

        _destroyScriptComponent: function (script) {
            var index;
            var instances = script.data.instances;
            for (var name in instances) {
                if (instances.hasOwnProperty(name)) {
                    var instance = instances[name].instance;
                    if (instance.destroy) {
                        instance.destroy();
                    }

                    if (instance.update) {
                        index = this.instancesWithUpdate.indexOf(instance);
                        if (index >= 0) {
                            this.instancesWithUpdate.splice(index, 1);
                        }
                    }

                    if (instance.fixedUpdate) {
                        index = this.instancesWithFixedUpdate.indexOf(instance);
                        if (index >= 0) {
                            this.instancesWithFixedUpdate.splice(index, 1);
                        }
                    }

                    if (instance.postUpdate) {
                        index = this.instancesWithPostUpdate.indexOf(instance);
                        if (index >= 0) {
                            this.instancesWithPostUpdate.splice(index, 1);
                        }
                    }

                    if (instance.toolsUpdate) {
                        index = this.instancesWithToolsUpdate.indexOf(instance);
                        if (index >= 0) {
                            this.instancesWithToolsUpdate.splice(index, 1);
                        }
                    }

                    if (script.instances[name].instance === script[name]) {
                        delete script[name];
                    }
                    delete script.instances[name];
                }
            }
        },

        _postInitializeScriptComponent: function (script) {
            this._callInstancesMethod(script, POST_INITIALIZE);
            script.data.postInitialized = true;
        },

        _updateInstances: function (method, updateList, dt) {
            var item;
            for (var i = 0, len = updateList.length; i < len; i++) {
                item = updateList[i];
                if (item && item.entity && item.entity.enabled && item.entity.script.enabled) {
                    item[method](dt);
                }
            }
        },

        onUpdate: function (dt) {
            this._updateInstances(UPDATE, this.instancesWithUpdate, dt);
        },

        onFixedUpdate: function (dt) {
            this._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);
        },

        onPostUpdate: function (dt) {
            this._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);
        },

        onToolsUpdate: function (dt) {
            this._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);
        },

        broadcast: function (name, functionName) {
            console.warn("DEPRECATED: ScriptLegacyComponentSystem.broadcast() is deprecated and will be removed soon. Please use: http://developer.playcanvas.com/user-manual/scripting/communication/");
            var args = makeArray(arguments).slice(2);

            var id, data, fn;
            var dataStore = this.store;
            // var results = [];

            for (id in dataStore) {
                if (dataStore.hasOwnProperty(id)) {
                    data = dataStore[id].data;
                    if (data.instances[name]) {
                        fn = data.instances[name].instance[functionName];
                        if (fn) {
                            fn.apply(data.instances[name].instance, args);
                        }
                    }
                }
            }
        },

        _preRegisterInstance: function (entity, url, name, instance) {
            if (entity.script) {
                entity.script.data._instances = entity.script.data._instances || {};
                if (entity.script.data._instances[name]) {
                    throw Error("Script name collision '" + name + "'. Scripts from '" + url + "' and '" + entity.script.data._instances[name].url + "' {" + entity.getGuid() + "}");
                }
                entity.script.data._instances[name] = {
                    url: url,
                    name: name,
                    instance: instance
                };
            }
        },

        _registerInstances: function (entity) {
            var preRegistered, instance, instanceName;

            if (entity.script) {
                if (entity.script.data._instances) {
                    entity.script.instances = entity.script.data._instances;

                    for (instanceName in entity.script.instances) {
                        preRegistered = entity.script.instances[instanceName];
                        instance = preRegistered.instance;

                        events.attach(instance);

                        if (instance.update) {
                            this.instancesWithUpdate.push(instance);
                        }

                        if (instance.fixedUpdate) {
                            this.instancesWithFixedUpdate.push(instance);
                        }

                        if (instance.postUpdate) {
                            this.instancesWithPostUpdate.push(instance);
                        }

                        if (instance.toolsUpdate) {
                            this.instancesWithToolsUpdate.push(instance);
                        }

                        if (entity.script.scripts) {
                            this._createAccessors(entity, preRegistered);
                        }

                        // Make instance accessible from the script component of the Entity
                        if (entity.script[instanceName]) {
                            throw Error("Script with name '" + instanceName + "' is already attached to Script Component");
                        } else {
                            entity.script[instanceName] = instance;
                        }
                    }

                    // Remove temp storage
                    delete entity.script.data._instances;
                }

            }

            var children = entity._children;
            var i, len = children.length;
            for (i = 0; i < len; i++) {
                if (children[i] instanceof Entity) {
                    this._registerInstances(children[i]);
                }
            }
        },

        _cloneAttributes: function (attributes) {
            var result = {};

            for (var key in attributes) {
                if (!attributes.hasOwnProperty(key))
                    continue;

                if (attributes[key].type !== 'entity') {
                    result[key] = extend({}, attributes[key]);
                } else {
                    // don't pc.extend an entity
                    var val = attributes[key].value;
                    delete attributes[key].value;

                    result[key] = extend({}, attributes[key]);
                    result[key].value = val;

                    attributes[key].value = val;
                }
            }

            return result;
        },

        _createAccessors: function (entity, instance) {
            var self = this;
            var i;
            var len = entity.script.scripts.length;
            var url = instance.url;

            for (i = 0; i < len; i++) {
                var script = entity.script.scripts[i];
                if (script.url === url) {
                    var attributes = script.attributes;
                    if (script.name && attributes) {
                        for (var key in attributes) {
                            if (attributes.hasOwnProperty(key)) {
                                self._createAccessor(attributes[key], instance);
                            }
                        }

                        entity.script.data.attributes[script.name] = self._cloneAttributes(attributes);
                    }
                    break;
                }
            }
        },

        _createAccessor: function (attribute, instance) {
            var self = this;

            // create copy of attribute data
            // to avoid overwriting the same attribute values
            // that are used by the Editor
            attribute = {
                name: attribute.name,
                value: attribute.value,
                type: attribute.type
            };

            self._convertAttributeValue(attribute);

            Object.defineProperty(instance.instance, attribute.name, {
                get: function () {
                    return attribute.value;
                },
                set: function (value) {
                    var oldValue = attribute.value;
                    attribute.value = value;
                    self._convertAttributeValue(attribute);
                    instance.instance.fire("set", attribute.name, oldValue, attribute.value);
                },
                configurable: true
            });
        },

        _updateAccessors: function (entity, instance) {
            var self = this;
            var i;
            var len = entity.script.scripts.length;
            var key;
            var url = instance.url;
            var scriptComponent, script, name, attributes;
            var previousAttributes;
            var oldAttribute;

            for (i = 0; i < len; i++) {
                scriptComponent = entity.script;
                script = scriptComponent.scripts[i];
                if (script.url === url) {
                    name = script.name;
                    attributes = script.attributes;
                    if (name) {
                        if (attributes) {
                            // create / update attribute accessors
                            for (key in attributes) {
                                if (attributes.hasOwnProperty(key)) {
                                    self._createAccessor(attributes[key], instance);
                                }
                            }
                        }

                        // delete accessors for attributes that no longer exist
                        // and fire onAttributeChange when an attribute value changed
                        previousAttributes = scriptComponent.data.attributes[name];
                        if (previousAttributes) {
                            for (key in previousAttributes) {
                                oldAttribute = previousAttributes[key];
                                if (!(key in attributes)) {
                                    delete instance.instance[oldAttribute.name];
                                } else {
                                    if (attributes[key].value !== oldAttribute.value) {
                                        if (instance.instance.onAttributeChanged) {
                                            instance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);
                                        }
                                    }
                                }
                            }
                        }

                        if (attributes) {
                            scriptComponent.data.attributes[name] = self._cloneAttributes(attributes);
                        } else {
                            delete scriptComponent.data.attributes[name];
                        }
                    }

                    break;
                }
            }
        },

        _convertAttributeValue: function (attribute) {
            if (attribute.type === 'rgb' || attribute.type === 'rgba') {
                if (type(attribute.value) === 'array') {
                    attribute.value = attribute.value.length === 3 ?
                        new Color(attribute.value[0], attribute.value[1], attribute.value[2]) :
                        new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);
                }
            } else if (attribute.type === 'vec2') {
                if (type(attribute.value) === 'array')
                    attribute.value = new Vec2(attribute.value[0], attribute.value[1]);

            } else if (attribute.type === 'vec3' || attribute.type === 'vector') {
                if (type(attribute.value) === 'array')
                    attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);

            } else if (attribute.type === 'vec4') {
                if (type(attribute.value) === 'array')
                    attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);

            } else if (attribute.type === 'entity') {
                if (attribute.value !== null && typeof attribute.value === 'string')
                    attribute.value = this.app.root.findByGuid(attribute.value);

            } else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {
                var curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;
                attribute.value = new curveType(attribute.value.keys);

                /* eslint-disable no-self-assign */
                attribute.value.type = attribute.value.type;
                /* eslint-enable no-self-assign */
            }
        }
    });

    var _inputScreenPosition = new Vec2();
    var _inputWorldPosition = new Vec3();
    var _rayOrigin = new Vec3();
    var _rayDirection = new Vec3();
    var _planeOrigin = new Vec3();
    var _planeNormal = new Vec3();
    var _entityRotation = new Quat();

    var OPPOSITE_AXIS = {
        x: 'y',
        y: 'x'
    };

    /**
     * @class
     * @name pc.ElementDragHelper
     * @augments pc.EventHandler
     * @description Create a new ElementDragHelper.
     * @classdesc Helper class that makes it easy to create Elements that can be dragged by the mouse or touch.
     * @param {pc.ElementComponent} element - The Element that should become draggable.
     * @param {string} [axis] - Optional axis to constrain to, either 'x', 'y' or null.
     */
    function ElementDragHelper(element, axis) {
        EventHandler.call(this);

        if (!element || !(element instanceof ElementComponent)) {
            throw new Error('Element was null or not an ElementComponent');
        }

        if (axis && axis !== 'x' && axis !== 'y') {
            throw new Error('Unrecognized axis: ' + axis);
        }

        this._element = element;
        this._app = element.system.app;
        this._axis = axis || null;
        this._enabled = true;
        this._dragScale = new Vec3();
        this._dragStartMousePosition = new Vec3();
        this._dragStartHandlePosition = new Vec3();
        this._deltaMousePosition = new Vec3();
        this._deltaHandlePosition = new Vec3();
        this._isDragging = false;

        this._toggleLifecycleListeners('on');
    }
    ElementDragHelper.prototype = Object.create(EventHandler.prototype);
    ElementDragHelper.prototype.constructor = ElementDragHelper;

    Object.assign(ElementDragHelper.prototype, {
        _toggleLifecycleListeners: function (onOrOff) {
            this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
            this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
        },

        _toggleDragListeners: function (onOrOff) {
            var isOn = onOrOff === 'on';
            var addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';

            // Prevent multiple listeners
            if (this._hasDragListeners && isOn) {
                return;
            }

            if (!this._handleMouseUpOrTouchEnd) {
                this._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);
            }

            // Note that we handle release events directly on the window object, rather than
            // on app.mouse or app.touch. This is in order to correctly handle cases where the
            // user releases the mouse/touch outside of the window.
            if (this._app.mouse) {
                this._app.mouse[onOrOff]('mousemove', this._onMove, this);
                window[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);
            }

            if (platform.touch) {
                this._app.touch[onOrOff]('touchmove', this._onMove, this);
                window[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);
                window[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);
            }

            this._hasDragListeners = isOn;
        },

        _onMouseDownOrTouchStart: function (event) {
            if (this._element && !this._isDragging && this.enabled) {
                this._dragCamera = event.camera;
                this._calculateDragScale();

                var currentMousePosition = this._screenToLocal(event);

                if (currentMousePosition) {
                    this._toggleDragListeners('on');
                    this._isDragging = true;
                    this._dragStartMousePosition.copy(currentMousePosition);
                    this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());

                    this.fire('drag:start');
                }
            }
        },

        _onMouseUpOrTouchEnd: function () {
            if (this._isDragging) {
                this._isDragging = false;
                this._toggleDragListeners('off');

                this.fire('drag:end');
            }
        },

        _screenToLocal: function (event) {
            this._determineInputPosition(event);
            this._chooseRayOriginAndDirection();

            _planeOrigin.copy(this._element.entity.getPosition());
            _planeNormal.copy(this._element.entity.forward).scale(-1);

            var denominator = _planeNormal.dot(_rayDirection);

            // If the ray and plane are not parallel
            if (Math.abs(denominator) > 0) {
                var rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);
                var collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;
                var position = _rayOrigin.add(_rayDirection.scale(collisionDistance));

                _entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);

                position.mul(this._dragScale);

                return position;
            }

            return null;
        },

        _determineInputPosition: function (event) {
            var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;

            if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
                _inputScreenPosition.x = event.x * devicePixelRatio;
                _inputScreenPosition.y = event.y * devicePixelRatio;
            } else if (event.changedTouches) {
                _inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
                _inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
            } else {
                console.warn('Could not determine position from input event');
            }
        },

        _chooseRayOriginAndDirection: function () {
            if (this._element.screen && this._element.screen.screen.screenSpace) {
                _rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
                _rayDirection.set(0, 0, -1);
            } else {
                _inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
                _rayOrigin.copy(this._dragCamera.entity.getPosition());
                _rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();
            }
        },

        _calculateDragScale: function () {
            var current = this._element.entity.parent;
            var screen = this._element.screen && this._element.screen.screen;
            var isWithin2DScreen = screen && screen.screenSpace;
            var screenScale = isWithin2DScreen ? screen.scale : 1;
            var dragScale = this._dragScale;

            dragScale.set(screenScale, screenScale, screenScale);

            while (current) {
                dragScale.mul(current.getLocalScale());
                current = current.parent;

                if (isWithin2DScreen && current.screen) {
                    break;
                }
            }

            dragScale.x = 1 / dragScale.x;
            dragScale.y = 1 / dragScale.y;
            dragScale.z = 1 / dragScale.z;
        },

        _onMove: function (event) {
            if (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {
                var currentMousePosition = this._screenToLocal(event);

                if (this._dragStartMousePosition && currentMousePosition) {
                    this._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);
                    this._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);

                    if (this._axis) {
                        var currentPosition = this._element.entity.getLocalPosition();
                        var constrainedAxis = OPPOSITE_AXIS[this._axis];
                        this._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
                    }

                    this._element.entity.setLocalPosition(this._deltaHandlePosition);
                    this.fire('drag:move', this._deltaHandlePosition);
                }
            }
        },

        destroy: function () {
            this._toggleLifecycleListeners('off');
            this._toggleDragListeners('off');
        }
    });

    Object.defineProperty(ElementDragHelper.prototype, 'enabled', {
        get: function () {
            return this._enabled;
        },

        set: function (value) {
            this._enabled = value;
        }
    });

    Object.defineProperty(ElementDragHelper.prototype, 'isDragging', {
        get: function () {
            return this._isDragging;
        }
    });

    /**
     * @constant
     * @type {number}
     * @name pc.SCROLL_MODE_CLAMP
     * @description Content does not scroll any further than its bounds.
     */
    var SCROLL_MODE_CLAMP = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.SCROLL_MODE_BOUNCE
     * @description Content scrolls past its bounds and then gently bounces back.
     */
    var SCROLL_MODE_BOUNCE = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.SCROLL_MODE_INFINITE
     * @description Content can scroll forever.
     */
    var SCROLL_MODE_INFINITE = 2;

    /**
     * @constant
     * @type {number}
     * @name pc.SCROLLBAR_VISIBILITY_SHOW_ALWAYS
     * @description The scrollbar will be visible all the time.
     */
    var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED
     * @description The scrollbar will be visible only when content exceeds the size of the viewport.
     */
    var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;

    var _tempScrollValue = new Vec2();

    /**
     * @component
     * @class
     * @name pc.ScrollViewComponent
     * @augments pc.Component
     * @classdesc A ScrollViewComponent enables a group of entities to behave like a masked scrolling area, with optional horizontal and vertical scroll bars.
     * @description Create a new ScrollViewComponent.
     * @param {pc.ScrollViewComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {boolean} horizontal Whether to enable horizontal scrolling.
     * @property {boolean} vertical Whether to enable vertical scrolling.
     * @property {number} scrollMode Specifies how the scroll view should behave when the user scrolls past the end of the content. Modes are defined as follows:
     *
     * * {@link pc.SCROLL_MODE_CLAMP}: Content does not scroll any further than its bounds.
     * * {@link pc.SCROLL_MODE_BOUNCE}: Content scrolls past its bounds and then gently bounces back.
     * * {@link pc.SCROLL_MODE_INFINITE}: Content can scroll forever.
     *
     * @property {number} bounceAmount Controls how far the content should move before bouncing back.
     * @property {number} friction Controls how freely the content should move if thrown, i.e. By flicking on a phone or by flinging the scroll wheel on a mouse. A value of 1 means that content will stop immediately; 0 means that content will continue moving forever (or until the bounds of the content are reached, depending on the scrollMode).
     * @property {number} horizontalScrollbarVisibility Controls whether the horizontal scrollbar should be visible all the time, or only visible when the content exceeds the size of the viewport.
     * @property {number} verticalScrollbarVisibility Controls whether the vertical scrollbar should be visible all the time, or only visible when the content exceeds the size of the viewport.
     * @property {pc.Entity} viewportEntity The entity to be used as the masked viewport area, within which the content will scroll. This entity must have an ElementGroup component.
     * @property {pc.Entity} contentEntity The entity which contains the scrolling content itself. This entity must have an Element component.
     * @property {pc.Entity} horizontalScrollbarEntity The entity to be used as the vertical scrollbar. This entity must have a Scrollbar component.
     * @property {pc.Entity} verticalScrollbarEntity The entity to be used as the vertical scrollbar. This entity must have a Scrollbar component.
     */
    function ScrollViewComponent(system, entity) {
        Component.call(this, system, entity);

        this._viewportReference = new EntityReference(this, 'viewportEntity', {
            'element#gain': this._onViewportElementGain,
            'element#resize': this._onSetContentOrViewportSize
        });

        this._contentReference = new EntityReference(this, 'contentEntity', {
            'element#gain': this._onContentElementGain,
            'element#lose': this._onContentElementLose,
            'element#resize': this._onSetContentOrViewportSize
        });

        this._scrollbarUpdateFlags = {};
        this._scrollbarReferences = {};
        this._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {
            'scrollbar#set:value': this._onSetHorizontalScrollbarValue,
            'scrollbar#gain': this._onHorizontalScrollbarGain
        });
        this._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {
            'scrollbar#set:value': this._onSetVerticalScrollbarValue,
            'scrollbar#gain': this._onVerticalScrollbarGain
        });

        this._prevContentSizes = {};
        this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
        this._prevContentSizes[ORIENTATION_VERTICAL] = null;

        this._scroll = new Vec2();
        this._velocity = new Vec3();

        this._dragStartPosition = new Vec3();
        this._disabledContentInput = false;
        this._disabledContentInputEntities = [];

        this._toggleLifecycleListeners('on', system);
        this._toggleElementListeners('on');
    }
    ScrollViewComponent.prototype = Object.create(Component.prototype);
    ScrollViewComponent.prototype.constructor = ScrollViewComponent;

    Object.assign(ScrollViewComponent.prototype, {
        _toggleLifecycleListeners: function (onOrOff, system) {
            this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
            this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);

            system.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);
            system.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);

            // TODO Handle scrollwheel events
        },

        _toggleElementListeners: function (onOrOff) {
            if (this.entity.element) {
                if (onOrOff === 'on' && this._hasElementListeners) {
                    return;
                }

                this.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);

                this._hasElementListeners = (onOrOff === 'on');
            }
        },

        _onElementComponentAdd: function (entity) {
            if (this.entity === entity) {
                this._toggleElementListeners('on');
            }
        },

        _onElementComponentRemove: function (entity) {
            if (this.entity === entity) {
                this._toggleElementListeners('off');
            }
        },

        _onViewportElementGain: function () {
            this._syncAll();
        },

        _onContentElementGain: function () {
            this._destroyDragHelper();
            this._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);
            this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
            this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
            this._contentDragHelper.on('drag:move', this._onContentDragMove, this);

            this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
            this._prevContentSizes[ORIENTATION_VERTICAL] = null;

            this._syncAll();
        },

        _onContentElementLose: function () {
            this._destroyDragHelper();
        },

        _onContentDragStart: function () {
            if (this._contentReference.entity && this.enabled && this.entity.enabled) {
                this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
            }
        },

        _onContentDragEnd: function () {
            this._prevContentDragPosition = null;
            this._enableContentInput();
        },

        _onContentDragMove: function (position) {
            if (this._contentReference.entity && this.enabled && this.entity.enabled) {
                this._wasDragged = true;
                this._setScrollFromContentPosition(position);
                this._setVelocityFromContentPositionDelta(position);

                // if we haven't already, when scrolling starts
                // disable input on all child elements
                if (!this._disabledContentInput) {

                    // Disable input events on content after we've moved past a threshold value
                    var dx = (position.x - this._dragStartPosition.x);
                    var dy = (position.y - this._dragStartPosition.y);

                    if (Math.abs(dx) > this.dragThreshold ||
                        Math.abs(dy) > this.dragThreshold) {
                        this._disableContentInput();
                    }

                }
            }
        },

        _onSetContentOrViewportSize: function () {
            this._syncAll();
        },

        _onSetHorizontalScrollbarValue: function (scrollValueX) {
            if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
                this._onSetScroll(scrollValueX, null);
            }
        },

        _onSetVerticalScrollbarValue: function (scrollValueY) {
            if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
                this._onSetScroll(null, scrollValueY);
            }
        },

        _onSetHorizontalScrollingEnabled: function () {
            this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
        },

        _onSetVerticalScrollingEnabled: function () {
            this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
        },

        _onHorizontalScrollbarGain: function () {
            this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
        },

        _onVerticalScrollbarGain: function () {
            this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            this._syncScrollbarPosition(ORIENTATION_VERTICAL);
        },

        _onSetScroll: function (x, y, resetVelocity) {
            if (resetVelocity !== false) {
                this._velocity.set(0, 0, 0);
            }

            var hasChanged = false;
            hasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
            hasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);

            if (hasChanged) {
                this.fire('set:scroll', this._scroll);
            }
        },

        _updateAxis: function (scrollValue, axis, orientation) {
            var hasChanged = (scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5);

            // always update if dragging because drag helper directly updates the entity position
            // always update if scrollValue === 0 because it will be clamped to 0
            // if viewport is larger than content and position could be moved by drag helper but
            // hasChanged will never be true
            if (hasChanged || this._isDragging() || scrollValue === 0) {
                this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
                this._syncContentPosition(orientation);
                this._syncScrollbarPosition(orientation);
            }

            return hasChanged;
        },

        _determineNewScrollValue: function (scrollValue, axis, orientation) {
            // If scrolling is disabled for the selected orientation, force the
            // scroll position to remain at the current value
            if (!this._getScrollingEnabled(orientation)) {
                return this._scroll[axis];
            }

            switch (this.scrollMode) {
                case SCROLL_MODE_CLAMP:
                    return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));

                case SCROLL_MODE_BOUNCE:
                    this._setVelocityFromOvershoot(scrollValue, axis, orientation);
                    return scrollValue;

                case SCROLL_MODE_INFINITE:
                    return scrollValue;

                default:
                    console.warn('Unhandled scroll mode:' + this.scrollMode);
                    return scrollValue;
            }
        },

        _syncAll: function () {
            this._syncContentPosition(ORIENTATION_HORIZONTAL);
            this._syncContentPosition(ORIENTATION_VERTICAL);
            this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
            this._syncScrollbarPosition(ORIENTATION_VERTICAL);
            this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
        },

        _syncContentPosition: function (orientation) {
            var axis = this._getAxis(orientation);
            var sign = this._getSign(orientation);
            var contentEntity = this._contentReference.entity;

            if (contentEntity) {
                var prevContentSize = this._prevContentSizes[orientation];
                var currContentSize = this._getContentSize(orientation);

                // If the content size has changed, adjust the scroll value so that the content will
                // stay in the same place from the user's perspective.
                if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
                    var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
                    var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
                    if (currMaxOffset === 0) {
                        this._scroll[axis] = 1;
                    } else {
                        this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
                    }
                }

                var offset = this._scroll[axis] * this._getMaxOffset(orientation);
                var contentPosition = contentEntity.getLocalPosition();
                contentPosition[axis] = offset * sign;

                contentEntity.setLocalPosition(contentPosition);

                this._prevContentSizes[orientation] = currContentSize;
            }
        },

        _syncScrollbarPosition: function (orientation) {
            var axis = this._getAxis(orientation);
            var scrollbarEntity = this._scrollbarReferences[orientation].entity;

            if (scrollbarEntity && scrollbarEntity.scrollbar) {
                // Setting the value of the scrollbar will fire a 'set:value' event, which in turn
                // will call the _onSetHorizontalScrollbarValue/_onSetVerticalScrollbarValue handlers
                // and cause a cycle. To avoid this we keep track of the fact that we're in the process
                // of updating the scrollbar value.
                this._scrollbarUpdateFlags[orientation] = true;
                scrollbarEntity.scrollbar.value = this._scroll[axis];
                scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
                this._scrollbarUpdateFlags[orientation] = false;
            }
        },

        // Toggles the scrollbar entities themselves to be enabled/disabled based
        // on whether the user has enabled horizontal/vertical scrolling on the
        // scroll view.
        _syncScrollbarEnabledState: function (orientation) {
            var entity = this._scrollbarReferences[orientation].entity;

            if (entity) {
                var isScrollingEnabled = this._getScrollingEnabled(orientation);
                var requestedVisibility = this._getScrollbarVisibility(orientation);

                switch (requestedVisibility) {
                    case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
                        entity.enabled = isScrollingEnabled;
                        return;

                    case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
                        entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
                        return;

                    default:
                        console.warn('Unhandled scrollbar visibility:' + requestedVisibility);
                        entity.enabled = isScrollingEnabled;
                }
            }
        },

        _contentIsLargerThanViewport: function (orientation) {
            return this._getContentSize(orientation) > this._getViewportSize(orientation);
        },

        _contentPositionToScrollValue: function (contentPosition) {
            var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
            var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);

            if (maxOffsetH === 0) {
                _tempScrollValue.x = 0;
            } else {
                _tempScrollValue.x = contentPosition.x / maxOffsetH;
            }

            if (maxOffsetV === 0) {
                _tempScrollValue.y = 0;
            } else {
                _tempScrollValue.y = contentPosition.y / -maxOffsetV;
            }

            return _tempScrollValue;
        },

        _getMaxOffset: function (orientation, contentSize) {
            contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;

            var viewportSize = this._getViewportSize(orientation);

            if (contentSize < viewportSize) {
                return -this._getViewportSize(orientation);
            }

            return viewportSize - contentSize;
        },

        _getMaxScrollValue: function (orientation) {
            return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
        },

        _getScrollbarHandleSize: function (axis, orientation) {
            var viewportSize = this._getViewportSize(orientation);
            var contentSize = this._getContentSize(orientation);

            if (Math.abs(contentSize) < 0.001) {
                return 1;
            }

            var handleSize = Math.min(viewportSize / contentSize, 1);
            var overshoot = this._toOvershoot(this._scroll[axis], orientation);

            if (overshoot === 0) {
                return handleSize;
            }

            // Scale the handle down when the content has been dragged past the bounds
            return handleSize / (1 + Math.abs(overshoot));
        },

        _getViewportSize: function (orientation) {
            return this._getSize(orientation, this._viewportReference);
        },

        _getContentSize: function (orientation) {
            return this._getSize(orientation, this._contentReference);
        },

        _getSize: function (orientation, entityReference) {
            if (entityReference.entity && entityReference.entity.element) {
                return entityReference.entity.element[this._getCalculatedDimension(orientation)];
            }

            return 0;
        },

        _getScrollingEnabled: function (orientation) {
            if (orientation === ORIENTATION_HORIZONTAL) {
                return this.horizontal;
            } else if (orientation === ORIENTATION_VERTICAL) {
                return this.vertical;
            }

            console.warn('Unrecognized orientation: ' + orientation);
        },

        _getScrollbarVisibility: function (orientation) {
            if (orientation === ORIENTATION_HORIZONTAL) {
                return this.horizontalScrollbarVisibility;
            } else if (orientation === ORIENTATION_VERTICAL) {
                return this.verticalScrollbarVisibility;
            }

            console.warn('Unrecognized orientation: ' + orientation);
        },

        _getSign: function (orientation) {
            return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
        },

        _getAxis: function (orientation) {
            return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
        },

        _getCalculatedDimension: function (orientation) {
            return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
        },

        _destroyDragHelper: function () {
            if (this._contentDragHelper) {
                this._contentDragHelper.destroy();
            }
        },

        onUpdate: function () {
            if (this._contentReference.entity) {
                this._updateVelocity();
                this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
                this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            }
        },

        _updateVelocity: function () {
            if (!this._isDragging()) {
                if (this.scrollMode === SCROLL_MODE_BOUNCE) {
                    if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
                        this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
                    }

                    if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
                        this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
                    }
                }

                this._velocity.x *= (1 - this.friction);
                this._velocity.y *= (1 - this.friction);

                if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
                    var position = this._contentReference.entity.getLocalPosition();
                    position.x += this._velocity.x;
                    position.y += this._velocity.y;
                    this._contentReference.entity.setLocalPosition(position);

                    this._setScrollFromContentPosition(position);
                }
            }
        },

        _hasOvershoot: function (axis, orientation) {
            return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
        },

        _toOvershoot: function (scrollValue, orientation) {
            var maxScrollValue = this._getMaxScrollValue(orientation);

            if (scrollValue < 0) {
                return scrollValue;
            } else if (scrollValue > maxScrollValue) {
                return scrollValue - maxScrollValue;
            }

            return 0;
        },

        _setVelocityFromOvershoot: function (scrollValue, axis, orientation) {
            var overshootValue = this._toOvershoot(scrollValue, orientation);
            var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);

            if (Math.abs(overshootPixels) > 0) {
                // 50 here is just a magic number – it seems to give us a range of useful
                // range of bounceAmount values, so that 0.1 is similar to the iOS bounce
                // feel, 1.0 is much slower, etc. The + 1 means that when bounceAmount is
                // 0, the content will just snap back immediately instead of moving gradually.
                this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
            }
        },

        _setVelocityFromContentPositionDelta: function (position) {
            if (this._prevContentDragPosition) {
                this._velocity.sub2(position, this._prevContentDragPosition);
                this._prevContentDragPosition.copy(position);
            } else {
                this._velocity.set(0, 0, 0);
                this._prevContentDragPosition = position.clone();
            }
        },

        _setScrollFromContentPosition: function (position) {
            var scrollValue = this._contentPositionToScrollValue(position);

            if (this._isDragging()) {
                scrollValue = this._applyScrollValueTension(scrollValue);
            }

            this._onSetScroll(scrollValue.x, scrollValue.y, false);
        },

        // Create nice tension effect when dragging past the extents of the viewport
        _applyScrollValueTension: function (scrollValue) {
            var max;
            var overshoot;
            var factor = 1;

            max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
            overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
            if (overshoot > 0) {
                scrollValue.x = max + factor * Math.log10(1 + overshoot);
            } else if (overshoot < 0) {
                scrollValue.x = -factor * Math.log10(1 - overshoot);
            }

            max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
            overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);

            if (overshoot > 0) {
                scrollValue.y = max + factor * Math.log10(1 + overshoot);
            } else if (overshoot < 0) {
                scrollValue.y = -factor * Math.log10(1 - overshoot);
            }

            return scrollValue;
        },

        _isDragging: function () {
            return this._contentDragHelper && this._contentDragHelper.isDragging;
        },

        _setScrollbarComponentsEnabled: function (enabled) {
            if (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {
                this._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;
            }

            if (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {
                this._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;
            }
        },

        _setContentDraggingEnabled: function (enabled) {
            if (this._contentDragHelper) {
                this._contentDragHelper.enabled = enabled;
            }
        },

        // re-enable useInput flag on any descendent that was disabled
        _enableContentInput: function () {
            while (this._disabledContentInputEntities.length) {
                var e = this._disabledContentInputEntities.pop();
                if (e.element) {
                    e.element.useInput = true;
                }
            }

            this._disabledContentInput = false;
        },

        // disable useInput flag on all descendents of this contentEntity
        _disableContentInput: function () {
            var self = this;
            var _disableInput = function (e) {
                if (e.element && e.element.useInput) {
                    self._disabledContentInputEntities.push(e);
                    e.element.useInput = false;
                }

                var children = e.children;
                var i, l;
                for (i = 0, l = children.length; i < l; i++) {
                    _disableInput(children[i]);
                }
            };

            var contentEntity = this._contentReference.entity;
            if (contentEntity) {
                // disable input recursively for all children of the content entity
                var children = contentEntity.children;
                var i, l = children.length;
                for (i = 0; i < l; i++) {
                    _disableInput(children[i]);
                }
            }

            this._disabledContentInput = true;
        },

        onEnable: function () {
            this._viewportReference.onParentComponentEnable();
            this._contentReference.onParentComponentEnable();
            this._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();
            this._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();
            this._setScrollbarComponentsEnabled(true);
            this._setContentDraggingEnabled(true);

            this._syncAll();
        },

        onDisable: function () {
            this._setScrollbarComponentsEnabled(false);
            this._setContentDraggingEnabled(false);
        },

        onRemove: function () {
            this._toggleLifecycleListeners('off', this.system);
            this._toggleElementListeners('off');
            this._destroyDragHelper();
        }
    });

    Object.defineProperty(ScrollViewComponent.prototype, 'scroll', {
        get: function () {
            return this._scroll;
        },

        set: function (value) {
            this._onSetScroll(value.x, value.y);
        }
    });

    function ScrollViewComponentData() {
        this.enabled = true;
    }

    var _schema$f = [
        { name: 'enabled', type: 'boolean' },
        { name: 'horizontal', type: 'boolean' },
        { name: 'vertical', type: 'boolean' },
        { name: 'scrollMode', type: 'number' },
        { name: 'bounceAmount', type: 'number' },
        { name: 'friction', type: 'number' },
        { name: 'dragThreshold', type: 'number' },
        { name: 'horizontalScrollbarVisibility', type: 'number' },
        { name: 'verticalScrollbarVisibility', type: 'number' },
        { name: 'viewportEntity', type: 'entity' },
        { name: 'contentEntity', type: 'entity' },
        { name: 'horizontalScrollbarEntity', type: 'entity' },
        { name: 'verticalScrollbarEntity', type: 'entity' }
    ];

    var DEFAULT_DRAG_THRESHOLD = 10;

    /**
     * @class
     * @name pc.ScrollViewComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.ScrollViewComponent}s.
     * @description Create a new ScrollViewComponentSystem.
     * @param {pc.Application} app - The application.
     */
    var ScrollViewComponentSystem = function ScrollViewComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'scrollview';

        this.ComponentType = ScrollViewComponent;
        this.DataType = ScrollViewComponentData;

        this.schema = _schema$f;

        this.on('beforeremove', this._onRemoveComponent, this);

        ComponentSystem.bind('update', this.onUpdate, this);
    };
    ScrollViewComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ScrollViewComponentSystem.prototype.constructor = ScrollViewComponentSystem;

    Component._buildAccessors(ScrollViewComponent.prototype, _schema$f);

    Object.assign(ScrollViewComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            if (data.dragThreshold === undefined) {
                data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
            }

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$f);
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                var entity = components[id].entity;
                var component = entity.scrollview;
                if (component.enabled && entity.enabled) {
                    component.onUpdate();
                }

            }
        },

        _onRemoveComponent: function (entity, component) {
            component.onRemove();
        }
    });

    /**
     * @component
     * @class
     * @name pc.ScrollbarComponent
     * @augments pc.Component
     * @description Create a new ScrollbarComponent.
     * @classdesc A ScrollbarComponent enables a group of entities to behave like a draggable scrollbar.
     * @param {pc.ScrollbarComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {number} orientation Whether the scrollbar moves horizontally or vertically. Can be:
     *
     * * {@link pc.ORIENTATION_HORIZONTAL}: The scrollbar animates in the horizontal axis.
     * * {@link pc.ORIENTATION_VERTICAL}: The scrollbar animates in the vertical axis.
     *
     * Defaults to pc.ORIENTATION_HORIZONTAL.
     * @property {number} value The current position value of the scrollbar, in the range 0 to 1. Defaults to 0.
     * @property {number} handleSize The size of the handle relative to the size of the track, in the range
     * 0 to 1. For a vertical scrollbar, a value of 1 means that the handle will take up the full height of
     * the track.
     * @property {pc.Entity} handleEntity The entity to be used as the scrollbar handle. This entity must
     * have a Scrollbar component.
     */
    function ScrollbarComponent(system, entity) {
        Component.call(this, system, entity);

        this._app = system.app;

        this._handleReference = new EntityReference(this, 'handleEntity', {
            'element#gain': this._onHandleElementGain,
            'element#lose': this._onHandleElementLose,
            'element#set:anchor': this._onSetHandleAlignment,
            'element#set:margin': this._onSetHandleAlignment,
            'element#set:pivot': this._onSetHandleAlignment
        });

        this._toggleLifecycleListeners('on');
    }
    ScrollbarComponent.prototype = Object.create(Component.prototype);
    ScrollbarComponent.prototype.constructor = ScrollbarComponent;

    Object.assign(ScrollbarComponent.prototype, {
        _toggleLifecycleListeners: function (onOrOff) {
            this[onOrOff]('set_value', this._onSetValue, this);
            this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
            this[onOrOff]('set_orientation', this._onSetOrientation, this);

            // TODO Handle scrollwheel events
        },

        _onHandleElementGain: function () {
            this._destroyDragHelper();
            this._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());
            this._handleDragHelper.on('drag:move', this._onHandleDrag, this);

            this._updateHandlePositionAndSize();
        },

        _onHandleElementLose: function () {
            this._destroyDragHelper();
        },

        _onHandleDrag: function (position) {
            if (this._handleReference.entity && this.enabled && this.entity.enabled) {
                this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
            }
        },

        _onSetValue: function (name, oldValue, newValue) {
            if (Math.abs(newValue - oldValue) > 1e-5) {
                this.data.value = math.clamp(newValue, 0, 1);
                this._updateHandlePositionAndSize();
                this.fire('set:value', this.data.value);
            }
        },

        _onSetHandleSize: function (name, oldValue, newValue) {
            if (Math.abs(newValue - oldValue) > 1e-5) {
                this.data.handleSize = math.clamp(newValue, 0, 1);
                this._updateHandlePositionAndSize();
            }
        },

        _onSetHandleAlignment: function () {
            this._updateHandlePositionAndSize();
        },

        _onSetOrientation: function (name, oldValue, newValue) {
            if (newValue !== oldValue && this._handleReference.hasComponent('element')) {
                this._handleReference.entity.element[this._getOppositeDimension()] = 0;
            }
        },

        _updateHandlePositionAndSize: function () {
            var handleEntity = this._handleReference.entity;
            var handleElement = handleEntity && handleEntity.element;

            if (handleEntity) {
                var position = handleEntity.getLocalPosition();
                position[this._getAxis()] = this._getHandlePosition();
                this._handleReference.entity.setLocalPosition(position);
            }

            if (handleElement) {
                handleElement[this._getDimension()] = this._getHandleLength();
            }
        },

        _handlePositionToScrollValue: function (handlePosition) {
            return handlePosition * this._getSign() / this._getUsableTrackLength();
        },

        _scrollValueToHandlePosition: function (value) {
            return value * this._getSign() * this._getUsableTrackLength();
        },

        _getUsableTrackLength: function () {
            return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
        },

        _getTrackLength: function () {
            if (this.entity.element) {
                return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
            }

            return 0;
        },

        _getHandleLength: function () {
            return this._getTrackLength() * this.handleSize;
        },

        _getHandlePosition: function () {
            return this._scrollValueToHandlePosition(this.value);
        },

        _getSign: function () {
            return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
        },

        _getAxis: function () {
            return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
        },

        _getDimension: function () {
            return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
        },

        _getOppositeDimension: function () {
            return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
        },

        _destroyDragHelper: function () {
            if (this._handleDragHelper) {
                this._handleDragHelper.destroy();
            }
        },

        _setHandleDraggingEnabled: function (enabled) {
            if (this._handleDragHelper) {
                this._handleDragHelper.enabled = enabled;
            }
        },

        onEnable: function () {
            this._handleReference.onParentComponentEnable();
            this._setHandleDraggingEnabled(true);
        },

        onDisable: function () {
            this._setHandleDraggingEnabled(false);
        },

        onRemove: function () {
            this._destroyDragHelper();
            this._toggleLifecycleListeners('off');
        }
    });

    function ScrollbarComponentData() {
        this.enabled = true;
    }

    var _schema$g = [
        { name: 'enabled', type: 'boolean' },
        { name: 'orientation', type: 'number' },
        { name: 'value', type: 'number' },
        { name: 'handleSize', type: 'number' },
        { name: 'handleEntity', type: 'entity' }
    ];

    /**
     * @class
     * @name pc.ScrollbarComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.ScrollbarComponent}s.
     * @description Create a new ScrollbarComponentSystem.
     * @param {pc.Application} app - The application.
     */
    function ScrollbarComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'scrollbar';

        this.ComponentType = ScrollbarComponent;
        this.DataType = ScrollbarComponentData;

        this.schema = _schema$g;

        this.on('beforeremove', this._onRemoveComponent, this);
    }
    ScrollbarComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ScrollbarComponentSystem.prototype.constructor = ScrollbarComponentSystem;

    Component._buildAccessors(ScrollbarComponent.prototype, _schema$g);

    Object.assign(ScrollbarComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, _schema$g);
        },

        _onRemoveComponent: function (entity, component) {
            component.onRemove();
        }
    });

    var STATE_PLAYING = 0;
    var STATE_PAUSED = 1;
    var STATE_STOPPED = 2;

    // Return time % duration but always return a number
    // instead of NaN when duration is 0
    var capTime = function (time, duration) {
        return (time % duration) || 0;
    };

    if (hasAudioContext()) {
        /**
         * @class
         * @name pc.SoundInstance
         * @augments pc.EventHandler
         * @classdesc A pc.SoundInstance plays a {@link pc.Sound}.
         * @param {pc.SoundManager} manager - The sound manager.
         * @param {pc.Sound} sound - The sound to play.
         * @param {object} options - Options for the instance.
         * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
         * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
         * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the end or not.
         * @param {number} [options.startTime=0] - The time from which the playback will start in seconds. Default is 0 to start at the beginning.
         * @param {number} [options.duration=null] - The total time after the startTime in seconds when playback will stop or restart if loop is true.
         * @param {Function} [options.onPlay=null] - Function called when the instance starts playing.
         * @param {Function} [options.onPause=null] - Function called when the instance is paused.
         * @param {Function} [options.onResume=null] - Function called when the instance is resumed.
         * @param {Function} [options.onStop=null] - Function called when the instance is stopped.
         * @param {Function} [options.onEnd=null] - Function called when the instance ends.
         * @property {number} volume The volume modifier to play the sound with. In range 0-1.
         * @property {number} pitch The pitch modifier to play the sound with. Must be larger than 0.01.
         * @property {number} startTime The start time from which the sound will start playing.
         * @property {number} currentTime Gets or sets the current time of the sound that is playing. If the value provided is bigger than the duration of the instance it will wrap from the beginning.
         * @property {number} duration The duration of the sound that the instance will play starting from startTime.
         * @property {boolean} loop If true the instance will restart when it finishes playing.
         * @property {boolean} isPlaying Returns true if the instance is currently playing.
         * @property {boolean} isPaused Returns true if the instance is currently paused.
         * @property {boolean} isStopped Returns true if the instance is currently stopped.
         * @property {boolean} isSuspended Returns true if the instance is currently suspended because the window is not focused.
         * @property {AudioBufferSourceNode} source Gets the source that plays the sound resource. If the Web Audio API is not supported the type of source is <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio" target="_blank">Audio</a>. Source is only available after calling play.
         * @property {pc.Sound} sound The sound resource that the instance will play.
         */
        exports.SoundInstance = function (manager, sound, options) {
            EventHandler.call(this);

            options = options || {};

            this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
            this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
            this._loop = !!(options.loop !== undefined ? options.loop : false);

            this._sound = sound;

            // start at 'stopped'
            this._state = STATE_STOPPED;

            // true if the manager was suspended
            this._suspended = false;
            // true if we want to suspend the event handled to the 'onended' event
            this._suspendEndEvent = false;
            // true if we want to suspend firing instance events
            this._suspendInstanceEvents = false;

            this._startTime = Math.max(0, Number(options.startTime) || 0);
            this._duration = Math.max(0, Number(options.duration) || 0);

            this._startedAt = 0;
            this._startOffset = null;

            // manually keep track of the playback position
            // because the Web Audio API does not provide a way to do this
            // accurately if the playbackRate is not 1
            this._currentTime = 0;
            this._currentOffset = 0;

            // if true then the instance will start playing its source
            // when its created
            this._playWhenLoaded = true;

            this._manager = manager;

            // The input node is the one that is connected to the source.
            this._inputNode = null;
            // the connected node is the one that is connected to the destination (speakers). Any
            // external nodes will be connected to this node.
            this._connectorNode = null;

            // The first external node set by a user
            this._firstNode = null;
            // The last external node set by a user
            this._lastNode = null;

            this._initializeNodes();

            // external event handlers
            this._onPlayCallback = options.onPlay;
            this._onPauseCallback = options.onPause;
            this._onResumeCallback = options.onResume;
            this._onStopCallback = options.onStop;
            this._onEndCallback = options.onEnd;

            // bind internal event handlers to 'this'
            this._endedHandler = this._onEnded.bind(this);

            // source is initialized when play() is called
            this.source = null;
        };
        exports.SoundInstance.prototype = Object.create(EventHandler.prototype);
        exports.SoundInstance.prototype.constructor = exports.SoundInstance;

        Object.assign(exports.SoundInstance.prototype, {
            /**
             * @function
             * @private
             * @name pc.SoundInstance#_initializeNodes
             * @description Creates internal audio nodes and connects them.
             */
            _initializeNodes: function () {
                // create gain node for volume control
                this.gain = this._manager.context.createGain();
                this._inputNode = this.gain;
                // the gain node is also the connector node for 2D sound instances
                this._connectorNode = this.gain;
                this._connectorNode.connect(this._manager.context.destination);
            },

            /**
             * @function
             * @name pc.SoundInstance#play
             * @description Begins playback of sound. If the sound is not loaded this will return false.
             * If the sound is already playing this will restart the sound.
             * @returns {boolean} True if the sound was started.
             */
            play: function () {
                if (this._state !== STATE_STOPPED) {
                    this.stop();
                }

                if (!this.source) {
                    this._createSource();
                }

                // calculate start offset
                var offset = capTime(this._startOffset, this.duration);
                offset = capTime(this._startTime + offset, this._sound.duration);
                // reset start offset now that we started the sound
                this._startOffset = null;

                // start source with specified offset and duration
                if (this._duration) {
                    this.source.start(0, offset, this._duration);
                } else {
                    this.source.start(0, offset);
                }

                // reset times
                this._startedAt = this._manager.context.currentTime;
                this._currentTime = 0;
                this._currentOffset = offset;

                // set state to playing
                this._state = STATE_PLAYING;
                // no need for this anymore
                this._playWhenLoaded = false;

                // Initialize volume and loop - note moved to be after start() because of Chrome bug
                this.volume = this._volume;
                this.loop = this._loop;
                this.pitch = this._pitch;

                // handle suspend events / volumechange events
                this._manager.on('volumechange', this._onManagerVolumeChange, this);
                this._manager.on('suspend', this._onManagerSuspend, this);
                this._manager.on('resume', this._onManagerResume, this);
                this._manager.on('destroy', this._onManagerDestroy, this);

                // suspend immediately if manager is suspended
                if (this._manager.suspended) {
                    this._onManagerSuspend();
                }

                if (!this._suspendInstanceEvents)
                    this._onPlay();

                return true;
            },

            /**
             * @function
             * @name pc.SoundInstance#pause
             * @description Pauses playback of sound. Call resume() to resume playback from the same position.
             * @returns {boolean} Returns true if the sound was paused.
             */
            pause: function () {
                if (this._state !== STATE_PLAYING || !this.source)
                    return false;

                // store current time
                this._updateCurrentTime();

                // set state to paused
                this._state = STATE_PAUSED;

                // Stop the source and re-create it because we cannot reuse the same source.
                // Suspend the end event as we are manually stopping the source
                this._suspendEndEvent = true;
                this.source.stop(0);
                this.source = null;

                // no need for this anymore
                this._playWhenLoaded = false;
                // reset user-set start offset
                this._startOffset = null;

                if (!this._suspendInstanceEvents)
                    this._onPause();

                return true;
            },

            /**
             * @function
             * @name pc.SoundInstance#resume
             * @description Resumes playback of the sound. Playback resumes at the point that the audio was paused.
             * @returns {boolean} Returns true if the sound was resumed.
             */
            resume: function () {
                if (this._state !== STATE_PAUSED) {
                    return false;
                }

                if (!this.source) {
                    this._createSource();
                }

                // start at point where sound was paused
                var offset = this.currentTime;

                // if the user set the 'currentTime' property while the sound
                // was paused then use that as the offset instead
                if (this._startOffset !== null) {
                    offset = capTime(this._startOffset, this.duration);
                    offset = capTime(this._startTime + offset, this._sound.duration);

                    // reset offset
                    this._startOffset = null;
                }

                // start source
                if (this._duration) {
                    this.source.start(0, offset, this._duration);
                } else {
                    this.source.start(0, offset);
                }

                // set state back to playing
                this._state = STATE_PLAYING;

                this._startedAt = this._manager.context.currentTime;
                this._currentOffset = offset;

                // Initialize parameters
                this.volume = this._volume;
                this.loop = this._loop;
                this.pitch = this._pitch;
                this._playWhenLoaded = false;

                if (!this._suspendInstanceEvents)
                    this._onResume();

                return true;
            },

            /**
             * @function
             * @name pc.SoundInstance#stop
             * @description Stops playback of sound. Calling play() again will restart playback from the beginning of the sound.
             * @returns {boolean} Returns true if the sound was stopped.
             */
            stop: function () {
                if (this._state === STATE_STOPPED || !this.source)
                    return false;

                // unsubscribe from manager events
                this._manager.off('volumechange', this._onManagerVolumeChange, this);
                this._manager.off('suspend', this._onManagerSuspend, this);
                this._manager.off('resume', this._onManagerResume, this);
                this._manager.off('destroy', this._onManagerDestroy, this);

                // reset stored times
                this._startedAt = 0;
                this._currentTime = 0;
                this._currentOffset = 0;

                this._startOffset = null;
                this._playWhenLoaded = false;

                this._suspendEndEvent = true;
                if (this._state === STATE_PLAYING) {
                    this.source.stop(0);
                }
                this.source = null;

                // set the state to stopped
                this._state = STATE_STOPPED;

                if (!this._suspendInstanceEvents)
                    this._onStop();

                return true;
            },

            /**
             * @function
             * @name pc.SoundInstance#setExternalNodes
             * @description Connects external Web Audio API nodes. You need to pass
             * the first node of the node graph that you created externally and the last node of that graph. The first
             * node will be connected to the audio source and the last node will be connected to the destination of the
             * AudioContext (e.g. speakers). Requires Web Audio API support.
             * @param {AudioNode} firstNode - The first node that will be connected to the audio source of sound instances.
             * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of the AudioContext.
             * If unspecified then the firstNode will be connected to the destination instead.
             * @example
             * var context = app.systems.sound.context;
             * var analyzer = context.createAnalyzer();
             * var distortion = context.createWaveShaper();
             * var filter = context.createBiquadFilter();
             * analyzer.connect(distortion);
             * distortion.connect(filter);
             * instance.setExternalNodes(analyzer, filter);
             */
            setExternalNodes: function (firstNode, lastNode) {
                if (!firstNode) {
                    console.error('The firstNode must be a valid Audio Node');
                    return;
                }

                if (!lastNode) {
                    lastNode = firstNode;
                }

                // connections are:
                // source -> inputNode -> connectorNode -> [firstNode -> ... -> lastNode] -> speakers

                var speakers = this._manager.context.destination;

                if (this._firstNode !== firstNode) {
                    if (this._firstNode) {
                        // if firstNode already exists means the connector node
                        // is connected to it so disconnect it
                        this._connectorNode.disconnect(this._firstNode);
                    } else {
                        // if firstNode does not exist means that its connected
                        // to the speakers so disconnect it
                        this._connectorNode.disconnect(speakers);
                    }

                    // set first node and connect with connector node
                    this._firstNode = firstNode;
                    this._connectorNode.connect(firstNode);
                }

                if (this._lastNode !== lastNode) {
                    if (this._lastNode) {
                        // if last node exists means it's connected to the speakers so disconnect it
                        this._lastNode.disconnect(speakers);
                    }

                    // set last node and connect with speakers
                    this._lastNode = lastNode;
                    this._lastNode.connect(speakers);
                }
            },

            /**
             * @function
             * @name pc.SoundInstance#clearExternalNodes
             * @description Clears any external nodes set by {@link pc.SoundInstance#setExternalNodes}.
             */
            clearExternalNodes: function () {
                var speakers = this._manager.context.destination;

                // break existing connections
                if (this._firstNode) {
                    this._connectorNode.disconnect(this._firstNode);
                    this._firstNode = null;
                }

                if (this._lastNode) {
                    this._lastNode.disconnect(speakers);
                    this._lastNode = null;
                }

                // reset connect to speakers
                this._connectorNode.connect(speakers);
            },


            /**
             * @function
             * @name pc.SoundInstance#getExternalNodes
             * @description Gets any external nodes set by {@link pc.SoundInstance#setExternalNodes}.
             * @returns {AudioNode[]} Returns an array that contains the two nodes set by {@link pc.SoundInstance#setExternalNodes}.
             */
            getExternalNodes: function () {
                return [this._firstNode, this._lastNode];
            },

            /**
             * @private
             * @function
             * @description Creates the source for the instance.
             */

            _createSource: function () {
                if (!this._sound) {
                    return null;
                }

                var context = this._manager.context;

                if (this._sound.buffer) {
                    this.source = context.createBufferSource();
                    this.source.buffer = this._sound.buffer;

                    // Connect up the nodes
                    this.source.connect(this._inputNode);

                    // set events
                    this.source.onended = this._endedHandler;

                    // set loopStart and loopEnd so that the source starts and ends at the correct user-set times
                    this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
                    if (this._duration) {
                        this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
                    }
                }

                return this.source;
            },

            /**
             * @private
             * @function
             * @name pc.SoundInstance#_updateCurrentTime
             * @description Sets the current time taking into account the time the instance started playing, the current pitch and the current time offset.
             */
            _updateCurrentTime: function () {
                this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
            },

            /**
             * @private
             * @function
             * @name pc.SoundInstance#_onManagerDestroy
             * @description Handle the manager's 'destroy' event.
             */
            _onManagerDestroy: function () {
                if (this.source && this._state === STATE_PLAYING) {
                    this.source.stop(0);
                    this.source = null;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'volume', {
            get: function () {
                return this._volume;
            },

            set: function (volume) {
                volume = math.clamp(volume, 0, 1);
                this._volume = volume;
                if (this.gain) {
                    this.gain.gain.value = volume * this._manager.volume;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'pitch', {
            get: function () {
                return this._pitch;
            },

            set: function (pitch) {
                // set offset to current time so that
                // we calculate the rest of the time with the new pitch
                // from now on
                this._currentOffset = this.currentTime;
                this._startedAt = this._manager.context.currentTime;

                this._pitch = Math.max(Number(pitch) || 0, 0.01);
                if (this.source) {
                    this.source.playbackRate.value = this._pitch;
                }

            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'loop', {
            get: function () {
                return this._loop;
            },

            set: function (loop) {
                this._loop = !!loop;
                if (this.source) {
                    this.source.loop = this._loop;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'sound', {
            get: function () {
                return this._sound;
            },

            set: function (value) {
                this._sound = value;

                if (this._state !== STATE_STOPPED) {
                    this.stop();
                } else {
                    this._createSource();
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'currentTime', {
            get: function () {
                // if the user has set the currentTime and we have not used it yet
                // then just return that
                if (this._startOffset !== null) {
                    return this._startOffset;
                }

                // if the sound is paused return the currentTime calculated when
                // pause() was called
                if (this._state === STATE_PAUSED) {
                    return this._currentTime;
                }

                // if the sound is stopped or we don't have a source
                // return 0
                if (this._state === STATE_STOPPED || !this.source) {
                    return 0;
                }

                // recalculate current time
                this._updateCurrentTime();
                return this._currentTime;
            },
            set: function (value) {
                if (value < 0) return;

                if (this._state === STATE_PLAYING) {
                    // stop first which will set _startOffset to null
                    this.stop();

                    var suspend = this._suspendInstanceEvents;
                    this._suspendInstanceEvents = true;
                    // set _startOffset and play
                    this._startOffset = value;
                    this.play();
                    this._suspendInstanceEvents = suspend;
                } else {
                    // set _startOffset which will be used when the instance will start playing
                    this._startOffset = value;
                    // set _currentTime
                    this._currentTime = value;
                }
            }
        });

    } else if (hasAudio()) {
        exports.SoundInstance = function (manager, resource, options) {
            EventHandler.call(this);

            options = options || {};

            this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
            this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
            this._loop = !!(options.loop !== undefined ? options.loop : false);

            this._sound = resource;
            this._state = STATE_STOPPED;
            this._suspended = false;
            this._suspendEndEvent = false;
            this._suspendInstanceEvents = false;
            this._playWhenLoaded = true;

            this._startTime = Math.max(0, Number(options.startTime) || 0);
            this._duration = Math.max(0, Number(options.duration) || 0);
            this._startOffset = null;

            this._isReady = false;

            this._manager = manager;

            this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
            this._timeUpdateHandler = this._onTimeUpdate.bind(this);
            this._endedHandler = this._onEnded.bind(this);

            // external event handlers
            this._onPlayCallback = options.onPlay;
            this._onPauseCallback = options.onPause;
            this._onResumeCallback = options.onResume;
            this._onStopCallback = options.onStop;
            this._onEndCallback = options.onEnd;

            this.source = null;
            this._createSource();
        };
        exports.SoundInstance.prototype = Object.create(EventHandler.prototype);
        exports.SoundInstance.prototype.constructor = exports.SoundInstance;

        Object.assign(exports.SoundInstance.prototype, {
            play: function () {
                if (this._state !== STATE_STOPPED) {
                    this.stop();
                }

                if (!this.source) {
                    if (!this._createSource()) {
                        return false;
                    }
                }

                this.volume = this._volume;
                this.pitch = this._pitch;
                this.loop = this._loop;

                this.source.play();
                this._state = STATE_PLAYING;
                this._playWhenLoaded = false;

                this._manager.on('volumechange', this._onManagerVolumeChange, this);
                this._manager.on('suspend', this._onManagerSuspend, this);
                this._manager.on('resume', this._onManagerResume, this);
                this._manager.on('destroy', this._onManagerDestroy, this);

                // suspend immediately if manager is suspended
                if (this._manager.suspended)
                    this._onManagerSuspend();

                if (!this._suspendInstanceEvents)
                    this._onPlay();

                return true;

            },

            pause: function () {
                if (!this.source || this._state !== STATE_PLAYING)
                    return false;

                this._suspendEndEvent = true;
                this.source.pause();
                this._playWhenLoaded = false;
                this._state = STATE_PAUSED;
                this._startOffset = null;

                if (!this._suspendInstanceEvents)
                    this._onPause();

                return true;
            },

            resume: function () {
                if (!this.source || this._state !== STATE_PAUSED)
                    return false;

                this._state = STATE_PLAYING;
                this._playWhenLoaded = false;
                if (this.source.paused) {
                    this.source.play();

                    if (!this._suspendInstanceEvents)
                        this._onResume();
                }

                return true;
            },

            stop: function () {
                if (!this.source || this._state === STATE_STOPPED)
                    return false;

                this._manager.off('volumechange', this._onManagerVolumeChange, this);
                this._manager.off('suspend', this._onManagerSuspend, this);
                this._manager.off('resume', this._onManagerResume, this);
                this._manager.off('destroy', this._onManagerDestroy, this);

                this._suspendEndEvent = true;
                this.source.pause();
                this._playWhenLoaded = false;
                this._state = STATE_STOPPED;
                this._startOffset = null;

                if (!this._suspendInstanceEvents)
                    this._onStop();

                return true;
            },

            setExternalNodes: function () {
                // not supported
            },

            clearExternalNodes: function () {
                // not supported
            },

            getExternalNodes: function () {
                // not supported but return same type of result
                return [null, null];
            },

            // Sets start time after loadedmetadata is fired which is required by most browsers
            _onLoadedMetadata: function () {
                this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);

                this._isReady = true;

                // calculate start time for source
                var offset = capTime(this._startOffset, this.duration);
                offset = capTime(this._startTime + offset, this._sound.duration);
                // reset currentTime
                this._startOffset = null;

                // set offset on source
                this.source.currentTime = offset;
            },

            _createSource: function () {
                if (this._sound && this._sound.audio) {

                    this._isReady = false;
                    this.source = this._sound.audio.cloneNode(true);

                    // set events
                    this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
                    this.source.addEventListener('timeupdate', this._timeUpdateHandler);
                    this.source.onended = this._endedHandler;
                }

                return this.source;
            },

            // called every time the 'currentTime' is changed
            _onTimeUpdate: function () {
                if (!this._duration)
                    return;

                // if the currentTime passes the end then if looping go back to the beginning
                // otherwise manually stop
                if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
                    if (this.loop) {
                        this.source.currentTime = capTime(this._startTime, this.source.duration);
                    } else {
                        // remove listener to prevent multiple calls
                        this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
                        this.source.pause();

                        // call this manually because it doesn't work in all browsers in this case
                        this._onEnded();
                    }
                }
            },

            /**
             * @private
             * @function
             * @name pc.SoundInstance#_onManagerDestroy
             * @description Handle the manager's 'destroy' event.
             */
            _onManagerDestroy: function () {
                if (this.source) {
                    this.source.pause();
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'volume', {
            get: function () {
                return this._volume;
            },

            set: function (volume) {
                volume = math.clamp(volume, 0, 1);
                this._volume = volume;
                if (this.source) {
                    this.source.volume = volume * this._manager.volume;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'pitch', {
            get: function () {
                return this._pitch;
            },

            set: function (pitch) {
                this._pitch = Math.max(Number(pitch) || 0, 0.01);
                if (this.source) {
                    this.source.playbackRate = this._pitch;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'loop', {
            get: function () {
                return this._loop;
            },

            set: function (loop) {
                this._loop = !!loop;
                if (this.source) {
                    this.source.loop = this._loop;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance.prototype, 'sound', {
            get: function () {
                return this._sound;
            },

            set: function (value) {
                this.stop();
                this._sound = value;
            }
        });


        Object.defineProperty(exports.SoundInstance.prototype, 'currentTime', {
            get: function () {
                if (this._startOffset !== null) {
                    return this._startOffset;
                }

                if (this._state === STATE_STOPPED || !this.source) {
                    return 0;
                }

                return this.source.currentTime - this._startTime;
            },
            set: function (value) {
                if (value < 0) return;

                this._startOffset = value;
                if (this.source && this._isReady) {
                    this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
                    this._startOffset = null;
                }
            }
        });

    } else {
        exports.SoundInstance = function () { };
    }

    // Add functions which don't depend on source type
    Object.assign(exports.SoundInstance.prototype, {

        _onPlay: function () {
            this.fire('play');

            if (this._onPlayCallback)
                this._onPlayCallback(this);
        },

        _onPause: function () {
            this.fire('pause');

            if (this._onPauseCallback)
                this._onPauseCallback(this);
        },

        _onResume: function () {
            this.fire('resume');

            if (this._onResumeCallback)
                this._onResumeCallback(this);
        },

        _onStop: function () {
            this.fire('stop');

            if (this._onStopCallback)
                this._onStopCallback(this);
        },

        _onEnded: function () {
            // the callback is not fired synchronously
            // so only reset _suspendEndEvent to false when the
            // callback is fired
            if (this._suspendEndEvent) {
                this._suspendEndEvent = false;
                return;
            }

            this.fire('end');

            if (this._onEndCallback)
                this._onEndCallback(this);

            this.stop();
        },

        /**
         * @private
         * @function
         * @name pc.SoundInstance#_onManagerVolumeChange
         * @description Handle the manager's 'volumechange' event.
         */
        _onManagerVolumeChange: function () {
            this.volume = this._volume;
        },

        /**
         * @private
         * @function
         * @name pc.SoundInstance#_onManagerSuspend
         * @description Handle the manager's 'suspend' event.
         */
        _onManagerSuspend: function () {
            if (this._state === STATE_PLAYING && !this._suspended) {
                this._suspended = true;
                this.pause();
            }
        },

        /**
         * @private
         * @function
         * @name pc.SoundInstance#_onManagerResume
         * @description Handle the manager's 'resume' event.
         */
        _onManagerResume: function () {
            if (this._suspended) {
                this._suspended = false;
                this.resume();
            }
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'startTime', {
        get: function () {
            return this._startTime;
        },

        set: function (value) {
            this._startTime = Math.max(0, Number(value) || 0);

            // restart
            var isPlaying = this._state === STATE_PLAYING;
            this.stop();
            if (isPlaying) {
                this.play();
            }
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'duration', {
        get: function () {
            if (!this._sound) {
                return 0;
            }
            if (this._duration) {
                return capTime(this._duration, this._sound.duration);
            }
            return this._sound.duration;
        },
        set: function (value) {
            this._duration = Math.max(0, Number(value) || 0);

            // restart
            var isPlaying = this._state === STATE_PLAYING;
            this.stop();
            if (isPlaying) {
                this.play();
            }
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'isPlaying', {
        get: function () {
            return this._state === STATE_PLAYING;
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'isPaused', {
        get: function () {
            return this._state === STATE_PAUSED;
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'isStopped', {
        get: function () {
            return this._state === STATE_STOPPED;
        }
    });

    Object.defineProperty(exports.SoundInstance.prototype, 'isSuspended', {
        get: function () {
            return this._suspended;
        }
    });

    // default maxDistance, same as Web Audio API
    var MAX_DISTANCE$1 = 10000;



    if (hasAudioContext()) {
        /**
         * @class
         * @name pc.SoundInstance3d
         * @augments pc.SoundInstance
         * @classdesc A pc.SoundInstance3d plays a {@link pc.Sound} in 3D.
         * @param {pc.SoundManager} manager - The sound manager.
         * @param {pc.Sound} sound - The sound to play.
         * @param {object} options - Options for the instance.
         * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
         * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
         * @param {boolean} [options.loop=false] - Whether the sound should loop when it reaches the end or not.
         * @param {number} [options.startTime=0] - The time from which the playback will start. Default is 0 to start at the beginning.
         * @param {number} [options.duration=null] - The total time after the startTime when playback will stop or restart if loop is true.
         * @param {pc.Vec3} [options.position=null] - The position of the sound in 3D space.
         * @param {pc.Vec3} [options.velocity=null] - The velocity of the sound.
         * @param {string} [options.distanceModel=pc.DISTANCE_LINEAR] - Determines which algorithm to use to reduce the volume of the audio as it moves away from the listener. Can be:
         *
         * * {@link pc.DISTANCE_LINEAR}
         * * {@link pc.DISTANCE_INVERSE}
         * * {@link pc.DISTANCE_EXPONENTIAL}
         *
         * Default is {@link pc.DISTANCE_LINEAR}.
         * @param {number} [options.refDistance=1] - The reference distance for reducing volume as the sound source moves further from the listener.
         * @param {number} [options.maxDistance=10000] - The maximum distance from the listener at which audio falloff stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off anymore.
         * @param {number} [options.rollOffFactor=1] - The factor used in the falloff equation.
         * @property {pc.Vec3} position The position of the sound in 3D space.
         * @property {pc.Vec3} velocity The velocity of the sound.
         * @property {string} distanceModel Determines which algorithm to use to reduce the volume of the audio as it moves away from the listener. Can be:
         *
         * * {@link pc.DISTANCE_LINEAR}
         * * {@link pc.DISTANCE_INVERSE}
         * * {@link pc.DISTANCE_EXPONENTIAL}
         *
         * Default is {@link pc.DISTANCE_LINEAR}.
         * @property {number} refDistance The reference distance for reducing volume as the sound source moves further from the listener.
         * @property {number} maxDistance The maximum distance from the listener at which audio falloff stops. Note the volume of the audio is not 0 after this distance, but just doesn't fall off anymore.
         * @property {number} rollOffFactor The factor used in the falloff equation.
         */
        exports.SoundInstance3d = function (manager, sound, options) {
            exports.SoundInstance.call(this, manager, sound, options);

            options = options || {};

            this._position = new Vec3();
            if (options.position)
                this.position = options.position;

            this._velocity = new Vec3();
            if (options.velocity)
                this.velocity = options.velocity;

            this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE$1;
            this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
            this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
            this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
        };
        exports.SoundInstance3d.prototype = Object.create(exports.SoundInstance.prototype);
        exports.SoundInstance3d.prototype.constructor = exports.SoundInstance3d;

        Object.assign(exports.SoundInstance3d.prototype, {
            _initializeNodes: function () {
                this.gain = this._manager.context.createGain();
                this.panner = this._manager.context.createPanner();
                this.panner.connect(this.gain);
                this._inputNode = this.panner;
                this._connectorNode = this.gain;
                this._connectorNode.connect(this._manager.context.destination);
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'position', {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position.copy(position);
                this.panner.setPosition(position.x, position.y, position.z);
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'velocity', {
            get: function () {
                return this._velocity;
            },
            set: function (velocity) {
                this._velocity.copy(velocity);
                this.panner.setVelocity(velocity.x, velocity.y, velocity.z);
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'maxDistance', {
            get: function () {
                return this.panner.maxDistance;
            },
            set: function (value) {
                this.panner.maxDistance = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'refDistance', {
            get: function () {
                return this.panner.refDistance;
            },
            set: function (value) {
                this.panner.refDistance = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'rollOffFactor', {
            get: function () {
                return this.panner.rolloffFactor;
            },
            set: function (value) {
                this.panner.rolloffFactor = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'distanceModel', {
            get: function () {
                return this.panner.distanceModel;
            },
            set: function (value) {
                this.panner.distanceModel = value;
            }
        });

    } else if (hasAudio()) {
        // temp vector storage
        var offset$1 = new Vec3();

        // Fall off function which should be the same as the one in the Web Audio API
        // Taken from https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel
        var fallOff$1 = function (posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
            offset$1 = offset$1.sub2(posOne, posTwo);
            var distance = offset$1.length();

            if (distance < refDistance) {
                return 1;
            } else if (distance > maxDistance) {
                return 0;
            }

            var result = 0;
            if (distanceModel === DISTANCE_LINEAR) {
                result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
            } else if (distanceModel === DISTANCE_INVERSE) {
                result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
            } else if (distanceModel === DISTANCE_EXPONENTIAL) {
                result = Math.pow(distance / refDistance, -rollOffFactor);
            }
            return math.clamp(result, 0, 1);
        };

        exports.SoundInstance3d = function (manager, sound, options) {
            exports.SoundInstance.call(this, manager, sound, options);

            options = options || {};

            this._position = new Vec3();
            if (options.position)
                this.position = options.position;

            this._velocity = new Vec3();
            if (options.velocity)
                this.velocity = options.velocity;

            this._maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE$1;
            this._refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
            this._rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
            this._distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
        };
        exports.SoundInstance3d.prototype = Object.create(exports.SoundInstance.prototype);
        exports.SoundInstance3d.prototype.constructor = exports.SoundInstance3d;

        Object.defineProperty(exports.SoundInstance3d.prototype, 'position', {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position.copy(position);

                if (this.source) {
                    var listener = this._manager.listener;

                    var lpos = listener.getPosition();

                    var factor = fallOff$1(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);

                    var v = this.volume;

                    this.source.volume = v * factor * this._manager.volume;
                }
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'velocity', {
            get: function () {
                return this._velocity;
            },
            set: function (velocity) {
                this._velocity.copy(velocity);
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'maxDistance', {
            get: function () {
                return this._maxDistance;
            },
            set: function (value) {
                this._maxDistance = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'refDistance', {
            get: function () {
                return this._refDistance;
            },
            set: function (value) {
                this._refDistance = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'rollOffFactor', {
            get: function () {
                return this._rollOffFactor;
            },
            set: function (value) {
                this._rollOffFactor = value;
            }
        });

        Object.defineProperty(exports.SoundInstance3d.prototype, 'distanceModel', {
            get: function () {
                return this._distanceModel;
            },
            set: function (value) {
                this._distanceModel = value;
            }
        });
    } else {
        exports.SoundInstance3d = function () { };
    }

    // temporary object for creating
    // instances
    var instanceOptions = {
        volume: 0,
        pitch: 0,
        loop: false,
        startTime: 0,
        duration: 0,
        position: new Vec3(),
        maxDistance: 0,
        refDistance: 0,
        rollOffFactor: 0,
        distanceModel: 0,
        onPlay: null,
        onPause: null,
        onResume: null,
        onStop: null,
        onEnd: null
    };

    /**
     * @class
     * @name pc.SoundSlot
     * @augments pc.EventHandler
     * @classdesc The SoundSlot controls playback of an audio asset.
     * @description Create a new SoundSlot.
     * @param {pc.SoundComponent} component - The Component that created this slot.
     * @param {string} name - The name of the slot.
     * @param {object} options - Settings for the slot.
     * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
     * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
     * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the end.
     * @param {number} [options.startTime=0] - The start time from which the sound will start playing.
     * @param {number} [options.duration=null] - The duration of the sound that the slot will play starting from startTime.
     * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be played independently of each other. Otherwise the slot will first stop the current sound before starting the new one.
     * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as its audio asset is loaded.
     * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be played by this slot.
     * @property {string} name The name of the slot.
     * @property {number|null} asset The asset id.
     * @property {boolean} autoPlay If true the slot will begin playing as soon as it is loaded.
     * @property {number} volume The volume modifier to play the sound with. In range 0-1.
     * @property {number} pitch The pitch modifier to play the sound with. Must be larger than 0.01.
     * @property {number} startTime The start time from which the sound will start playing.
     * @property {number} duration The duration of the sound that the slot will play starting from startTime.
     * @property {boolean} loop If true the slot will restart when it finishes playing.
     * @property {boolean} overlap If true then sounds played from slot will be played independently of each other. Otherwise the slot will first stop the current sound before starting the new one.
     * @property {boolean} isLoaded Returns true if the asset of the slot is loaded.
     * @property {boolean} isPlaying Returns true if the slot is currently playing.
     * @property {boolean} isPaused Returns true if the slot is currently paused.
     * @property {boolean} isStopped Returns true if the slot is currently stopped.
     * @property {pc.SoundInstance[]} instances An array that contains all the {@link pc.SoundInstance}s currently being played by the slot.
     */
    function SoundSlot(component, name, options) {
        EventHandler.call(this);

        options = options || {};
        this._component = component;
        this._assets = component.system.app.assets;
        this._manager = component.system.manager;
        this._name = name || 'Untitled';
        this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
        this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
        this._loop = !!(options.loop !== undefined ? options.loop : false);
        this._duration = options.duration > 0 ? options.duration : null;
        this._startTime = Math.max(0, Number(options.startTime) || 0);
        this._overlap = !!(options.overlap);
        this._autoPlay = !!(options.autoPlay);
        this._firstNode = null;
        this._lastNode = null;

        this._asset = options.asset;
        if (this._asset instanceof Asset) {
            this._asset = this._asset.id;
        }

        this._onInstancePlayHandler = this._onInstancePlay.bind(this);
        this._onInstancePauseHandler = this._onInstancePause.bind(this);
        this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
        this._onInstanceStopHandler = this._onInstanceStop.bind(this);
        this._onInstanceEndHandler = this._onInstanceEnd.bind(this);

        this.instances = [];
    }
    SoundSlot.prototype = Object.create(EventHandler.prototype);
    SoundSlot.prototype.constructor = SoundSlot;

    Object.assign(SoundSlot.prototype, {
        /**
         * @function pc.SoundSlot#play
         * @description Plays a sound. If {@link pc.SoundSlot#overlap} is true the new sound
         * instance will be played independently of any other instances already playing.
         * Otherwise existing sound instances will stop before playing the new sound.
         * @returns {pc.SoundInstance} The new sound instance.
         */
        play: function () {
            // stop if overlap is false
            if (!this.overlap) {
                this.stop();
            }

            // If not loaded and doesn't have asset - then we cannot play it.  Warn and exit.
            if (!this.isLoaded && !this._hasAsset()) {
                return;
            }

            var instance = this._createInstance();
            this.instances.push(instance);

            // if not loaded then load first
            // and then set sound resource on the created instance
            if (!this.isLoaded) {
                var onLoad = function (sound) {
                    var playWhenLoaded = instance._playWhenLoaded;
                    instance.sound = sound;
                    if (playWhenLoaded) {
                        instance.play();
                    }
                };

                this.off('load', onLoad);
                this.once('load', onLoad);
                this.load();
            } else {
                instance.play();
            }

            return instance;
        },

        /**
         * @function
         * @name pc.SoundSlot#pause
         * @description Pauses all sound instances. To continue playback call {@link pc.SoundSlot#resume}.
         * @returns {boolean} True if the sound instances paused successfully, false otherwise.
         */
        pause: function () {
            var paused = false;

            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                if (instances[i].pause()) {
                    paused = true;
                }
            }

            return paused;
        },

        /**
         * @function
         * @name pc.SoundSlot#resume
         * @description Resumes playback of all paused sound instances.
         * @returns {boolean} True if any instances were resumed.
         */
        resume: function () {
            var resumed = false;
            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                if (instances[i].resume())
                    resumed = true;
            }

            return resumed;
        },

        /**
         * @function
         * @name pc.SoundSlot#stop
         * @description Stops playback of all sound instances.
         * @returns {boolean} True if any instances were stopped.
         */
        stop: function () {
            var stopped = false;
            var instances = this.instances;
            var i = instances.length;
            // do this in reverse order because as each instance
            // is stopped it will be removed from the instances array
            // by the instance stop event handler
            while (i--) {
                instances[i].stop();
                stopped = true;
            }

            instances.length = 0;

            return stopped;
        },

        /**
         * @function
         * @name pc.SoundSlot#load
         * @description Loads the asset assigned to this slot.
         */
        load: function () {
            if (!this._hasAsset())
                return;

            var asset = this._assets.get(this._asset);
            if (!asset) {
                this._assets.off('add:' + this._asset, this._onAssetAdd, this);
                this._assets.once('add:' + this._asset, this._onAssetAdd, this);
                return;
            }

            asset.off('remove', this._onAssetRemoved, this);
            asset.on('remove', this._onAssetRemoved, this);

            if (!asset.resource) {
                asset.off('load', this._onAssetLoad, this);
                asset.once('load', this._onAssetLoad, this);

                this._assets.load(asset);

                return;
            }

            this.fire('load', asset.resource);
        },

        /**
         * @function
         * @name pc.SoundSlot#setExternalNodes
         * @description Connect external Web Audio API nodes. Any sound played by this slot will
         * automatically attach the specified nodes to the source that plays the sound. You need to pass
         * the first node of the node graph that you created externally and the last node of that graph. The first
         * node will be connected to the audio source and the last node will be connected to the destination of the AudioContext (e.g. speakers).
         * @param {AudioNode} firstNode - The first node that will be connected to the audio source of sound instances.
         * @param {AudioNode} [lastNode] - The last node that will be connected to the destination of the AudioContext.
         * If unspecified then the firstNode will be connected to the destination instead.
         * @example
         * var context = app.systems.sound.context;
         * var analyzer = context.createAnalyzer();
         * var distortion = context.createWaveShaper();
         * var filter = context.createBiquadFilter();
         * analyzer.connect(distortion);
         * distortion.connect(filter);
         * slot.setExternalNodes(analyzer, filter);
         */
        setExternalNodes: function (firstNode, lastNode) {
            if (!(firstNode)) {
                console.error('The firstNode must have a valid AudioNode');
                return;
            }

            if (!lastNode) {
                lastNode = firstNode;
            }

            this._firstNode = firstNode;
            this._lastNode = lastNode;

            // update instances if not overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].setExternalNodes(firstNode, lastNode);
                }
            }
        },

        /**
         * @function
         * @name pc.SoundSlot#clearExternalNodes
         * @description Clears any external nodes set by {@link pc.SoundSlot#setExternalNodes}.
         */
        clearExternalNodes: function () {
            this._firstNode = null;
            this._lastNode = null;

            // update instances if not overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].clearExternalNodes();
                }
            }
        },

        /**
         * @function
         * @name pc.SoundSlot#getExternalNodes
         * @description Gets an array that contains the two external nodes set by {@link pc.SoundSlot#setExternalNodes}.
         * @returns {AudioNode[]} An array of 2 elements that contains the first and last nodes set by {@link pc.SoundSlot#setExternalNodes}.
         */
        getExternalNodes: function () {
            return [this._firstNode, this._lastNode];
        },

        /**
         * @function
         * @private
         * @name pc.SoundSlot#_hasAsset
         * @returns {boolean} Returns true if the slot has an asset assigned.
         */
        _hasAsset: function () {
            // != intentional
            return this._asset != null;
        },

        /**
         * @function
         * @private
         * @name pc.SoundSlot#_createInstance
         * @description Creates a new pc.SoundInstance with the properties of the slot.
         * @returns {pc.SoundInstance} The new instance.
         */
        _createInstance: function () {
            var instance = null;

            var component = this._component;

            var sound = null;

            // get sound resource
            if (this._hasAsset()) {
                var asset = this._assets.get(this._asset);
                if (asset) {
                    sound = asset.resource;
                }
            }

            // initialize instance options
            var data = instanceOptions;
            data.volume = this._volume * component.volume;
            data.pitch = this._pitch * component.pitch;
            data.loop = this._loop;
            data.startTime = this._startTime;
            data.duration = this._duration;

            data.onPlay = this._onInstancePlayHandler;
            data.onPause = this._onInstancePauseHandler;
            data.onResume = this._onInstanceResumeHandler;
            data.onStop = this._onInstanceStopHandler;
            data.onEnd = this._onInstanceEndHandler;

            if (component.positional) {
                data.position.copy(component.entity.getPosition());
                data.maxDistance = component.maxDistance;
                data.refDistance = component.refDistance;
                data.rollOffFactor = component.rollOffFactor;
                data.distanceModel = component.distanceModel;

                instance = new exports.SoundInstance3d(this._manager, sound, data);
            } else {
                instance = new exports.SoundInstance(this._manager, sound, data);
            }

            // hook external audio nodes
            if (this._firstNode) {
                instance.setExternalNodes(this._firstNode, this._lastNode);
            }

            return instance;
        },

        _onInstancePlay: function (instance) {
            // propagate event to slot
            this.fire('play', instance);

            // propagate event to component
            this._component.fire('play', this, instance);
        },

        _onInstancePause: function (instance) {
            // propagate event to slot
            this.fire('pause', instance);

            // propagate event to component
            this._component.fire('pause', this, instance);
        },

        _onInstanceResume: function (instance) {
            // propagate event to slot
            this.fire('resume', instance);

            // propagate event to component
            this._component.fire('resume', this, instance);
        },

        _onInstanceStop: function (instance) {
            // remove instance that stopped
            var idx = this.instances.indexOf(instance);
            if (idx !== -1) {
                this.instances.splice(idx, 1);
            }

            // propagate event to slot
            this.fire('stop', instance);

            // propagate event to component
            this._component.fire('stop', this, instance);
        },

        _onInstanceEnd: function (instance) {
            // remove instance that ended
            var idx = this.instances.indexOf(instance);
            if (idx !== -1) {
                this.instances.splice(idx, 1);
            }

            // propagate event to slot
            this.fire('end', instance);

            // propagate event to component
            this._component.fire('end', this, instance);
        },

        _onAssetAdd: function (asset) {
            this.load();
        },

        _onAssetLoad: function (asset) {
            this.load();
        },

        _onAssetRemoved: function (asset) {
            asset.off('remove', this._onAssetRemoved, this);
            this._assets.off('add:' + asset.id, this._onAssetAdd, this);
            this.stop();
        },

        updatePosition: function (position) {
            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                instances[i].position = position;
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'name', {
        get: function () {
            return this._name;
        },
        set: function (value) {
            this._name = value;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'volume', {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            this._volume = math.clamp(Number(value) || 0, 0, 1);

            // update instances if non overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].volume = this._volume * this._component.volume;
                }
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'pitch', {
        get: function () {
            return this._pitch;
        },
        set: function (value) {
            this._pitch = Math.max(Number(value) || 0, 0.01);

            // update instances if non overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].pitch = this.pitch * this._component.pitch;
                }
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'loop', {
        get: function () {
            return this._loop;
        },
        set: function (value) {
            this._loop = !!value;

            // update instances if non overlapping
            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                instances[i].loop = this._loop;
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'autoPlay', {
        get: function () {
            return this._autoPlay;
        },
        set: function (value) {
            this._autoPlay = !!value;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'overlap', {
        get: function () {
            return this._overlap;
        },
        set: function (value) {
            this._overlap = !!value;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'startTime', {
        get: function () {
            return this._startTime;
        },
        set: function (value) {
            this._startTime = Math.max(0, Number(value) || 0);

            // update instances if non overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].startTime = this._startTime;
                }
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'duration', {
        get: function () {
            var assetDuration = 0;
            if (this._hasAsset()) {
                var asset = this._assets.get(this._asset);
                assetDuration = asset.resource ? asset.resource.duration : 0;
            }

            // != intentional
            if (this._duration != null) {
                return this._duration % (assetDuration || 1);
            }
            return assetDuration;
        },
        set: function (value) {
            this._duration = Math.max(0, Number(value) || 0) || null;

            // update instances if non overlapping
            if (!this._overlap) {
                var instances = this.instances;
                for (var i = 0, len = instances.length; i < len; i++) {
                    instances[i].duration = this._duration;
                }
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'asset', {
        get: function () {
            return this._asset;
        },
        set: function (value) {
            var old = this._asset;

            if (old) {
                this._assets.off('add:' + old, this._onAssetAdd, this);
                var oldAsset = this._assets.get(old);
                if (oldAsset) {
                    oldAsset.off('remove', this._onAssetRemoved, this);
                }
            }

            this._asset = value;
            if (this._asset instanceof Asset) {
                this._asset = this._asset.id;
            }

            // load asset if component and entity are enabled
            if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
                this.load();
            }
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'isLoaded', {
        get: function () {
            if (this._hasAsset()) {
                var asset = this._assets.get(this._asset);
                if (asset) {
                    return !!asset.resource;
                }
            }

            return false;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'isPlaying', {
        get: function () {
            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                if (instances[i].isPlaying)
                    return true;
            }

            return false;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'isPaused', {
        get: function () {
            var instances = this.instances;
            var len = instances.length;
            if (len === 0)
                return false;

            for (var i = 0; i < len; i++) {
                if (!instances[i].isPaused)
                    return false;
            }

            return true;
        }
    });

    Object.defineProperty(SoundSlot.prototype, 'isStopped', {
        get: function () {
            var instances = this.instances;
            for (var i = 0, len = instances.length; i < len; i++) {
                if (!instances[i].isStopped)
                    return false;
            }

            return true;
        }
    });

    /**
     * @component
     * @class
     * @name pc.SoundComponent
     * @augments pc.Component
     * @classdesc The Sound Component controls playback of {@link pc.Sound}s.
     * @description Create a new Sound Component.
     * @param {pc.SoundComponentSystem} system - The ComponentSystem that created this
     * component.
     * @param {pc.Entity} entity - The entity that the Component is attached to.
     * @property {number} volume The volume modifier to play the audio with. In range 0-1.
     * @property {number} pitch The pitch modifier to play the audio with. Must be larger
     * than 0.01.
     * @property {boolean} positional If true the audio will play back at the location
     * of the Entity in space, so the audio will be affected by the position of the
     * {@link pc.AudioListenerComponent}.
     * @property {string} distanceModel Determines which algorithm to use to reduce the
     * volume of the sound as it moves away from the listener. Can be:
     *
     * * {@link pc.DISTANCE_LINEAR}
     * * {@link pc.DISTANCE_INVERSE}
     * * {@link pc.DISTANCE_EXPONENTIAL}
     *
     * Default is {@link pc.DISTANCE_LINEAR}.
     * @property {number} refDistance The reference distance for reducing volume as the
     * sound source moves further from the listener.
     * @property {number} maxDistance The maximum distance from the listener at which audio
     * falloff stops. Note the volume of the audio is not 0 after this distance, but just
     * doesn't fall off anymore.
     * @property {number} rollOffFactor The factor used in the falloff equation.
     * @property {object} slots A dictionary that contains the {@link pc.SoundSlot}s managed
     * by this Component.
     */
    function SoundComponent(system, entity) {
        Component.call(this, system, entity);

        this.on('set_slots', this.onSetSlots, this);
        this.on('set_volume', this.onSetVolume, this);
        this.on('set_pitch', this.onSetPitch, this);
        this.on("set_refDistance", this.onSetRefDistance, this);
        this.on("set_maxDistance", this.onSetMaxDistance, this);
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this);
        this.on("set_distanceModel", this.onSetDistanceModel, this);
        this.on("set_positional", this.onSetPositional, this);
    }
    SoundComponent.prototype = Object.create(Component.prototype);
    SoundComponent.prototype.constructor = SoundComponent;

    Object.assign(SoundComponent.prototype, {
        onSetSlots: function (name, oldValue, newValue) {
            var key;

            // stop previous slots
            if (oldValue) {
                for (key in oldValue) {
                    oldValue[key].stop();
                }
            }

            var slots = {};

            // convert data to slots
            for (key in newValue) {
                if (!(newValue[key] instanceof SoundSlot)) {
                    if (newValue[key].name) {
                        slots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);
                    }
                } else {
                    slots[newValue[key].name] = newValue[key];
                }
            }

            this.data.slots = slots;

            // call onEnable in order to start autoPlay slots
            if (this.enabled && this.entity.enabled)
                this.onEnable();
        },

        onSetVolume: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change volume of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].volume = slot.volume * newValue;
                    }
                }
            }
        },

        onSetPitch: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change pitch of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].pitch = slot.pitch * newValue;
                    }
                }
            }
        },

        onSetRefDistance: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change refDistance of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].refDistance = newValue;
                    }
                }
            }
        },

        onSetMaxDistance: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change maxDistance of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].maxDistance = newValue;
                    }
                }
            }
        },

        onSetRollOffFactor: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change rollOffFactor of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].rollOffFactor = newValue;
                    }
                }
            }
        },

        onSetDistanceModel: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // change distanceModel of non-overlapping instances
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        instances[i].distanceModel = newValue;
                    }
                }
            }
        },

        onSetPositional: function (name, oldValue, newValue) {
            var slots = this.data.slots;
            for (var key in slots) {
                var slot = slots[key];
                // recreate non overlapping sounds
                if (!slot.overlap) {
                    var instances = slot.instances;
                    for (var i = 0, len = instances.length; i < len; i++) {
                        var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
                        var currentTime = instances[i].currentTime;
                        if (isPlaying)
                            instances[i].stop();

                        instances[i] = slot._createInstance();
                        if (isPlaying) {
                            instances[i].play();
                            instances[i].currentTime = currentTime;
                        }
                    }
                }
            }
        },

        onEnable: function () {
            // do not run if running in Editor
            if (this.system._inTools) {
                return;
            }

            var slots = this.data.slots;
            var playingBeforeDisable = this.data.playingBeforeDisable;

            for (var key in slots) {
                var slot = slots[key];
                // play if autoPlay is true or
                // if the slot was paused when the component
                // got disabled
                if (slot.autoPlay && slot.isStopped) {
                    slot.play();
                } else if (playingBeforeDisable[key]) {
                    slot.resume();
                } else if (!slot.isLoaded) {
                    // start loading slots
                    slot.load();
                }
            }
        },

        onDisable: function () {
            var slots = this.data.slots;
            var playingBeforeDisable = {};
            for (var key in slots) {
                // pause non-overlapping sounds
                if (!slots[key].overlap) {
                    if (slots[key].isPlaying) {
                        slots[key].pause();
                        // remember sounds playing when we disable
                        // so we can resume them on enable
                        playingBeforeDisable[key] = true;
                    }
                }
            }

            this.data.playingBeforeDisable = playingBeforeDisable;
        },

        onRemove: function () {
            this.off();
        },

        /**
         * @function
         * @name pc.SoundComponent#addSlot
         * @description Creates a new {@link pc.SoundSlot} with the specified name.
         * @param {string} name - The name of the slot.
         * @param {object} [options] - Settings for the slot.
         * @param {number} [options.volume=1] - The playback volume, between 0 and 1.
         * @param {number} [options.pitch=1] - The relative pitch, default of 1, plays at normal pitch.
         * @param {boolean} [options.loop=false] - If true the sound will restart when it reaches the end.
         * @param {number} [options.startTime=0] - The start time from which the sound will start playing.
         * @param {number} [options.duration=null] - The duration of the sound that the slot will play starting from startTime.
         * @param {boolean} [options.overlap=false] - If true then sounds played from slot will be played independently of each other. Otherwise the slot will first stop the current sound before starting the new one.
         * @param {boolean} [options.autoPlay=false] - If true the slot will start playing as soon as its audio asset is loaded.
         * @param {number} [options.asset=null] - The asset id of the audio asset that is going to be played by this slot.
         * @returns {pc.SoundSlot} The new slot.
         * @example
         * // get an asset by id
         * var asset = app.assets.get(10);
         * // add a slot
         * this.entity.sound.addSlot('beep', {
         *     asset: asset
         * });
         * // play
         * this.entity.sound.play('beep');
         */
        addSlot: function (name, options) {
            var slots = this.data.slots;
            if (slots[name]) {
                return null;
            }

            var slot = new SoundSlot(this, name, options);
            slots[name] = slot;

            if (slot.autoPlay && this.enabled && this.entity.enabled) {
                slot.play();
            }

            return slot;
        },

        /**
         * @function
         * @name pc.SoundComponent#removeSlot
         * @description Removes the {@link pc.SoundSlot} with the specified name.
         * @param {string} name - The name of the slot.
         * @example
         * // remove a slot called 'beep'
         * this.entity.sound.removeSlot('beep');
         */
        removeSlot: function (name) {
            var slots = this.data.slots;
            if (slots[name]) {
                slots[name].stop();
                delete slots[name];
            }
        },

        /**
         * @function
         * @name pc.SoundComponent#slot
         * @description Returns the slot with the specified name.
         * @param {string} name - The name of the slot.
         * @returns {pc.SoundSlot} The slot.
         * @example
         * // get a slot and set its volume
         * this.entity.sound.slot('beep').volume = 0.5;
         *
         */
        slot: function (name) {
            return this.data.slots[name];
        },

        /**
         * @function
         * @name pc.SoundComponent#play
         * @description Begins playing the sound slot with the specified name. The slot will restart playing if it is already playing unless the overlap field is true in which case a new sound will be created and played.
         * @param {string} name - The name of the {@link pc.SoundSlot} to play.
         * @example
         * // get asset by id
         * var asset = app.assets.get(10);
         * // create a slot and play it
         * this.entity.sound.addSlot('beep', {
         *     asset: asset
         * });
         * this.entity.sound.play('beep');
         * @returns {pc.SoundInstance} The sound instance that will be played.
         */
        play: function (name) {
            if (!this.enabled || !this.entity.enabled) {
                return null;
            }

            var slot = this.slots[name];
            if (!slot) {
                return null;
            }

            return slot.play();
        },

        /**
         * @function
         * @name pc.SoundComponent#pause
         * @description Pauses playback of the slot with the specified name. If the name is undefined then all slots currently played will be paused. The slots can be resumed by calling {@link pc.SoundComponent#resume}.
         * @param {string} [name] - The name of the slot to pause. Leave undefined to pause everything.
         * @example
         * // pause all sounds
         * this.entity.sound.pause();
         * // pause a specific sound
         * this.entity.sound.pause('beep');
         */
        pause: function (name) {
            var slot;
            var slots = this.data.slots;

            if (name) {
                slot = slots[name];
                if (!slot) {
                    return;
                }

                slot.pause();
            } else {
                for (var key in slots) {
                    slots[key].pause();
                }
            }
        },

        /**
         * @function
         * @name pc.SoundComponent#resume
         * @description Resumes playback of the sound slot with the specified name if it's paused. If no name is specified all slots will be resumed.
         * @param {string} name - The name of the slot to resume. Leave undefined to resume everything.
         * @example
         * // resume all sounds
         * this.entity.sound.resume();
         * // resume a specific sound
         * this.entity.sound.resume('beep');
         */
        resume: function (name) {
            var slot;
            var slots = this.data.slots;

            if (name) {
                slot = slots[name];
                if (!slot) {
                    return;
                }

                if (slot.isPaused) {
                    slot.resume();
                }
            } else {
                for (var key in slots) {
                    slots[key].resume();
                }
            }
        },

        /**
         * @function
         * @name pc.SoundComponent#stop
         * @description Stops playback of the sound slot with the specified name if it's paused. If no name is specified all slots will be stopped.
         * @param {string} name - The name of the slot to stop. Leave undefined to stop everything.
         * @example
         * // stop all sounds
         * this.entity.sound.stop();
         * // stop a specific sound
         * this.entity.sound.stop('beep');
         */
        stop: function (name) {
            var slot;
            var slots = this.data.slots;

            if (name) {
                slot = slots[name];
                if (!slot) {
                    return;
                }

                slot.stop();
            } else {
                for (var key in slots) {
                    slots[key].stop();
                }
            }
        }
    });

    function SoundComponentData() {
        // serialized
        this.enabled = true;
        this.volume = 1;
        this.pitch = 1;
        this.positional = true;
        this.refDistance = 1;
        this.maxDistance = 10000;
        this.rollOffFactor = 1;
        this.distanceModel = DISTANCE_LINEAR;
        this.slots = {};

        // non serialized
        this.playingBeforeDisable = {};
    }

    var _schema$h = [
        'enabled',
        'volume',
        'pitch',
        'positional',
        'refDistance',
        'maxDistance',
        'rollOffFactor',
        'distanceModel',
        'slots'
    ];

    /**
     * @class
     * @name pc.SoundComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.SoundComponent}s.
     * @description Create a SoundComponentSystem.
     * @param {pc.Application} app - The Application.
     * @param {pc.SoundManager} manager - The sound manager.
     * @property {number} volume Sets / gets the volume for the entire Sound system. All sounds will have their volume
     * multiplied by this value. Valid between [0, 1].
     * @property {AudioContext} context Gets the AudioContext currently used by the sound manager. Requires Web Audio API support.
     * @property {pc.SoundManager} manager Gets / sets the sound manager.
     */
    var SoundComponentSystem = function (app, manager) {
        ComponentSystem.call(this, app);

        this.id = "sound";
        this.description = "Allows an Entity to play sounds";

        this.ComponentType = SoundComponent;
        this.DataType = SoundComponentData;

        this.schema = _schema$h;

        this.manager = manager;

        ComponentSystem.bind('update', this.onUpdate, this);

        this.on('beforeremove', this.onBeforeRemove, this);
    };
    SoundComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    SoundComponentSystem.prototype.constructor = SoundComponentSystem;

    Component._buildAccessors(SoundComponent.prototype, _schema$h);

    Object.assign(SoundComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            properties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots', 'enabled'];
            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var key;
            var oldData = entity.sound.data;
            var newData = {};

            // copy old data to new data
            for (key in oldData) {
                if (oldData.hasOwnProperty(key)) {
                    newData[key] = oldData[key];
                }
            }

            // convert 'slots' back to
            // simple option objects
            newData.slots = {};

            for (key in oldData.slots) {
                var oldSlot = oldData.slots[key];
                if (oldSlot instanceof SoundSlot) {
                    newData.slots[key] = {
                        name: oldSlot.name,
                        volume: oldSlot.volume,
                        pitch: oldSlot.pitch,
                        loop: oldSlot.loop,
                        duration: oldSlot.duration,
                        startTime: oldSlot.startTime,
                        overlap: oldSlot.overlap,
                        autoPlay: oldSlot.autoPlay,
                        asset: oldSlot.asset
                    };
                } else {
                    newData.slots[key] = oldSlot;
                }
            }

            // reset playingBeforeDisable
            newData.playingBeforeDisable = {};

            // add component with new data
            return this.addComponent(clone, newData);
        },

        onUpdate: function (dt) {
            var store = this.store;

            for (var id in store) {
                if (store.hasOwnProperty(id)) {
                    var item = store[id];
                    var entity = item.entity;
                    var componentData = item.data;

                    // Update slot position if this is a 3d sound
                    if (componentData.enabled && entity.enabled && componentData.positional) {
                        var position = entity.getPosition();
                        var slots = componentData.slots;
                        for (var key in slots) {
                            slots[key].updatePosition(position);
                        }
                    }
                }
            }
        },

        onBeforeRemove: function (entity, component) {
            var slots = component.slots;
            // stop non overlapping sounds
            for (var key in slots) {
                if (!slots[key].overlap) {
                    slots[key].stop();
                }
            }

            component.onRemove();
        }
    });

    Object.defineProperty(SoundComponentSystem.prototype, 'volume', {
        get: function () {
            return this.manager.volume;
        },
        set: function (volume) {
            this.manager.volume = volume;
        }
    });

    Object.defineProperty(SoundComponentSystem.prototype, 'context', {
        get: function () {
            if (!hasAudioContext()) {
                console.warn('WARNING: Audio context is not supported on this browser');
                return null;
            }

            return this.manager.context;
        }
    });

    /**
     * @constant
     * @type {string}
     * @name pc.SPRITETYPE_SIMPLE
     * @description A {@link pc.SpriteComponent} that displays a single frame from a sprite asset.
     */
    var SPRITETYPE_SIMPLE = 'simple';

    /**
     * @constant
     * @type {string}
     * @name pc.SPRITETYPE_ANIMATED
     * @description A {@link pc.SpriteComponent} that renders sprite animations.
     */
    var SPRITETYPE_ANIMATED = 'animated';

    /**
     * @class
     * @name pc.SpriteAnimationClip
     * @augments pc.EventHandler
     * @classdesc Handles playing of sprite animations and loading of relevant sprite assets.
     * @param {pc.SpriteComponent} component - The sprite component managing this clip.
     * @param {object} data - Data for the new animation clip.
     * @param {number} [data.fps] - Frames per second for the animation clip.
     * @param {object} [data.loop] - Whether to loop the animation clip.
     * @param {string} [data.name] - The name of the new animation clip.
     * @param {number} [data.spriteAsset] - The id of the sprite asset that this clip will play.
     * @property {number} spriteAsset The id of the sprite asset used to play the animation.
     * @property {pc.Sprite} sprite The current sprite used to play the animation.
     * @property {number} frame The index of the frame of the {@link pc.Sprite} currently being rendered.
     * @property {number} time The current time of the animation in seconds.
     * @property {number} duration The total duration of the animation in seconds.
     * @property {boolean} isPlaying Whether the animation is currently playing.
     * @property {boolean} isPaused Whether the animation is currently paused.
     */
    function SpriteAnimationClip(component, data) {
        EventHandler.call(this);

        this._component = component;

        this._frame = 0;
        this._sprite = null;
        this._spriteAsset = null;
        this.spriteAsset = data.spriteAsset;

        this.name = data.name;
        this.fps = data.fps || 0;
        this.loop = data.loop || false;

        this._playing = false;
        this._paused = false;

        this._time = 0;
    }
    SpriteAnimationClip.prototype = Object.create(EventHandler.prototype);
    SpriteAnimationClip.prototype.constructor = SpriteAnimationClip;

    Object.assign(SpriteAnimationClip.prototype, {
        // When sprite asset is added bind it
        _onSpriteAssetAdded: function (asset) {
            this._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);
            if (this._spriteAsset === asset.id) {
                this._bindSpriteAsset(asset);
            }
        },

        // Hook up event handlers on sprite asset
        _bindSpriteAsset: function (asset) {
            asset.on("load", this._onSpriteAssetLoad, this);
            asset.on("remove", this._onSpriteAssetRemove, this);

            if (asset.resource) {
                this._onSpriteAssetLoad(asset);
            } else {
                this._component.system.app.assets.load(asset);
            }
        },

        _unbindSpriteAsset: function (asset) {
            asset.off("load", this._onSpriteAssetLoad, this);
            asset.off("remove", this._onSpriteAssetRemove, this);

            // unbind atlas
            if (asset.resource && asset.resource.atlas) {
                this._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
            }
        },

        // When sprite asset is loaded make sure the texture atlas asset is loaded too
        // If so then set the sprite, otherwise wait for the atlas to be loaded first
        _onSpriteAssetLoad: function (asset) {
            if (!asset.resource) {
                this.sprite = null;
            } else {
                if (!asset.resource.atlas) {
                    var atlasAssetId = asset.data.textureAtlasAsset;
                    var assets = this._component.system.app.assets;
                    assets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
                    assets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);
                } else {
                    this.sprite = asset.resource;
                }
            }
        },

        // When atlas is loaded try to reset the sprite asset
        _onTextureAtlasLoad: function (atlasAsset) {
            var spriteAsset = this._spriteAsset;
            if (spriteAsset instanceof Asset) {
                this._onSpriteAssetLoad(spriteAsset);
            } else {
                this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
            }
        },

        _onSpriteAssetRemove: function (asset) {
            this.sprite = null;
        },

        // If the meshes are re-created make sure
        // we update them in the mesh instance
        _onSpriteMeshesChange: function () {
            if (this._component.currentClip === this) {
                this._component._showFrame(this.frame);
            }
        },

        // Update frame if ppu changes for 9-sliced sprites
        _onSpritePpuChanged: function () {
            if (this._component.currentClip === this) {
                if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
                    this._component._showFrame(this.frame);
                }
            }
        },

        /**
         * @private
         * @function
         * @name pc.SpriteAnimationClip#_update
         * @param {number} dt - The delta time.
         * @description Advances the animation looping if necessary.
         */
        _update: function (dt) {
            if (this.fps === 0) return;
            if (!this._playing || this._paused || !this._sprite) return;

            var dir = this.fps < 0 ? -1 : 1;
            var time = this._time + dt * this._component.speed * dir;
            var duration = this.duration;
            var end = (time > duration || time < 0);

            this._setTime(time);

            var frame = this.frame;
            if (this._sprite) {
                frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
            } else {
                frame = 0;
            }

            if (frame !== this._frame) {
                this._setFrame(frame);
            }

            if (end) {
                if (this.loop) {
                    this.fire('loop');
                    this._component.fire('loop', this);
                } else {
                    this._playing = false;
                    this._paused = false;
                    this.fire('end');
                    this._component.fire('end', this);
                }
            }
        },

        _setTime: function (value) {
            this._time = value;
            var duration = this.duration;
            if (this._time < 0) {
                if (this.loop) {
                    this._time = this._time % duration + duration;
                } else {
                    this._time = 0;
                }
            } else if (this._time > duration) {
                if (this.loop) {
                    this._time %= duration;
                } else {
                    this._time = duration;
                }
            }
        },

        _setFrame: function (value) {
            if (this._sprite) {
                // clamp frame
                this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
            } else {
                this._frame = value;
            }

            if (this._component.currentClip === this) {
                this._component._showFrame(this._frame);
            }
        },

        _destroy: function () {
            // remove sprite
            if (this._sprite) {
                this.sprite = null;
            }

            // remove sprite asset
            if (this._spriteAsset) {
                this.spriteAsset = null;
            }
        },

        /**
         * @function
         * @name pc.SpriteAnimationClip#play
         * @description Plays the animation. If it's already playing then this does nothing.
         */
        play: function () {
            if (this._playing)
                return;

            this._playing = true;
            this._paused = false;
            this.frame = 0;

            this.fire('play');
            this._component.fire('play', this);
        },

        /**
         * @function
         * @name pc.SpriteAnimationClip#pause
         * @description Pauses the animation.
         */
        pause: function () {
            if (!this._playing || this._paused)
                return;

            this._paused = true;

            this.fire('pause');
            this._component.fire('pause', this);
        },

        /**
         * @function
         * @name pc.SpriteAnimationClip#resume
         * @description Resumes the paused animation.
         */
        resume: function () {
            if (!this._paused) return;

            this._paused = false;
            this.fire('resume');
            this._component.fire('resume', this);
        },

        /**
         * @function
         * @name pc.SpriteAnimationClip#stop
         * @description Stops the animation and resets the animation to the first frame.
         */
        stop: function () {
            if (!this._playing) return;

            this._playing = false;
            this._paused = false;
            this._time = 0;
            this.frame = 0;

            this.fire('stop');
            this._component.fire('stop', this);
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "spriteAsset", {
        get: function () {
            return this._spriteAsset;
        },
        set: function (value) {
            var assets = this._component.system.app.assets;
            var id = value;

            if (value instanceof Asset) {
                id = value.id;
            }

            if (this._spriteAsset !== id) {
                if (this._spriteAsset) {
                    // clean old event listeners
                    var prev = assets.get(this._spriteAsset);
                    if (prev) {
                        this._unbindSpriteAsset(prev);
                    }
                }

                this._spriteAsset = id;

                // bind sprite asset
                if (this._spriteAsset) {
                    var asset = assets.get(this._spriteAsset);
                    if (!asset) {
                        this.sprite = null;
                        assets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);
                    } else {
                        this._bindSpriteAsset(asset);
                    }
                } else {
                    this.sprite = null;
                }
            }
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "sprite", {
        get: function () {
            return this._sprite;
        },
        set: function (value) {
            if (this._sprite) {
                this._sprite.off('set:meshes', this._onSpriteMeshesChange, this);
                this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
                this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
                if (this._sprite.atlas) {
                    this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
                }
            }

            this._sprite = value;

            if (this._sprite) {
                this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
                this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
                this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);

                if (this._sprite.atlas) {
                    this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
                }
            }

            if (this._component.currentClip === this) {
                var mi;

                // if we are clearing the sprite clear old mesh instance parameters
                if (!value || !value.atlas) {
                    mi = this._component._meshInstance;
                    if (mi) {
                        mi.deleteParameter('texture_emissiveMap');
                        mi.deleteParameter('texture_opacityMap');
                    }

                    this._component._hideModel();
                } else {
                    // otherwise show sprite

                    // update texture
                    if (value.atlas.texture) {
                        mi = this._component._meshInstance;
                        if (mi) {
                            mi.setParameter('texture_emissiveMap', value.atlas.texture);
                            mi.setParameter('texture_opacityMap', value.atlas.texture);
                        }

                        if (this._component.enabled && this._component.entity.enabled) {
                            this._component._showModel();
                        }
                    }

                    // if we have a time then force update
                    // frame based on the time (check if fps is not 0 otherwise time will be Infinity)

                    /* eslint-disable no-self-assign */
                    if (this.time && this.fps) {
                        this.time = this.time;
                    } else {
                        // if we don't have a time
                        // then force update frame counter
                        this.frame = this.frame;
                    }
                    /* eslint-enable no-self-assign */
                }
            }
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "frame", {
        get: function () {
            return this._frame;
        },

        set: function (value) {
            this._setFrame(value);

            // update time to start of frame
            var fps = this.fps || Number.MIN_VALUE;
            this._setTime(this._frame / fps);
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "isPlaying", {
        get: function () {
            return this._playing;
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "isPaused", {
        get: function () {
            return this._paused;
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "duration", {
        get: function () {
            if (this._sprite) {
                var fps = this.fps || Number.MIN_VALUE;
                return this._sprite.frameKeys.length / Math.abs(fps);
            }
            return 0;
        }
    });

    Object.defineProperty(SpriteAnimationClip.prototype, "time", {
        get: function () {
            return this._time;
        },
        set: function (value) {
            this._setTime(value);

            if (this._sprite) {
                this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
            } else {
                this.frame = 0;
            }
        }
    });

    var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
    var PARAM_OPACITY_MAP = 'texture_opacityMap';
    var PARAM_EMISSIVE = 'material_emissive';
    var PARAM_OPACITY = 'material_opacity';
    var PARAM_INNER_OFFSET = 'innerOffset';
    var PARAM_OUTER_SCALE = 'outerScale';
    var PARAM_ATLAS_RECT = 'atlasRect';

    /**
     * @component
     * @class
     * @name pc.SpriteComponent
     * @augments pc.Component
     * @classdesc Enables an Entity to render a simple static sprite or sprite animations.
     * @param {pc.SpriteComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Entity} entity - The Entity that this Component is attached to.
     * @property {string} type The type of the SpriteComponent. Can be:
     *
     * * {@link pc.SPRITETYPE_SIMPLE}: The component renders a single frame from a sprite asset.
     * * {@link pc.SPRITETYPE_ANIMATED}: The component can play sprite animation clips.
     *
     * @property {number} frame The frame counter of the sprite. Specifies which frame from the current sprite asset to render.
     * @property {number} spriteAsset The id of the sprite asset to render. Only works for {@link pc.SPRITETYPE_SIMPLE} types.
     * @property {pc.Sprite} sprite The current sprite.
     * @property {number} width The width of the sprite when rendering using 9-Slicing. The width and height are only used when the render mode of the sprite asset is Sliced or Tiled.
     * @property {number} height The height of the sprite when rendering using 9-Slicing. The width and height are only used when the render mode of the sprite asset is Sliced or Tiled.
     * @property {pc.Color} color The color tint of the sprite.
     * @property {number} opacity The opacity of the sprite.
     * @property {boolean} flipX Flip the X axis when rendering a sprite.
     * @property {boolean} flipY Flip the Y axis when rendering a sprite.
     * @property {object} clips A dictionary that contains {@link pc.SpriteAnimationClip}s.
     * @property {pc.SpriteAnimationClip} currentClip The current clip being played.
     * @property {number} speed A global speed modifier used when playing sprite animation clips.
     * @property {number} batchGroupId Assign sprite to a specific batch group (see {@link pc.BatchGroup}). Default value is -1 (no group).
     * @property {string} autoPlayClip The name of the clip to play automatically when the component is enabled and the clip exists.
     * @property {number[]} layers An array of layer IDs ({@link pc.Layer#id}) to which this sprite should belong.
     * @property {number} drawOrder The draw order of the component. A higher value means that the component will be rendered on top of other components in the same layer.
     */
    var SpriteComponent = function SpriteComponent(system, entity) {
        Component.call(this, system, entity);

        this._type = SPRITETYPE_SIMPLE;
        this._material = system.defaultMaterial;
        this._color = new Color(1, 1, 1, 1);
        this._colorUniform = new Float32Array(3);
        this._speed = 1;
        this._flipX = false;
        this._flipY = false;
        this._width = 1;
        this._height = 1;

        this._drawOrder = 0;
        this._layers = [LAYERID_WORLD]; // assign to the default world layer

        // 9-slicing
        this._outerScale = new Vec2(1, 1);
        this._outerScaleUniform = new Float32Array(2);
        this._innerOffset = new Vec4();
        this._innerOffsetUniform = new Float32Array(4);
        this._atlasRect = new Vec4();
        this._atlasRectUniform = new Float32Array(4);

        // batch groups
        this._batchGroupId = -1;
        this._batchGroup = null;

        // node / meshinstance
        this._node = new GraphNode();
        this._model = new Model();
        this._model.graph = this._node;
        this._meshInstance = null;
        entity.addChild(this._model.graph);
        this._model._entity = entity;
        this._updateAabbFunc = this._updateAabb.bind(this);

        this._addedModel = false;

        // animated sprites
        this._autoPlayClip = null;

        this._clips = {};

        // create default clip for simple sprite type
        this._defaultClip = new SpriteAnimationClip(this, {
            name: this.entity.name,
            fps: 0,
            loop: false,
            spriteAsset: null
        });

        this._currentClip = this._defaultClip;
    };
    SpriteComponent.prototype = Object.create(Component.prototype);
    SpriteComponent.prototype.constructor = SpriteComponent;

    Object.assign(SpriteComponent.prototype, {
        onEnable: function () {
            var app = this.system.app;
            var scene = app.scene;

            scene.on("set:layers", this._onLayersChanged, this);
            if (scene.layers) {
                scene.layers.on("add", this._onLayerAdded, this);
                scene.layers.on("remove", this._onLayerRemoved, this);
            }

            this._showModel();
            if (this._autoPlayClip)
                this._tryAutoPlay();

            if (this._batchGroupId >= 0) {
                app.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
            }
        },

        onDisable: function () {
            var app = this.system.app;
            var scene = app.scene;

            scene.off("set:layers", this._onLayersChanged, this);
            if (scene.layers) {
                scene.layers.off("add", this._onLayerAdded, this);
                scene.layers.off("remove", this._onLayerRemoved, this);
            }

            this.stop();
            this._hideModel();


            if (this._batchGroupId >= 0) {
                app.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
            }
        },

        onDestroy: function () {
            this._currentClip = null;

            if (this._defaultClip) {
                this._defaultClip._destroy();
                this._defaultClip = null;
            }
            for (var key in this._clips) {
                this._clips[key]._destroy();
            }
            this._clips = null;

            this._hideModel();
            this._model = null;

            if (this._node) {
                if (this._node.parent)
                    this._node.parent.removeChild(this._node);
                this._node = null;
            }

            if (this._meshInstance) {
                // make sure we decrease the ref counts materials and meshes
                this._meshInstance.material = null;
                this._meshInstance.mesh = null;
                this._meshInstance = null;
            }
        },

        _showModel: function () {
            if (this._addedModel) return;
            if (!this._meshInstance) return;

            var i;
            var len;

            var meshInstances = [this._meshInstance];

            for (i = 0, len = this._layers.length; i < len; i++) {
                var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
                if (layer) {
                    layer.addMeshInstances(meshInstances);
                }
            }

            this._addedModel = true;
        },

        _hideModel: function () {
            if (!this._addedModel || !this._meshInstance) return;

            var i;
            var len;

            var meshInstances = [this._meshInstance];

            for (i = 0, len = this._layers.length; i < len; i++) {
                var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
                if (layer) {
                    layer.removeMeshInstances(meshInstances);
                }
            }

            this._addedModel = false;
        },

        // Set the desired mesh on the mesh instance
        _showFrame: function (frame) {
            if (!this.sprite) return;

            var mesh = this.sprite.meshes[frame];
            // if mesh is null then hide the mesh instance
            if (!mesh) {
                if (this._meshInstance) {
                    this._meshInstance.mesh = null;
                    this._meshInstance.visible = false;
                }

                return;
            }

            var material;
            if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
                material = this.system.default9SlicedMaterialSlicedMode;
            } else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
                material = this.system.default9SlicedMaterialTiledMode;
            } else {
                material = this.system.defaultMaterial;
            }

            // create mesh instance if it doesn't exist yet
            if (!this._meshInstance) {
                this._meshInstance = new MeshInstance(this._node, mesh, this._material);
                this._meshInstance.castShadow = false;
                this._meshInstance.receiveShadow = false;
                this._meshInstance.drawOrder = this._drawOrder;
                this._model.meshInstances.push(this._meshInstance);

                // set overrides on mesh instance
                this._colorUniform[0] = this._color.r;
                this._colorUniform[1] = this._color.g;
                this._colorUniform[2] = this._color.b;
                this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
                this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);

                // now that we created the mesh instance, add the model to the scene
                if (this.enabled && this.entity.enabled) {
                    this._showModel();
                }
            }

            // update material
            if (this._meshInstance.material !== material) {
                this._meshInstance.material = material;
            }

            // update mesh
            if (this._meshInstance.mesh !== mesh) {
                this._meshInstance.mesh = mesh;
                this._meshInstance.visible = true;
                // reset aabb
                this._meshInstance._aabbVer = -1;
            }

            // set texture params
            if (this.sprite.atlas && this.sprite.atlas.texture) {
                this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
                this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
            } else {
                // no texture so reset texture params
                this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
                this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
            }

            // for 9-sliced
            if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
                // set custom aabb function
                this._meshInstance._updateAabbFunc = this._updateAabbFunc;

                // calculate inner offset
                var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
                if (frameData) {
                    var borderWidthScale = 2 / frameData.rect.z;
                    var borderHeightScale = 2 / frameData.rect.w;

                    this._innerOffset.set(
                        frameData.border.x * borderWidthScale,
                        frameData.border.y * borderHeightScale,
                        frameData.border.z * borderWidthScale,
                        frameData.border.w * borderHeightScale
                    );

                    var tex = this.sprite.atlas.texture;
                    this._atlasRect.set(frameData.rect.x / tex.width,
                                        frameData.rect.y / tex.height,
                                        frameData.rect.z / tex.width,
                                        frameData.rect.w / tex.height
                    );

                } else {
                    this._innerOffset.set(0, 0, 0, 0);
                }

                // set inner offset and atlas rect on mesh instance
                this._innerOffsetUniform[0] = this._innerOffset.x;
                this._innerOffsetUniform[1] = this._innerOffset.y;
                this._innerOffsetUniform[2] = this._innerOffset.z;
                this._innerOffsetUniform[3] = this._innerOffset.w;
                this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
                this._atlasRectUniform[0] = this._atlasRect.x;
                this._atlasRectUniform[1] = this._atlasRect.y;
                this._atlasRectUniform[2] = this._atlasRect.z;
                this._atlasRectUniform[3] = this._atlasRect.w;
                this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
            } else {
                this._meshInstance._updateAabbFunc = null;
            }

            this._updateTransform();
        },

        _updateTransform: function () {
            // flip
            var scaleX = this.flipX ? -1 : 1;
            var scaleY = this.flipY ? -1 : 1;

            // pivot
            var posX = 0;
            var posY = 0;

            if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {

                var w = 1;
                var h = 1;

                if (this.sprite.atlas) {
                    var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
                    if (frameData) {
                        // get frame dimensions
                        w = frameData.rect.z;
                        h = frameData.rect.w;

                        // update pivot
                        posX = (0.5 - frameData.pivot.x) * this._width;
                        posY = (0.5 - frameData.pivot.y) * this._height;
                    }
                }

                // scale: apply PPU
                var scaleMulX = w / this.sprite.pixelsPerUnit;
                var scaleMulY = h / this.sprite.pixelsPerUnit;

                // scale borders if necessary instead of overlapping
                this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));

                scaleX *= scaleMulX;
                scaleY *= scaleMulY;

                this._outerScale.x /= scaleMulX;
                this._outerScale.y /= scaleMulY;

                // scale: shrinking below 1
                scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
                scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);

                // update outer scale
                if (this._meshInstance) {
                    // use outerScale in ALL passes (depth, picker, etc) so the shape is correct
                    this._outerScaleUniform[0] = this._outerScale.x;
                    this._outerScaleUniform[1] = this._outerScale.y;
                    this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform, 0xFFFFFFFF);
                }
            }

            // scale
            this._node.setLocalScale(scaleX, scaleY, 1);
            // pivot
            this._node.setLocalPosition(posX, posY, 0);
        },

        // updates AABB while 9-slicing
        _updateAabb: function (aabb) {
            // pivot
            aabb.center.set(0, 0, 0);
            // size
            aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
            // world transform
            aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
            return aabb;
        },

        _tryAutoPlay: function () {
            if (!this._autoPlayClip) return;
            if (this.type !== SPRITETYPE_ANIMATED) return;

            var clip = this._clips[this._autoPlayClip];
            // if the clip exists and nothing else is playing play it
            if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
                if (this.enabled && this.entity.enabled) {
                    this.play(clip.name);
                }
            }
        },

        _onLayersChanged: function (oldComp, newComp) {
            oldComp.off("add", this.onLayerAdded, this);
            oldComp.off("remove", this.onLayerRemoved, this);
            newComp.on("add", this.onLayerAdded, this);
            newComp.on("remove", this.onLayerRemoved, this);

            if (this.enabled && this.entity.enabled) {
                this._showModel();
            }
        },

        _onLayerAdded: function (layer) {
            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;

            if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
                layer.addMeshInstances([this._meshInstance]);
            }
        },

        _onLayerRemoved: function (layer) {
            if (!this._meshInstance) return;

            var index = this.layers.indexOf(layer.id);
            if (index < 0) return;
            layer.removeMeshInstances([this._meshInstance]);
        },

        removeModelFromLayers: function () {
            var layer;
            for (var i = 0; i < this.layers.length; i++) {
                layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
                if (!layer) continue;
                layer.removeMeshInstances([this._meshInstance]);
            }
        },

        /**
         * @function
         * @name pc.SpriteComponent#addClip
         * @description Creates and adds a new {@link pc.SpriteAnimationClip} to the component's clips.
         * @param {object} data - Data for the new animation clip.
         * @param {string} [data.name] - The name of the new animation clip.
         * @param {number} [data.fps] - Frames per second for the animation clip.
         * @param {object} [data.loop] - Whether to loop the animation clip.
         * @param {number} [data.spriteAsset] - The id of the sprite asset that this clip will play.
         * @returns {pc.SpriteAnimationClip} The new clip that was added.
         */
        addClip: function (data) {
            var clip = new SpriteAnimationClip(this, {
                name: data.name,
                fps: data.fps,
                loop: data.loop,
                spriteAsset: data.spriteAsset
            });

            this._clips[data.name] = clip;

            if (clip.name && clip.name === this._autoPlayClip)
                this._tryAutoPlay();

            return clip;
        },

        /**
         * @function
         * @name pc.SpriteComponent#removeClip
         * @description Removes a clip by name.
         * @param {string} name - The name of the animation clip to remove.
         */
        removeClip: function (name) {
            delete this._clips[name];
        },

        /**
         * @function
         * @name pc.SpriteComponent#clip
         * @description Get an animation clip by name.
         * @param {string} name - The name of the clip.
         * @returns {pc.SpriteAnimationClip} The clip.
         */
        clip: function (name) {
            return this._clips[name];
        },

        /**
         * @function
         * @name pc.SpriteComponent#play
         * @description Plays a sprite animation clip by name. If the animation clip is already playing then this will do nothing.
         * @param {string} name - The name of the clip to play.
         * @returns {pc.SpriteAnimationClip} The clip that started playing.
         */
        play: function (name) {
            var clip = this._clips[name];

            var current = this._currentClip;
            if (current && current !== clip) {
                current._playing = false;
            }

            this._currentClip = clip;

            if (this._currentClip) {
                this._currentClip = clip;
                this._currentClip.play();
            }

            return clip;
        },

        /**
         * @function
         * @name pc.SpriteComponent#pause
         * @description Pauses the current animation clip.
         */
        pause: function () {
            if (this._currentClip === this._defaultClip) return;

            if (this._currentClip.isPlaying) {
                this._currentClip.pause();
            }
        },

        /**
         * @function
         * @name pc.SpriteComponent#resume
         * @description Resumes the current paused animation clip.
         */
        resume: function () {
            if (this._currentClip === this._defaultClip) return;

            if (this._currentClip.isPaused) {
                this._currentClip.resume();
            }
        },

        /**
         * @function
         * @name pc.SpriteComponent#stop
         * @description Stops the current animation clip and resets it to the first frame.
         */
        stop: function () {
            if (this._currentClip === this._defaultClip) return;

            this._currentClip.stop();
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "type", {
        get: function () {
            return this._type;
        },

        set: function (value) {
            if (this._type === value)
                return;

            this._type = value;
            if (this._type === SPRITETYPE_SIMPLE) {
                this.stop();
                this._currentClip = this._defaultClip;

                if (this.enabled && this.entity.enabled) {
                    this._currentClip.frame = this.frame;

                    if (this._currentClip.sprite) {
                        this._showModel();
                    } else {
                        this._hideModel();
                    }
                }

            } else if (this._type === SPRITETYPE_ANIMATED) {
                this.stop();

                if (this._autoPlayClip) {
                    this._tryAutoPlay();
                }

                if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
                    this._showModel();
                } else {
                    this._hideModel();
                }
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "frame", {
        get: function () {
            return this._currentClip.frame;
        },

        set: function (value) {
            this._currentClip.frame = value;
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "spriteAsset", {
        get: function () {
            return this._defaultClip._spriteAsset;
        },
        set: function (value) {
            this._defaultClip.spriteAsset = value;
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "sprite", {
        get: function () {
            return this._currentClip.sprite;
        },
        set: function (value) {
            this._currentClip.sprite = value;
        }
    });

    // (private) {pc.Material} material The material used to render a sprite.
    Object.defineProperty(SpriteComponent.prototype, "material", {
        get: function () {
            return this._material;
        },
        set: function (value) {
            this._material = value;
            if (this._meshInstance) {
                this._meshInstance.material = value;
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color.r = value.r;
            this._color.g = value.g;
            this._color.b = value.b;

            if (this._meshInstance) {
                this._colorUniform[0] = this._color.r;
                this._colorUniform[1] = this._color.g;
                this._colorUniform[2] = this._color.b;
                this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "opacity", {
        get: function () {
            return this._color.a;
        },
        set: function (value) {
            this._color.a = value;
            if (this._meshInstance) {
                this._meshInstance.setParameter(PARAM_OPACITY, value);
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "clips", {
        get: function () {
            return this._clips;
        },
        set: function (value) {
            var name, key;

            // if value is null remove all clips
            if (!value) {
                for (name in this._clips) {
                    this.removeClip(name);
                }
                return;
            }

            // remove existing clips not in new value
            // and update clips in both objects
            for (name in this._clips) {
                var found = false;
                for (key in value) {
                    if (value[key].name === name) {
                        found = true;
                        this._clips[name].fps = value[key].fps;
                        this._clips[name].loop = value[key].loop;

                        if (value[key].hasOwnProperty('sprite')) {
                            this._clips[name].sprite = value[key].sprite;
                        } else if (value[key].hasOwnProperty('spriteAsset')) {
                            this._clips[name].spriteAsset = value[key].spriteAsset;
                        }

                        break;
                    }
                }

                if (!found) {
                    this.removeClip(name);
                }
            }

            // add clips that do not exist
            for (key in value) {
                if (this._clips[value[key].name]) continue;

                this.addClip(value[key]);
            }

            // auto play clip
            if (this._autoPlayClip) {
                this._tryAutoPlay();
            }

            // if the current clip doesn't have a sprite then hide the model
            if (!this._currentClip || !this._currentClip.sprite) {
                this._hideModel();
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "currentClip", {
        get: function () {
            return this._currentClip;
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "speed", {
        get: function () {
            return this._speed;
        },
        set: function (value) {
            this._speed = value;
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "flipX", {
        get: function () {
            return this._flipX;
        },
        set: function (value) {
            if (this._flipX === value) return;

            this._flipX = value;
            this._updateTransform();
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "flipY", {
        get: function () {
            return this._flipY;
        },
        set: function (value) {
            if (this._flipY === value) return;

            this._flipY = value;
            this._updateTransform();
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (value === this._width) return;

            this._width = value;
            this._outerScale.x = this._width;

            if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
                this._updateTransform();
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (value === this._height) return;

            this._height = value;
            this._outerScale.y = this.height;

            if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
                this._updateTransform();
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "batchGroupId", {
        get: function () {
            return this._batchGroupId;
        },
        set: function (value) {
            if (this._batchGroupId === value)
                return;

            var prev = this._batchGroupId;
            this._batchGroupId = value;

            if (this.entity.enabled && prev >= 0) {
                this.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);
            }
            if (this.entity.enabled && value >= 0) {
                this.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);
            } else {
                // re-add model to scene in case it was removed by batching
                if (prev >= 0) {
                    if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
                        this._showModel();
                    }
                }
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "autoPlayClip", {
        get: function () {
            return this._autoPlayClip;
        },
        set: function (value) {
            this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
            this._tryAutoPlay();
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "drawOrder", {
        get: function () {
            return this._drawOrder;
        },
        set: function (value) {
            this._drawOrder = value;
            if (this._meshInstance) {
                this._meshInstance.drawOrder = value;
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "layers", {
        get: function () {
            return this._layers;
        },
        set: function (value) {
            if (this._addedModel) {
                this._hideModel();
            }

            this._layers = value;

            // early out
            if (!this._meshInstance) {
                return;
            }

            if (this.enabled && this.entity.enabled) {
                this._showModel();
            }
        }
    });

    Object.defineProperty(SpriteComponent.prototype, "aabb", {
        get: function () {
            if (this._meshInstance) {
                return this._meshInstance.aabb;
            }

            return null;
        }
    });

    function SpriteComponentData() {
        this.enabled = true;
    }

    var _schema$i = ['enabled'];

    /**
     * @class
     * @name pc.SpriteComponentSystem
     * @augments pc.ComponentSystem
     * @classdesc Manages creation of {@link pc.SpriteComponent}s.
     * @param {pc.Application} app - The application.
     */
    function SpriteComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'sprite';

        this.ComponentType = SpriteComponent;
        this.DataType = SpriteComponentData;

        this.schema = _schema$i;

        // default texture - make white so we can tint it with emissive color
        this._defaultTexture = null;

        // default material used by sprites
        this._defaultMaterial = null;

        // material used for 9-slicing in sliced mode
        this._default9SlicedMaterialSlicedMode = null;

        // material used for 9-slicing in tiled mode
        this._default9SlicedMaterialTiledMode = null;

        ComponentSystem.bind('update', this.onUpdate, this);
        this.on('beforeremove', this.onBeforeRemove, this);
    }
    SpriteComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    SpriteComponentSystem.prototype.constructor = SpriteComponentSystem;

    Component._buildAccessors(SpriteComponent.prototype, _schema$i);

    Object.defineProperties(SpriteComponentSystem.prototype, {
        defaultMaterial: {
            get: function () {
                if (!this._defaultMaterial) {
                    var texture = new Texture(this.app.graphicsDevice, {
                        width: 1,
                        height: 1,
                        format: PIXELFORMAT_R8_G8_B8_A8
                    });
                    var pixels = new Uint8Array(texture.lock());
                    pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
                    texture.name = 'sprite';
                    texture.unlock();

                    var material = new StandardMaterial();
                    material.diffuse.set(0, 0, 0); // black diffuse color to prevent ambient light being included
                    material.emissive.set(0.5, 0.5, 0.5); // use non-white to compile shader correctly
                    material.emissiveMap = texture;
                    material.emissiveMapTint = true;
                    material.opacityMap = texture;
                    material.opacityMapChannel = "a";
                    material.opacityTint = true;
                    material.opacity = 0; // use non-1 opacity to compile shader correctly
                    material.useLighting = false;
                    material.useGammaTonemap = false;
                    material.useFog = false;
                    material.useSkybox = false;
                    material.blendType = BLEND_PREMULTIPLIED;
                    material.depthWrite = false;
                    material.pixelSnap = false;
                    material.cull = CULLFACE_NONE; // don't cull because we might flipX or flipY which uses negative scale on the graph node
                    material.update();

                    this._defaultTexture = texture;
                    this._defaultMaterial = material;
                }
                return this._defaultMaterial;
            },
            set: function (material) {
                this._defaultMaterial = material;
            }
        },
        default9SlicedMaterialSlicedMode: {
            get: function () {
                if (!this._default9SlicedMaterialSlicedMode) {
                    var material = this.defaultMaterial.clone();
                    material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
                    material.update();

                    this._default9SlicedMaterialSlicedMode = material;
                }
                return this._default9SlicedMaterialSlicedMode;
            },
            set: function (material) {
                this._default9SlicedMaterialSlicedMode = material;
            }
        },
        default9SlicedMaterialTiledMode: {
            get: function () {
                if (!this._default9SlicedMaterialTiledMode) {
                    var material = this.defaultMaterial.clone();
                    material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
                    material.update();

                    this._default9SlicedMaterialTiledMode = material;
                }
                return this._default9SlicedMaterialTiledMode;
            },
            set: function (material) {
                this._default9SlicedMaterialTiledMode = material;
            }
        }
    });

    Object.assign(SpriteComponentSystem.prototype, {
        destroy: function () {
            if (this._defaultTexture) {
                this._defaultTexture.destroy();
                this._defaultTexture = null;
            }
        },

        initializeComponentData: function (component, data, properties) {
            if (data.enabled !== undefined) {
                component.enabled = data.enabled;
            }

            component.type = data.type;

            if (data.layers && type(data.layers) === 'array') {
                component.layers = data.layers.slice(0);
            }

            if (data.drawOrder !== undefined) {
                component.drawOrder = data.drawOrder;
            }

            if (data.color !== undefined) {
                if (data.color instanceof Color) {
                    component.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);
                } else {
                    component.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);
                }

                /* eslint-disable no-self-assign */
                // force update
                component.color = component.color;
                /* eslint-enable no-self-assign */
            }

            if (data.opacity !== undefined) {
                component.opacity = data.opacity;
            }

            if (data.flipX !== undefined) {
                component.flipX = data.flipX;
            }

            if (data.flipY !== undefined) {
                component.flipY = data.flipY;
            }

            if (data.width !== undefined) {
                component.width = data.width;
            }

            if (data.height !== undefined) {
                component.height = data.height;
            }

            if (data.spriteAsset !== undefined) {
                component.spriteAsset = data.spriteAsset;
            }

            if (data.sprite) {
                component.sprite = data.sprite;
            }

            if (data.frame !== undefined) {
                component.frame = data.frame;
            }

            if (data.clips) {
                for (var name in data.clips) {
                    component.addClip(data.clips[name]);
                }
            }

            if (data.speed !== undefined)  {
                component.speed = data.speed;
            }

            if (data.autoPlayClip) {
                component.autoPlayClip = data.autoPlayClip;
            }

            component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;

            ComponentSystem.prototype.initializeComponentData.call(this, component, data, properties);
        },

        cloneComponent: function (entity, clone) {
            var source = entity.sprite;

            return this.addComponent(clone, {
                enabled: source.enabled,
                type: source.type,
                spriteAsset: source.spriteAsset,
                sprite: source.sprite,
                frame: source.frame,
                color: source.color.clone(),
                opacity: source.opacity,
                flipX: source.flipX,
                flipY: source.flipY,
                speed: source.speed,
                clips: source.clips,
                autoPlayClip: source.autoPlayClip,
                batchGroupId: source.batchGroupId,
                drawOrder: source.drawOrder,
                layers: source.layers.slice(0)
            });
        },

        onUpdate: function (dt) {
            var components = this.store;

            for (var id in components) {
                if (components.hasOwnProperty(id)) {
                    var component = components[id];
                    // if sprite component is enabled advance its current clip
                    if (component.data.enabled && component.entity.enabled) {
                        var sprite = component.entity.sprite;
                        if (sprite._currentClip) {
                            sprite._currentClip._update(dt);
                        }
                    }
                }
            }
        },

        onBeforeRemove: function (entity, component) {
            component.onDestroy();
        }
    });

    /**
     * @private
     * @component
     * @class
     * @name pc.ZoneComponent
     * @augments pc.Component
     * @classdesc The ZoneComponent allows you to define an area in world space of certain size.
     * This can be used in various ways, such as affecting audio reverb when audiolistener is within zone.
     * Or create culling system with portals between zones to hide whole indoor sections for performance reasons.
     * And many other possible options. Zones are building blocks and meant to be used in many different ways.
     * @param {pc.ZoneComponentSystem} system - The ComponentSystem that created this Component.
     * @param {pc.Vec3} size - The Size of Box of a Zone.
     */

    function ZoneComponent(system, entity) {
        Component.call(this, system, entity);

        this._oldState = true;
        this._size = new Vec3();
        this.on('set_enabled', this._onSetEnabled, this);
    }
    ZoneComponent.prototype = Object.create(Component.prototype);
    ZoneComponent.prototype.constructor = ZoneComponent;

    /**
     * @private
     * @event
     * @name pc.ZoneComponent#enable
     * @description Fired when Component becomes enabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @example
     * entity.zone.on('enable', function () {
     *     // component is enabled
     * });
     */

    /**
     * @private
     * @event
     * @name pc.ZoneComponent#disable
     * @description Fired when Component becomes disabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @example
     * entity.zone.on('disable', function () {
     *     // component is disabled
     * });
     */

    /**
     * @private
     * @event
     * @name pc.ZoneComponent#state
     * @description Fired when Component changes state to enabled or disabled
     * Note: this event does not take in account entity or any of its parent enabled state.
     * @param {boolean} enabled - True if now enabled, False if disabled.
     * @example
     * entity.zone.on('state', function (enabled) {
     *     // component changed state
     * });
     */

    /**
     * @private
     * @event
     * @name pc.ZoneComponent#remove
     * @description Fired when a zone is removed from an entity.
     * @example
     * entity.zone.on('remove', function () {
     *     // zone has been removed from an entity
     * });
     */

    Object.assign(ZoneComponent.prototype, {
        onEnable: function () {
            this._checkState();
        },

        onDisable: function () {
            this._checkState();
        },

        _onSetEnabled: function (prop, old, value) {
            this._checkState();
        },

        _checkState: function () {
            var state = this.enabled && this.entity.enabled;
            if (state === this._oldState)
                return;

            this._oldState = state;

            this.fire('enable');
            this.fire('state', this.enabled);
        },

        _onBeforeRemove: function () {
            this.fire('remove');
        }
    });

    Object.defineProperty(ZoneComponent.prototype, 'size', {
        set: function (data) {
            if (data instanceof Vec3) {
                this._size.copy(data);
            } else if (data instanceof Array && data.length >= 3) {
                this.size.set(data[0], data[1], data[2]);
            }
        },
        get: function () {
            return this._size;
        }
    });

    function ZoneComponentData() {
        this.enabled = true;
    }

    var _schema$j = ['enabled'];

    /**
     * @private
     * @class
     * @name pc.ZoneComponentSystem
     * @classdesc Defines zone in world.
     * @description Create a new ZoneComponentSystem.
     * @param {pc.Application} app - The application.
     * @augments pc.ComponentSystem
     */
    var ZoneComponentSystem = function ZoneComponentSystem(app) {
        ComponentSystem.call(this, app);

        this.id = 'zone';

        this.ComponentType = ZoneComponent;
        this.DataType = ZoneComponentData;

        this.schema = _schema$j;

        this.on('beforeremove', this._onBeforeRemove, this);
    };
    ZoneComponentSystem.prototype = Object.create(ComponentSystem.prototype);
    ZoneComponentSystem.prototype.constructor = ZoneComponentSystem;

    Component._buildAccessors(ZoneComponent.prototype, _schema$j);

    Object.assign(ZoneComponentSystem.prototype, {
        initializeComponentData: function (component, data, properties) {
            component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;

            if (data.size) {
                if (data.size instanceof Vec3) {
                    component.size.copy(data.size);
                } else if (data.size instanceof Array && data.size.length >= 3) {
                    component.size.set(data.size[0], data.size[1], data.size[2]);
                }
            }
        },

        cloneComponent: function (entity, clone) {
            var data = {
                size: entity.zone.size
            };

            return this.addComponent(clone, data);
        },

        _onBeforeRemove: function (entity, component) {
            component._onBeforeRemove();
        }
    });

    /**
     * @private
     * @class
     * @name pc.ApplicationStats
     * @param {pc.GraphicsDevice} device - The graphics device.
     */
    function ApplicationStats(device) {
        this.frame = {
            fps: 0,
            ms: 0,
            dt: 0,

            updateStart: 0,
            updateTime: 0,
            renderStart: 0,
            renderTime: 0,
            physicsStart: 0,
            physicsTime: 0,
            cullTime: 0,
            sortTime: 0,
            skinTime: 0,
            morphTime: 0,
            instancingTime: 0, // deprecated

            triangles: 0,
            otherPrimitives: 0,
            shaders: 0,
            materials: 0,
            cameras: 0,
            shadowMapUpdates: 0,
            shadowMapTime: 0,
            depthMapTime: 0, // deprecated
            forwardTime: 0,

            _timeToCountFrames: 0,
            _fpsAccum: 0
        };

        this.drawCalls = {
            forward: 0,
            depth: 0, // deprecated
            shadow: 0,
            immediate: 0, // deprecated
            misc: 0, // everything that is not forward/depth/shadow (post effect quads etc)
            total: 0, // total = forward + depth + shadow + misc

            // Some of forward/depth/shadow/misc draw calls:
            skinned: 0,
            instanced: 0, // deprecated

            removedByInstancing: 0 // deprecated
        };

        this.misc = {
            renderTargetCreationTime: 0
        };

        this.particles = {
            updatesPerFrame: 0, _updatesPerFrame: 0,
            frameTime: 0, _frameTime: 0
        };

        this.vram = device._vram;
        this.shaders = device._shaderStats;

        Object.defineProperty(this.vram, 'totalUsed', {
            get: function () {
                return this.tex + this.vb + this.ib;
            }
        });

        Object.defineProperty(this, 'scene', {
            get: function () {
                return Application._currentApplication.scene._stats;
            }
        });

        Object.defineProperty(this, 'lightmapper', {
            get: function () {
                return Application._currentApplication.lightmapper._stats;
            }
        });

        Object.defineProperty(this, 'batcher', {
            get: function () {
                return Application._currentApplication.batcher._stats;
            }
        });
    }

    /**
     * @class
     * @name pc.SceneRegistryItem
     * @description Item to be stored in the {@link pc.SceneRegistry}.
     * @param {string} name - The name of the scene.
     * @param {string} url - The url of the scene file.
     * @property {string} name - The name of the scene.
     * @property {string} url - The url of the scene file.
     */
    function SceneRegistryItem(name, url) {
        this.name = name;
        this.url = url;
    }

    /**
     * @class
     * @name pc.SceneRegistry
     * @description Container for storing the name and url for scene files.
     * @param {pc.Application} app - The application.
     */
    function SceneRegistry(app) {
        this._app = app;
        this._list = [];
        this._index = {};
        this._urlIndex = {};
    }

    SceneRegistry.prototype.destroy = function () {
        this._app = null;
    };

    /**
     * @function
     * @name pc.SceneRegistry#list
     * @description Return the list of scene.
     * @returns {pc.SceneRegistryItem[]} All items in the registry.
     */
    SceneRegistry.prototype.list = function () {
        return this._list;
    };

    /**
     * @function
     * @name  pc.SceneRegistry#add
     * @description  Add a new item to the scene registry.
     * @param {string} name - The name of the scene.
     * @param {string} url -  The url of the scene file.
     * @returns {boolean} Returns true if the scene was successfully added to the registry, false otherwise.
     */
    SceneRegistry.prototype.add = function (name, url) {
        if (this._index.hasOwnProperty(name)) {
            return false;
        }

        var item = new SceneRegistryItem(name, url);

        var i = this._list.push(item);
        this._index[item.name] = i - 1;
        this._urlIndex[item.url] = i - 1;

        return true;
    };

    /**
     * @function
     * @name  pc.SceneRegistry#find
     * @description  Find a Scene by name and return the {@link pc.SceneRegistryItem}.
     * @param  {string} name - The name of the scene.
     * @returns {pc.SceneRegistryItem} The stored data about a scene.
     */
    SceneRegistry.prototype.find = function (name) {
        if (this._index.hasOwnProperty(name)) {
            return this._list[this._index[name]];
        }
        return null;

    };

    /**
     * @function
     * @name  pc.SceneRegistry#findByUrl
     * @description  Find a scene by the URL and return the {@link pc.SceneRegistryItem}.
     * @param  {string} url - The URL to search by.
     * @returns {pc.SceneRegistryItem} The stored data about a scene.
     */
    SceneRegistry.prototype.findByUrl = function (url) {
        if (this._urlIndex.hasOwnProperty(url)) {
            return this._list[this._urlIndex[url]];
        }
        return null;
    };

    /**
     * @function
     * @name  pc.SceneRegistry#remove
     * @description  Remove an item from the scene registry.
     * @param  {string} name - The name of the scene.
     */
    SceneRegistry.prototype.remove = function (name) {
        if (this._index.hasOwnProperty(name)) {
            var i = this._index[name];
            var item = this._list[i];

            delete this._urlIndex[item.url];
            // remove from index
            delete this._index[name];

            // remove from list
            this._list.splice(i, 1);

            // refresh index
            for (i = 0; i < this._list.length; i++) {
                item = this._list[i];
                this._index[item.name] = i;
                this._urlIndex[item.url] = i;
            }
        }
    };


    /**
     * @function
     * @name pc.SceneRegistry#loadSceneHierarchy
     * @description Load a scene file, create and initialize the Entity hierarchy
     * and add the hierarchy to the application root Entity.
     * @param {string} url - The URL of the scene file. Usually this will be "scene_id.json".
     * @param {pc.callbacks.LoadHierarchy} callback - The function to call after loading,
     * passed (err, entity) where err is null if no errors occurred.
     * @example
     *
     * var url = app.scenes.getSceneUrl("Scene Name");
     * app.scenes.loadSceneHierarchy(url, function (err, entity) {
     *     if (!err) {
     *         var e = app.root.find("My New Entity");
     *     } else {
     *         // error
     *     }
     * });
     */
    SceneRegistry.prototype.loadSceneHierarchy = function (url, callback) {
        var self = this;

        // Because we need to load scripts before we instance the hierarchy (i.e. before we create script components)
        // Split loading into load and open
        var handler = this._app.loader.getHandler("hierarchy");

        // include asset prefix if present
        if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
            url = path.join(this._app.assets.prefix, url);
        }

        handler.load(url, function (err, data) {
            if (err) {
                if (callback) callback(err);
                return;
            }

            // called after scripts are preloaded
            var _loaded = function () {
                self._app.systems.script.preloading = true;
                var entity = handler.open(url, data);
                self._app.systems.script.preloading = false;

                // clear from cache because this data is modified by entity operations (e.g. destroy)
                self._app.loader.clearCache(url, "hierarchy");

                // add to hierarchy
                self._app.root.addChild(entity);

                // initialize components
                ComponentSystem.initialize(entity);
                ComponentSystem.postInitialize(entity);

                if (callback) callback(err, entity);
            };

            // load priority and referenced scripts before opening scene
            self._app._preloadScripts(data, _loaded);
        });
    };

    /**
     * @function
     * @name pc.SceneRegistry#loadSceneSettings
     * @description Load a scene file and apply the scene settings to the current scene.
     * @param {string} url - The URL of the scene file. This can be looked up using app.getSceneUrl.
     * @param {pc.callbacks.LoadSettings} callback - The function called after the settings
     * are applied. Passed (err) where err is null if no error occurred.
     * @example
     *
     * var url = app.getSceneUrl("Scene Name");
     * app.loadSceneSettings(url, function (err) {
     *     if (!err) {
     *       // success
     *     } else {
     *       // error
     *     }
     * });
     */
    SceneRegistry.prototype.loadSceneSettings = function (url, callback) {
        var self = this;

        // include asset prefix if present
        if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
            url = path.join(this._app.assets.prefix, url);
        }

        this._app.loader.load(url, "scenesettings", function (err, settings) {
            if (!err) {
                self._app.applySceneSettings(settings);
                if (callback) {
                    callback(null);
                }

            } else {
                if (callback) {
                    callback(err);
                }
            }
        });
    };

    /**
     * @function
     * @name  pc.SceneRegistry#loadScene
     * @description Load the scene hierarchy and scene settings. This is an internal method used
     * by the pc.Application.
     * @param {string} url - The URL of the scene file.
     * @param {pc.callbacks.LoadScene} callback - The function called after the settings are
     * applied. Passed (err, scene) where err is null if no error occurred and scene is the
     * {@link pc.Scene}.
     */
    SceneRegistry.prototype.loadScene =  function (url, callback) {
        var self = this;

        var handler = this._app.loader.getHandler("scene");

        // include asset prefix if present
        if (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {
            url = path.join(this._app.assets.prefix, url);
        }

        handler.load(url, function (err, data) {
            if (!err) {
                var _loaded = function () {
                    // parse and create scene
                    self._app.systems.script.preloading = true;
                    var scene = handler.open(url, data);
                    self._app.systems.script.preloading = false;

                    // clear scene from cache because we'll destroy it when we load another one
                    // so data will be invalid
                    self._app.loader.clearCache(url, "scene");

                    self._app.loader.patch({
                        resource: scene,
                        type: "scene"
                    }, self._app.assets);

                    self._app.root.addChild(scene.root);

                    // Initialise pack settings
                    if (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {
                        self._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
                    }

                    if (callback) {
                        callback(null, scene);
                    }
                };

                // preload scripts before opening scene
                self._app._preloadScripts(data, _loaded);
            } else {
                if (callback) {
                    callback(err);
                }
            }
        });
    };

    var _deprecationWarning = false;
    var tempGraphNode = new GraphNode();

    /**
     * @class
     * @name pc.Application
     * @augments pc.EventHandler
     * @classdesc A pc.Application represents and manages your PlayCanvas application.
     * If you are developing using the PlayCanvas Editor, the pc.Application is created
     * for you. You can access your pc.Application instance in your scripts. Below is a
     * skeleton script which shows how you can access the application 'app' property inside
     * the initialize and update functions:
     *
     * ```javascript
     * // Editor example: accessing the pc.Application from a script
     * var MyScript = pc.createScript('myScript');
     *
     * MyScript.prototype.initialize = function() {
     *     // Every script instance has a property 'this.app' accessible in the initialize...
     *     var app = this.app;
     * };
     *
     * MyScript.prototype.update = function(dt) {
     *     // ...and update functions.
     *     var app = this.app;
     * };
     * ```
     *
     * If you are using the Engine without the Editor, you have to create the application
     * instance manually.
     * @description Create a new Application.
     * @param {Element} canvas - The canvas element.
     * @param {object} options
     * @param {pc.ElementInput} [options.elementInput] - Input handler for {@link pc.ElementComponent}s.
     * @param {pc.Keyboard} [options.keyboard] - Keyboard handler for input.
     * @param {pc.Mouse} [options.mouse] - Mouse handler for input.
     * @param {pc.TouchDevice} [options.touch] - TouchDevice handler for input.
     * @param {pc.GamePads} [options.gamepads] - Gamepad handler for input.
     * @param {string} [options.scriptPrefix] - Prefix to apply to script urls before loading.
     * @param {string} [options.assetPrefix] - Prefix to apply to asset urls before loading.
     * @param {object} [options.graphicsDeviceOptions] - Options object that is passed into the {@link pc.GraphicsDevice} constructor.
     * @param {string[]} [options.scriptsOrder] - Scripts in order of loading first.
     * @example
     * // Engine-only example: create the application manually
     * var app = new pc.Application(canvas, options);
     *
     * // Start the application's main loop
     * app.start();
     */

    // PROPERTIES

    /**
     * @name pc.Application#scene
     * @type {pc.Scene}
     * @description The scene managed by the application.
     * @example
     * // Set the tone mapping property of the application's scene
     * this.app.scene.toneMapping = pc.TONEMAP_FILMIC;
     */

    /**
     * @name pc.Application#timeScale
     * @type {number}
     * @description Scales the global time delta. Defaults to 1.
     * @example
     * // Set the app to run at half speed
     * this.app.timeScale = 0.5;
     */

    /**
     * @name pc.Application#maxDeltaTime
     * @type {number}
     * @description Clamps per-frame delta time to an upper bound. Useful since returning from a tab
     * deactivation can generate huge values for dt, which can adversely affect game state. Defaults
     * to 0.1 (seconds).
     * @example
     * // Don't clamp inter-frame times of 200ms or less
     * this.app.maxDeltaTime = 0.2;
     */

    /**
     * @name pc.Application#scenes
     * @type {pc.SceneRegistry}
     * @description The scene registry managed by the application.
     * @example
     * // Search the scene registry for a item with the name 'racetrack1'
     * var sceneItem = this.app.scenes.find('racetrack1');
     *
     * // Load the scene using the item's url
     * this.app.scenes.loadScene(sceneItem.url);
     */

    /**
     * @name pc.Application#assets
     * @type {pc.AssetRegistry}
     * @description The asset registry managed by the application.
     * @example
     * // Search the asset registry for all assets with the tag 'vehicle'
     * var vehicleAssets = this.app.assets.findByTag('vehicle');
     */

    /**
     * @name pc.Application#graphicsDevice
     * @type {pc.GraphicsDevice}
     * @description The graphics device used by the application.
     */

    /**
     * @name pc.Application#systems
     * @type {pc.ComponentSystemRegistry}
     * @description The application's component system registry. The pc.Application
     * constructor adds the following component systems to its component system registry:
     *
     * * animation ({@link pc.AnimationComponentSystem})
     * * audiolistener ({@link pc.AudioListenerComponentSystem})
     * * button ({@link pc.ButtonComponentSystem})
     * * camera ({@link pc.CameraComponentSystem})
     * * collision ({@link pc.CollisionComponentSystem})
     * * element ({@link pc.ElementComponentSystem})
     * * layoutchild ({@link pc.LayoutChildComponentSystem})
     * * layoutgroup ({@link pc.LayoutGroupComponentSystem})
     * * light ({@link pc.LightComponentSystem})
     * * model ({@link pc.ModelComponentSystem})
     * * particlesystem ({@link pc.ParticleSystemComponentSystem})
     * * rigidbody ({@link pc.RigidBodyComponentSystem})
     * * screen ({@link pc.ScreenComponentSystem})
     * * script ({@link pc.ScriptComponentSystem})
     * * scrollbar ({@link pc.ScrollbarComponentSystem})
     * * scrollview ({@link pc.ScrollViewComponentSystem})
     * * sound ({@link pc.SoundComponentSystem})
     * * sprite ({@link pc.SpriteComponentSystem})
     * @example
     * // Set global gravity to zero
     * this.app.systems.rigidbody.gravity.set(0, 0, 0);
     * @example
     * // Set the global sound volume to 50%
     * this.app.systems.sound.volume = 0.5;
     */

    /**
     * @name pc.Application#xr
     * @type {pc.XrManager}
     * @description The XR Manager that provides ability to start VR/AR sessions.
     * @example
     * // check if VR is available
     * if (app.xr.isAvailable(pc.XRTYPE_VR)) {
     *     // VR is available
     * }
     */

    /**
     * @name pc.Application#loader
     * @type {pc.ResourceLoader}
     * @description The resource loader.
     */

    /**
     * @name pc.Application#root
     * @type {pc.Entity}
     * @description The root entity of the application.
     * @example
     * // Return the first entity called 'Camera' in a depth-first search of the scene hierarchy
     * var camera = this.app.root.findByName('Camera');
     */

    /**
     * @name pc.Application#keyboard
     * @type {pc.Keyboard}
     * @description The keyboard device.
     */

    /**
     * @name pc.Application#mouse
     * @type {pc.Mouse}
     * @description The mouse device.
     */

    /**
     * @name pc.Application#touch
     * @type {pc.TouchDevice}
     * @description Used to get touch events input.
     */

    /**
     * @name pc.Application#gamepads
     * @type {pc.GamePads}
     * @description Used to access GamePad input.
     */

    /**
     * @name pc.Application#elementInput
     * @type {pc.ElementInput}
     * @description Used to handle input for {@link pc.ElementComponent}s.
     */

    /**
     * @name pc.Application#scripts
     * @type {pc.ScriptRegistry}
     * @description The application's script registry.
     */

    /**
     * @name pc.Application#batcher
     * @type {pc.BatchManager}
     * @description The application's batch manager. The batch manager is used to
     * merge mesh instances in the scene, which reduces the overall number of draw
     * calls, thereby boosting performance.
     */

    /**
     * @name pc.Application#autoRender
     * @type {boolean}
     * @description When true, the application's render function is called every frame.
     * Setting autoRender to false is useful to applications where the rendered image
     * may often be unchanged over time. This can heavily reduce the application's
     * load on the CPU and GPU. Defaults to true.
     * @example
     * // Disable rendering every frame and only render on a keydown event
     * this.app.autoRender = false;
     * this.app.keyboard.on('keydown', function (event) {
     *     this.app.renderNextFrame = true;
     * }, this);
     */

    /**
     * @name pc.Application#renderNextFrame
     * @type {boolean}
     * @description Set to true to render the scene on the next iteration of the main loop.
     * This only has an effect if {@link pc.Application#autoRender} is set to false. The
     * value of renderNextFrame is set back to false again as soon as the scene has been
     * rendered.
     * @example
     * // Render the scene only while space key is pressed
     * if (this.app.keyboard.isPressed(pc.KEY_SPACE)) {
     *     this.app.renderNextFrame = true;
     * }
     */

     /**
      * @name pc.Application#i18n
      * @type {pc.I18n}
      * @description Handles localization.
      */

    /**
     * @private
     * @static
     * @name pc.app
     * @type {pc.Application|undefined}
     * @description Gets the current application, if any.
     */
    exports.app = null;

    function Application(canvas, options) {
        EventHandler.call(this);

        options = options || {};

        console.log("Powered by PlayCanvas " + version + " " + revision);

        // Store application instance
        Application._applications[canvas.id] = this;
        Application._currentApplication = this;

        exports.app = this;

        this._time = 0;
        this.timeScale = 1;
        this.maxDeltaTime = 0.1; // Maximum delta is 0.1s or 10 fps.

        this.frame = 0; // the total number of frames the application has updated since start() was called

        this.autoRender = true;
        this.renderNextFrame = false;

        // enable if you want entity type script attributes
        // to not be re-mapped when an entity is cloned
        this.useLegacyScriptAttributeCloning = script.legacy;

        this._librariesLoaded = false;
        this._fillMode = FILLMODE_KEEP_ASPECT;
        this._resolutionMode = RESOLUTION_FIXED;
        this._allowResize = true;

        // for compatibility
        this.context = this;

        if (! options.graphicsDeviceOptions)
            options.graphicsDeviceOptions = { };

        options.graphicsDeviceOptions.xrCompatible = true;

        this.graphicsDevice = new GraphicsDevice(canvas, options.graphicsDeviceOptions);
        this.stats = new ApplicationStats(this.graphicsDevice);
        this._soundManager = new SoundManager(options);
        this.loader = new ResourceLoader(this);

        // stores all entities that have been created
        // for this app by guid
        this._entityIndex = {};

        this.scene = new Scene();
        this.root = new Entity(this);
        this.root._enabledInHierarchy = true;
        this._enableList = [];
        this._enableList.size = 0;
        this.assets = new AssetRegistry(this.loader);
        if (options.assetPrefix) this.assets.prefix = options.assetPrefix;
        this.bundles = new BundleRegistry(this.assets);
        // set this to false if you want to run without using bundles
        // We set it to true only if TextDecoder is available because we currently
        // rely on it for untarring.
        this.enableBundles = (typeof TextDecoder !== 'undefined');
        this.scriptsOrder = options.scriptsOrder || [];
        this.scripts = new ScriptRegistry(this);

        this.i18n = new I18n(this);

        this.scenes = new SceneRegistry(this);

        var self = this;
        this.defaultLayerWorld = new Layer({
            name: "World",
            id: LAYERID_WORLD
        });

        if (this.graphicsDevice.webgl2) {
            // WebGL 2 depth layer just copies existing depth
            this.defaultLayerDepth = new Layer({
                enabled: false,
                name: "Depth",
                id: LAYERID_DEPTH,

                onEnable: function () {
                    if (this.renderTarget) return;
                    var depthBuffer = new Texture(self.graphicsDevice, {
                        format: PIXELFORMAT_DEPTHSTENCIL,
                        width: self.graphicsDevice.width,
                        height: self.graphicsDevice.height
                    });
                    depthBuffer.name = 'rt-depth2';
                    depthBuffer.minFilter = FILTER_NEAREST;
                    depthBuffer.magFilter = FILTER_NEAREST;
                    depthBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
                    depthBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
                    this.renderTarget = new RenderTarget({
                        colorBuffer: null,
                        depthBuffer: depthBuffer,
                        autoResolve: false
                    });
                    self.graphicsDevice.scope.resolve("uDepthMap").setValue(depthBuffer);
                },

                onDisable: function () {
                    if (!this.renderTarget) return;
                    this.renderTarget._depthBuffer.destroy();
                    this.renderTarget.destroy();
                    this.renderTarget = null;
                },

                onPreRenderOpaque: function (cameraPass) { // resize depth map if needed
                    var gl = self.graphicsDevice.gl;
                    this.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);

                    if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
                        this.onDisable();
                        this.onEnable();
                    }

                    // disable clearing
                    this.oldClear = this.cameras[cameraPass].camera._clearOptions;
                    this.cameras[cameraPass].camera._clearOptions = this.depthClearOptions;
                },

                onPostRenderOpaque: function (cameraPass) { // copy depth
                    if (!this.renderTarget) return;

                    this.cameras[cameraPass].camera._clearOptions = this.oldClear;

                    var gl = self.graphicsDevice.gl;

                    self.graphicsDevice.setRenderTarget(this.renderTarget);
                    self.graphicsDevice.updateBegin();

                    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);
                    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);
                    gl.blitFramebuffer( 0, 0, this.renderTarget.width, this.renderTarget.height,
                                        0, 0, this.renderTarget.width, this.renderTarget.height,
                                        gl.DEPTH_BUFFER_BIT,
                                        gl.NEAREST);
                }

            });
            this.defaultLayerDepth.depthClearOptions = {
                flags: 0
            };
        } else {
            // WebGL 1 depth layer just renders same objects as in World, but with RGBA-encoded depth shader
            this.defaultLayerDepth = new Layer({
                enabled: false,
                name: "Depth",
                id: LAYERID_DEPTH,
                shaderPass: SHADER_DEPTH,

                onEnable: function () {
                    if (this.renderTarget) return;
                    var colorBuffer = new Texture(self.graphicsDevice, {
                        format: PIXELFORMAT_R8_G8_B8_A8,
                        width: self.graphicsDevice.width,
                        height: self.graphicsDevice.height
                    });
                    colorBuffer.name = 'rt-depth1';
                    colorBuffer.minFilter = FILTER_NEAREST;
                    colorBuffer.magFilter = FILTER_NEAREST;
                    colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
                    colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
                    this.renderTarget = new RenderTarget(self.graphicsDevice, colorBuffer, {
                        depth: true,
                        stencil: self.graphicsDevice.supportsStencil
                    });
                    self.graphicsDevice.scope.resolve("uDepthMap").setValue(colorBuffer);
                },

                onDisable: function () {
                    if (!this.renderTarget) return;
                    this.renderTarget._colorBuffer.destroy();
                    this.renderTarget.destroy();
                    this.renderTarget = null;
                },

                onPostCull: function (cameraPass) {
                    // Collect all rendered mesh instances with the same render target as World has, depthWrite == true and prior to this layer to replicate blitFramebuffer on WebGL2
                    var visibleObjects = this.instances.visibleOpaque[cameraPass];
                    var visibleList = visibleObjects.list;
                    var visibleLength = 0;
                    var layers = self.scene.layers.layerList;
                    var subLayerEnabled = self.scene.layers.subLayerEnabled;
                    var isTransparent = self.scene.layers.subLayerList;
                    var rt = self.defaultLayerWorld.renderTarget;
                    var cam = this.cameras[cameraPass];
                    var layer;
                    var j;
                    var layerVisibleList, layerCamId, layerVisibleListLength, drawCall, transparent;
                    for (var i = 0; i < layers.length; i++) {
                        layer = layers[i];
                        if (layer === this) break;
                        if (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;
                        layerCamId = layer.cameras.indexOf(cam);
                        if (layerCamId < 0) continue;
                        transparent = isTransparent[i];
                        layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];
                        layerVisibleListLength = layerVisibleList.length;
                        layerVisibleList = layerVisibleList.list;
                        for (j = 0; j < layerVisibleListLength; j++) {
                            drawCall = layerVisibleList[j];
                            if (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {
                                visibleList[visibleLength] = drawCall;
                                visibleLength++;
                            }
                        }
                    }
                    visibleObjects.length = visibleLength;
                },

                onPreRenderOpaque: function (cameraPass) { // resize depth map if needed
                    if (!this.renderTarget || (this.renderTarget.width !== self.graphicsDevice.width || this.renderTarget.height !== self.graphicsDevice.height)) {
                        this.onDisable();
                        this.onEnable();
                    }
                    this.oldClear = this.cameras[cameraPass].camera._clearOptions;
                    this.cameras[cameraPass].camera._clearOptions = this.rgbaDepthClearOptions;
                },

                onDrawCall: function () {
                    self.graphicsDevice.setColorWrite(true, true, true, true);
                },

                onPostRenderOpaque: function (cameraPass) {
                    if (!this.renderTarget) return;
                    this.cameras[cameraPass].camera._clearOptions = this.oldClear;
                }

            });
            this.defaultLayerDepth.rgbaDepthClearOptions = {
                color: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],
                depth: 1.0,
                flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
            };
        }

        this.defaultLayerSkybox = new Layer({
            enabled: false,
            name: "Skybox",
            id: LAYERID_SKYBOX,
            opaqueSortMode: SORTMODE_NONE
        });
        this.defaultLayerUi = new Layer({
            enabled: true,
            name: "UI",
            id: LAYERID_UI,
            transparentSortMode: SORTMODE_MANUAL,
            passThrough: false
        });
        this.defaultLayerImmediate = new Layer({
            enabled: true,
            name: "Immediate",
            id: LAYERID_IMMEDIATE,
            opaqueSortMode: SORTMODE_NONE,
            passThrough: true
        });
        this.defaultLayerComposition = new LayerComposition();

        this.defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
        this.defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
        this.defaultLayerComposition.pushTransparent(this.defaultLayerUi);

        this.scene.layers = this.defaultLayerComposition;

        this._immediateLayer = this.defaultLayerImmediate;

        // Default layers patch
        this.scene.on('set:layers', function (oldComp, newComp) {
            var list = newComp.layerList;
            var layer;
            for (var i = 0; i < list.length; i++) {
                layer = list[i];
                switch (layer.id) {
                    case LAYERID_DEPTH:
                        layer.onEnable = self.defaultLayerDepth.onEnable;
                        layer.onDisable = self.defaultLayerDepth.onDisable;
                        layer.onPreRenderOpaque = self.defaultLayerDepth.onPreRenderOpaque;
                        layer.onPostRenderOpaque = self.defaultLayerDepth.onPostRenderOpaque;
                        layer.depthClearOptions = self.defaultLayerDepth.depthClearOptions;
                        layer.rgbaDepthClearOptions = self.defaultLayerDepth.rgbaDepthClearOptions;
                        layer.shaderPass = self.defaultLayerDepth.shaderPass;
                        layer.onPostCull = self.defaultLayerDepth.onPostCull;
                        layer.onDrawCall = self.defaultLayerDepth.onDrawCall;
                        break;
                    case LAYERID_UI:
                        layer.passThrough = self.defaultLayerUi.passThrough;
                        break;
                    case LAYERID_IMMEDIATE:
                        layer.passThrough = self.defaultLayerImmediate.passThrough;
                        break;
                }
            }
        });

        this.renderer = new ForwardRenderer(this.graphicsDevice);
        this.renderer.scene = this.scene;
        this.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);
        this.once('prerender', this._firstBake, this);
        this.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);
        this.once('prerender', this._firstBatch, this);

        this.keyboard = options.keyboard || null;
        this.mouse = options.mouse || null;
        this.touch = options.touch || null;
        this.gamepads = options.gamepads || null;
        this.elementInput = options.elementInput || null;
        if (this.elementInput)
            this.elementInput.app = this;

        this.vr = null;
        this.xr = new XrManager(this);

        if (this.elementInput)
            this.elementInput.attachSelectEvents();

        this._inTools = false;

        this._skyboxLast = 0;

        this._scriptPrefix = options.scriptPrefix || '';

        if (this.enableBundles) {
            this.loader.addHandler("bundle", new BundleHandler(this.assets));
        }

        this.loader.addHandler("animation", new AnimationHandler());
        this.loader.addHandler("animclip", new AnimClipHandler());
        this.loader.addHandler("animstategraph", new AnimStateGraphHandler());
        this.loader.addHandler("model", new ModelHandler(this.graphicsDevice, this.scene.defaultMaterial));
        this.loader.addHandler("material", new MaterialHandler(this));
        this.loader.addHandler("texture", new TextureHandler(this.graphicsDevice, this.assets, this.loader));
        this.loader.addHandler("text", new TextHandler());
        this.loader.addHandler("json", new JsonHandler());
        this.loader.addHandler("audio", new AudioHandler(this._soundManager));
        this.loader.addHandler("script", new ScriptHandler(this));
        this.loader.addHandler("scene", new SceneHandler(this));
        this.loader.addHandler("cubemap", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));
        this.loader.addHandler("html", new HtmlHandler());
        this.loader.addHandler("css", new CssHandler());
        this.loader.addHandler("shader", new ShaderHandler());
        this.loader.addHandler("hierarchy", new HierarchyHandler(this));
        this.loader.addHandler("scenesettings", new SceneSettingsHandler(this));
        this.loader.addHandler("folder", new FolderHandler());
        this.loader.addHandler("font", new FontHandler(this.loader));
        this.loader.addHandler("binary", new BinaryHandler());
        this.loader.addHandler("textureatlas", new TextureAtlasHandler(this.loader));
        this.loader.addHandler("sprite", new SpriteHandler(this.assets, this.graphicsDevice));
        this.loader.addHandler("template", new TemplateHandler(this));
        this.loader.addHandler("container", new ContainerHandler(this.graphicsDevice, this.scene.defaultMaterial));

        this.systems = new ComponentSystemRegistry();
        this.systems.add(new RigidBodyComponentSystem(this));
        this.systems.add(new CollisionComponentSystem(this));
        this.systems.add(new AnimationComponentSystem(this));
        this.systems.add(new AnimComponentSystem(this));
        this.systems.add(new ModelComponentSystem(this));
        this.systems.add(new CameraComponentSystem(this));
        this.systems.add(new LightComponentSystem(this));
        if (script.legacy) {
            this.systems.add(new ScriptLegacyComponentSystem(this));
        } else {
            this.systems.add(new ScriptComponentSystem(this));
        }
        this.systems.add(new AudioSourceComponentSystem(this, this._soundManager));
        this.systems.add(new SoundComponentSystem(this, this._soundManager));
        this.systems.add(new AudioListenerComponentSystem(this, this._soundManager));
        this.systems.add(new ParticleSystemComponentSystem(this));
        this.systems.add(new ScreenComponentSystem(this));
        this.systems.add(new ElementComponentSystem(this));
        this.systems.add(new ButtonComponentSystem(this));
        this.systems.add(new ScrollViewComponentSystem(this));
        this.systems.add(new ScrollbarComponentSystem(this));
        this.systems.add(new SpriteComponentSystem(this));
        this.systems.add(new LayoutGroupComponentSystem(this));
        this.systems.add(new LayoutChildComponentSystem(this));
        this.systems.add(new ZoneComponentSystem(this));

        this._visibilityChangeHandler = this.onVisibilityChange.bind(this);

        // Depending on browser add the correct visibiltychange event and store the name of the hidden attribute
        // in this._hiddenAttr.
        if (typeof document !== 'undefined') {
            if (document.hidden !== undefined) {
                this._hiddenAttr = 'hidden';
                document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
            } else if (document.mozHidden !== undefined) {
                this._hiddenAttr = 'mozHidden';
                document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
            } else if (document.msHidden !== undefined) {
                this._hiddenAttr = 'msHidden';
                document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
            } else if (document.webkitHidden !== undefined) {
                this._hiddenAttr = 'webkitHidden';
                document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
            }
        }

        this.meshInstanceArray = [];

        // bind tick function to current scope

        /* eslint-disable-next-line no-use-before-define */
        this.tick = makeTick(this); // Circular linting issue as makeTick and Application reference each other
    }
    Application.prototype = Object.create(EventHandler.prototype);
    Application.prototype.constructor = Application;

    Application._currentApplication = null;
    Application._applications = {};

    /**
     * @static
     * @function
     * @name pc.Application.getApplication
     * @description Get the current application. In the case where there are multiple running
     * applications, the function can get an application based on a supplied canvas id. This
     * function is particularly useful when the current pc.Application is not readily available.
     * For example, in the JavaScript console of the browser's developer tools.
     * @param {string} [id] - If defined, the returned application should use the canvas which has this id. Otherwise current application will be returned.
     * @returns {pc.Application|undefined} The running application, if any.
     * @example
     * var app = pc.Application.getApplication();
     */
    Application.getApplication = function (id) {
        return id ? Application._applications[id] : Application._currentApplication;
    };

    // Mini-object used to measure progress of loading sets
    var Progress = function (length) {
        this.length = length;
        this.count = 0;

        this.inc = function () {
            this.count++;
        };

        this.done = function () {
            return (this.count === this.length);
        };
    };

    /**
     * @readonly
     * @name pc.Application#fillMode
     * @type {string}
     * @description The current fill mode of the canvas. Can be:
     *
     * * {@link pc.FILLMODE_NONE}: the canvas will always match the size provided.
     * * {@link pc.FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
     * * {@link pc.FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while maintaining the aspect ratio.
     */
    Object.defineProperty(Application.prototype, 'fillMode', {
        get: function () {
            return this._fillMode;
        }
    });

    /**
     * @readonly
     * @name pc.Application#resolutionMode
     * @type {string}
     * @description The current resolution mode of the canvas, Can be:
     *
     * * {@link pc.RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to match canvas client size.
     * * {@link pc.RESOLUTION_FIXED}: resolution of canvas will be fixed.
     */
    Object.defineProperty(Application.prototype, 'resolutionMode', {
        get: function () {
            return this._resolutionMode;
        }
    });

    Object.assign(Application.prototype, {
        /**
         * @function
         * @name pc.Application#configure
         * @description Load the application configuration file and apply application properties and fill the asset registry.
         * @param {string} url - The URL of the configuration file to load.
         * @param {pc.callbacks.ConfigureApp} callback - The Function called when the configuration file is loaded and parsed (or an error occurs).
         */
        configure: function (url, callback) {
            var self = this;
            http.get(url, function (err, response) {
                if (err) {
                    callback(err);
                    return;
                }

                var props = response.application_properties;
                var scenes = response.scenes;
                var assets = response.assets;

                self._parseApplicationProperties(props, function (err) {
                    self._parseScenes(scenes);
                    self._parseAssets(assets);
                    if (!err) {
                        callback(null);
                    } else {
                        callback(err);
                    }
                });
            });
        },

        /**
         * @function
         * @name pc.Application#preload
         * @description Load all assets in the asset registry that are marked as 'preload'.
         * @param {pc.callbacks.PreloadApp} callback - Function called when all assets are loaded.
         */
        preload: function (callback) {
            var self = this;
            var i, total;

            self.fire("preload:start");

            // get list of assets to preload
            var assets = this.assets.list({
                preload: true
            });

            var _assets = new Progress(assets.length);

            var _done = false;

            // check if all loading is done
            var done = function () {
                // do not proceed if application destroyed
                if (!self.graphicsDevice) {
                    return;
                }

                if (!_done && _assets.done()) {
                    _done = true;
                    self.fire("preload:end");
                    callback();
                }
            };

            // totals loading progress of assets
            total = assets.length;
            var count = function () {
                return _assets.count;
            };

            if (_assets.length) {
                var onAssetLoad = function (asset) {
                    _assets.inc();
                    self.fire('preload:progress', count() / total);

                    if (_assets.done())
                        done();
                };

                var onAssetError = function (err, asset) {
                    _assets.inc();
                    self.fire('preload:progress', count() / total);

                    if (_assets.done())
                        done();
                };

                // for each asset
                for (i = 0; i < assets.length; i++) {
                    if (!assets[i].loaded) {
                        assets[i].once('load', onAssetLoad);
                        assets[i].once('error', onAssetError);

                        this.assets.load(assets[i]);
                    } else {
                        _assets.inc();
                        self.fire("preload:progress", count() / total);

                        if (_assets.done())
                            done();
                    }
                }
            } else {
                done();
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#getSceneUrl
         * @description Look up the URL of the scene hierarchy file via the name given to the scene in the editor. Use this to in {@link pc.Application#loadSceneHierarchy}.
         * @param {string} name - The name of the scene file given in the Editor.
         * @returns {string} The URL of the scene file.
         */
        getSceneUrl: function (name) {
            var entry = this.scenes.find(name);
            if (entry) {
                return entry.url;
            }
            return null;
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#loadSceneHierarchy
         * @description Load a scene file, create and initialize the Entity hierarchy
         * and add the hierarchy to the application root Entity.
         * @param {string} url - The URL of the scene file. Usually this will be "scene_id.json".
         * @param {pc.callbacks.LoadHierarchy} callback - The function to call after loading, passed (err, entity) where err is null if no errors occurred.
         * @example
         *
         * app.loadSceneHierarchy("1000.json", function (err, entity) {
         *     if (!err) {
         *         var e = app.root.find("My New Entity");
         *     } else {
         *         // error
         *     }
         * });
         */
        loadSceneHierarchy: function (url, callback) {
            this.scenes.loadSceneHierarchy(url, callback);
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#loadSceneSettings
         * @description Load a scene file and automatically apply the scene settings to the current scene.
         * @param {string} url - The URL of the scene file. Usually this will be "scene_id.json".
         * @param {pc.callbacks.LoadSettings} callback - The function called after the settings are applied. Passed (err) where err is null if no error occurred.
         * @example
         * app.loadSceneSettings("1000.json", function (err) {
         *     if (!err) {
         *       // success
         *     } else {
         *       // error
         *     }
         * });
         */
        loadSceneSettings: function (url, callback) {
            this.scenes.loadSceneSettings(url, callback);
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#loadScene
         * @description Load a scene file.
         * @param {string} url - The URL of the scene file. Usually this will be "scene_id.json".
         * @param {pc.callbacks.LoadScene} callback - The function to call after loading, passed (err, entity) where err is null if no errors occurred.
         * @example
         *
         * app.loadScene("1000.json", function (err, entity) {
         *     if (!err) {
         *         var e = app.root.find("My New Entity");
         *     } else {
         *         // error
         *     }
         * });
         */
        loadScene: function (url, callback) {
            this.scenes.loadScene(url, callback);
        },

        _preloadScripts: function (sceneData, callback) {
            if (!script.legacy) {
                callback();
                return;
            }

            var self = this;

            self.systems.script.preloading = true;

            var scripts = this._getScriptReferences(sceneData);

            var i = 0, l = scripts.length;
            var progress = new Progress(l);
            var scriptUrl;
            var regex = /^http(s)?:\/\//;

            if (l) {
                var onLoad = function (err, ScriptType) {
                    if (err)
                        console.error(err);

                    progress.inc();
                    if (progress.done()) {
                        self.systems.script.preloading = false;
                        callback();
                    }
                };

                for (i = 0; i < l; i++) {
                    scriptUrl = scripts[i];
                    // support absolute URLs (for now)
                    if (!regex.test(scriptUrl.toLowerCase()) && self._scriptPrefix)
                        scriptUrl = path.join(self._scriptPrefix, scripts[i]);

                    this.loader.load(scriptUrl, 'script', onLoad);
                }
            } else {
                self.systems.script.preloading = false;
                callback();
            }
        },

        // set application properties from data file
        _parseApplicationProperties: function (props, callback) {
            var i;
            var len;

            // TODO: remove this temporary block after migrating properties
            if (!props.useDevicePixelRatio)
                props.useDevicePixelRatio = props.use_device_pixel_ratio;
            if (!props.resolutionMode)
                props.resolutionMode = props.resolution_mode;
            if (!props.fillMode)
                props.fillMode = props.fill_mode;

            this._width = props.width;
            this._height = props.height;
            if (props.useDevicePixelRatio) {
                this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
            }

            this.setCanvasResolution(props.resolutionMode, this._width, this._height);
            this.setCanvasFillMode(props.fillMode, this._width, this._height);

            // set up layers
            if (props.layers && props.layerOrder) {
                var composition = new LayerComposition();

                var layers = {};
                for (var key in props.layers) {
                    var data = props.layers[key];
                    data.id = parseInt(key, 10);
                    // depth layer should only be enabled when needed
                    // by incrementing its ref counter
                    data.enabled = data.id !== LAYERID_DEPTH;
                    layers[key] = new Layer(data);
                }

                for (i = 0, len = props.layerOrder.length; i < len; i++) {
                    var sublayer = props.layerOrder[i];
                    var layer = layers[sublayer.layer];
                    if (!layer) continue;

                    if (sublayer.transparent) {
                        composition.pushTransparent(layer);
                    } else {
                        composition.pushOpaque(layer);
                    }

                    composition.subLayerEnabled[i] = sublayer.enabled;
                }

                this.scene.layers = composition;
            }

            // add batch groups
            if (props.batchGroups) {
                for (i = 0, len = props.batchGroups.length; i < len; i++) {
                    var grp = props.batchGroups[i];
                    this.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
                }

            }

            // set localization assets
            if (props.i18nAssets) {
                this.i18n.assets = props.i18nAssets;
            }

            this._loadLibraries(props.libraries, callback);
        },

        _loadLibraries: function (urls, callback) {
            var len = urls.length;
            var count = len;
            var self = this;

            var regex = /^http(s)?:\/\//;

            if (len) {
                var onLoad = function (err, script) {
                    count--;
                    if (err) {
                        callback(err);
                    } else if (count === 0) {
                        self.onLibrariesLoaded();
                        callback(null);
                    }
                };

                for (var i = 0; i < len; ++i) {
                    var url = urls[i];

                    if (!regex.test(url.toLowerCase()) && self._scriptPrefix)
                        url = path.join(self._scriptPrefix, url);

                    this.loader.load(url, 'script', onLoad);
                }
            } else {
                self.onLibrariesLoaded();
                callback(null);
            }
        },

        // insert scene name/urls into the registry
        _parseScenes: function (scenes) {
            if (!scenes) return;

            for (var i = 0; i < scenes.length; i++) {
                this.scenes.add(scenes[i].name, scenes[i].url);
            }
        },

        // insert assets into registry
        _parseAssets: function (assets) {
            var i, id;
            var list = [];

            var scriptsIndex = {};
            var bundlesIndex = {};

            if (!script.legacy) {
                // add scripts in order of loading first
                for (i = 0; i < this.scriptsOrder.length; i++) {
                    id = this.scriptsOrder[i];
                    if (!assets[id])
                        continue;

                    scriptsIndex[id] = true;
                    list.push(assets[id]);
                }

                // then add bundles
                if (this.enableBundles) {
                    for (id in assets) {
                        if (assets[id].type === 'bundle') {
                            bundlesIndex[id] = true;
                            list.push(assets[id]);
                        }
                    }
                }

                // then add rest of assets
                for (id in assets) {
                    if (scriptsIndex[id] || bundlesIndex[id])
                        continue;

                    list.push(assets[id]);
                }
            } else {
                if (this.enableBundles) {
                    // add bundles
                    for (id in assets) {
                        if (assets[id].type === 'bundle') {
                            bundlesIndex[id] = true;
                            list.push(assets[id]);
                        }
                    }
                }


                // then add rest of assets
                for (id in assets) {
                    if (bundlesIndex[id])
                        continue;

                    list.push(assets[id]);
                }
            }

            for (i = 0; i < list.length; i++) {
                var data = list[i];
                var asset = new Asset(data.name, data.type, data.file, data.data);
                asset.id = parseInt(data.id, 10);
                asset.preload = data.preload ? data.preload : false;
                // if this is a script asset and has already been embedded in the page then
                // mark it as loaded
                asset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;
                // tags
                asset.tags.add(data.tags);
                // i18n
                if (data.i18n) {
                    for (var locale in data.i18n) {
                        asset.addLocalizedAssetId(locale, data.i18n[locale]);
                    }
                }
                // registry
                this.assets.add(asset);
            }
        },

        _getScriptReferences: function (scene) {
            var i, key;

            var priorityScripts = [];
            if (scene.settings.priority_scripts) {
                priorityScripts = scene.settings.priority_scripts;
            }

            var _scripts = [];
            var _index = {};

            // first add priority scripts
            for (i = 0; i < priorityScripts.length; i++) {
                _scripts.push(priorityScripts[i]);
                _index[priorityScripts[i]] = true;
            }

            // then iterate hierarchy to get referenced scripts
            var entities = scene.entities;
            for (key in entities) {
                if (!entities[key].components.script) {
                    continue;
                }

                var scripts = entities[key].components.script.scripts;
                for (i = 0; i < scripts.length; i++) {
                    if (_index[scripts[i].url])
                        continue;
                    _scripts.push(scripts[i].url);
                    _index[scripts[i].url] = true;
                }
            }

            return _scripts;
        },

        /**
         * @function
         * @name pc.Application#start
         * @description Start the application. This function does the following:
         * 1. Fires an event on the application named 'start'
         * 2. Calls initialize for all components on entities in the hierachy
         * 3. Fires an event on the application named 'initialize'
         * 4. Calls postInitialize for all components on entities in the hierachy
         * 5. Fires an event on the application named 'postinitialize'
         * 6. Starts executing the main loop of the application
         * This function is called internally by PlayCanvas applications made in the Editor
         * but you will need to call start yourself if you are using the engine stand-alone.
         * @example
         * app.start();
         */
        start: function () {
            this.frame = 0;

            this.fire("start", {
                timestamp: now(),
                target: this
            });

            if (!this._librariesLoaded) {
                this.onLibrariesLoaded();
            }

            ComponentSystem.initialize(this.root);
            this.fire("initialize");

            ComponentSystem.postInitialize(this.root);
            this.fire("postinitialize");

            this.tick();
        },

        /**
         * @function
         * @name pc.Application#update
         * @description Update the application. This function will call the update
         * functions and then the postUpdate functions of all enabled components. It
         * will then update the current state of all connected input devices.
         * This function is called internally in the application's main loop and
         * does not need to be called explicitly.
         * @param {number} dt - The time delta since the last frame.
         */
        update: function (dt) {
            this.frame++;

            this.graphicsDevice.updateClientRect();

            if (this.vr) this.vr.poll();


            // Perform ComponentSystem update
            if (script.legacy)
                ComponentSystem.fixedUpdate(1.0 / 60.0, this._inTools);

            ComponentSystem.update(dt, this._inTools);
            ComponentSystem.animationUpdate(dt, this._inTools);
            ComponentSystem.postUpdate(dt, this._inTools);

            // fire update event
            this.fire("update", dt);

            if (this.controller) {
                this.controller.update(dt);
            }
            if (this.mouse) {
                this.mouse.update(dt);
            }
            if (this.keyboard) {
                this.keyboard.update(dt);
            }
            if (this.gamepads) {
                this.gamepads.update(dt);
            }

        },

        /**
         * @function
         * @name pc.Application#render
         * @description Render the application's scene. More specifically, the scene's
         * {@link pc.LayerComposition} is rendered by the application's {@link pc.ForwardRenderer}.
         * This function is called internally in the application's main loop and
         * does not need to be called explicitly.
         */
        render: function () {

            this.fire("prerender");
            this.root.syncHierarchy();
            this.batcher.updateAll();
    //        pc._skipRenderCounter = 0;
            this.renderer.renderComposition(this.scene.layers);
            this.fire("postrender");

        },

        _fillFrameStats: function (now, dt, ms) {
            // Timing stats
            var stats = this.stats.frame;
            stats.dt = dt;
            stats.ms = ms;
            if (now > stats._timeToCountFrames) {
                stats.fps = stats._fpsAccum;
                stats._fpsAccum = 0;
                stats._timeToCountFrames = now + 1000;
            } else {
                stats._fpsAccum++;
            }

            // Render stats
            stats.cameras = this.renderer._camerasRendered;
            stats.materials = this.renderer._materialSwitches;
            stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
            stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
            stats.shadowMapTime = this.renderer._shadowMapTime;
            stats.depthMapTime = this.renderer._depthMapTime;
            stats.forwardTime = this.renderer._forwardTime;
            var prims = this.graphicsDevice._primsPerFrame;
            stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 +
                Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) +
                Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
            stats.cullTime = this.renderer._cullTime;
            stats.sortTime = this.renderer._sortTime;
            stats.skinTime = this.renderer._skinTime;
            stats.morphTime = this.renderer._morphTime;
            stats.instancingTime = this.renderer._instancingTime;
            stats.otherPrimitives = 0;
            for (var i = 0; i < prims.length; i++) {
                if (i < PRIMITIVE_TRIANGLES) {
                    stats.otherPrimitives += prims[i];
                }
                prims[i] = 0;
            }
            this.renderer._camerasRendered = 0;
            this.renderer._materialSwitches = 0;
            this.renderer._shadowMapUpdates = 0;
            this.graphicsDevice._shaderSwitchesPerFrame = 0;
            this.renderer._cullTime = 0;
            this.renderer._sortTime = 0;
            this.renderer._skinTime = 0;
            this.renderer._morphTime = 0;
            this.renderer._instancingTime = 0;
            this.renderer._shadowMapTime = 0;
            this.renderer._depthMapTime = 0;
            this.renderer._forwardTime = 0;

            // Draw call stats
            stats = this.stats.drawCalls;
            stats.forward = this.renderer._forwardDrawCalls;
            stats.culled = this.renderer._numDrawCallsCulled;
            stats.depth = 0;
            stats.shadow = this.renderer._shadowDrawCalls;
            stats.skinned = this.renderer._skinDrawCalls;
            stats.immediate = 0;
            stats.instanced = 0;
            stats.removedByInstancing = 0;
            stats.total = this.graphicsDevice._drawCallsPerFrame;
            stats.misc = stats.total - (stats.forward + stats.shadow);
            this.renderer._depthDrawCalls = 0;
            this.renderer._shadowDrawCalls = 0;
            this.renderer._forwardDrawCalls = 0;
            this.renderer._numDrawCallsCulled = 0;
            this.renderer._skinDrawCalls = 0;
            this.renderer._immediateRendered = 0;
            this.renderer._instancedDrawCalls = 0;
            this.renderer._removedByInstancing = 0;
            this.graphicsDevice._drawCallsPerFrame = 0;

            this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;

            stats = this.stats.particles;
            stats.updatesPerFrame = stats._updatesPerFrame;
            stats.frameTime = stats._frameTime;
            stats._updatesPerFrame = 0;
            stats._frameTime = 0;
        },

        /**
         * @function
         * @name pc.Application#setCanvasFillMode
         * @description Controls how the canvas fills the window and resizes when the window changes.
         * @param {string} mode - The mode to use when setting the size of the canvas. Can be:
         *
         * * {@link pc.FILLMODE_NONE}: the canvas will always match the size provided.
         * * {@link pc.FILLMODE_FILL_WINDOW}: the canvas will simply fill the window, changing aspect ratio.
         * * {@link pc.FILLMODE_KEEP_ASPECT}: the canvas will grow to fill the window as best it can while maintaining the aspect ratio.
         * @param {number} [width] - The width of the canvas (only used when mode is pc.FILLMODE_NONE).
         * @param {number} [height] - The height of the canvas (only used when mode is pc.FILLMODE_NONE).
         */
        setCanvasFillMode: function (mode, width, height) {
            this._fillMode = mode;
            this.resizeCanvas(width, height);
        },

        /**
         * @function
         * @name pc.Application#setCanvasResolution
         * @description Change the resolution of the canvas, and set the way it behaves when the window is resized.
         * @param {string} mode - The mode to use when setting the resolution. Can be:
         *
         * * {@link pc.RESOLUTION_AUTO}: if width and height are not provided, canvas will be resized to match canvas client size.
         * * {@link pc.RESOLUTION_FIXED}: resolution of canvas will be fixed.
         * @param {number} [width] - The horizontal resolution, optional in AUTO mode, if not provided canvas clientWidth is used.
         * @param {number} [height] - The vertical resolution, optional in AUTO mode, if not provided canvas clientHeight is used.
         */
        setCanvasResolution: function (mode, width, height) {
            this._resolutionMode = mode;

            // In AUTO mode the resolution is the same as the canvas size, unless specified
            if (mode === RESOLUTION_AUTO && (width === undefined)) {
                width = this.graphicsDevice.canvas.clientWidth;
                height = this.graphicsDevice.canvas.clientHeight;
            }

            this.graphicsDevice.resizeCanvas(width, height);
        },

        /**
         * @function
         * @name pc.Application#isHidden
         * @description Queries the visibility of the window or tab in which the application is running.
         * @returns {boolean} True if the application is not visible and false otherwise.
         */
        isHidden: function () {
            return document[this._hiddenAttr];
        },

        /**
         * @private
         * @function
         * @name pc.Application#onVisibilityChange
         * @description Called when the visibility state of the current tab/window changes.
         */
        onVisibilityChange: function () {
            if (this.isHidden()) {
                this._soundManager.suspend();
            } else {
                this._soundManager.resume();
            }
        },

        /**
         * @function
         * @name pc.Application#resizeCanvas
         * @description Resize the application's canvas element in line with the current fill mode.
         * In {@link pc.FILLMODE_KEEP_ASPECT} mode, the canvas will grow to fill the window as best it can while maintaining the aspect ratio.
         * In {@link pc.FILLMODE_FILL_WINDOW} mode, the canvas will simply fill the window, changing aspect ratio.
         * In {@link pc.FILLMODE_NONE} mode, the canvas will always match the size provided.
         * @param {number} [width] - The width of the canvas. Only used if current fill mode is {@link pc.FILLMODE_NONE}.
         * @param {number} [height] - The height of the canvas. Only used if current fill mode is {@link pc.FILLMODE_NONE}.
         * @returns {object} A object containing the values calculated to use as width and height.
         */
        resizeCanvas: function (width, height) {
            if (!this._allowResize) return; // prevent resizing (e.g. if presenting in VR HMD)

            // prevent resizing when in XR session
            if (this.xr && this.xr.session)
                return;

            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;

            if (this._fillMode === FILLMODE_KEEP_ASPECT) {
                var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
                var winR = windowWidth / windowHeight;

                if (r > winR) {
                    width = windowWidth;
                    height = width / r;
                } else {
                    height = windowHeight;
                    width = height * r;
                }
            } else if (this._fillMode === FILLMODE_FILL_WINDOW) {
                width = windowWidth;
                height = windowHeight;
            }

            this.graphicsDevice.canvas.style.width = width + 'px';
            this.graphicsDevice.canvas.style.height = height + 'px';

            // In AUTO mode the resolution is changed to match the canvas size
            if (this._resolutionMode === RESOLUTION_AUTO) {
                this.setCanvasResolution(RESOLUTION_AUTO);
            }

            // return the final values calculated for width and height
            return {
                width: width,
                height: height
            };
        },

        /**
         * @private
         * @name pc.Application#onLibrariesLoaded
         * @description Event handler called when all code libraries have been loaded.
         * Code libraries are passed into the constructor of the Application and the application won't start running or load packs until all libraries have
         * been loaded.
         */
        onLibrariesLoaded: function () {
            this._librariesLoaded = true;
            this.systems.rigidbody.onLibraryLoaded();
        },

        /**
         * @function
         * @name pc.Application#applySceneSettings
         * @description Apply scene settings to the current scene. Useful when your scene settings are parsed or generated from a non-URL source.
         * @param {object} settings - The scene settings to be applied.
         * @param {object} settings.physics - The physics settings to be applied.
         * @param {number[]} settings.physics.gravity - The world space vector representing global gravity in the physics simulation. Must be a fixed size array with three number elements, corresponding to each axis [ X, Y, Z ].
         * @param {object} settings.render - The rendering settings to be applied.
         * @param {number[]} settings.render.global_ambient - The color of the scene's ambient light. Must be a fixed size array with three number elements, corresponding to each color channel [ R, G, B ].
         * @param {string} settings.render.fog - The type of fog used by the scene. Can be:
         *
         * * {@link pc.FOG_NONE}
         * * {@link pc.FOG_LINEAR}
         * * {@link pc.FOG_EXP}
         * * {@link pc.FOG_EXP2}
         * @param {number[]} settings.render.fog_color - The color of the fog (if enabled). Must be a fixed size array with three number elements, corresponding to each color channel [ R, G, B ].
         * @param {number} settings.render.fog_density - The density of the fog (if enabled). This property is only valid if the fog property is set to pc.FOG_EXP or pc.FOG_EXP2.
         * @param {number} settings.render.fog_start - The distance from the viewpoint where linear fog begins. This property is only valid if the fog property is set to pc.FOG_LINEAR.
         * @param {number} settings.render.fog_end - The distance from the viewpoint where linear fog reaches its maximum. This property is only valid if the fog property is set to pc.FOG_LINEAR.
         * @param {number} settings.render.gamma_correction - The gamma correction to apply when rendering the scene. Can be:
         *
         * * {@link pc.GAMMA_NONE}
         * * {@link pc.GAMMA_SRGB}
         * @param {number} settings.render.tonemapping - The tonemapping transform to apply when writing fragments to the
         * frame buffer. Can be:
         *
         * * {@link pc.TONEMAP_LINEAR}
         * * {@link pc.TONEMAP_FILMIC}
         * * {@link pc.TONEMAP_HEJL}
         * * {@link pc.TONEMAP_ACES}
         * @param {number} settings.render.exposure - The exposure value tweaks the overall brightness of the scene.
         * @param {number|null} [settings.render.skybox] - The asset ID of the cube map texture to be used as the scene's skybox. Defaults to null.
         * @param {number} settings.render.skyboxIntensity - Multiplier for skybox intensity.
         * @param {number} settings.render.skyboxMip - The mip level of the skybox to be displayed. Only valid for prefiltered cubemap skyboxes.
         * @param {number} settings.render.lightmapSizeMultiplier - The lightmap resolution multiplier.
         * @param {number} settings.render.lightmapMaxResolution - The maximum lightmap resolution.
         * @param {number} settings.render.lightmapMode - The lightmap baking mode. Can be:
         *
         * * {@link pc.BAKE_COLOR}: single color lightmap
         * * {@link pc.BAKE_COLORDIR}: single color lightmap + dominant light direction (used for bump/specular)
         *
         * Only lights with bakeDir=true will be used for generating the dominant light direction. Defaults to.
         * @example
         *
         * var settings = {
         *     physics: {
         *         gravity: [0, -9.8, 0]
         *     },
         *     render: {
         *         fog_end: 1000,
         *         tonemapping: 0,
         *         skybox: null,
         *         fog_density: 0.01,
         *         gamma_correction: 1,
         *         exposure: 1,
         *         fog_start: 1,
         *         global_ambient: [0, 0, 0],
         *         skyboxIntensity: 1,
         *         fog_color: [0, 0, 0],
         *         lightmapMode: 1,
         *         fog: 'none',
         *         lightmapMaxResolution: 2048,
         *         skyboxMip: 2,
         *         lightmapSizeMultiplier: 16
         *     }
         * };
         * app.applySceneSettings(settings);
         */
        applySceneSettings: function (settings) {
            var asset;

            if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
                var gravity = settings.physics.gravity;
                this.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);
            }

            this.scene.applySettings(settings);

            if (settings.render.hasOwnProperty('skybox')) {
                if (settings.render.skybox) {
                    asset = this.assets.get(settings.render.skybox);

                    if (asset) {
                        this.setSkybox(asset);
                    } else {
                        this.assets.once('add:' + settings.render.skybox, this.setSkybox, this);
                    }
                } else {
                    this.setSkybox(null);
                }
            }
        },

        /**
         * @function
         * @name pc.Application#setSkybox
         * @description Sets the skybox asset to current scene, and subscribes to asset load/change events.
         * @param {pc.Asset} asset - Asset of type `skybox` to be set to, or null to remove skybox.
         */
        setSkybox: function (asset) {
            if (asset) {
                if (this._skyboxLast === asset.id) {
                    if (this.scene.skyboxMip === 0 && !asset.loadFaces) {
                        this._skyboxLoad(asset);
                    } else {
                        this._onSkyboxChange(asset);
                    }
                    return;
                }

                if (this._skyboxLast) {
                    this.assets.off('add:' + this._skyboxLast, this.setSkybox, this);
                    this.assets.off('load:' + this._skyboxLast, this._onSkyboxChange, this);
                    this.assets.off('remove:' + this._skyboxLast, this._skyboxRemove, this);
                }

                this._skyboxLast = asset.id;

                this.assets.on('load:' + asset.id, this._onSkyboxChange, this);
                this.assets.once('remove:' + asset.id, this._skyboxRemove, this);

                if (asset.resource)
                    this.scene.setSkybox(asset.resources);

                this._skyboxLoad(asset);
            } else {
                if (!this._skyboxLast)
                    return;

                this._skyboxRemove({
                    id: this._skyboxLast
                });
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#enableVr
         * @description Create and assign a {@link pc.VrManager} object to allow this application render in VR.
         */
        enableVr: function () {
            if (!this.vr) {
                this.vr = new VrManager(this);
            }
        },

        /**
         * @private
         * @deprecated
         * @function
         * @name pc.Application#disableVr
         * @description Destroy the {@link pc.VrManager}.
         */
        disableVr: function () {
            if (this.vr) {
                this.vr.destroy();
                this.vr = null;
            }
        },

        _onSkyboxChange: function (asset) {
            this.scene.setSkybox(asset.resources);
        },

        _skyboxLoad: function (asset) {
            if (this.scene.skyboxMip === 0)
                asset.loadFaces = true;

            this.assets.load(asset);

            this._onSkyboxChange(asset);
        },

        _skyboxRemove: function (asset) {
            if (!this._skyboxLast)
                return;

            this.assets.off('add:' + asset.id, this.setSkybox, this);
            this.assets.off('load:' + asset.id, this._onSkyboxChange, this);
            this.assets.off('remove:' + asset.id, this._skyboxRemove, this);
            this.scene.setSkybox(null);
            this._skyboxLast = null;
        },

        _firstBake: function () {
            this.lightmapper.bake(null, this.scene.lightmapMode);
        },

        _firstBatch: function () {
            if (this.scene._needsStaticPrepare) {
                this.renderer.prepareStaticMeshes(this.graphicsDevice, this.scene);
                this.scene._needsStaticPrepare = false;
            }
            this.batcher.generate();
        },

        _processTimestamp: function (timestamp) {
            return timestamp;
        },

        // IMMEDIATE MODE API
        _preRenderImmediate: function () {
            for (var i = 0; i < this._immediateData.lineBatches.length; i++) {
                if (this._immediateData.lineBatches[i]) {
                    this._immediateData.lineBatches[i].finalize(this.meshInstanceArray);
                }
            }
        },

        _postRenderImmediate: function () {
            for (var i = 0; i < this._immediateData.layers.length; i++) {
                this._immediateData.layers[i].clearMeshInstances(true);
            }

            this._immediateData.layers.length = 0;
        },

        _initImmediate: function () {
            // Init global line drawing data once
            if (!this._immediateData) {
                this._immediateData = new ImmediateData(this.graphicsDevice);

                this.on('prerender', this._preRenderImmediate, this);
                this.on('postrender', this._postRenderImmediate, this);
            }
        },

        _addLines: function (position, color, options) {
            var layer = (options && options.layer) ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);
            var depthTest = (options && options.depthTest !== undefined) ? options.depthTest : true;
            var mask = (options && options.mask) ? options.mask : undefined;

            this._initImmediate();

            this._immediateData.addLayer(layer);

            var idx = this._immediateData.getLayerIdx(layer);
            if (idx === undefined) {
                // Init used batch once
                var batch = new LineBatch();
                batch.init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
                batch.material.depthTest = depthTest;
                if (mask) batch.meshInstance.mask = mask;

                idx = this._immediateData.lineBatches.push(batch) - 1; // push into list and get index
                this._immediateData.addLayerIdx(idx, layer);
            } else {
                // Possibly reallocate buffer if it's small
                this._immediateData.lineBatches[idx].init(this.graphicsDevice, this._immediateData.lineVertexFormat, layer, position.length / 2);
                this._immediateData.lineBatches[idx].material.depthTest = depthTest;
                if (mask) this._immediateData.lineBatches[idx].meshInstance.mask = mask;
            }
            // Append
            this._immediateData.lineBatches[idx].addLines(position, color);
        },

        /**
         * @function
         * @name pc.Application#renderLine
         * @description Renders a line. Line start and end coordinates are specified in
         * world-space. If a single color is supplied, the line will be flat-shaded with
         * that color. If two colors are supplied, the line will be smooth shaded between
         * those colors. It is also possible to control which scene layer the line is
         * rendered into. By default, lines are rendered into the immediate layer
         * {@link pc.LAYERID_IMMEDIATE}.
         * @param {pc.Vec3} start - The start world-space coordinate of the line.
         * @param {pc.Vec3} end - The end world-space coordinate of the line.
         * @param {pc.Color} color - The start color of the line.
         * @param {pc.Color} [endColor] - The end color of the line.
         * @param {object} [options] - Options to set rendering properties.
         * @param {pc.Layer} [options.layer] - The layer to render the line into. Defaults
         * to {@link pc.LAYERID_IMMEDIATE}.
         * @example
         * // Render a 1-unit long white line
         * var start = new pc.Vec3(0, 0, 0);
         * var end = new pc.Vec3(1, 0, 0);
         * var color = new pc.Color(1, 1, 1);
         * app.renderLine(start, end, color);
         * @example
         * // Render a 1-unit long line that is smooth-shaded from white to red
         * var start = new pc.Vec3(0, 0, 0);
         * var end = new pc.Vec3(1, 0, 0);
         * var startColor = new pc.Color(1, 1, 1);
         * var endColor = new pc.Color(1, 0, 0);
         * app.renderLine(start, end, startColor, endColor);
         * @example
         * // Render a 1-unit long white line into the world layer
         * var start = new pc.Vec3(0, 0, 0);
         * var end = new pc.Vec3(1, 0, 0);
         * var color = new pc.Color(1, 1, 1);
         * var worldLayer = app.scene.layers.getLayerById(pc.LAYERID_WORLD);
         * app.renderLine(start, end, color, {
         *     layer: worldLayer
         * });
         * @example
         * // Render a 1-unit long line that is smooth-shaded from white to red into the world layer
         * var start = new pc.Vec3(0, 0, 0);
         * var end = new pc.Vec3(1, 0, 0);
         * var startColor = new pc.Color(1, 1, 1);
         * var endColor = new pc.Color(1, 0, 0);
         * var worldLayer = app.scene.layers.getLayerById(pc.LAYERID_WORLD);
         * app.renderLine(start, end, color, {
         *     layer: worldLayer
         * });
         */
        renderLine: function (start, end, color) {
            var endColor = color;
            var options;

            var arg3 = arguments[3];
            var arg4 = arguments[4];

            if (arg3 instanceof Color) {
                // passed in end color
                endColor = arg3;

                if (typeof arg4 === 'number') {
                    if (!_deprecationWarning) {
                        console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
                        _deprecationWarning = true;
                    }
                    // compatibility: convert linebatch id into options
                    if (arg4 === LINEBATCH_OVERLAY) {
                        options = {
                            layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                            depthTest: false
                        };
                    } else {
                        options = {
                            layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                            depthTest: true
                        };
                    }
                } else {
                    // use passed in options
                    options = arg4;
                }
            } else if (typeof arg3 === 'number') {
                if (!_deprecationWarning) {
                    console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
                    _deprecationWarning = true;
                }

                endColor = color;

                // compatibility: convert linebatch id into options
                if (arg3 === LINEBATCH_OVERLAY) {
                    options = {
                        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                        depthTest: false
                    };
                } else {
                    options = {
                        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                        depthTest: true
                    };
                }
            } else if (arg3) {
                // options passed in
                options = arg3;
            }

            this._addLines([start, end], [color, endColor], options);
        },

        /**
         * @function
         * @name pc.Application#renderLines
         * @description Draw an array of lines.
         * @param {pc.Vec3[]} position - An array of points to draw lines between.
         * @param {pc.Color[]} color - An array of colors to color the lines. This must be the same size as the position array.
         * @param {object} [options] - Options to set rendering properties.
         * @param {pc.Layer} [options.layer] - The layer to render the line into.
         * @example
         * var points = [new pc.Vec3(0, 0, 0), new pc.Vec3(1, 0, 0), new pc.Vec3(1, 1, 0), new pc.Vec3(1, 1, 1)];
         * var colors = [new pc.Color(1, 0, 0), new pc.Color(1, 1, 0), new pc.Color(0, 1, 1), new pc.Color(0, 0, 1)];
         * app.renderLines(points, colors);
         */
        renderLines: function (position, color, options) {
            if (!options) {
                // default option
                options = {
                    layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                    depthTest: true
                };
            } else if (typeof options === 'number') {
                if (!_deprecationWarning) {
                    console.warn("lineBatch argument is deprecated for renderLine. Use options.layer instead");
                    _deprecationWarning = true;
                }

                // backwards compatibility, LINEBATCH_OVERLAY lines have depthtest disabled
                if (options === LINEBATCH_OVERLAY) {
                    options = {
                        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                        depthTest: false
                    };
                } else {
                    options = {
                        layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),
                        depthTest: true
                    };
                }
            }

            var multiColor = !!color.length;
            if (multiColor) {
                if (position.length !== color.length) {
                    console.error("renderLines: position/color arrays have different lengths");
                    return;
                }
            }
            if (position.length % 2 !== 0) {
                console.error("renderLines: array length is not divisible by 2");
                return;
            }
            this._addLines(position, color, options);
        },

        // Draw lines forming a transformed unit-sized cube at this frame
        // lineType is optional
        renderWireCube: function (matrix, color, options) {
            var i;

            this._initImmediate();

            // Init cube data once
            if (!this._immediateData.cubeLocalPos) {
                var x = 0.5;
                this._immediateData.cubeLocalPos = [new Vec3(-x, -x, -x), new Vec3(-x, x, -x), new Vec3(x, x, -x), new Vec3(x, -x, -x),
                    new Vec3(-x, -x, x), new Vec3(-x, x, x), new Vec3(x, x, x), new Vec3(x, -x, x)];
                this._immediateData.cubeWorldPos = [new Vec3(), new Vec3(), new Vec3(), new Vec3(),
                    new Vec3(), new Vec3(), new Vec3(), new Vec3()];
            }

            var cubeLocalPos = this._immediateData.cubeLocalPos;
            var cubeWorldPos = this._immediateData.cubeWorldPos;

            // Transform and append lines
            for (i = 0; i < 8; i++) {
                matrix.transformPoint(cubeLocalPos[i], cubeWorldPos[i]);
            }
            this.renderLines([
                cubeWorldPos[0], cubeWorldPos[1],
                cubeWorldPos[1], cubeWorldPos[2],
                cubeWorldPos[2], cubeWorldPos[3],
                cubeWorldPos[3], cubeWorldPos[0],

                cubeWorldPos[4], cubeWorldPos[5],
                cubeWorldPos[5], cubeWorldPos[6],
                cubeWorldPos[6], cubeWorldPos[7],
                cubeWorldPos[7], cubeWorldPos[4],

                cubeWorldPos[0], cubeWorldPos[4],
                cubeWorldPos[1], cubeWorldPos[5],
                cubeWorldPos[2], cubeWorldPos[6],
                cubeWorldPos[3], cubeWorldPos[7]
            ], color, options);
        },

        // Draw meshInstance at this frame
        renderMeshInstance: function (meshInstance, options) {
            if (!options) {
                options = {
                    layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
                };
            }

            this._initImmediate();

            this._immediateData.addLayer(options.layer);

            this.meshInstanceArray[0] = meshInstance;
            options.layer.addMeshInstances(this.meshInstanceArray, true);
        },

        // Draw mesh at this frame
        renderMesh: function (mesh, material, matrix, options) {
            if (!options) {
                options = {
                    layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
                };
            }

            this._initImmediate();
            tempGraphNode.worldTransform = matrix;
            tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;

            var instance = new MeshInstance(tempGraphNode, mesh, material);
            instance.cull = false;

            if (options.mask) instance.mask = options.mask;
            this._immediateData.addLayer(options.layer);

            this.meshInstanceArray[0] = instance;
            options.layer.addMeshInstances(this.meshInstanceArray, true);
        },

        // Draw quad of size [-0.5, 0.5] at this frame
        renderQuad: function (matrix, material, options) {
            if (!options) {
                options = {
                    layer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE)
                };
            }

            this._initImmediate();

            // Init quad data once
            if (!this._immediateData.quadMesh) {
                var format = new VertexFormat(this.graphicsDevice, [
                    { semantic: SEMANTIC_POSITION, components: 3, type: TYPE_FLOAT32 }
                ]);
                var quadVb = new VertexBuffer(this.graphicsDevice, format, 4);
                var iterator = new VertexIterator(quadVb);
                iterator.element[SEMANTIC_POSITION].set(-0.5, -0.5, 0);
                iterator.next();
                iterator.element[SEMANTIC_POSITION].set(0.5, -0.5, 0);
                iterator.next();
                iterator.element[SEMANTIC_POSITION].set(-0.5, 0.5, 0);
                iterator.next();
                iterator.element[SEMANTIC_POSITION].set(0.5, 0.5, 0);
                iterator.end();
                this._immediateData.quadMesh = new Mesh(this.graphicsDevice);
                this._immediateData.quadMesh.vertexBuffer = quadVb;
                this._immediateData.quadMesh.primitive[0].type = PRIMITIVE_TRISTRIP;
                this._immediateData.quadMesh.primitive[0].base = 0;
                this._immediateData.quadMesh.primitive[0].count = 4;
                this._immediateData.quadMesh.primitive[0].indexed = false;
            }

            // Issue quad drawcall
            tempGraphNode.worldTransform = matrix;
            tempGraphNode._dirtyWorld = tempGraphNode._dirtyNormal = false;

            var quad = new MeshInstance(tempGraphNode, this._immediateData.quadMesh, material);
            quad.cull = false;
            this.meshInstanceArray[0] = quad;

            this._immediateData.addLayer(options.layer);

            options.layer.addMeshInstances(this.meshInstanceArray, true);
        },

        /**
         * @function
         * @name pc.Application#destroy
         * @description Destroys application and removes all event listeners.
         * @example
         * this.app.destroy();
         */
        destroy: function () {
            var i, l;
            var canvasId = this.graphicsDevice.canvas.id;

            this.off('librariesloaded');
            document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
            document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
            document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
            document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
            this._visibilityChangeHandler = null;
            this.onVisibilityChange = null;

            this.root.destroy();
            this.root = null;

            if (this.mouse) {
                this.mouse.off();
                this.mouse.detach();
                this.mouse = null;
            }

            if (this.keyboard) {
                this.keyboard.off();
                this.keyboard.detach();
                this.keyboard = null;
            }

            if (this.touch) {
                this.touch.off();
                this.touch.detach();
                this.touch = null;
            }

            if (this.elementInput) {
                this.elementInput.detach();
                this.elementInput = null;
            }

            if (this.controller) {
                this.controller = null;
            }

            var systems = this.systems.list;
            for (i = 0, l = systems.length; i < l; i++) {
                systems[i].destroy();
            }

            ComponentSystem.destroy();

            // destroy all texture resources
            var assets = this.assets.list();
            for (i = 0; i < assets.length; i++) {
                assets[i].unload();
                assets[i].off();
            }
            this.assets.off();


            // destroy bundle registry
            this.bundles.destroy();
            this.bundles = null;

            this.i18n.destroy();
            this.i18n = null;

            for (var key in this.loader.getHandler('script')._cache) {
                var element = this.loader.getHandler('script')._cache[key];
                var parent = element.parentNode;
                if (parent) parent.removeChild(element);
            }
            this.loader.getHandler('script')._cache = {};

            this.loader.destroy();
            this.loader = null;

            this.scene.destroy();
            this.scene = null;

            this.systems = [];
            this.context = null;

            // script registry
            this.scripts.destroy();
            this.scripts = null;

            this.scenes.destroy();
            this.scenes = null;

            this.lightmapper.destroy();
            this.lightmapper = null;

            this.batcher.destroyManager();
            this.batcher = null;

            this._entityIndex = {};

            this.defaultLayerDepth.onPreRenderOpaque = null;
            this.defaultLayerDepth.onPostRenderOpaque = null;
            this.defaultLayerDepth.onDisable = null;
            this.defaultLayerDepth.onEnable = null;
            this.defaultLayerDepth = null;
            this.defaultLayerWorld = null;

            destroyPostEffectQuad();

            if (this.vr) {
                this.vr.destroy();
                this.vr = null;
            }
            this.xr.end();

            this.graphicsDevice.destroy();
            this.graphicsDevice = null;

            this.renderer = null;
            this.tick = null;

            this.off(); // remove all events

            if (this._soundManager) {
                this._soundManager.destroy();
                this._soundManager = null;
            }

            script.app = null;

            // remove default particle texture
            ParticleEmitter.DEFAULT_PARAM_TEXTURE = null;

            Application._applications[canvasId] = null;

            if (Application._currentApplication === this) {
                Application._currentApplication = null;
            }
        },

        /**
         * @private
         * @function
         * @name pc.Application#getEntityFromIndex
         * @description Get entity from the index by guid.
         * @param {string} guid - The GUID to search for.
         * @returns {pc.Entity} The Entity with the GUID or null.
         */
        getEntityFromIndex: function (guid) {
            return this._entityIndex[guid];
        }
    });

    // static data
    var _frameEndData = {};

    // create tick function to be wrapped in closure
    var makeTick = function (_app) {
        var application = _app;
        var frameRequest;

        return function (timestamp, frame) {
            if (!application.graphicsDevice)
                return;

            Application._currentApplication = application;

            if (frameRequest) {
                window.cancelAnimationFrame(frameRequest);
                frameRequest = null;
            }

            // have current application pointer in pc
            exports.app = application;

            var currentTime = application._processTimestamp(timestamp) || now();
            var ms = currentTime - (application._time || currentTime);
            var dt = ms / 1000.0;
            dt = math.clamp(dt, 0, application.maxDeltaTime);
            dt *= application.timeScale;

            application._time = currentTime;

            // Submit a request to queue up a new animation frame immediately
            if (application.vr && application.vr.display) {
                frameRequest = application.vr.display.requestAnimationFrame(application.tick);
            } else if (application.xr.session) {
                frameRequest = application.xr.session.requestAnimationFrame(application.tick);
            } else {
                frameRequest = window.requestAnimationFrame(application.tick);
            }

            if (application.graphicsDevice.contextLost)
                return;


            application.fire("frameupdate", ms);

            if (frame) {
                application.xr.update(frame);
                application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
            } else {
                application.graphicsDevice.defaultFramebuffer = null;
            }

            application.update(dt);

            application.fire("framerender");

            if (application.autoRender || application.renderNextFrame) {
                application.render();
                application.renderNextFrame = false;
            }

            // set event data
            _frameEndData.timestamp = now();
            _frameEndData.target = application;

            application.fire("frameend", _frameEndData);
            application.fire("frameEnd", _frameEndData);// deprecated old event, remove when editor updated

            if (application.vr && application.vr.display && application.vr.display.presenting) {
                application.vr.display.submitFrame();
            }
        };
    };

    function getDefaultMaterial() {
        return Application.getApplication().scene.defaultMaterial;
    }

    var id$1 = 0;

    /**
     * @class
     * @name pc.Material
     * @classdesc A material determines how a particular mesh instance is rendered. It specifies the shader and render state that is
     * set before the mesh instance is submitted to the graphics device.
     * @description Create a new Material instance.
     * @property {number} alphaTest The alpha test reference value to control which fragments are written to the currently
     * active render target based on alpha value. All fragments with an alpha value of less than the alphaTest reference value
     * will be discarded. alphaTest defaults to 0 (all fragments pass).
     * @property {boolean} alphaToCoverage Enables or disables alpha to coverage (WebGL2 only). When enabled, and if hardware anti-aliasing is on,
     * limited order-independent transparency can be achieved. Quality depends on the number of MSAA samples of the current render target.
     * It can nicely soften edges of otherwise sharp alpha cutouts, but isn't recommended for large area semi-transparent surfaces.
     * Note, that you don't need to enable blending to make alpha to coverage work. It will work without it, just like alphaTest.
     * @property {boolean} alphaWrite If true, the alpha component of fragments generated by the shader of this material is written to
     * the color buffer of the currently active render target. If false, the alpha component will not be written. Defaults to true.
     * @property {number} blendType Controls how primitives are blended when being written to the currently active render target.
     * Can be:
     *
     * * {@link pc.BLEND_SUBTRACTIVE}: Subtract the color of the source fragment from the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_ADDITIVE}: Add the color of the source fragment to the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_NORMAL}: Enable simple translucency for materials such as glass. This is equivalent to enabling a source blend mode of pc.BLENDMODE_SRC_ALPHA and a destination blend mode of pc.BLENDMODE_ONE_MINUS_SRC_ALPHA.
     * * {@link pc.BLEND_NONE}: Disable blending.
     * * {@link pc.BLEND_PREMULTIPLIED}: Similar to pc.BLEND_NORMAL expect the source fragment is assumed to have already been multiplied by the source alpha value.
     * * {@link pc.BLEND_MULTIPLICATIVE}: Multiply the color of the source fragment by the color of the destination fragment and write the result to the frame buffer.
     * * {@link pc.BLEND_ADDITIVEALPHA}: Same as pc.BLEND_ADDITIVE except the source RGB is multiplied by the source alpha.
     *
     * Defaults to pc.BLEND_NONE.
     * @property {boolean} blueWrite If true, the blue component of fragments generated by the shader of this material is written to
     * the color buffer of the currently active render target. If false, the blue component will not be written. Defaults to true.
     * @property {number} cull Controls how triangles are culled based on their face direction with respect to the viewpoint.
     * Can be:
     *
     * * {@link pc.CULLFACE_NONE}: Do not cull triangles based on face direction.
     * * {@link pc.CULLFACE_BACK}: Cull the back faces of triangles (do not render triangles facing away from the view point).
     * * {@link pc.CULLFACE_FRONT}: Cull the front faces of triangles (do not render triangles facing towards the view point).
     * * {@link pc.CULLFACE_FRONTANDBACK}: Cull both front and back faces (triangles will not be rendered).
     *
     * Defaults to pc.CULLFACE_BACK.
     * @property {boolean} depthTest If true, fragments generated by the shader of this material are only written to the
     * current render target if they pass the depth test. If false, fragments generated by the shader of this material are
     * written to the current render target regardless of what is in the depth buffer. Defaults to true.
     * @property {boolean} depthWrite If true, fragments generated by the shader of this material write a depth value to
     * the depth buffer of the currently active render target. If false, no depth value is written. Defaults to true.
     * @property {boolean} greenWrite If true, the green component of fragments generated by the shader of this material is written to
     * the color buffer of the currently active render target. If false, the green component will not be written. Defaults to true.
     * @property {string} name The name of the material.
     * @property {boolean} redWrite If true, the red component of fragments generated by the shader of this material is written to
     * the color buffer of the currently active render target. If false, the red component will not be written. Defaults to true.
     * @property {pc.Shader|null} shader The shader used by this material to render mesh instances (default is null).
     * @property {pc.StencilParameters|null} stencilFront Stencil parameters for front faces (default is null).
     * @property {pc.StencilParameters|null} stencilBack Stencil parameters for back faces (default is null).
     * @property {number} depthBias Offsets the output depth buffer value. Useful for decals to prevent z-fighting.
     * @property {number} slopeDepthBias Same as {@link pc.Material#depthBias}, but also depends on the slope of the triangle relative to the camera.
     */
    function Material() {
        this.name = "Untitled";
        this.id = id$1++;

        this._shader = null;
        this.variants = {};
        this.parameters = {};

        // Render states
        this.alphaTest = 0;
        this.alphaToCoverage = false;

        this.blend = false;
        this.blendSrc = BLENDMODE_ONE;
        this.blendDst = BLENDMODE_ZERO;
        this.blendEquation = BLENDEQUATION_ADD;

        this.separateAlphaBlend = false;
        this.blendSrcAlpha = BLENDMODE_ONE;
        this.blendDstAlpha = BLENDMODE_ZERO;
        this.blendAlphaEquation = BLENDEQUATION_ADD;

        this.cull = CULLFACE_BACK;

        this.depthTest = true;
        this.depthWrite = true;
        this.stencilFront = null;
        this.stencilBack = null;

        this.depthBias = 0;
        this.slopeDepthBias = 0;

        this.redWrite = true;
        this.greenWrite = true;
        this.blueWrite = true;
        this.alphaWrite = true;

        this.meshInstances = []; // The mesh instances referencing this material

        this._shaderVersion = 0;
        this._scene = null;
        this._dirtyBlend = false;

        this.dirty = true;
    }

    Object.defineProperty(Material.prototype, 'shader', {
        get: function () {
            return this._shader;
        },
        set: function (shader) {
            this._shader = shader;
        }
    });

    Object.defineProperty(Material.prototype, 'blendType', {
        get: function () {
            if ((!this.blend) &&
                (this.blendSrc === BLENDMODE_ONE) &&
                (this.blendDst === BLENDMODE_ZERO) &&
                (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_NONE;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_SRC_ALPHA) &&
                       (this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_NORMAL;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_ONE) &&
                       (this.blendDst === BLENDMODE_ONE) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_ADDITIVE;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_SRC_ALPHA) &&
                       (this.blendDst === BLENDMODE_ONE) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_ADDITIVEALPHA;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_DST_COLOR) &&
                       (this.blendDst === BLENDMODE_SRC_COLOR) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_MULTIPLICATIVE2X;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR) &&
                       (this.blendDst === BLENDMODE_ONE) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_SCREEN;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_ONE) &&
                       (this.blendDst === BLENDMODE_ONE) &&
                       (this.blendEquation === BLENDEQUATION_MIN)) {
                return BLEND_MIN;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_ONE) &&
                       (this.blendDst === BLENDMODE_ONE) &&
                       (this.blendEquation === BLENDEQUATION_MAX)) {
                return BLEND_MAX;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_DST_COLOR) &&
                       (this.blendDst === BLENDMODE_ZERO) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_MULTIPLICATIVE;
            } else if ((this.blend) &&
                       (this.blendSrc === BLENDMODE_ONE) &&
                       (this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA) &&
                       (this.blendEquation === BLENDEQUATION_ADD)) {
                return BLEND_PREMULTIPLIED;
            }
            return BLEND_NORMAL;
        },
        set: function (type) {
            var prevBlend = this.blend;
            switch (type) {
                case BLEND_NONE:
                    this.blend = false;
                    this.blendSrc = BLENDMODE_ONE;
                    this.blendDst = BLENDMODE_ZERO;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_NORMAL:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_SRC_ALPHA;
                    this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_PREMULTIPLIED:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_ONE;
                    this.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_ADDITIVE:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_ONE;
                    this.blendDst = BLENDMODE_ONE;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_ADDITIVEALPHA:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_SRC_ALPHA;
                    this.blendDst = BLENDMODE_ONE;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_MULTIPLICATIVE2X:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_DST_COLOR;
                    this.blendDst = BLENDMODE_SRC_COLOR;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_SCREEN:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;
                    this.blendDst = BLENDMODE_ONE;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_MULTIPLICATIVE:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_DST_COLOR;
                    this.blendDst = BLENDMODE_ZERO;
                    this.blendEquation = BLENDEQUATION_ADD;
                    break;
                case BLEND_MIN:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_ONE;
                    this.blendDst = BLENDMODE_ONE;
                    this.blendEquation = BLENDEQUATION_MIN;
                    break;
                case BLEND_MAX:
                    this.blend = true;
                    this.blendSrc = BLENDMODE_ONE;
                    this.blendDst = BLENDMODE_ONE;
                    this.blendEquation = BLENDEQUATION_MAX;
                    break;
            }
            if (prevBlend !== this.blend) {
                if (this._scene) {
                    this._scene.layers._dirtyBlend = true;
                } else {
                    this._dirtyBlend = true;
                }
            }
            this._updateMeshInstanceKeys();
        }
    });

    Material.prototype._cloneInternal = function (clone) {
        clone.name = this.name;
        clone.shader = this.shader;

        // Render states
        clone.alphaTest = this.alphaTest;
        clone.alphaToCoverage = this.alphaToCoverage;

        clone.blend = this.blend;
        clone.blendSrc = this.blendSrc;
        clone.blendDst = this.blendDst;
        clone.blendEquation = this.blendEquation;

        clone.separateAlphaBlend = this.separateAlphaBlend;
        clone.blendSrcAlpha = this.blendSrcAlpha;
        clone.blendDstAlpha = this.blendDstAlpha;
        clone.blendAlphaEquation = this.blendAlphaEquation;

        clone.cull = this.cull;

        clone.depthTest = this.depthTest;
        clone.depthWrite = this.depthWrite;
        clone.depthBias = this.depthBias;
        clone.slopeDepthBias = this.slopeDepthBias;
        if (this.stencilFront) clone.stencilFront = this.stencilFront.clone();
        if (this.stencilBack) {
            if (this.stencilFront === this.stencilBack) {
                clone.stencilBack = clone.stencilFront;
            } else {
                clone.stencilBack = this.stencilBack.clone();
            }
        }

        clone.redWrite = this.redWrite;
        clone.greenWrite = this.greenWrite;
        clone.blueWrite = this.blueWrite;
        clone.alphaWrite = this.alphaWrite;
    };

    Material.prototype.clone = function () {
        var clone = new Material();
        this._cloneInternal(clone);
        return clone;
    };

    Material.prototype._updateMeshInstanceKeys = function () {
        var i, meshInstances = this.meshInstances;
        for (i = 0; i < meshInstances.length; i++) {
            meshInstances[i].updateKey();
        }
    };

    Material.prototype.updateUniforms = function () {
    };

    Material.prototype.updateShader = function (device, scene, objDefs) {
        // For vanilla materials, the shader can only be set by the user
    };

    /**
     * @function
     * @name pc.Material#update
     * @description Applies any changes made to the material's properties.
     */
    Material.prototype.update = function () {
        this.dirty = true;
    };

    // Parameter management
    Material.prototype.clearParameters = function () {
        this.parameters = {};
    };

    Material.prototype.getParameters = function () {
        return this.parameters;
    };

    Material.prototype.clearVariants = function () {
        var meshInstance;
        this.variants = {};
        var j;
        for (var i = 0; i < this.meshInstances.length; i++) {
            meshInstance = this.meshInstances[i];
            for (j = 0; j < meshInstance._shader.length; j++) {
                meshInstance._shader[j] = null;
            }
        }
    };

    /**
     * @function
     * @name pc.Material#getParameter
     * @description Retrieves the specified shader parameter from a material.
     * @param {string} name - The name of the parameter to query.
     * @returns {object} The named parameter.
     */
    Material.prototype.getParameter = function (name) {
        return this.parameters[name];
    };

    /**
     * @function
     * @name pc.Material#setParameter
     * @description Sets a shader parameter on a material.
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|pc.Texture} data - The value for the specified parameter.
     * @param {number} [passFlags] - Mask describing which passes the material should be included in.
     */
    Material.prototype.setParameter = function (name, data, passFlags) {
        if (passFlags === undefined) passFlags = -524285; // All bits set except 2 - 18 range

        if (data === undefined && typeof name === 'object') {
            var uniformObject = name;
            if (uniformObject.length) {
                for (var i = 0; i < uniformObject.length; i++) {
                    this.setParameter(uniformObject[i]);
                }
                return;
            }
            name = uniformObject.name;
            data = uniformObject.value;
        }

        var param = this.parameters[name];
        if (param) {
            param.data = data;
            param.passFlags = passFlags;
        } else {
            this.parameters[name] = {
                scopeId: null,
                data: data,
                passFlags: passFlags
            };
        }
    };

    /**
     * @function
     * @name pc.Material#deleteParameter
     * @description Deletes a shader parameter on a material.
     * @param {string} name - The name of the parameter to delete.
     */
    Material.prototype.deleteParameter = function (name) {
        if (this.parameters[name]) {
            delete this.parameters[name];
        }
    };

    /**
     * @function
     * @name pc.Material#setParameters
     * @description Pushes all material parameters into scope.
     */
    Material.prototype.setParameters = function () {
        // Push each shader parameter into scope
        for (var paramName in this.parameters) {
            var parameter = this.parameters[paramName];
            parameter.scopeId.setValue(parameter.data);
        }
    };

    /**
     * @function
     * @name pc.Material#destroy
     * @description Removes this material from the scene and possibly frees up memory from its shaders (if there are no other materials using it).
     */
    Material.prototype.destroy = function () {
        this.variants = {};
        this.shader = null;

        var meshInstance, j;
        for (var i = 0; i < this.meshInstances.length; i++) {
            meshInstance = this.meshInstances[i];
            for (j = 0; j < meshInstance._shader.length; j++) {
                meshInstance._shader[j] = null;
            }
            meshInstance._material = null;
            var defaultMaterial = getDefaultMaterial();
            if (this !== defaultMaterial) {
                meshInstance.material = defaultMaterial;
            }
        }
    };

    function StandardMaterialOptionsBuilder() {
        this._mapXForms = null;
    }

    // Minimal options for Depth and Shadow passes
    StandardMaterialOptionsBuilder.prototype.updateMinRef = function (options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
        this._updateSharedOptions(options, stdMat, objDefs, pass);
        this._updateMinOptions(options, stdMat);
        this._updateUVOptions(options, stdMat, objDefs, true);
    };

    StandardMaterialOptionsBuilder.prototype.updateRef = function (options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128) {
        this._updateSharedOptions(options, stdMat, objDefs, pass);
        options.useTexCubeLod = device.useTexCubeLod;
        this._updateEnvOptions(options, stdMat, scene, prefilteredCubeMap128);
        this._updateMaterialOptions(options, stdMat);
        if (pass === SHADER_FORWARDHDR) {
            if (options.gamma) options.gamma = GAMMA_SRGBHDR;
            options.toneMap = TONEMAP_LINEAR;
        }
        options.hasTangents = objDefs && stdMat.normalMap && ((objDefs & SHADERDEF_TANGENTS) !== 0);
        this._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);
        this._updateUVOptions(options, stdMat, objDefs, false);
        options.clearCoat = stdMat.clearCoat;
        options.clearCoatGlossiness = stdMat.clearCoatGlossiness;
    };

    StandardMaterialOptionsBuilder.prototype._updateSharedOptions = function (options, stdMat, objDefs, pass) {
        options.pass = pass;
        options.alphaTest = stdMat.alphaTest > 0;
        options.forceFragmentPrecision = stdMat.forceFragmentPrecision || "";
        options.chunks = stdMat.chunks || "";
        options.blendType = stdMat.blendType;
        options.forceUv1 = stdMat.forceUv1;

        options.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
        options.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
        options.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
        options.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
        options.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;

        options.nineSlicedMode = stdMat.nineSlicedMode || 0;
    };

    StandardMaterialOptionsBuilder.prototype._updateUVOptions = function (options, stdMat, objDefs, minimalOptions) {
        var hasUv0 = false;
        var hasUv1 = false;
        var hasVcolor = false;
        if (objDefs) {
            hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
            hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
            hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
        }

        options.vertexColors = false;
        this._mapXForms = [];
        for (var p in _matTex2D) {
            this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);
        }
        this._mapXForms = null;
    };

    StandardMaterialOptionsBuilder.prototype._updateMinOptions = function (options, stdMat) {
        options.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;
        options.lights = [];
    };

    StandardMaterialOptionsBuilder.prototype._updateMaterialOptions = function (options, stdMat) {
        var diffuseTint = ((stdMat.diffuse.r !== 1 || stdMat.diffuse.g !== 1 || stdMat.diffuse.b !== 1) &&
            (stdMat.diffuseTint || (!stdMat.diffuseMap && !stdMat.diffuseVertexColor))) ? 3 : 0;

        var specularTint = false;
        var useSpecular = (stdMat.useMetalness ? true : !!stdMat.specularMap) || (!!stdMat.sphereMap) || (!!stdMat.cubeMap) || (!!stdMat.dpAtlas);
        useSpecular = useSpecular || (stdMat.useMetalness ? true : !(stdMat.specular.r === 0 && stdMat.specular.g === 0 && stdMat.specular.b === 0));
        useSpecular = useSpecular || stdMat.enableGGXSpecular;
        useSpecular = useSpecular || (stdMat.clearCoat > 0);

        if (useSpecular) {
            if ((stdMat.specularTint || (!stdMat.specularMap && !stdMat.specularVertexColor)) && !stdMat.useMetalness) {
                specularTint = stdMat.specular.r !== 1 || stdMat.specular.g !== 1 || stdMat.specular.b !== 1;
            }
        }

        var emissiveTint = stdMat.emissiveMap ? 0 : 3;
        if (!emissiveTint) {
            emissiveTint = (stdMat.emissive.r !== 1 || stdMat.emissive.g !== 1 || stdMat.emissive.b !== 1 || stdMat.emissiveIntensity !== 1) && stdMat.emissiveTint;
            emissiveTint = emissiveTint ? 3 : (stdMat.emissiveIntensity !== 1 ? 1 : 0);
        }

        var isPackedNormalMap = stdMat.normalMap ? (stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR) : false;

        options.opacityTint = (stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE) ? 1 : 0;
        options.blendMapsWithColors = true;
        options.ambientTint = stdMat.ambientTint;
        options.diffuseTint = diffuseTint;
        options.specularTint = specularTint ? 3 : 0;
        options.metalnessTint = (stdMat.useMetalness && stdMat.metalness < 1) ? 1 : 0;
        options.glossTint = 1;
        options.emissiveTint = emissiveTint;
        options.alphaToCoverage = stdMat.alphaToCoverage;
        options.normalizeNormalMap = stdMat.normalizeNormalMap;
        options.sphereMap = !!stdMat.sphereMap;
        options.cubeMap = !!stdMat.cubeMap;
        options.dpAtlas = !!stdMat.dpAtlas;
        options.ambientSH = !!stdMat.ambientSH;
        options.useSpecular = useSpecular;
        options.emissiveFormat = stdMat.emissiveMap ? (stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : (stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0)) : null;
        options.lightMapFormat = stdMat.lightMap ? (stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : (stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0)) : null;
        options.specularAntialias = stdMat.specularAntialias && (!!stdMat.normalMap) && (!!stdMat.normalMap.mipmaps) && !isPackedNormalMap;
        options.conserveEnergy = stdMat.conserveEnergy;
        options.occludeSpecular = stdMat.occludeSpecular;
        options.occludeSpecularFloat = (stdMat.occludeSpecularIntensity !== 1.0);
        options.occludeDirect = stdMat.occludeDirect;
        options.shadingModel = stdMat.shadingModel;
        options.fresnelModel = stdMat.fresnelModel;
        options.packedNormal = isPackedNormalMap;
        options.fastTbn = stdMat.fastTbn;
        options.cubeMapProjection = stdMat.cubeMapProjection;
        options.customFragmentShader = stdMat.customFragmentShader;
        options.refraction = !!stdMat.refraction;
        options.useMetalness = stdMat.useMetalness;
        options.enableGGXSpecular = stdMat.enableGGXSpecular;
        options.msdf = !!stdMat.msdfMap;
        options.twoSidedLighting = stdMat.twoSidedLighting;
        options.pixelSnap = stdMat.pixelSnap;
        options.aoMapUv = stdMat.aoUvSet; // backwards componen
        options.diffuseDetail = !!stdMat.diffuseMap;
        options.normalDetail = !!stdMat.normalMap;
        options.diffuseDetailMode = stdMat.diffuseDetailMode;
        options.detailModes = !!options.diffuseDetail;
    };

    StandardMaterialOptionsBuilder.prototype._updateEnvOptions = function (options, stdMat, scene, prefilteredCubeMap128) {
        var rgbmAmbient = (prefilteredCubeMap128 && prefilteredCubeMap128.type === TEXTURETYPE_RGBM) ||
            (stdMat.cubeMap && stdMat.cubeMap.type === TEXTURETYPE_RGBM) ||
            (stdMat.dpAtlas && stdMat.dpAtlas.type === TEXTURETYPE_RGBM);

        var hdrAmbient = (prefilteredCubeMap128 && (prefilteredCubeMap128.type === TEXTURETYPE_RGBM || prefilteredCubeMap128.format === PIXELFORMAT_RGBA32F)) ||
            (stdMat.cubeMap && (stdMat.cubeMap.type === TEXTURETYPE_RGBM || stdMat.cubeMap.format === PIXELFORMAT_RGBA32F)) ||
            (stdMat.dpAtlas && (stdMat.dpAtlas.type === TEXTURETYPE_RGBM || stdMat.dpAtlas.format === PIXELFORMAT_RGBA32F));

        var rgbmReflection = (prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas && prefilteredCubeMap128.type === TEXTURETYPE_RGBM) ||
            (stdMat.cubeMap && stdMat.cubeMap.type === TEXTURETYPE_RGBM) ||
            (stdMat.sphereMap && stdMat.sphereMap.type === TEXTURETYPE_RGBM) ||
            (stdMat.dpAtlas && stdMat.dpAtlas.type === TEXTURETYPE_RGBM);

        var hdrReflection = ((prefilteredCubeMap128 && !stdMat.cubeMap && !stdMat.sphereMap && !stdMat.dpAtlas) ? prefilteredCubeMap128.type === TEXTURETYPE_RGBM || prefilteredCubeMap128.format === PIXELFORMAT_RGBA32F : false) ||
            (stdMat.cubeMap && (stdMat.cubeMap.type === TEXTURETYPE_RGBM || stdMat.cubeMap.format === PIXELFORMAT_RGBA32F)) ||
            (stdMat.sphereMap && (stdMat.sphereMap.type === TEXTURETYPE_RGBM || stdMat.sphereMap.format === PIXELFORMAT_RGBA32F)) ||
            (stdMat.dpAtlas && (stdMat.dpAtlas.type === TEXTURETYPE_RGBM || stdMat.dpAtlas.format === PIXELFORMAT_RGBA32F));

        var globalSky128;
        if (stdMat.useSkybox && scene._skyboxPrefiltered)
            globalSky128 = scene._skyboxPrefiltered[0];

        options.fog = stdMat.useFog ? scene.fog : "none";
        options.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;
        options.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;
        options.rgbmAmbient = rgbmAmbient;
        options.hdrAmbient = hdrAmbient;
        options.rgbmReflection = rgbmReflection;
        options.hdrReflection = hdrReflection;
        options.useRgbm = rgbmReflection || rgbmAmbient || (stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM) || (stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM);
        options.fixSeams = prefilteredCubeMap128 ? prefilteredCubeMap128.fixCubemapSeams : (stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false);
        options.prefilteredCubemap = !!prefilteredCubeMap128;
        options.skyboxIntensity = (prefilteredCubeMap128 && globalSky128 && prefilteredCubeMap128 === globalSky128) && (scene.skyboxIntensity !== 1);
    };

    StandardMaterialOptionsBuilder.prototype._updateLightOptions = function (options, stdMat, objDefs, sortedLights, staticLightList) {
        options.lightMap = false;
        options.lightMapChannel = "";
        options.lightMapUv = 0;
        options.lightMapTransform = 0;
        options.lightMapWithoutAmbient = false;
        options.dirLightMap = false;

        if (objDefs) {
            options.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;

            if ((objDefs & SHADERDEF_LM) !== 0) {
                options.lightMapFormat = 1; // rgbm
                options.lightMap = true;
                options.lightMapChannel = "rgb";
                options.lightMapUv = 1;
                options.lightMapTransform = 0;
                options.lightMapWithoutAmbient = !stdMat.lightMap;
                options.useRgbm = true;
                if ((objDefs & SHADERDEF_DIRLM) !== 0) {
                    options.dirLightMap = true;
                }
            }
        }

        if (stdMat.useLighting) {
            var lightsFiltered = [];
            var mask = objDefs ? (objDefs >> 16) : 1;
            if (sortedLights) {
                this._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
                this._collectLights(LIGHTTYPE_POINT, sortedLights[LIGHTTYPE_POINT], lightsFiltered, mask, staticLightList);
                this._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);
            }
            options.lights = lightsFiltered;
        } else {
            options.lights = [];
        }

        if (options.lights.length === 0) {
            options.noShadow = true;
        }
    };

    StandardMaterialOptionsBuilder.prototype._updateTexOptions = function (options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {
        var mname = p + "Map";
        var vname = p + "VertexColor";
        var vcname = p + "VertexColorChannel";
        var cname = mname + "Channel";
        var tname = mname + "Transform";
        var uname = mname + "Uv";

        // Avoid overriding previous lightMap properties
        if (p !== "light") {
            options[mname] = false;
            options[cname] = "";
            options[tname] = 0;
            options[uname] = 0;
        }
        options[vname] = false;
        options[vcname] = "";

        var isOpacity = p === "opacity";
        if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage)
            return options;

        if (!minimalOptions || isOpacity) {
            if (p !== "height" && stdMat[vname]) {
                if (hasVcolor) {
                    options[vname] = stdMat[vname];
                    options[vcname] = stdMat[vcname];
                    options.vertexColors = true;
                }
            }
            if (stdMat[mname]) {
                var allow = true;
                if (stdMat[uname] === 0 && !hasUv0) allow = false;
                if (stdMat[uname] === 1 && !hasUv1) allow = false;
                if (allow) {
                    options[mname] = !!stdMat[mname];
                    options[tname] = this._getMapTransformID(stdMat[tname], stdMat[uname]);
                    options[cname] = stdMat[cname];
                    options[uname] = stdMat[uname];
                }
            }
        }
    };

    StandardMaterialOptionsBuilder.prototype._collectLights = function (lType, lights, lightsFiltered, mask, staticLightList) {
        var light;
        var i;
        for (i = 0; i < lights.length; i++) {
            light = lights[i];
            if (light.enabled) {
                if (light.mask & mask) {
                    if (lType !== LIGHTTYPE_DIRECTIONAL) {
                        if (light.isStatic) {
                            continue;
                        }
                    }
                    lightsFiltered.push(light);
                }
            }
        }

        if (staticLightList) {
            for (i = 0; i < staticLightList.length; i++) {
                light = staticLightList[i];
                if (light._type === lType) {
                    lightsFiltered.push(light);
                }
            }
        }
    };

    StandardMaterialOptionsBuilder.prototype._getMapTransformID = function (xform, uv) {
        if (!xform) return 0;
        if (!this._mapXForms[uv]) this._mapXForms[uv] = [];

        var i, same;
        for (i = 0; i < this._mapXForms[uv].length; i++) {
            same = true;
            if (this._mapXForms[uv][i][0] != xform.x) {
                same = false;
                break;
            }
            if (this._mapXForms[uv][i][1] != xform.y) {
                same = false;
                break;
            }
            if (this._mapXForms[uv][i][2] != xform.z) {
                same = false;
                break;
            }
            if (this._mapXForms[uv][i][3] != xform.w) {
                same = false;
                break;
            }
            if (same) {
                return i + 1;
            }
        }
        var newID = this._mapXForms[uv].length;
        this._mapXForms[uv][newID] = [];

        this._mapXForms[uv][newID][0] = xform.x;
        this._mapXForms[uv][newID][1] = xform.y;
        this._mapXForms[uv][newID][2] = xform.z;
        this._mapXForms[uv][newID][3] = xform.w;

        return newID + 1;
    };

    /**
     * @class
     * @name pc.StandardMaterial
     * @augments pc.Material
     * @classdesc A Standard material is the main, general purpose material that is most often used for rendering.
     * It can approximate a wide variety of surface types and can simulate dynamic reflected light.
     * Most maps can use 3 types of input values in any combination: constant (color or number), mesh vertex colors and a texture. All enabled inputs are multiplied together.
     *
     * @property {pc.Color} ambient The ambient color of the material. This color value is 3-component (RGB),
     * where each component is between 0 and 1.
     *
     * @property {pc.Color} diffuse The diffuse color of the material. This color value is 3-component (RGB),
     * where each component is between 0 and 1.
     * Defines basic surface color (aka albedo).
     * @property {boolean} diffuseTint Multiply main (primary) diffuse map and/or diffuse vertex color by the constant diffuse value.
     * @property {pc.Texture|null} diffuseMap The main (primary) diffuse map of the material (default is null).
     * @property {number} diffuseMapUv Main (primary) diffuse map UV channel.
     * @property {pc.Vec2} diffuseMapTiling Controls the 2D tiling of the main (primary) diffuse map.
     * @property {pc.Vec2} diffuseMapOffset Controls the 2D offset of the main (primary) diffuse map. Each component is between 0 and 1.
     * @property {string} diffuseMapChannel Color channels of the main (primary) diffuse map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {boolean} diffuseVertexColor Use mesh vertex colors for diffuse. If diffuseMap or are diffuseTint are set, they'll be multiplied by vertex colors.
     * @property {string} diffuseVertexColorChannel Vertex color channels to use for diffuse. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     *
     * @property {pc.Texture|null} diffuseDetailMap The detail (secondary) diffuse map of the material (default is null). Will only be used if main (primary) diffuse map is non-null.
     * @property {number} diffuseDetailMapUv Detail (secondary) diffuse map UV channel.
     * @property {pc.Vec2} diffuseDetailMapTiling Controls the 2D tiling of the detail (secondary) diffuse map.
     * @property {pc.Vec2} diffuseDetailMapOffset Controls the 2D offset of the detail (secondary) diffuse map. Each component is between 0 and 1.
     * @property {string} diffuseDetailMapChannel Color channels of the detail (secondary) diffuse map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {string} diffuseDetailMode Determines how the main (primary) and detail (secondary) diffuse maps are blended together. Can be:
     * * {@link pc.DETAILMODE_MUL}: Multiply together the primary and secondary colors.
     * * {@link pc.DETAILMODE_ADD}: Add together the primary and secondary colors.
     * * {@link pc.DETAILMODE_SCREEN}: Softer version of {@link pc.DETAILMODE_ADD}.
     * * {@link pc.DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color.
     * * {@link pc.DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker, component-wise.
     * * {@link pc.DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter, component-wise.
     * Defaults to {@link pc.DETAILMODE_MUL}.
     *
     * @property {pc.Color} specular The specular color of the material. This color value is 3-component (RGB),
     * where each component is between 0 and 1.
     * Defines surface reflection/specular color. Affects specular intensity and tint.
     * @property {boolean} specularTint Multiply specular map and/or specular vertex color by the constant specular value.
     * @property {pc.Texture|null} specularMap The specular map of the material (default is null).
     * @property {number} specularMapUv Specular map UV channel.
     * @property {pc.Vec2} specularMapTiling Controls the 2D tiling of the specular map.
     * @property {pc.Vec2} specularMapOffset Controls the 2D offset of the specular map. Each component is between 0 and 1.
     * @property {string} specularMapChannel Color channels of the specular map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {boolean} specularVertexColor Use mesh vertex colors for specular. If specularMap or are specularTint are set, they'll be multiplied by vertex colors.
     * @property {string} specularVertexColorChannel Vertex color channels to use for specular. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     *
     * @property {boolean} enableGGXSpecular Enables GGX specular. Also enables anisotropy parameter to set material anisotropy.
     * @property {number} anisotropy Defines amount of anisotropy. Requires enableGGXSpecular is set to true.
     * * When anisotropy == 0, specular is isotropic.
     * * When anisotropy < 0, anistropy direction aligns with the tangent, and specular anisotropy increases as the anisotropy value decreases to minimum of -1.
     * * When anisotropy > 0, anistropy direction aligns with the bi-normal, and specular anisotropy increases as anisotropy value increases to maximum of 1.
     *
     * @property {number} clearCoat Defines the strength of clear coat layer from 0 to 1. Clear coat layer is disabled when clearCoat == 0. Default value is 0 (disabled).
     * @property {number} clearCoatGlossiness Defines the glossiness of the clear coat layer from 0 (rough) to 1 (mirror).
     *
     * @property {boolean} useMetalness Use metalness properties instead of specular.
     * When enabled, diffuse colors also affect specular instead of the dedicated specular map.
     * This can be used as alternative to specular color to save space.
     * With metaless == 0, the pixel is assumed to be dielectric, and diffuse color is used as normal.
     * With metaless == 1, the pixel is fully metallic, and diffuse color is used as specular color instead.
     * @property {number} metalness Defines how much the surface is metallic. From 0 (dielectric) to 1 (metal).
     * @property {pc.Texture|null} metalnessMap Monochrome metalness map (default is null).
     * @property {number} metalnessMapUv Metalness map UV channel.
     * @property {pc.Vec2} metalnessMapTiling Controls the 2D tiling of the metalness map.
     * @property {pc.Vec2} metalnessMapOffset Controls the 2D offset of the metalness map. Each component is between 0 and 1.
     * @property {string} metalnessMapChannel Color channel of the metalness map to use. Can be "r", "g", "b" or "a".
     * @property {boolean} metalnessVertexColor Use mesh vertex colors for metalness. If metalnessMap is set, it'll be multiplied by vertex colors.
     * @property {string} metalnessVertexColorChannel Vertex color channel to use for metalness. Can be "r", "g", "b" or "a".
     *
     * @property {number} shininess Defines glossiness of the material from 0 (rough) to 100 (shiny mirror).
     * A higher shininess value results in a more focused specular highlight.
     * Glossiness map/vertex colors are always multiplied by this value (normalized to 0 - 1 range), or it is used directly as constant output.
     * @property {pc.Texture|null} glossMap Glossiness map (default is null). If specified, will be multiplied by normalized 'shininess' value and/or vertex colors.
     * @property {number} glossMapUv Gloss map UV channel.
     * @property {string} glossMapChannel Color channel of the gloss map to use. Can be "r", "g", "b" or "a".
     * @property {pc.Vec2} glossMapTiling Controls the 2D tiling of the gloss map.
     * @property {pc.Vec2} glossMapOffset Controls the 2D offset of the gloss map. Each component is between 0 and 1.
     * @property {boolean} glossVertexColor Use mesh vertex colors for glossiness. If glossMap is set, it'll be multiplied by vertex colors.
     * @property {string} glossVertexColorChannel Vertex color channel to use for glossiness. Can be "r", "g", "b" or "a".
     *
     * @property {number} refraction Defines the visibility of refraction. Material can refract the same cube map as used for reflections.
     * @property {number} refractionIndex Defines the index of refraction, i.e. The amount of distortion.
     * The value is calculated as (outerIor / surfaceIor), where inputs are measured indices of refraction, the one around the object and the one of it's own surface.
     * In most situations outer medium is air, so outerIor will be approximately 1. Then you only need to do (1.0 / surfaceIor).
     *
     * @property {pc.Color} emissive The emissive color of the material. This color value is 3-component (RGB),
     * where each component is between 0 and 1.
     * @property {boolean} emissiveTint Multiply emissive map and/or emissive vertex color by the constant emissive value.
     * @property {pc.Texture|null} emissiveMap The emissive map of the material (default is null). Can be HDR.
     * @property {number} emissiveIntensity Emissive color multiplier.
     * @property {number} emissiveMapUv Emissive map UV channel.
     * @property {pc.Vec2} emissiveMapTiling Controls the 2D tiling of the emissive map.
     * @property {pc.Vec2} emissiveMapOffset Controls the 2D offset of the emissive map. Each component is between 0 and 1.
     * @property {string} emissiveMapChannel Color channels of the emissive map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {boolean} emissiveVertexColor Use mesh vertex colors for emission. If emissiveMap or emissiveTint are set, they'll be multiplied by vertex colors.
     * @property {string} emissiveVertexColorChannel Vertex color channels to use for emission. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     *
     * @property {number} opacity The opacity of the material. This value can be between 0 and 1, where 0 is fully
     * transparent and 1 is fully opaque. If you want the material to be semi-transparent you also need to
     * set the {@link pc.Material#blendType} to pc.BLEND_NORMAL, pc.BLEND_ADDITIVE or any other mode.
     * Also note that for most semi-transparent objects you want {@link pc.Material#depthWrite} to be false, otherwise they can fully occlude objects behind them.
     * @property {pc.Texture|null} opacityMap The opacity map of the material (default is null).
     * @property {number} opacityMapUv Opacity map UV channel.
     * @property {string} opacityMapChannel Color channel of the opacity map to use. Can be "r", "g", "b" or "a".
     * @property {pc.Vec2} opacityMapTiling Controls the 2D tiling of the opacity map.
     * @property {pc.Vec2} opacityMapOffset Controls the 2D offset of the opacity map. Each component is between 0 and 1.
     * @property {boolean} opacityVertexColor Use mesh vertex colors for opacity. If opacityMap is set, it'll be multiplied by vertex colors.
     * @property {string} opacityVertexColorChannel Vertex color channels to use for opacity. Can be "r", "g", "b" or "a".
     *
     * @property {pc.Texture|null} normalMap The main (primary) normal map of the material (default is null).
     * The texture must contains normalized, tangent space normals.
     * @property {number} normalMapUv Main (primary) normal map UV channel.
     * @property {pc.Vec2} normalMapTiling Controls the 2D tiling of the main (primary) normal map.
     * @property {pc.Vec2} normalMapOffset Controls the 2D offset of the main (primary) normal map. Each component is between 0 and 1.
     * @property {number} bumpiness The bumpiness of the material. This value scales the assigned main (primary) normal map.
     * It should be normally between 0 (no bump mapping) and 1 (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
     *
     * @property {pc.Texture|null} normalDetailMap The detail (secondary) normal map of the material (default is null). Will only be used if main (primary) normal map is non-null.
     * @property {number} normalDetailMapUv Detail (secondary) normal map UV channel.
     * @property {pc.Vec2} normalDetailMapTiling Controls the 2D tiling of the detail (secondary) normal map.
     * @property {pc.Vec2} normalDetailMapOffset Controls the 2D offset of the detail (secondary) normal map. Each component is between 0 and 1.
     * @property {number} normalDetailMapBumpiness The bumpiness of the material. This value scales the assigned detail (secondary) normal map.
     * It should be normally between 0 (no bump mapping) and 1 (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect.
     *
     * @property {pc.Texture|null} heightMap The height map of the material (default is null). Used for a view-dependent parallax effect.
     * The texture must represent the height of the surface where darker pixels are lower and lighter pixels are higher.
     * It is recommended to use it together with a normal map.
     * @property {number} heightMapUv Height map UV channel.
     * @property {string} heightMapChannel Color channel of the height map to use. Can be "r", "g", "b" or "a".
     * @property {pc.Vec2} heightMapTiling Controls the 2D tiling of the height map.
     * @property {pc.Vec2} heightMapOffset Controls the 2D offset of the height map. Each component is between 0 and 1.
     * @property {number} heightMapFactor Height map multiplier. Affects the strength of the parallax effect.
     *
     * @property {pc.Texture|null} sphereMap The spherical environment map of the material (default is null). Affects reflections.
     * @property {pc.Texture|null} cubeMap The cubic environment map of the material (default is null). Overrides sphereMap. Affects reflections. If cubemap is prefiltered, will also affect ambient color.
     * @property {number} cubeMapProjection The type of projection applied to the cubeMap property:
     * * {@link pc.CUBEPROJ_NONE}: The cube map is treated as if it is infinitely far away.
     * * {@link pc.CUBEPROJ_BOX}: Box-projection based on a world space axis-aligned bounding box.
     * Defaults to pc.CUBEPROJ_NONE.
     * @property {pc.BoundingBox} cubeMapProjectionBox The world space axis-aligned bounding box defining the
     * box-projection used for the cubeMap property. Only used when cubeMapProjection is set to pc.CUBEPROJ_BOX.
     * @property {number} reflectivity Environment map intensity.
     *
     * @property {pc.Texture|null} lightMap A custom lightmap of the material (default is null). Lightmaps are textures that contain pre-rendered lighting. Can be HDR.
     * @property {number} lightMapUv Lightmap UV channel
     * @property {string} lightMapChannel Color channels of the lightmap to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @property {pc.Vec2} lightMapTiling Controls the 2D tiling of the lightmap.
     * @property {pc.Vec2} lightMapOffset Controls the 2D offset of the lightmap. Each component is between 0 and 1.
     * @property {boolean} lightVertexColor Use baked vertex lighting. If lightMap is set, it'll be multiplied by vertex colors.
     * @property {string} lightVertexColorChannel Vertex color channels to use for baked lighting. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     *
     * @property {boolean} ambientTint Enables scene ambient multiplication by material ambient color.
     * @property {pc.Texture|null} aoMap Baked ambient occlusion (AO) map (default is null). Modulates ambient color.
     * @property {number} aoMapUv AO map UV channel
     * @property {string} aoMapChannel Color channel of the AO map to use. Can be "r", "g", "b" or "a".
     * @property {pc.Vec2} aoMapTiling Controls the 2D tiling of the AO map.
     * @property {pc.Vec2} aoMapOffset Controls the 2D offset of the AO map. Each component is between 0 and 1.
     * @property {boolean} aoVertexColor Use mesh vertex colors for AO. If aoMap is set, it'll be multiplied by vertex colors.
     * @property {string} aoVertexColorChannel Vertex color channels to use for AO. Can be "r", "g", "b" or "a".
     * @property {number} occludeSpecular Uses ambient occlusion to darken specular/reflection. It's a hack, because real specular occlusion is view-dependent. However, it can be better than nothing.
     * * {@link pc.SPECOCC_NONE}: No specular occlusion
     * * {@link pc.SPECOCC_AO}: Use AO directly to occlude specular.
     * * {@link pc.SPECOCC_GLOSSDEPENDENT}: Modify AO based on material glossiness/view angle to occlude specular.
     * @property {number} occludeSpecularIntensity Controls visibility of specular occlusion.
     * @property {number} occludeDirect Tells if AO should darken directional lighting.
     *
     * @property {boolean} specularAntialias Enables Toksvig AA for mipmapped normal maps with specular.
     * @property {boolean} conserveEnergy Defines how diffuse and specular components are combined when Fresnel is on.
     * It is recommended that you leave this option enabled, although you may want to disable it in case when all reflection comes only from a few light sources, and you don't use an environment map, therefore having mostly black reflection.
     * @property {number} shadingModel Defines the shading model.
     * * {@link pc.SPECULAR_PHONG}: Phong without energy conservation. You should only use it as a backwards compatibility with older projects.
     * * {@link pc.SPECULAR_BLINN}: Energy-conserving Blinn-Phong.
     * @property {number} fresnelModel Defines the formula used for Fresnel effect.
     * As a side-effect, enabling any Fresnel model changes the way diffuse and reflection components are combined.
     * When Fresnel is off, legacy non energy-conserving combining is used. When it is on, combining behaviour is defined by conserveEnergy parameter.
     * * {@link pc.FRESNEL_NONE}: No Fresnel.
     * * {@link pc.FRESNEL_SCHLICK}: Schlick's approximation of Fresnel (recommended). Parameterized by specular color.
     * @property {boolean} useFog Apply fogging (as configured in scene settings)
     * @property {boolean} useLighting Apply lighting
     * @property {boolean} useSkybox Apply scene skybox as prefiltered environment map
     * @property {boolean} useGammaTonemap Apply gamma correction and tonemapping (as configured in scene settings)
     * @property {boolean} pixelSnap Align vertices to pixel co-ordinates when rendering. Useful for pixel perfect 2D graphics
     * @property {boolean} twoSidedLighting Calculate proper normals (and therefore lighting) on backfaces
     * @property {object} chunks Object containing custom shader chunks that will replace default ones.
     *
     * @property {pc.callbacks.UpdateShader} onUpdateShader A custom function that will be called after all shader generator properties are collected and before shader code is generated.
     * This function will receive an object with shader generator settings (based on current material and scene properties), that you can change and then return.
     * Returned value will be used instead. This is mostly useful when rendering the same set of objects, but with different shader variations based on the same material.
     * For example, you may wish to render a depth or normal pass using textures assigned to the material, a reflection pass with simpler shaders and so on.
     * Properties of the object passed into this function are:
     * * pass: value of {@link pc.Layer#shaderPass} of the Layer being rendered.
     * * chunks: Object containing custom shader chunks that will replace default ones.
     * * customFragmentShader: Completely replace fragment shader with this code.
     * * forceUv1: if UV1 (second set of texture coordinates) is required in the shader. Will be declared as "vUv1" and passed to the fragment shader.
     * * fog: the type of fog being applied in the shader. See {@link pc.Scene#fog} for the list of possible values.
     * * gamma: the type of gamma correction being applied in the shader. See {@link pc.Scene#gammaCorrection} for the list of possible values.
     * * toneMap: the type of tone mapping being applied in the shader. See {@link pc.Scene#toneMapping} for the list of possible values.
     * * ambientTint: the value of {@link pc.StandardMaterial#ambientTint}.
     * * specularAntialias: the value of {@link pc.StandardMaterial#specularAntialias}.
     * * conserveEnergy: the value of {@link pc.StandardMaterial#conserveEnergy}.
     * * occludeSpecular: the value of {@link pc.StandardMaterial#occludeSpecular}.
     * * occludeDirect: the value of {@link pc.StandardMaterial#occludeDirect}.
     * * shadingModel: the value of {@link pc.StandardMaterial#shadingModel}.
     * * fresnelModel: the value of {@link pc.StandardMaterial#fresnelModel}.
     * * cubeMapProjection: the value of {@link pc.StandardMaterial#cubeMapProjection}.
     * * useMetalness: the value of {@link pc.StandardMaterial#useMetalness}.
     * * blendType: the value of {@link pc.Material#blendType}.
     * * twoSidedLighting: the value of {@link pc.Material#twoSidedLighting}.
     * * diffuseTint: defines if {@link pc.StandardMaterial#diffuse} constant should affect diffuse color.
     * * specularTint: defines if {@link pc.StandardMaterial#specular} constant should affect specular color.
     * * metalnessTint: defines if {@link pc.StandardMaterial#metalness} constant should affect metalness value.
     * * glossTint: defines if {@link pc.StandardMaterial#shininess} constant should affect glossiness value.
     * * emissiveTint: defines if {@link pc.StandardMaterial#emissive} constant should affect emission value.
     * * opacityTint: defines if {@link pc.StandardMaterial#opacity} constant should affect opacity value.
     * * occludeSpecularFloat: defines if {@link pc.StandardMaterial#occludeSpecularIntensity} constant should affect specular occlusion.
     * * alphaTest: enable alpha testing. See {@link pc.Material#alphaTest}.
     * * alphaToCoverage: enable alpha to coverage. See {@link pc.Material#alphaToCoverage}.
     * * sphereMap: if {@link pc.StandardMaterial#sphereMap} is used.
     * * cubeMap: if {@link pc.StandardMaterial#cubeMap} is used.
     * * dpAtlas: if dual-paraboloid reflection is used. Dual paraboloid reflections replace prefiltered cubemaps on certain platform (mostly Android) for performance reasons.
     * * ambientSH: if ambient spherical harmonics are used. Ambient SH replace prefiltered cubemap ambient on certain platform (mostly Android) for performance reasons.
     * * useSpecular: if any specular or reflections are needed at all.
     * * rgbmAmbient: if ambient cubemap or spherical harmonics are RGBM-encoded.
     * * hdrAmbient: if ambient cubemap or spherical harmonics are plain float HDR data.
     * * rgbmReflection: if reflection cubemap or dual paraboloid are RGBM-encoded.
     * * hdrReflection: if reflection cubemap or dual paraboloid are plain float HDR data.
     * * fixSeams: if cubemaps require seam fixing (see {@link pc.Texture#options.fixCubemapSeams}).
     * * prefilteredCubemap: if prefiltered cubemaps are used.
     * * emissiveFormat: how emissiveMap must be sampled. This value is based on {@link pc.Texture#options.rgbm} and {@link pc.Texture#options.format}. Possible values are:
     *   * 0: sRGB texture
     *   * 1: RGBM-encoded HDR texture
     *   * 2: Simple read (no conversion from sRGB)
     * * lightMapFormat: how lightMap must be sampled. This value is based on {@link pc.Texture#options.rgbm} and {@link pc.Texture#options.format}. Possible values are:
     *   * 0: sRGB texture
     *   * 1: RGBM-encoded HDR texture
     *   * 2: Simple read (no conversion from sRGB)
     * * useRgbm: if decodeRGBM() function is needed in the shader at all.
     * * packedNormal: if normal map contains X in RGB, Y in Alpha, and Z must be reconstructed.
     * * forceFragmentPrecision: Override fragment shader numeric precision. Can be "lowp", "mediump", "highp" or null to use default.
     * * fastTbn: Use slightly cheaper normal mapping code (skip tangent space normalization). Can look buggy sometimes.
     * * refraction: if refraction is used.
     * * skyboxIntensity: if reflected skybox intensity should be modulated.
     * * useTexCubeLod: if textureCubeLodEXT function should be used to read prefiltered cubemaps. Usually true of iOS, false on other devices due to quality/performance balance.
     * * useInstancing: if hardware instancing compatible shader should be generated. Transform is read from per-instance {@link pc.VertexBuffer} instead of shader's uniforms.
     * * useMorphPosition: if morphing code should be generated to morph positions.
     * * useMorphNormal: if morphing code should be generated to morph normals.
     * @example
     * // Create a new Standard material
     * var material = new pc.StandardMaterial();
     *
     * // Update the material's diffuse and specular properties
     * material.diffuse.set(1, 0, 0);
     * material.specular.set(1, 1, 1);
     *
     * // Notify the material that it has been modified
     * material.update();
     */
    function StandardMaterial() {
        Material.call(this);

        // storage for texture and cubemap asset references
        this._assetReferences = {};
        this._validator = null;

        this.shaderOptBuilder = new StandardMaterialOptionsBuilder();

        this.reset();
    }
    StandardMaterial.prototype = Object.create(Material.prototype);
    StandardMaterial.prototype.constructor = StandardMaterial;

    StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
    StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;

    var _propsSerial = [];
    var _propsSerialDefaultVal = [];
    var _propsInternalNull = [];
    var _propsInternalVec3 = [];
    var _prop2Uniform = {};

    var _defineTex2D = function (obj, name, uv, channels, defChannel, vertexColor, detailMode) {
        var privMap = "_" + name + "Map";
        var privMapTiling = privMap + "Tiling";
        var privMapOffset = privMap + "Offset";
        var mapTransform = privMap.substring(1) + "Transform";
        var mapTransformUniform = mapTransform + "Uniform";
        var privMapUv = privMap + "Uv";
        var privMapChannel = privMap + "Channel";
        var privMapVertexColor = "_" + name + "VertexColor";
        var privMapVertexColorChannel = "_" + name + "VertexColorChannel";
        var privMapDetailMode = "_" + name + "Mode";

        obj[privMap] = null;
        obj[privMapTiling] = new Vec2(1, 1);
        obj[privMapOffset] = new Vec2(0, 0);
        obj[mapTransform] = null;
        obj[mapTransformUniform] = null;
        obj[privMapUv] = uv;
        if (channels > 0) {
            var channel = defChannel ? defChannel : (channels > 1 ? "rgb" : "g");
            obj[privMapChannel] = channel;
            if (vertexColor) obj[privMapVertexColorChannel] = channel;
        }
        if (vertexColor) obj[privMapVertexColor] = false;
        if (detailMode) obj[privMapDetailMode] = DETAILMODE_MUL;

        _matTex2D[name] = channels;

        Object.defineProperty(StandardMaterial.prototype, privMap.substring(1), {
            get: function () {
                return this[privMap];
            },
            set: function (value) {
                var oldVal = this[privMap];
                if (!!oldVal ^ !!value) this.dirtyShader = true;
                if (oldVal && value) {
                    if (oldVal.type !== value.type || oldVal.fixCubemapSeams !== value.fixCubemapSeams || oldVal.format !== value.format) {
                        this.dirtyShader = true;
                    }
                }

                this[privMap] = value;
            }
        });

        var mapTiling = privMapTiling.substring(1);
        var mapOffset = privMapOffset.substring(1);

        Object.defineProperty(StandardMaterial.prototype, mapTiling, {
            get: function () {
                return this[privMapTiling];
            },
            set: function (value) {
                this.dirtyShader = true;
                this[privMapTiling] = value;
            }
        });
        _prop2Uniform[mapTiling] = function (mat, val, changeMat) {
            var tform = mat._updateMapTransform(
                changeMat ? mat[mapTransform] : null,
                val,
                mat[privMapOffset]
            );
            return { name: ("texture_" + mapTransform), value: tform.data };
        };

        Object.defineProperty(StandardMaterial.prototype, mapOffset, {
            get: function () {
                return this[privMapOffset];
            },
            set: function (value) {
                this.dirtyShader = true;
                this[privMapOffset] = value;
            }
        });
        _prop2Uniform[mapOffset] = function (mat, val, changeMat) {
            var tform = mat._updateMapTransform(
                changeMat ? mat[mapTransform] : null,
                mat[privMapTiling],
                val
            );
            return { name: ("texture_" + mapTransform), value: tform.data };
        };

        Object.defineProperty(StandardMaterial.prototype, privMapUv.substring(1), {
            get: function () {
                return this[privMapUv];
            },
            set: function (value) {
                if (this[privMapUv] !== value) this.dirtyShader = true;
                this[privMapUv] = value;
            }
        });
        Object.defineProperty(StandardMaterial.prototype, privMapChannel.substring(1), {
            get: function () {
                return this[privMapChannel];
            },
            set: function (value) {
                if (this[privMapChannel] !== value) this.dirtyShader = true;
                this[privMapChannel] = value;
            }
        });

        if (vertexColor) {
            Object.defineProperty(StandardMaterial.prototype, privMapVertexColor.substring(1), {
                get: function () {
                    return this[privMapVertexColor];
                },
                set: function (value) {
                    this.dirtyShader = true;
                    this[privMapVertexColor] = value;
                }
            });
            Object.defineProperty(StandardMaterial.prototype, privMapVertexColorChannel.substring(1), {
                get: function () {
                    return this[privMapVertexColorChannel];
                },
                set: function (value) {
                    if (this[privMapVertexColorChannel] !== value) this.dirtyShader = true;
                    this[privMapVertexColorChannel] = value;
                }
            });
        }

        if (detailMode) {
            Object.defineProperty(StandardMaterial.prototype, privMapDetailMode.substring(1), {
                get: function () {
                    return this[privMapDetailMode];
                },
                set: function (value) {
                    this.dirtyShader = true;
                    this[privMapDetailMode] = value;
                }
            });
        }

        _propsSerial.push(privMap.substring(1));
        _propsSerial.push(privMapTiling.substring(1));
        _propsSerial.push(privMapOffset.substring(1));
        _propsSerial.push(privMapUv.substring(1));
        _propsSerial.push(privMapChannel.substring(1));
        if (vertexColor) {
            _propsSerial.push(privMapVertexColor.substring(1));
            _propsSerial.push(privMapVertexColorChannel.substring(1));
        }
        if (detailMode) {
            _propsSerial.push(privMapDetailMode.substring(1));
        }
        _propsInternalNull.push(mapTransform);
    };

    var _propsColor = [];
    var _defineColor = function (obj, name, defaultValue, hasMultiplier) {
        var priv = "_" + name;
        var uform = name + "Uniform";
        var mult = name + "Intensity";
        var pmult = "_" + mult;
        obj[priv] = defaultValue;
        obj[uform] = new Float32Array(3);
        Object.defineProperty(StandardMaterial.prototype, name, {
            get: function () {
                this.dirtyColor = true;
                this.dirtyShader = true;
                return this[priv];
            },
            set: function (newValue) {
                var oldValue = this[priv];
                var wasRound = (oldValue.r === 0 && oldValue.g === 0 && oldValue.b === 0) || (oldValue.r === 1 && oldValue.g === 1 && oldValue.b === 1);
                var isRound = (newValue.r === 0 && newValue.g === 0 && newValue.b === 0) || (newValue.r === 1 && newValue.g === 1 && newValue.b === 1);
                if (wasRound ^ isRound) this.dirtyShader = true;
                this.dirtyColor = true;
                this[priv] = newValue;
            }
        });
        _propsSerial.push(name);
        _propsInternalVec3.push(uform);
        _propsColor.push(name);
        _prop2Uniform[name] = function (mat, val, changeMat) {
            var arr = changeMat ? mat[uform] : new Float32Array(3);
            var gammaCorrection = false;
            if (mat.useGammaTonemap) {
                var scene = mat._scene || Application.getApplication().scene;
                gammaCorrection = scene.gammaCorrection;
            }
            for (var c = 0; c < 3; c++) {
                if (gammaCorrection) {
                    arr[c] = Math.pow(val.data[c], 2.2);
                } else {
                    arr[c] = val.data[c];
                }
                if (hasMultiplier) arr[c] *= mat[pmult];
            }
            return { name: ("material_" + name), value: arr };
        };

        if (hasMultiplier) {
            obj[pmult] = 1;
            Object.defineProperty(StandardMaterial.prototype, mult, {
                get: function () {
                    return this[pmult];
                },
                set: function (newValue) {
                    var oldValue = this[pmult];
                    var wasRound = oldValue === 0 || oldValue === 1;
                    var isRound = newValue === 0 || newValue === 1;
                    if (wasRound ^ isRound) this.dirtyShader = true;
                    this.dirtyColor = true;
                    this[pmult] = newValue;
                }
            });
            _propsSerial.push(mult);
            _prop2Uniform[mult] = function (mat, val, changeMat) {
                var arr = changeMat ? mat[uform] : new Float32Array(3);
                var gammaCorrection = false;
                if (mat.useGammaTonemap) {
                    var scene = mat._scene || Application.getApplication().scene;
                    gammaCorrection = scene.gammaCorrection;
                }
                for (var c = 0; c < 3; c++) {
                    if (gammaCorrection) {
                        arr[c] = Math.pow(mat[priv].data[c], 2.2);
                    } else {
                        arr[c] = mat[priv].data[c];
                    }
                    arr[c] *= mat[pmult];
                }
                return { name: ("material_" + name), value: arr };
            };
        }
    };

    var _defineFloat = function (obj, name, defaultValue, func) {
        var priv = "_" + name;
        obj[priv] = defaultValue;
        Object.defineProperty(StandardMaterial.prototype, name, {
            get: function () {
                return this[priv];
            },
            set: function (newValue) {
                var oldValue = this[priv];
                if (oldValue === newValue) return;
                this[priv] = newValue;

               // This is not always optimal and will sometimes trigger redundant shader
               // recompilation. However, no number property on a standard material
               // triggers a shader recompile if the previous and current values both
               // have a fractional part.
                var wasRound = oldValue === 0 || oldValue === 1;
                var isRound = newValue === 0 || newValue === 1;
                if (wasRound || isRound) this.dirtyShader = true;
            }
        });
        _propsSerial.push(name);
        _prop2Uniform[name] = func !== undefined ? func : function (mat, val, changeMat) {
            return {
                name: "material_" + name,
                value: val
            };
        };
    };

    var _defineObject = function (obj, name, func) {
        var priv = "_" + name;
        obj[priv] = null;
        Object.defineProperty(StandardMaterial.prototype, name, {
            get: function () {
                return this[priv];
            },
            set: function (value) {
                var oldVal = this[priv];
                if (!!oldVal ^ !!value) this.dirtyShader = true;
                this[priv] = value;
            }
        });
        _propsSerial.push(name);
        _prop2Uniform[name] = func;
    };

    var _defineAlias = function (obj, newName, oldName) {
        Object.defineProperty(StandardMaterial.prototype, oldName, {
            get: function () {
                return this[newName];
            },
            set: function (value) {
                this[newName] = value;
            }
        });
    };

    var _defineChunks = function (obj) {
        Object.defineProperty(StandardMaterial.prototype, "chunks", {
            get: function () {
                this.dirtyShader = true;
                return this._chunks;
            },
            set: function (value) {
                this.dirtyShader = true;
                this._chunks = value;
            }
        });
        _propsSerial.push("chunks");
    };

    var _defineFlag = function (obj, name, defaultValue) {
        var priv = "_" + name;
        obj[priv] = defaultValue;
        Object.defineProperty(StandardMaterial.prototype, name, {
            get: function () {
                return this[priv];
            },
            set: function (value) {
                if (this[priv] !== value) this.dirtyShader = true;
                this[priv] = value;
            }
        });
        _propsSerial.push(name);
    };

    var Chunks = function () { };
    Chunks.prototype.copy = function (from) {
        for (var p in from) {
            if (from.hasOwnProperty(p) && p !== 'copy')
                this[p] = from[p];
        }
    };

    Object.assign(StandardMaterial.prototype, {

        reset: function () {
            var i;
            for (i = 0; i < _propsSerial.length; i++) {
                var defVal = _propsSerialDefaultVal[i];
                this[_propsSerial[i]] = defVal ? (defVal.clone ? defVal.clone() : defVal) : defVal;
            }
            for (i = 0; i < _propsInternalNull.length; i++) {
                this[_propsInternalNull[i]] = null;
            }
            for (i = 0; i < _propsInternalVec3.length; i++) {
                this[_propsInternalVec3[i]] = new Float32Array(3);
            }

            this._chunks = new Chunks();

            this.cubeMapMinUniform = new Float32Array(3);
            this.cubeMapMaxUniform = new Float32Array(3);
        },


       /**
        * @function
        * @name pc.StandardMaterial#clone
        * @description Duplicates a Standard material. All properties are duplicated except textures
        * where only the references are copied.
        * @returns {pc.StandardMaterial} A cloned Standard material.
        */
        clone: function () {
            var clone = new StandardMaterial();
            Material.prototype._cloneInternal.call(this, clone);

            var pname;
            for (var i = 0; i < _propsSerial.length; i++) {
                pname = _propsSerial[i];
                if (this[pname] !== undefined) {
                    if (this[pname] && this[pname].copy) {
                        if (clone[pname]) {
                            clone[pname].copy(this[pname]);
                        } else {
                            clone[pname] = this[pname].clone();
                        }
                    } else {
                        clone[pname] = this[pname];
                    }
                }
            }

            return clone;
        },

        _updateMapTransform: function (transform, tiling, offset) {
            transform = transform || new Vec4();
            transform.set(tiling.x, tiling.y, offset.x, offset.y);

            if ((transform.x === 1) && (transform.y === 1) && (transform.z === 0) && (transform.w === 0)) return null;
            return transform;
        },

        _setParameter: function (name, value) {
            if (!this.parameters[name])
                this._propsSet.push(name);
            this.setParameter(name, value);
        },

        _clearParameters: function () {
            var props = this._propsSet;
            for (var i = 0; i < props.length; i++) {
                delete this.parameters[props[i]];
            }
            this._propsSet = [];
        },

        _updateMap: function (p) {
            var mname = p + "Map";
            if (this[mname]) {
                this._setParameter("texture_" + mname, this[mname]);
                var tname = mname + "Transform";
                var uname = mname + "TransformUniform";
                if (!this[tname]) {
                    this[uname] = new Float32Array(4);
                }
                this[tname] = this._updateMapTransform(
                    this[tname],
                    this[mname + "Tiling"],
                    this[mname + "Offset"]
                );

                if (this[tname]) {
                    this[uname][0] = this[tname].x;
                    this[uname][1] = this[tname].y;
                    this[uname][2] = this[tname].z;
                    this[uname][3] = this[tname].w;
                    this._setParameter('texture_' + tname, this[uname]);
                }
            }
        },

        getUniform: function (varName, value, changeMat) {
            var func = _prop2Uniform[varName];
            if (func) {
                return func(this, value, changeMat);
            }
            return null;
        },

        updateUniforms: function () {
            var uniform;
            this._clearParameters();

            this._setParameter('material_ambient', this.ambientUniform);

            if (!this.diffuseMap || this.diffuseTint) {
                this._setParameter('material_diffuse', this.diffuseUniform);
            }

            if (!this.useMetalness) {
                if (!this.specularMap || this.specularTint) {
                    this._setParameter('material_specular', this.specularUniform);
                }
            } else {
                if (!this.metalnessMap || this.metalness < 1) {
                    this._setParameter('material_metalness', this.metalness);
                }

                if (this.enableGGXSpecular){
                    this._setParameter('material_anisotropy', this.anisotropy);
                }
            }

            if (this.clearCoat > 0) {
                this._setParameter('material_clearCoatSpecularity', this.clearCoat);
                this._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);
                this._setParameter('material_clearCoatReflectivity', this.clearCoat); // for now don't separate this
            }

            uniform = this.getUniform("shininess", this.shininess, true);
            this._setParameter(uniform.name, uniform.value);

            if (!this.emissiveMap || this.emissiveTint) {
                this._setParameter('material_emissive', this.emissiveUniform);
            }
            if (this.emissiveMap) {
                this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
            }

            if (this.refraction > 0) {
                this._setParameter('material_refraction', this.refraction);
                this._setParameter('material_refractionIndex', this.refractionIndex);
            }

            this._setParameter('material_opacity', this.opacity);

            if (this.occludeSpecular) {
                this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
            }

            if (this.cubeMapProjection === CUBEPROJ_BOX) {
                this._setParameter(this.getUniform("cubeMapProjectionBox", this.cubeMapProjectionBox, true));
            }

            for (var p in _matTex2D) {
                this._updateMap(p);
            }

            if (this.ambientSH) {
                this._setParameter('ambientSH[0]', this.ambientSH);
            }

            if (this.normalMap) {
                this._setParameter('material_bumpiness', this.bumpiness);
            }

            if (this.normalMap && this.normalDetailMap) {
                this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
            }

            if (this.heightMap) {
                uniform = this.getUniform('heightMapFactor', this.heightMapFactor, true);
                this._setParameter(uniform.name, uniform.value);
            }

            if (this.cubeMap) {
                this._setParameter('texture_cubeMap', this.cubeMap);
            }

            if (this.prefilteredCubeMap128) {
                this._setParameter('texture_prefilteredCubeMap128', this.prefilteredCubeMap128);
            } else if (this._scene && this._scene._skyboxPrefiltered[0]) {
                this._setParameter('texture_prefilteredCubeMap128', this._scene._skyboxPrefiltered[0]);
            }

            if (this.prefilteredCubeMap64) {
                this._setParameter('texture_prefilteredCubeMap64', this.prefilteredCubeMap64);
            } else if (this._scene && this._scene._skyboxPrefiltered[1]) {
                this._setParameter('texture_prefilteredCubeMap64', this._scene._skyboxPrefiltered[1]);
            }

            if (this.prefilteredCubeMap32) {
                this._setParameter('texture_prefilteredCubeMap32', this.prefilteredCubeMap32);
            } else if (this._scene && this._scene._skyboxPrefiltered[2]) {
                this._setParameter('texture_prefilteredCubeMap32', this._scene._skyboxPrefiltered[2]);
            }

            if (this.prefilteredCubeMap16) {
                this._setParameter('texture_prefilteredCubeMap16', this.prefilteredCubeMap16);
            } else if (this._scene && this._scene._skyboxPrefiltered[3]) {
                this._setParameter('texture_prefilteredCubeMap16', this._scene._skyboxPrefiltered[3]);
            }

            if (this.prefilteredCubeMap8) {
                this._setParameter('texture_prefilteredCubeMap8', this.prefilteredCubeMap8);
            } else if (this._scene && this._scene._skyboxPrefiltered[4]) {
                this._setParameter('texture_prefilteredCubeMap8', this._scene._skyboxPrefiltered[4]);
            }

            if (this.prefilteredCubeMap4) {
                this._setParameter('texture_prefilteredCubeMap4', this.prefilteredCubeMap4);
            } else if (this._scene && this._scene._skyboxPrefiltered[5]) {
                this._setParameter('texture_prefilteredCubeMap4', this._scene._skyboxPrefiltered[5]);
            }

            if (this.sphereMap) {
                this._setParameter('texture_sphereMap', this.sphereMap);
            }
            if (this.dpAtlas) {
                this._setParameter('texture_sphereMap', this.dpAtlas);
            }
           // if (this.sphereMap || this.cubeMap || this.prefilteredCubeMap128) {
            this._setParameter('material_reflectivity', this.reflectivity);
           // }

            if (this.dirtyShader || !this._scene) {
                this.shader = null;
                this.clearVariants();
            }

            this._processColor();
        },

        _processColor: function () {
            var c, i;
            if (!this.dirtyColor) return;
            if (!this._scene && this.useGammaTonemap) return;
            var gammaCorrection = false;
            if (this.useGammaTonemap) gammaCorrection = this._scene.gammaCorrection;

           // Gamma correct colors
            for (i = 0; i < _propsColor.length; i++) {
                var clr = this["_" + _propsColor[i]];
                var arr = this[_propsColor[i] + "Uniform"];
                if (gammaCorrection) {
                    arr[0] = Math.pow(clr.r, 2.2);
                    arr[1] = Math.pow(clr.g, 2.2);
                    arr[2] = Math.pow(clr.b, 2.2);
                } else {
                    arr[0] = clr.r;
                    arr[1] = clr.g;
                    arr[2] = clr.b;
                }
            }
            for (c = 0; c < 3; c++) {
                this.emissiveUniform[c] *= this.emissiveIntensity;
            }
            this.dirtyColor = false;
        },

        updateShader: function (device, scene, objDefs, staticLightList, pass, sortedLights) {

            if (!this._colorProcessed && this._scene) {
                this._colorProcessed = true;
                this._processColor();
            }

            var useTexCubeLod = device.useTexCubeLod;
            var useDp = !device.extTextureLod; // no basic extension? likely slow device, force dp

            var globalSky128, globalSky64, globalSky32, globalSky16, globalSky8, globalSky4;
            if (this.useSkybox) {
                globalSky128 = scene._skyboxPrefiltered[0];
                globalSky64 = scene._skyboxPrefiltered[1];
                globalSky32 = scene._skyboxPrefiltered[2];
                globalSky16 = scene._skyboxPrefiltered[3];
                globalSky8 = scene._skyboxPrefiltered[4];
                globalSky4 = scene._skyboxPrefiltered[5];
            }

            var prefilteredCubeMap128 = this.prefilteredCubeMap128 || globalSky128;
            var prefilteredCubeMap64 = this.prefilteredCubeMap64 || globalSky64;
            var prefilteredCubeMap32 = this.prefilteredCubeMap32 || globalSky32;
            var prefilteredCubeMap16 = this.prefilteredCubeMap16 || globalSky16;
            var prefilteredCubeMap8 = this.prefilteredCubeMap8 || globalSky8;
            var prefilteredCubeMap4 = this.prefilteredCubeMap4 || globalSky4;

            if (prefilteredCubeMap128) {
                var allMips = prefilteredCubeMap128 &&
                             prefilteredCubeMap64 &&
                             prefilteredCubeMap32 &&
                             prefilteredCubeMap16 &&
                             prefilteredCubeMap8 &&
                             prefilteredCubeMap4;

                if (useDp && allMips) {
                    if (!prefilteredCubeMap128.dpAtlas) {
                        var atlas = [prefilteredCubeMap128, prefilteredCubeMap64, prefilteredCubeMap32,
                            prefilteredCubeMap16, prefilteredCubeMap8, prefilteredCubeMap4];
                        prefilteredCubeMap128.dpAtlas = generateDpAtlas(device, atlas);
                        prefilteredCubeMap128.sh = shFromCubemap(prefilteredCubeMap16);
                    }
                    this.dpAtlas = prefilteredCubeMap128.dpAtlas;
                    this.ambientSH = prefilteredCubeMap128.sh;
                    this._setParameter('ambientSH[0]', this.ambientSH);
                    this._setParameter('texture_sphereMap', this.dpAtlas);
                } else if (useTexCubeLod) {
                    if (prefilteredCubeMap128._levels.length < 6) {
                        if (allMips) {
                           // Multiple -> single (provided cubemap per mip, but can use texCubeLod)
                            this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
                        } else {
                            console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
                        }
                    } else {
                       // Single (able to use single cubemap with texCubeLod)
                        this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
                    }
                } else if (allMips) {
                   // Multiple (no texCubeLod, but able to use cubemap per mip)
                    this._setParameter('texture_prefilteredCubeMap128', prefilteredCubeMap128);
                    this._setParameter('texture_prefilteredCubeMap64', prefilteredCubeMap64);
                    this._setParameter('texture_prefilteredCubeMap32', prefilteredCubeMap32);
                    this._setParameter('texture_prefilteredCubeMap16', prefilteredCubeMap16);
                    this._setParameter('texture_prefilteredCubeMap8', prefilteredCubeMap8);
                    this._setParameter('texture_prefilteredCubeMap4', prefilteredCubeMap4);
                } else {
                    console.log("Can't use prefiltered cubemap: " + allMips + ", " + useTexCubeLod + ", " + prefilteredCubeMap128._levels);
                }
            }

            var generator = programlib.standard;
           // Minimal options for Depth and Shadow passes
            var minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;
            var options = minimalOptions ? generator.optionsContextMin : generator.optionsContext;

            if (minimalOptions)
                this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);
            else
                this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights, prefilteredCubeMap128);

            if (this.onUpdateShader) {
                options = this.onUpdateShader(options);
            }

            var library = device.getProgramLibrary();
            this.shader = library.getProgram('standard', options);

            if (!objDefs) {
                this.clearVariants();
                this.variants[0] = this.shader;
            }

            this.dirtyShader = false;
        }
    });

    var _defineMaterialProps = function (obj) {

        obj.dirtyShader = true;
        obj.dirtyColor = true;
        obj._scene = null;
        obj._colorProcessed = false;

        _defineColor(obj, "ambient", new Color(0.7, 0.7, 0.7));
        _defineColor(obj, "diffuse", new Color(1, 1, 1));
        _defineColor(obj, "specular", new Color(0, 0, 0));
        _defineColor(obj, "emissive", new Color(0, 0, 0), true);

        _defineFloat(obj, "shininess", 25, function (mat, shininess) {
           // Shininess is 0-100 value
           // which is actually a 0-1 glosiness value.
           // Can be converted to specular power using exp2(shininess * 0.01 * 11)
            var value;
            if (mat.shadingModel === SPECULAR_PHONG) {
                value = Math.pow(2, shininess * 0.01 * 11); // legacy: expand back to specular power
            } else {
                value = shininess * 0.01; // correct
            }
            return { name: "material_shininess", value: value };
        });
        _defineFloat(obj, "heightMapFactor", 1, function (mat, height) {
            return { name: 'material_heightMapFactor', value: height * 0.025 };
        });
        _defineFloat(obj, "opacity", 1);
        _defineFloat(obj, "alphaTest", 0);
        _defineFloat(obj, "bumpiness", 1);
        _defineFloat(obj, "normalDetailMapBumpiness", 1);
        _defineFloat(obj, "reflectivity", 1);
        _defineFloat(obj, "occludeSpecularIntensity", 1);
        _defineFloat(obj, "refraction", 0);
        _defineFloat(obj, "refractionIndex", 1.0 / 1.5); // approx. (air ior / glass ior)
        _defineFloat(obj, "metalness", 1);
        _defineFloat(obj, "anisotropy", 0);
        _defineFloat(obj, "clearCoat", 0);
        _defineFloat(obj, "clearCoatGlossiness", 1);
        _defineFloat(obj, "aoUvSet", 0, null); // legacy

        _defineObject(obj, "ambientSH", function (mat, val, changeMat) {
            return { name: "ambientSH[0]", value: val };
        });

        _defineObject(obj, "cubeMapProjectionBox", function (mat, val, changeMat) {
            var bmin = changeMat ? mat.cubeMapMinUniform : new Float32Array(3);
            var bmax = changeMat ? mat.cubeMapMaxUniform : new Float32Array(3);

            bmin[0] = val.center.x - val.halfExtents.x;
            bmin[1] = val.center.y - val.halfExtents.y;
            bmin[2] = val.center.z - val.halfExtents.z;

            bmax[0] = val.center.x + val.halfExtents.x;
            bmax[1] = val.center.y + val.halfExtents.y;
            bmax[2] = val.center.z + val.halfExtents.z;

            return [{ name: "envBoxMin", value: bmin }, { name: "envBoxMax", value: bmax }];
        });

        _defineChunks();

        _defineFlag(obj, "ambientTint", false);

        _defineFlag(obj, "diffuseTint", false);
        _defineFlag(obj, "specularTint", false);
        _defineFlag(obj, "emissiveTint", false);
        _defineFlag(obj, "fastTbn", false);
        _defineFlag(obj, "specularAntialias", false);
        _defineFlag(obj, "useMetalness", false);
        _defineFlag(obj, "enableGGXSpecular", false);
        _defineFlag(obj, "occludeDirect", false);
        _defineFlag(obj, "normalizeNormalMap", true);
        _defineFlag(obj, "conserveEnergy", true);
        _defineFlag(obj, "occludeSpecular", SPECOCC_AO);
        _defineFlag(obj, "shadingModel", SPECULAR_BLINN);
        _defineFlag(obj, "fresnelModel", FRESNEL_NONE);
        _defineFlag(obj, "cubeMapProjection", CUBEPROJ_NONE);
        _defineFlag(obj, "customFragmentShader", null);
        _defineFlag(obj, "forceFragmentPrecision", null);
        _defineFlag(obj, "useFog", true);
        _defineFlag(obj, "useLighting", true);
        _defineFlag(obj, "useGammaTonemap", true);
        _defineFlag(obj, "useSkybox", true);
        _defineFlag(obj, "forceUv1", false);
        _defineFlag(obj, "pixelSnap", false);
        _defineFlag(obj, "twoSidedLighting", false);
        _defineFlag(obj, "nineSlicedMode", undefined); // NOTE: this used to be SPRITE_RENDERMODE_SLICED but was undefined pre-Rollup

        _defineTex2D(obj, "diffuse", 0, 3, "", true);
        _defineTex2D(obj, "specular", 0, 3, "", true);
        _defineTex2D(obj, "emissive", 0, 3, "", true);
        _defineTex2D(obj, "normal", 0, -1, "", false);
        _defineTex2D(obj, "metalness", 0, 1, "", true);
        _defineTex2D(obj, "gloss", 0, 1, "", true);
        _defineTex2D(obj, "opacity", 0, 1, "a", true);
        _defineTex2D(obj, "height", 0, 1, "", false);
        _defineTex2D(obj, "ao", 0, 1, "", true);
        _defineTex2D(obj, "light", 1, 3, "", true);
        _defineTex2D(obj, "msdf", 0, 3, "", false);
        _defineTex2D(obj, "diffuseDetail", 0, 3, "", false, true);
        _defineTex2D(obj, "normalDetail", 0, -1, "", false);

        _defineObject(obj, "cubeMap");
        _defineObject(obj, "sphereMap");
        _defineObject(obj, "dpAtlas");
        _defineObject(obj, "prefilteredCubeMap128");
        _defineObject(obj, "prefilteredCubeMap64");
        _defineObject(obj, "prefilteredCubeMap32");
        _defineObject(obj, "prefilteredCubeMap16");
        _defineObject(obj, "prefilteredCubeMap8");
        _defineObject(obj, "prefilteredCubeMap4");

        _defineAlias(obj, "diffuseTint", "diffuseMapTint");
        _defineAlias(obj, "specularTint", "specularMapTint");
        _defineAlias(obj, "emissiveTint", "emissiveMapTint");
        _defineAlias(obj, "aoVertexColor", "aoMapVertexColor");
        _defineAlias(obj, "diffuseVertexColor", "diffuseMapVertexColor");
        _defineAlias(obj, "specularVertexColor", "specularMapVertexColor");
        _defineAlias(obj, "emissiveVertexColor", "emissiveMapVertexColor");
        _defineAlias(obj, "metalnessVertexColor", "metalnessMapVertexColor");
        _defineAlias(obj, "glossVertexColor", "glossMapVertexColor");
        _defineAlias(obj, "opacityVertexColor", "opacityMapVertexColor");
        _defineAlias(obj, "lightVertexColor", "lightMapVertexColor");

        for (var i = 0; i < _propsSerial.length; i++) {
            _propsSerialDefaultVal[i] = obj[_propsSerial[i]];
        }

        obj._propsSet = [];
    };

    _defineMaterialProps(StandardMaterial.prototype);

    // Public interface
    function ProgramLibrary(device) {
        this._device = device;
        this._cache = {};
        this._generators = {};
        this._isClearingCache = false;
        this._precached = false;

        // Unique non-cached programs collection to dump and update game shaders cache
        this._programsCollection = [];
        this._defaultStdMatOption = {};
        this._defaultStdMatOptionMin = {};
        var m = new StandardMaterial();
        m.shaderOptBuilder.updateRef(
            this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);
        m.shaderOptBuilder.updateMinRef(
            this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);
    }

    ProgramLibrary.prototype.register = function (name, generator) {
        if (!this.isRegistered(name)) {
            this._generators[name] = generator;
        }
    };

    ProgramLibrary.prototype.unregister = function (name) {
        if (this.isRegistered(name)) {
            delete this._generators[name];
        }
    };

    ProgramLibrary.prototype.isRegistered = function (name) {
        var generator = this._generators[name];
        return (generator !== undefined);
    };

    ProgramLibrary.prototype.getProgram = function (name, options) {
        var generator = this._generators[name];
        if (generator === undefined) {
            return null;
        }
        var gd = this._device;
        var key = generator.generateKey(options);
        var shader = this._cache[key];
        if (!shader) {
            var lights;
            if (options.lights) {
                lights = options.lights;
                options.lights = lights.map(function (l) {
                    var lcopy = l.clone ? l.clone() : l;
                    lcopy.key = l.key;
                    return lcopy;
                });
            }

            this.storeNewProgram(name, options);

            if (options.lights)
                options.lights = lights;

            if (this._precached)
                console.warn("ProgramLibrary#getProgram: Cache miss for shader", name, "key", key, "after shaders precaching");

            var shaderDefinition = generator.createShaderDefinition(gd, options);
            shader = this._cache[key] = new Shader(gd, shaderDefinition);
        }
        return shader;
    };

    ProgramLibrary.prototype.storeNewProgram = function (name, options) {
        var opt = {};
        if (name === "standard") {
            // For standard material saving all default values is overkill, so we store only diff
            var defaultMat = this._getDefaultStdMatOptions(options.pass);

            for (var p in options) {
                if ((options.hasOwnProperty(p) && defaultMat[p] !== options[p]) || p === "pass")
                    opt[p] = options[p];
            }
        } else {
            // Other shaders have only dozen params
            opt = options;
        }

        this._programsCollection.push(JSON.stringify({ name: name, options: opt }));
    };

    // run pc.app.graphicsDevice.programLib.dumpPrograms(); from browser console to build shader options script
    ProgramLibrary.prototype.dumpPrograms = function () {
        var text = 'var device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
        text += 'var shaders = [';
        if (this._programsCollection[0])
            text += '\n\t' + this._programsCollection[0];
        for (var i = 1; i < this._programsCollection.length; ++i) {
            text += ',\n\t' + this._programsCollection[i];
        }
        text += '\n];\n';
        text += 'device.programLib.precompile(shaders);\n';
        text += 'if (pc.version != \"' + version + '\" || pc.revision != \"' + revision + '\")\n';
        text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';

        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', 'precompile-shaders.js');
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    };

    ProgramLibrary.prototype.clearCache = function () {
        var cache = this._cache;
        this._isClearingCache = true;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                cache[key].destroy();
            }
        }
        this._cache = {};
        this._isClearingCache = false;
    };

    ProgramLibrary.prototype.removeFromCache = function (shader) {
        if (this._isClearingCache) return; // don't delete by one when clearing whole cache
        var cache = this._cache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                if (cache[key] === shader) {
                    delete cache[key];
                    break;
                }
            }
        }
    };

    ProgramLibrary.prototype._getDefaultStdMatOptions = function (pass) {
        return (pass > SHADER_FORWARDHDR && pass <= SHADER_PICK) ?
            this._defaultStdMatOptionMin : this._defaultStdMatOption;
    };

    ProgramLibrary.prototype.precompile = function (cache) {

        if (cache) {
            var shaders = new Array(cache.length);
            for (var i = 0; i < cache.length; i++) {
                if (cache[i].name === "standard") {
                    var opt = cache[i].options;
                    var defaultMat = this._getDefaultStdMatOptions(opt.pass);
                    for (var p in defaultMat) {
                        if (defaultMat.hasOwnProperty(p) && opt[p] === undefined)
                            opt[p] = defaultMat[p];
                    }
                    // Patch device specific properties
                    opt.useTexCubeLod = this._device.useTexCubeLod;
                }
                shaders[i] = this.getProgram(cache[i].name, cache[i].options);
            }
            // Uncomment to force finish linking after preload
            // var device = this._device;
            // var forceLink = function () {
            //     for (var i = 0; i < shaders.length; i++) {
            //         device.postLink(shaders[i]);
            //     }
            // };
            // pc.Application.getApplication().on("preload:end", forceLink);
        }
        this._precached = true;
    };

    function Version() {
        // Set the variables
        this.globalId = 0;
        this.revision = 0;
    }

    Object.assign(Version.prototype, {
        equals: function (other) {
            return this.globalId === other.globalId &&
                   this.revision === other.revision;
        },

        notequals: function (other) {
            return this.globalId !== other.globalId ||
                   this.revision !== other.revision;
        },

        copy: function (other) {
            this.globalId = other.globalId;
            this.revision = other.revision;
        },

        reset: function () {
            this.globalId = 0;
            this.revision = 0;
        }
    });

    var idCounter = 0;

    function VersionedObject() {
        // Increment the global object ID counter
        idCounter++;

        // Create a version for this object
        this.version = new Version();

        // Set the unique object ID
        this.version.globalId = idCounter;
    }

    Object.assign(VersionedObject.prototype, {
        increment: function () {
            // Increment the revision number
            this.version.revision++;
        }
    });

    /**
     * @class
     * @name pc.ScopeId
     * @classdesc The scope for a variable.
     * @param {string} name - The variable name.
     * @property {string} name The variable name.
     */
    function ScopeId(name) {
        // Set the name
        this.name = name;

        // Set the default value
        this.value = null;

        // Create the version object
        this.versionObject = new VersionedObject();
    }

    Object.assign(ScopeId.prototype, {
        /**
         * @function
         * @name pc.ScopeId#setValue
         * @description Set variable value.
         * @param {*} value - The value.
         */
        setValue: function (value) {
            // Set the new value
            this.value = value;

            // Increment the revision
            this.versionObject.increment();
        },

        /**
         * @function
         * @name pc.ScopeId#getValue
         * @description Get variable value.
         * @returns {*} The value.
         */
        getValue: function () {
            return this.value;
        }
    });

    /**
     * @class
     * @name pc.ScopeSpace
     * @classdesc The scope for variables and subspaces.
     * @param {string} name - The scope name.
     * @property {string} name The scope name.
     */
    function ScopeSpace(name) {
        // Store the name
        this.name = name;

        // Create the empty tables
        this.variables = {};
        this.namespaces = {};
    }

    Object.assign(ScopeSpace.prototype, {
        /**
         * @function
         * @name pc.ScopeSpace#resolve
         * @description Get (or create, if it doesn't already exist) a variable in the scope.
         * @param {string} name - The variable name.
         * @returns {pc.ScopeId} The variable instance.
         */
        resolve: function (name) {
            // Check if the ScopeId already exists
            if (!this.variables.hasOwnProperty(name)) {
                // Create and add to the table
                this.variables[name] = new ScopeId(name);
            }

            // Now return the ScopeId instance
            return this.variables[name];
        },

        /**
         * @function
         * @name pc.ScopeSpace#getSubSpace
         * @description Get (or create, if it doesn't already exist) a subspace in the scope.
         * @param {string} name - The subspace name.
         * @returns {pc.ScopeSpace} The subspace instance.
         */
        getSubSpace: function (name) {
            // Check if the nested namespace already exists
            if (!this.namespaces.hasOwnProperty(name)) {
                // Create and add to the table
                this.namespaces[name] = new ScopeSpace(name);
            }

            // Now return the ScopeNamespace instance
            return this.namespaces[name];
        }
    });

    function ShaderInput(graphicsDevice, name, type, locationId) {
        // Set the shader attribute location
        this.locationId = locationId;

        // Resolve the ScopeId for the attribute name
        this.scopeId = graphicsDevice.scope.resolve(name);

        // Create the version
        this.version = new Version();

        // Set the data dataType
        if (type === UNIFORMTYPE_FLOAT) {
            if (name.substr(name.length - 3) === "[0]") type = UNIFORMTYPE_FLOATARRAY;
        }
        this.dataType = type;

        this.value = [null, null, null, null];

        // Array to hold texture unit ids
        this.array = [];
    }

    var EVENT_RESIZE = 'resizecanvas';

    var _downsampleImage = function (image, size) {
        var srcW = image.width;
        var srcH = image.height;

        if ((srcW > size) || (srcH > size)) {
            var scale = size / Math.max(srcW, srcH);
            var dstW = Math.floor(srcW * scale);
            var dstH = Math.floor(srcH * scale);

            console.warn('Image dimensions larger than max supported texture size of ' + size + '. ' +
                         'Resizing from ' + srcW + ', ' + srcH + ' to ' + dstW + ', ' + dstH + '.');

            var canvas = document.createElement('canvas');
            canvas.width = dstW;
            canvas.height = dstH;

            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);

            return canvas;
        }

        return image;
    };

    function testRenderable(gl, pixelFormat) {
        var result = true;

        // Create a 2x2 texture
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);

        // Try to use this texture as a render target
        var framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

        // It is legal for a WebGL implementation exposing the OES_texture_float extension to
        // support floating-point textures but not as attachments to framebuffer objects.
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            result = false;
        }

        // Clean up
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.deleteTexture(texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(framebuffer);

        return result;
    }

    function testTextureFloatHighPrecision(device) {
        if (!device.textureFloatRenderable)
            return false;

        var chunks = shaderChunks;
        var test1 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTestPS, "ptest1");
        var test2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.precisionTest2PS, "ptest2");

        var textureOptions = {
            format: PIXELFORMAT_RGBA32F,
            width: 1,
            height: 1,
            mipmaps: false,
            minFilter: FILTER_NEAREST,
            magFilter: FILTER_NEAREST
        };
        var tex1 = new Texture(device, textureOptions);
        tex1.name = 'testFHP';
        var targ1 = new RenderTarget(device, tex1, {
            depth: false
        });
        drawQuadWithShader(device, targ1, test1);

        textureOptions.format = PIXELFORMAT_R8_G8_B8_A8;
        var tex2 = new Texture(device, textureOptions);
        tex2.name = 'testFHP';
        var targ2 = new RenderTarget(device, tex2, {
            depth: false
        });
        device.constantTexSource.setValue(tex1);
        drawQuadWithShader(device, targ2, test2);

        var prevFramebuffer = device.activeFramebuffer;
        device.setFramebuffer(targ2._glFrameBuffer);

        var pixels = new Uint8Array(4);
        device.readPixels(0, 0, 1, 1, pixels);

        device.setFramebuffer(prevFramebuffer);

        var x = pixels[0] / 255;
        var y = pixels[1] / 255;
        var z = pixels[2] / 255;
        var w = pixels[3] / 255;
        var f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;

        tex1.destroy();
        targ1.destroy();
        tex2.destroy();
        targ2.destroy();

        return f === 0;
    }

    /**
     * @readonly
     * @name pc.GraphicsDevice#precision
     * @type {string}
     * @description The highest shader precision supported by this graphics device. Can be 'hiphp', 'mediump' or 'lowp'.
     */
    /**
     * @readonly
     * @name pc.GraphicsDevice#maxCubeMapSize
     * @type {number}
     * @description The maximum supported dimension of a cube map.
     */
    /**
     * @readonly
     * @name pc.GraphicsDevice#maxTextureSize
     * @type {number}
     * @description The maximum supported dimension of a texture.
     */
    /**
     * @readonly
     * @name pc.GraphicsDevice#maxVolumeSize
     * @type {number}
     * @description The maximum supported dimension of a 3D texture (any axis).
     */
    /**
     * @readonly
     * @name pc.GraphicsDevice#maxAnisotropy
     * @type {number}
     * @description The maximum supported texture anisotropy setting.
     */
    /**
     * @readonly
     * @name pc.GraphicsDevice#supportsInstancing
     * @type {boolean}
     * @description True if hardware instancing is supported.
     */
    /**
     * @event
     * @name pc.GraphicsDevice#resizecanvas
     * @description The 'resizecanvas' event is fired when the canvas is resized.
     * @param {number} width - The new width of the canvas in pixels.
     * @param {number} height - The new height of the canvas in pixels.
     */

    /**
     * @class
     * @name pc.GraphicsDevice
     * @augments pc.EventHandler
     * @classdesc The graphics device manages the underlying graphics context. It is responsible
     * for submitting render state changes and graphics primitives to the hardware. A graphics
     * device is tied to a specific canvas HTML element. It is valid to have more than one
     * canvas element per page and create a new graphics device against each.
     * @description Creates a new graphics device.
     * @param {HTMLCanvasElement} canvas - The canvas to which the graphics device will render.
     * @param {object} [options] - Options passed when creating the WebGL context. More info {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext here}.
     * @property {HTMLCanvasElement} canvas The canvas DOM element that provides the underlying WebGL context used by the graphics device.
     * @property {boolean} textureFloatRenderable Determines if 32-bit floating-point textures can be used as frame buffer. [read only].
     * @property {boolean} textureHalfFloatRenderable Determines if 16-bit floating-point textures can be used as frame buffer. [read only].
     * @property {pc.ScopeSpace} scope The scope namespace for shader attributes and variables. [read only].
     */
    var GraphicsDevice = function (canvas, options) {
        EventHandler.call(this);

        var i;
        this.canvas = canvas;
        this.shader = null;
        this.indexBuffer = null;
        this.vertexBuffers = [];
        this.vbOffsets = [];
        this._enableAutoInstancing = false;
        this.autoInstancingMaxObjects = 16384;
        this.attributesInvalidated = true;
        this.defaultFramebuffer = null;
        this.boundBuffer = null;
        this.boundElementBuffer = null;
        this.instancedAttribs = { };
        this.enabledAttributes = { };
        this.transformFeedbackBuffer = null;
        this.activeFramebuffer = null;
        this.textureUnit = 0;
        this.textureUnits = [];
        this._maxPixelRatio = 1;
        this.renderTarget = null;
        this.feedback = null;

        // enable temporary texture unit workaround on desktop safari
        this._tempEnableSafariTextureUnitWorkaround = !!window.safari;

        // local width/height without pixelRatio applied
        this._width = 0;
        this._height = 0;

        this.updateClientRect();

        // Shader code to WebGL shader cache
        this.vertexShaderCache = {};
        this.fragmentShaderCache = {};

        // Array of WebGL objects that need to be re-initialized after a context restore event
        this.shaders = [];
        this.buffers = [];
        this.textures = [];
        this.targets = [];

        // Add handlers for when the WebGL context is lost or restored
        this.contextLost = false;

        this._contextLostHandler = function (event) {
            event.preventDefault();
            this.contextLost = true;
            this.fire('devicelost');
        }.bind(this);

        this._contextRestoredHandler = function () {
            this.initializeContext();
            this.contextLost = false;
            this.fire('devicerestored');
        }.bind(this);

        canvas.addEventListener("webglcontextlost", this._contextLostHandler, false);
        canvas.addEventListener("webglcontextrestored", this._contextRestoredHandler, false);

        // Retrieve the WebGL context
        var preferWebGl2 = (options && options.preferWebGl2 !== undefined) ? options.preferWebGl2 : true;

        var names = preferWebGl2 ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] :
            ["webgl", "experimental-webgl"];
        var gl = null;
        options = options || {};
        options.stencil = true;
        for (i = 0; i < names.length; i++) {
            try {
                gl = canvas.getContext(names[i], options);
            } catch (e) { }

            if (gl) {
                this.webgl2 = preferWebGl2 && i < 2;
                break;
            }
        }

        if (!gl) {
            throw new Error("WebGL not supported");
        }

        this.gl = gl;

        this.initializeExtensions();
        this.initializeCapabilities();
        this.initializeRenderState();

        for (i = 0; i < this.maxCombinedTextures; i++) {
            this.textureUnits.push([null, null, null]);
        }

        this.defaultClearOptions = {
            color: [0, 0, 0, 1],
            depth: 1,
            stencil: 0,
            flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
        };

        this.glAddress = [
            gl.REPEAT,
            gl.CLAMP_TO_EDGE,
            gl.MIRRORED_REPEAT
        ];

        this.glBlendEquation = [
            gl.FUNC_ADD,
            gl.FUNC_SUBTRACT,
            gl.FUNC_REVERSE_SUBTRACT,
            this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD,
            this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD
        ];

        this.glBlendFunction = [
            gl.ZERO,
            gl.ONE,
            gl.SRC_COLOR,
            gl.ONE_MINUS_SRC_COLOR,
            gl.DST_COLOR,
            gl.ONE_MINUS_DST_COLOR,
            gl.SRC_ALPHA,
            gl.SRC_ALPHA_SATURATE,
            gl.ONE_MINUS_SRC_ALPHA,
            gl.DST_ALPHA,
            gl.ONE_MINUS_DST_ALPHA
        ];

        this.glComparison = [
            gl.NEVER,
            gl.LESS,
            gl.EQUAL,
            gl.LEQUAL,
            gl.GREATER,
            gl.NOTEQUAL,
            gl.GEQUAL,
            gl.ALWAYS
        ];

        this.glStencilOp = [
            gl.KEEP,
            gl.ZERO,
            gl.REPLACE,
            gl.INCR,
            gl.INCR_WRAP,
            gl.DECR,
            gl.DECR_WRAP,
            gl.INVERT
        ];

        this.glClearFlag = [
            0,
            gl.COLOR_BUFFER_BIT,
            gl.DEPTH_BUFFER_BIT,
            gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
            gl.STENCIL_BUFFER_BIT,
            gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT,
            gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
            gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT
        ];

        this.glCull = [
            0,
            gl.BACK,
            gl.FRONT,
            gl.FRONT_AND_BACK
        ];

        this.glFilter = [
            gl.NEAREST,
            gl.LINEAR,
            gl.NEAREST_MIPMAP_NEAREST,
            gl.NEAREST_MIPMAP_LINEAR,
            gl.LINEAR_MIPMAP_NEAREST,
            gl.LINEAR_MIPMAP_LINEAR
        ];

        this.glPrimitive = [
            gl.POINTS,
            gl.LINES,
            gl.LINE_LOOP,
            gl.LINE_STRIP,
            gl.TRIANGLES,
            gl.TRIANGLE_STRIP,
            gl.TRIANGLE_FAN
        ];

        this.glType = [
            gl.BYTE,
            gl.UNSIGNED_BYTE,
            gl.SHORT,
            gl.UNSIGNED_SHORT,
            gl.INT,
            gl.UNSIGNED_INT,
            gl.FLOAT
        ];

        this.pcUniformType = {};
        this.pcUniformType[gl.BOOL]         = UNIFORMTYPE_BOOL;
        this.pcUniformType[gl.INT]          = UNIFORMTYPE_INT;
        this.pcUniformType[gl.FLOAT]        = UNIFORMTYPE_FLOAT;
        this.pcUniformType[gl.FLOAT_VEC2]   = UNIFORMTYPE_VEC2;
        this.pcUniformType[gl.FLOAT_VEC3]   = UNIFORMTYPE_VEC3;
        this.pcUniformType[gl.FLOAT_VEC4]   = UNIFORMTYPE_VEC4;
        this.pcUniformType[gl.INT_VEC2]     = UNIFORMTYPE_IVEC2;
        this.pcUniformType[gl.INT_VEC3]     = UNIFORMTYPE_IVEC3;
        this.pcUniformType[gl.INT_VEC4]     = UNIFORMTYPE_IVEC4;
        this.pcUniformType[gl.BOOL_VEC2]    = UNIFORMTYPE_BVEC2;
        this.pcUniformType[gl.BOOL_VEC3]    = UNIFORMTYPE_BVEC3;
        this.pcUniformType[gl.BOOL_VEC4]    = UNIFORMTYPE_BVEC4;
        this.pcUniformType[gl.FLOAT_MAT2]   = UNIFORMTYPE_MAT2;
        this.pcUniformType[gl.FLOAT_MAT3]   = UNIFORMTYPE_MAT3;
        this.pcUniformType[gl.FLOAT_MAT4]   = UNIFORMTYPE_MAT4;
        this.pcUniformType[gl.SAMPLER_2D]   = UNIFORMTYPE_TEXTURE2D;
        this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
        if (this.webgl2) {
            this.pcUniformType[gl.SAMPLER_2D_SHADOW]   = UNIFORMTYPE_TEXTURE2D_SHADOW;
            this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
            this.pcUniformType[gl.SAMPLER_3D]          = UNIFORMTYPE_TEXTURE3D;
        }

        this.targetToSlot = {};
        this.targetToSlot[gl.TEXTURE_2D] = 0;
        this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
        this.targetToSlot[gl.TEXTURE_3D] = 2;

        // Define the uniform commit functions
        var scopeX, scopeY, scopeZ, scopeW;
        var uniformValue;
        this.commitFunction = [];
        this.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {
            if (uniform.value !== value) {
                gl.uniform1i(uniform.locationId, value);
                uniform.value = value;
            }
        };
        this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];
        this.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {
            if (uniform.value !== value) {
                gl.uniform1f(uniform.locationId, value);
                uniform.value = value;
            }
        };
        this.commitFunction[UNIFORMTYPE_VEC2]  = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
                gl.uniform2fv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
            }
        };
        this.commitFunction[UNIFORMTYPE_VEC3]  = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            scopeZ = value[2];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
                gl.uniform3fv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
                uniformValue[2] = scopeZ;
            }
        };
        this.commitFunction[UNIFORMTYPE_VEC4]  = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            scopeZ = value[2];
            scopeW = value[3];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
                gl.uniform4fv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
                uniformValue[2] = scopeZ;
                uniformValue[3] = scopeW;
            }
        };
        this.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
                gl.uniform2iv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
            }
        };
        this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];
        this.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            scopeZ = value[2];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
                gl.uniform3iv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
                uniformValue[2] = scopeZ;
            }
        };
        this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];
        this.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {
            uniformValue = uniform.value;
            scopeX = value[0];
            scopeY = value[1];
            scopeZ = value[2];
            scopeW = value[3];
            if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
                gl.uniform4iv(uniform.locationId, value);
                uniformValue[0] = scopeX;
                uniformValue[1] = scopeY;
                uniformValue[2] = scopeZ;
                uniformValue[3] = scopeW;
            }
        };
        this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];
        this.commitFunction[UNIFORMTYPE_MAT2]  = function (uniform, value) {
            gl.uniformMatrix2fv(uniform.locationId, false, value);
        };
        this.commitFunction[UNIFORMTYPE_MAT3]  = function (uniform, value) {
            gl.uniformMatrix3fv(uniform.locationId, false, value);
        };
        this.commitFunction[UNIFORMTYPE_MAT4]  = function (uniform, value) {
            gl.uniformMatrix4fv(uniform.locationId, false, value);
        };
        this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {
            gl.uniform1fv(uniform.locationId, value);
        };

        // Create the ScopeNamespace for shader attributes and variables
        this.scope = new ScopeSpace("Device");

        this.programLib = new ProgramLibrary(this);
        for (var generator in programlib)
            this.programLib.register(generator, programlib[generator]);

        this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
        this.useTexCubeLod = this.extTextureLod && this.maxTextures < 16;

        // Calculate an estimate of the maximum number of bones that can be uploaded to the GPU
        // based on the number of available uniforms and the number of uniforms required for non-
        // bone data.  This is based off of the Standard shader.  A user defined shader may have
        // even less space available for bones so this calculated value can be overridden via
        // pc.GraphicsDevice.setBoneLimit.
        var numUniforms = this.vertexUniformsCount;
        numUniforms -= 4 * 4; // Model, view, projection and shadow matrices
        numUniforms -= 8;     // 8 lights max, each specifying a position vector
        numUniforms -= 1;     // Eye position
        numUniforms -= 4 * 4; // Up to 4 texture transforms
        this.boneLimit = Math.floor(numUniforms / 4);

        // Put a limit on the number of supported bones before skin partitioning must be performed
        // Some GPUs have demonstrated performance issues if the number of vectors allocated to the
        // skin matrix palette is left unbounded
        this.boneLimit = Math.min(this.boneLimit, 128);

        if (this.unmaskedRenderer === 'Mali-450 MP') {
            this.boneLimit = 34;
        }

        // Profiler stats
        this._drawCallsPerFrame = 0;
        this._shaderSwitchesPerFrame = 0;
        this._primsPerFrame = [];
        for (i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {
            this._primsPerFrame[i] = 0;
        }
        this._renderTargetCreationTime = 0;

        this._vram = {
            tex: 0,
            vb: 0,
            ib: 0
        };

        this._shaderStats = {
            vsCompiled: 0,
            fsCompiled: 0,
            linked: 0,
            materialShaders: 0,
            compileTime: 0
        };

        this.constantTexSource = this.scope.resolve("source");

        if (this.extTextureFloat) {
            if (this.webgl2) {
                // In WebGL2 float texture renderability is dictated by the EXT_color_buffer_float extension
                this.textureFloatRenderable = !!this.extColorBufferFloat;
            } else {
                // In WebGL1 we should just try rendering into a float texture
                this.textureFloatRenderable = testRenderable(gl, gl.FLOAT);
            }
        } else {
            this.textureFloatRenderable = false;
        }
        if (this.extTextureHalfFloat) {
            if (this.webgl2) {
                // EXT_color_buffer_float should affect both float and halffloat formats
                this.textureHalfFloatRenderable = !!this.extColorBufferFloat;
            } else {
                // Manual render check for half float
                this.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);
            }
        } else {
            this.textureHalfFloatRenderable = false;
        }

        this._textureFloatHighPrecision = undefined;


        this.createGrabPass(options.alpha);

        VertexFormat.init(this);
    };
    GraphicsDevice.prototype = Object.create(EventHandler.prototype);
    GraphicsDevice.prototype.constructor = GraphicsDevice;

    Object.assign(GraphicsDevice.prototype, {


        getPrecision: function () {
            var gl = this.gl;
            var precision = "highp";

            // Query the precision supported by ints and floats in vertex and fragment shaders.
            // Note that getShaderPrecisionFormat is not guaranteed to be present (such as some
            // instances of the default Android browser). In this case, assume highp is available.
            if (gl.getShaderPrecisionFormat) {
                var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
                var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);

                var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
                var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT );

                var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
                var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;

                if (!highpAvailable) {
                    if (mediumpAvailable) {
                        precision = "mediump";
                    } else {
                        precision = "lowp";
                    }
                }
            }

            return precision;
        },

        initializeExtensions: function () {
            var gl = this.gl;
            var ext;

            var supportedExtensions = gl.getSupportedExtensions();

            var getExtension = function () {
                for (var i = 0; i < arguments.length; i++) {
                    if (supportedExtensions.indexOf(arguments[i]) !== -1) {
                        return gl.getExtension(arguments[i]);
                    }
                }
                return null;
            };

            if (this.webgl2) {
                this.extBlendMinmax = true;
                this.extDrawBuffers = true;
                this.extInstancing = true;
                this.extStandardDerivatives = true;
                this.extTextureFloat = true;
                this.extTextureHalfFloat = true;
                this.extTextureHalfFloatLinear = true;
                this.extTextureLod = true;
                this.extUintElement = true;
                this.extVertexArrayObject = true;
                this.extColorBufferFloat = getExtension('EXT_color_buffer_float');
                // Note that Firefox exposes EXT_disjoint_timer_query under WebGL2 rather than
                // EXT_disjoint_timer_query_webgl2
                this.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
            } else {
                this.extBlendMinmax = getExtension("EXT_blend_minmax");
                this.extDrawBuffers = getExtension('EXT_draw_buffers');
                this.extInstancing = getExtension("ANGLE_instanced_arrays");
                if (this.extInstancing) {
                    // Install the WebGL 2 Instancing API for WebGL 1.0
                    ext = this.extInstancing;
                    gl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);
                    gl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);
                    gl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);
                }

                this.extStandardDerivatives = getExtension("OES_standard_derivatives");
                this.extTextureFloat = getExtension("OES_texture_float");
                this.extTextureHalfFloat = getExtension("OES_texture_half_float");
                this.extTextureHalfFloatLinear = getExtension("OES_texture_half_float_linear");
                this.extTextureLod = getExtension('EXT_shader_texture_lod');
                this.extUintElement = getExtension("OES_element_index_uint");
                this.extVertexArrayObject = getExtension("OES_vertex_array_object");
                if (this.extVertexArrayObject) {
                    // Install the WebGL 2 VAO API for WebGL 1.0
                    ext = this.extVertexArrayObject;
                    gl.createVertexArray = ext.createVertexArrayOES.bind(ext);
                    gl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);
                    gl.isVertexArray = ext.isVertexArrayOES.bind(ext);
                    gl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);
                }
                this.extColorBufferFloat = null;
                this.extDisjointTimerQuery = null;
            }

            this.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');
            this.extTextureFloatLinear = getExtension("OES_texture_float_linear");
            this.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
            this.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');
            this.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');
            this.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
            this.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
            this.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');
            this.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');
            this.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');

            this.supportsInstancing = !!this.extInstancing;
        },

        initializeCapabilities: function () {
            var gl = this.gl;
            var ext;

            this.maxPrecision = this.precision = this.getPrecision();

            var contextAttribs = gl.getContextAttributes();
            this.supportsMsaa = contextAttribs.antialias;
            this.supportsStencil = contextAttribs.stencil;

            // Query parameter values from the WebGL context
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            if (this.webgl2) {
                this.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
                this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
                this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
            } else {
                ext = this.extDrawBuffers;
                this.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;
                this.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;
                this.maxVolumeSize = 1;
            }

            ext = this.extDebugRendererInfo;
            this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
            this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';

            ext = this.extTextureFilterAnisotropic;
            this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;

            this.samples = gl.getParameter(gl.SAMPLES);
        },

        initializeRenderState: function () {
            var gl = this.gl;

            // Initialize render state to a known start state
            this.blending = false;
            gl.disable(gl.BLEND);

            this.blendSrc = BLENDMODE_ONE;
            this.blendDst = BLENDMODE_ZERO;
            this.blendSrcAlpha = BLENDMODE_ONE;
            this.blendDstAlpha = BLENDMODE_ZERO;
            this.separateAlphaBlend = false;
            this.blendEquation = BLENDEQUATION_ADD;
            this.blendAlphaEquation = BLENDEQUATION_ADD;
            this.separateAlphaEquation = false;
            gl.blendFunc(gl.ONE, gl.ZERO);
            gl.blendEquation(gl.FUNC_ADD);

            this.writeRed = true;
            this.writeGreen = true;
            this.writeBlue = true;
            this.writeAlpha = true;
            gl.colorMask(true, true, true, true);

            this.cullMode = CULLFACE_BACK;
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            this.depthTest = true;
            gl.enable(gl.DEPTH_TEST);

            this.depthFunc = FUNC_LESSEQUAL;
            gl.depthFunc(gl.LEQUAL);

            this.depthWrite = true;
            gl.depthMask(true);

            this.stencil = false;
            gl.disable(gl.STENCIL_TEST);

            this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
            this.stencilRefFront = this.stencilRefBack = 0;
            this.stencilMaskFront = this.stencilMaskBack = 0xFF;
            gl.stencilFunc(gl.ALWAYS, 0, 0xFF);

            this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
            this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
            this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
            this.stencilWriteMaskFront = 0xFF;
            this.stencilWriteMaskBack = 0xFF;
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            gl.stencilMask(0xFF);

            this.alphaToCoverage = false;
            this.raster = true;
            if (this.webgl2) {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                gl.disable(gl.RASTERIZER_DISCARD);
            }

            this.depthBiasEnabled = false;
            gl.disable(gl.POLYGON_OFFSET_FILL);

            this.clearDepth = 1;
            gl.clearDepth(1);

            this.clearRed = 0;
            this.clearBlue = 0;
            this.clearGreen = 0;
            this.clearAlpha = 0;
            gl.clearColor(0, 0, 0, 0);

            this.clearStencil = 0;
            gl.clearStencil(0);

            // Cached viewport and scissor dimensions
            this.vx = this.vy = this.vw = this.vh = 0;
            this.sx = this.sy = this.sw = this.sh = 0;

            if (this.webgl2) {
                gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
            } else {
                if (this.extStandardDerivatives) {
                    gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);
                }
            }

            gl.enable(gl.SCISSOR_TEST);

            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);

            this.unpackFlipY = false;
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            this.unpackPremultiplyAlpha = false;
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        },

        initializeContext: function () {
            this.initializeExtensions();
            this.initializeCapabilities();
            this.initializeRenderState();

            // Recompile all shaders (they'll be linked when they're next actually used)
            var i, len;
            for (i = 0, len = this.shaders.length; i < len; i++) {
                this.compileAndLinkShader(this.shaders[i]);
            }
            this.shader = null;

            // Recreate buffer objects and reupload buffer data to the GPU
            for (i = 0, len = this.buffers.length; i < len; i++) {
                this.buffers[i].bufferId = undefined;
                this.buffers[i].unlock();
            }
            this.boundBuffer = null;
            this.boundElementBuffer = null;
            this.indexBuffer = null;
            this.attributesInvalidated = true;
            this.enabledAttributes = {};
            this.vertexBuffers = [];

            // Force all textures to be recreated and reuploaded
            for (i = 0, len = this.textures.length; i < len; i++) {
                var texture = this.textures[i];
                this.destroyTexture(texture);
                texture.dirtyAll();
            }
            this.textureUnit = 0;
            this.textureUnits.length = 0;
            for (i = 0; i < this.maxCombinedTextures; i++) {
                this.textureUnits.push([null, null, null]);
            }

            // Reset all render targets so they'll be recreated as required.
            // TODO: a solution for the case where a render target contains something
            // that was previously generated that needs to be re-rendered.
            for (i = 0, len = this.targets.length; i < len; i++) {
                this.targets[i]._glFrameBuffer = undefined;
                this.targets[i]._glDepthBuffer = undefined;
                this.targets[i]._glResolveFrameBuffer = undefined;
                this.targets[i]._glMsaaColorBuffer = undefined;
                this.targets[i]._glMsaaDepthBuffer = undefined;
            }
            this.renderTarget = null;
            this.activeFramebuffer = null;
            this.feedback = null;
            this.transformFeedbackBuffer = null;
        },

        createGrabPass: function (alpha) {
            if (this.grabPassTexture) return;

            var format = alpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8;

            var grabPassTexture = new Texture(this, {
                format: format,
                minFilter: FILTER_LINEAR,
                magFilter: FILTER_LINEAR,
                addressU: ADDRESS_CLAMP_TO_EDGE,
                addressV: ADDRESS_CLAMP_TO_EDGE,
                mipmaps: false
            });

            grabPassTexture.name = 'texture_grabPass';

            var grabPassTextureId = this.scope.resolve(grabPassTexture.name);
            grabPassTextureId.setValue(grabPassTexture);

            var grabPassRenderTarget = new RenderTarget({
                colorBuffer: grabPassTexture,
                depth: false
            });

            this.grabPassRenderTarget = grabPassRenderTarget;
            this.grabPassTextureId = grabPassTextureId;
            this.grabPassTexture = grabPassTexture;
        },

        updateGrabPass: function () {
            var gl = this.gl;

            var renderTarget = this.renderTarget;
            var resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;
            var grabPassTexture = this.grabPassTexture;
            var width = this.width;
            var height = this.height;

            if (this.webgl2 && width === grabPassTexture._width && height === grabPassTexture._height) {
                if (resolveRenderTarget) renderTarget.resolve(true);

                var currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;
                var resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;

                this.initRenderTarget(this.grabPassRenderTarget);
                var grabPassFrameBuffer = this.grabPassRenderTarget._glFrameBuffer;

                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);
                gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);

            } else {
                if (resolveRenderTarget) {
                    renderTarget.resolve(true);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);
                }

                var format = grabPassTexture._glFormat;
                gl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);
                grabPassTexture._width = width;
                grabPassTexture._height = height;

                if (resolveRenderTarget) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);
                }
            }
        },

        destroyGrabPass: function () {
            this.grabPassRenderTarget.destroy();
            this.grabPassRenderTarget = null;

            this.grabPassTextureId = null;
            this.grabPassTexture.destroy();
            this.grabPassTexture = null;
        },

        updateClientRect: function () {
            this.clientRect = this.canvas.getBoundingClientRect();
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setViewport
         * @description Set the active rectangle for rendering on the specified device.
         * @param {number} x - The pixel space x-coordinate of the bottom left corner of the viewport.
         * @param {number} y - The pixel space y-coordinate of the bottom left corner of the viewport.
         * @param {number} w - The width of the viewport in pixels.
         * @param {number} h - The height of the viewport in pixels.
         */
        setViewport: function (x, y, w, h) {
            if ((this.vx !== x) || (this.vy !== y) || (this.vw !== w) || (this.vh !== h)) {
                this.gl.viewport(x, y, w, h);
                this.vx = x;
                this.vy = y;
                this.vw = w;
                this.vh = h;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setScissor
         * @description Set the active scissor rectangle on the specified device.
         * @param {number} x - The pixel space x-coordinate of the bottom left corner of the scissor rectangle.
         * @param {number} y - The pixel space y-coordinate of the bottom left corner of the scissor rectangle.
         * @param {number} w - The width of the scissor rectangle in pixels.
         * @param {number} h - The height of the scissor rectangle in pixels.
         */
        setScissor: function (x, y, w, h) {
            if ((this.sx !== x) || (this.sy !== y) || (this.sw !== w) || (this.sh !== h)) {
                this.gl.scissor(x, y, w, h);
                this.sx = x;
                this.sy = y;
                this.sw = w;
                this.sh = h;
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#getProgramLibrary
         * @description Retrieves the program library assigned to the specified graphics device.
         * @returns {pc.ProgramLibrary} The program library assigned to the device.
         */
        getProgramLibrary: function () {
            return this.programLib;
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#setProgramLibrary
         * @description Assigns a program library to the specified device. By default, a graphics
         * device is created with a program library that manages all of the programs that are
         * used to render any graphical primitives. However, this function allows the user to
         * replace the existing program library with a new one.
         * @param {pc.ProgramLibrary} programLib - The program library to assign to the device.
         */
        setProgramLibrary: function (programLib) {
            this.programLib = programLib;
        },

        setFramebuffer: function (fb) {
            if (this.activeFramebuffer !== fb) {
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fb);
                this.activeFramebuffer = fb;
            }
        },

        _checkFbo: function () {
            // Ensure all is well
            var gl = this.gl;
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            switch (status) {
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
                    break;
                case gl.FRAMEBUFFER_COMPLETE:
                    break;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#copyRenderTarget
         * @description Copies source render target into destination render target. Mostly used by post-effects.
         * @param {pc.RenderTarget} source - The source render target.
         * @param {pc.RenderTarget} [dest] - The destination render target. Defaults to frame buffer.
         * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
         * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
         * @returns {boolean} True if the copy was successful, false otherwise.
         */
        copyRenderTarget: function (source, dest, color, depth) {
            var gl = this.gl;

            if (!this.webgl2 && depth) {
                return false;
            }
            if (color) {
                if (!dest) {
                    // copying to backbuffer
                    if (!source._colorBuffer) {
                        return false;
                    }
                } else {
                    // copying to render target
                    if (!source._colorBuffer || !dest._colorBuffer) {
                        return false;
                    }
                    if (source._colorBuffer._format !== dest._colorBuffer._format) {
                        return false;
                    }
                }
            }
            if (depth) {
                if (!source._depthBuffer || !dest._depthBuffer) {
                    return false;
                }
                if (source._depthBuffer._format !== dest._depthBuffer._format) {
                    return false;
                }
            }

            if (this.webgl2 && dest) {
                var prevRt = this.renderTarget;
                this.renderTarget = dest;
                this.updateBegin();
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);
                var w = source ? source.width : dest.width;
                var h = source ? source.height : dest.height;
                gl.blitFramebuffer( 0, 0, w, h,
                                    0, 0, w, h,
                                    (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0),
                                    gl.NEAREST);
                this.renderTarget = prevRt;
                gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);
            } else {
                var shader = this.getCopyShader();
                this.constantTexSource.setValue(source._colorBuffer);
                drawQuadWithShader(this, dest, shader);
            }

            return true;
        },


        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#initRenderTarget
         * @description Initialize render target before it can be used.
         * @param {pc.RenderTarget} target - The render target to be initialized.
         */
        initRenderTarget: function (target) {
            if (target._glFrameBuffer) return;


            // Set RT's device
            target._device = this;
            var gl = this.gl;

            // ##### Create main FBO #####
            target._glFrameBuffer = gl.createFramebuffer();
            this.setFramebuffer(target._glFrameBuffer);

            // --- Init the provided color buffer (optional) ---
            var colorBuffer = target._colorBuffer;
            if (colorBuffer) {
                if (!colorBuffer._glTexture) {
                    // Clamp the render buffer size to the maximum supported by the device
                    colorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);
                    colorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);
                    this.setTexture(colorBuffer, 0);
                }
                // Attach the color buffer
                gl.framebufferTexture2D(
                    gl.FRAMEBUFFER,
                    gl.COLOR_ATTACHMENT0,
                    colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
                    colorBuffer._glTexture,
                    0
                );
            }

            var depthBuffer = target._depthBuffer;
            if (depthBuffer && this.webgl2) {
                // --- Init the provided depth/stencil buffer (optional, WebGL2 only) ---
                if (!depthBuffer._glTexture) {
                    // Clamp the render buffer size to the maximum supported by the device
                    depthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);
                    depthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);
                    this.setTexture(depthBuffer, 0);
                }
                // Attach
                if (target._stencil) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
                                            depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
                                            target._depthBuffer._glTexture, 0);
                } else {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
                                            depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D,
                                            target._depthBuffer._glTexture, 0);
                }
            } else if (target._depth) {
                // --- Init a new depth/stencil buffer (optional) ---
                // if this is a MSAA RT, and no buffer to resolve to, skip creating non-MSAA depth
                var willRenderMsaa = target._samples > 1 && this.webgl2;
                if (!willRenderMsaa) {
                    if (!target._glDepthBuffer) {
                        target._glDepthBuffer = gl.createRenderbuffer();
                    }
                    gl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);
                    if (target._stencil) {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
                    } else {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);
                    }
                    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                }
            }


            // ##### Create MSAA FBO (WebGL2 only) #####
            if (this.webgl2 && target._samples > 1) {

                // Use previous FBO for resolves
                target._glResolveFrameBuffer = target._glFrameBuffer;

                // Actual FBO will be MSAA
                target._glFrameBuffer = gl.createFramebuffer();
                this.setFramebuffer(target._glFrameBuffer);

                // Create an optional MSAA color buffer
                if (colorBuffer) {
                    if (!target._glMsaaColorBuffer) {
                        target._glMsaaColorBuffer = gl.createRenderbuffer();
                    }
                    gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);
                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);
                }

                // Optionally add a MSAA depth/stencil buffer
                if (target._depth) {
                    if (!target._glMsaaDepthBuffer) {
                        target._glMsaaDepthBuffer = gl.createRenderbuffer();
                    }
                    gl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);
                    if (target._stencil) {
                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
                    } else {
                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);
                    }
                }
            }

            this.targets.push(target);

        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#getCopyShader
         * @description Get copy shader for efficient rendering of fullscreen-quad with texture.
         * @returns {pc.Shader} The copy shader (based on `fullscreenQuadVS` and `outputTex2DPS` in `pc.shaderChunks`).
         */
        getCopyShader: function () {
            if (!this._copyShader) {
                var chunks = shaderChunks;
                this._copyShader = chunks.createShaderFromCode(this, chunks.fullscreenQuadVS, chunks.outputTex2DPS, "outputTex2D");
            }
            return this._copyShader;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#updateBegin
         * @description Marks the beginning of a block of rendering. Internally, this function
         * binds the render target currently set on the device. This function should be matched
         * with a call to pc.GraphicsDevice#updateEnd. Calls to pc.GraphicsDevice#updateBegin
         * and pc.GraphicsDevice#updateEnd must not be nested.
         */
        updateBegin: function () {
            this.boundBuffer = null;
            this.boundElementBuffer = null;

            // clear texture units once a frame on desktop safari
            if (this._tempEnableSafariTextureUnitWorkaround) {
                for (var unit = 0; unit < this.textureUnits.length; ++unit) {
                    for (var slot = 0; slot < 3; ++slot) {
                        this.textureUnits[unit][slot] = null;
                    }
                }
            }

            // Set the render target
            var target = this.renderTarget;
            if (target) {
                // Create a new WebGL frame buffer object
                if (!target._glFrameBuffer) {
                    this.initRenderTarget(target);

                } else {
                    this.setFramebuffer(target._glFrameBuffer);
                }
            } else {
                this.setFramebuffer(this.defaultFramebuffer);
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#updateEnd
         * @description Marks the end of a block of rendering. This function should be called
         * after a matching call to pc.GraphicsDevice#updateBegin. Calls to pc.GraphicsDevice#updateBegin
         * and pc.GraphicsDevice#updateEnd must not be nested.
         */
        updateEnd: function () {
            var gl = this.gl;

            // Unset the render target
            var target = this.renderTarget;
            if (target) {
                // If the active render target is auto-mipmapped, generate its mip chain
                var colorBuffer = target._colorBuffer;
                if (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && colorBuffer.pot) {
                    this.activeTexture(this.maxCombinedTextures - 1);
                    this.bindTexture(colorBuffer);
                    gl.generateMipmap(colorBuffer._glTarget);
                }

                // Resolve MSAA if needed
                if (this.webgl2 && target._samples > 1 && target.autoResolve) {
                    target.resolve();
                }
            }
        },

        initializeTexture: function (texture) {
            var gl = this.gl;
            var ext;

            texture._glTexture = gl.createTexture();

            texture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP :
                (texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D);

            switch (texture._format) {
                case PIXELFORMAT_A8:
                    texture._glFormat = gl.ALPHA;
                    texture._glInternalFormat = gl.ALPHA;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_L8:
                    texture._glFormat = gl.LUMINANCE;
                    texture._glInternalFormat = gl.LUMINANCE;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_L8_A8:
                    texture._glFormat = gl.LUMINANCE_ALPHA;
                    texture._glInternalFormat = gl.LUMINANCE_ALPHA;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_R5_G6_B5:
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = gl.RGB;
                    texture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
                    break;
                case PIXELFORMAT_R5_G5_B5_A1:
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = gl.RGBA;
                    texture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case PIXELFORMAT_R4_G4_B4_A4:
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = gl.RGBA;
                    texture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case PIXELFORMAT_R8_G8_B8:
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_R8_G8_B8_A8:
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_DXT1:
                    ext = this.extCompressedTextureS3TC;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    break;
                case PIXELFORMAT_DXT3:
                    ext = this.extCompressedTextureS3TC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case PIXELFORMAT_DXT5:
                    ext = this.extCompressedTextureS3TC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
                case PIXELFORMAT_ETC1:
                    ext = this.extCompressedTextureETC1;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;
                    break;
                case PIXELFORMAT_PVRTC_2BPP_RGB_1:
                    ext = this.extCompressedTexturePVRTC;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    break;
                case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
                    ext = this.extCompressedTexturePVRTC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    break;
                case PIXELFORMAT_PVRTC_4BPP_RGB_1:
                    ext = this.extCompressedTexturePVRTC;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    break;
                case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
                    ext = this.extCompressedTexturePVRTC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    break;
                case PIXELFORMAT_ETC2_RGB:
                    ext = this.extCompressedTextureETC;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;
                    break;
                case PIXELFORMAT_ETC2_RGBA:
                    ext = this.extCompressedTextureETC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;
                    break;
                case PIXELFORMAT_ASTC_4x4:
                    ext = this.extCompressedTextureASTC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    break;
                case PIXELFORMAT_ATC_RGB:
                    ext = this.extCompressedTextureATC;
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;
                    break;
                case PIXELFORMAT_ATC_RGBA:
                    ext = this.extCompressedTextureATC;
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
                    break;
                case PIXELFORMAT_RGB16F:
                    // definition varies between WebGL1 and 2
                    ext = this.extTextureHalfFloat;
                    texture._glFormat = gl.RGB;
                    if (this.webgl2) {
                        texture._glInternalFormat = gl.RGB16F;
                        texture._glPixelType = gl.HALF_FLOAT;
                    } else {
                        texture._glInternalFormat = gl.RGB;
                        texture._glPixelType = ext.HALF_FLOAT_OES;
                    }
                    break;
                case PIXELFORMAT_RGBA16F:
                    // definition varies between WebGL1 and 2
                    ext = this.extTextureHalfFloat;
                    texture._glFormat = gl.RGBA;
                    if (this.webgl2) {
                        texture._glInternalFormat = gl.RGBA16F;
                        texture._glPixelType = gl.HALF_FLOAT;
                    } else {
                        texture._glInternalFormat = gl.RGBA;
                        texture._glPixelType = ext.HALF_FLOAT_OES;
                    }
                    break;
                case PIXELFORMAT_RGB32F:
                    // definition varies between WebGL1 and 2
                    texture._glFormat = gl.RGB;
                    if (this.webgl2) {
                        texture._glInternalFormat = gl.RGB32F;
                    } else {
                        texture._glInternalFormat = gl.RGB;
                    }
                    texture._glPixelType = gl.FLOAT;
                    break;
                case PIXELFORMAT_RGBA32F:
                    // definition varies between WebGL1 and 2
                    texture._glFormat = gl.RGBA;
                    if (this.webgl2) {
                        texture._glInternalFormat = gl.RGBA32F;
                    } else {
                        texture._glInternalFormat = gl.RGBA;
                    }
                    texture._glPixelType = gl.FLOAT;
                    break;
                case PIXELFORMAT_R32F: // WebGL2 only
                    texture._glFormat = gl.RED;
                    texture._glInternalFormat = gl.R32F;
                    texture._glPixelType = gl.FLOAT;
                    break;
                case PIXELFORMAT_DEPTH:
                    if (this.webgl2) {
                        // native WebGL2
                        texture._glFormat = gl.DEPTH_COMPONENT;
                        texture._glInternalFormat = gl.DEPTH_COMPONENT32F; // should allow 16/24 bits?
                        texture._glPixelType = gl.FLOAT;
                    } else {
                        // using WebGL1 extension
                        texture._glFormat = gl.DEPTH_COMPONENT;
                        texture._glInternalFormat = gl.DEPTH_COMPONENT;
                        texture._glPixelType = gl.UNSIGNED_SHORT; // the only acceptable value?
                    }
                    break;
                case PIXELFORMAT_DEPTHSTENCIL: // WebGL2 only
                    texture._glFormat = gl.DEPTH_STENCIL;
                    texture._glInternalFormat = gl.DEPTH24_STENCIL8;
                    texture._glPixelType = gl.UNSIGNED_INT_24_8;
                    break;
                case PIXELFORMAT_111110F: // WebGL2 only
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = gl.R11F_G11F_B10F;
                    texture._glPixelType = gl.FLOAT;
                    break;
                case PIXELFORMAT_SRGB: // WebGL2 only
                    texture._glFormat = gl.RGB;
                    texture._glInternalFormat = gl.SRGB8;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
                case PIXELFORMAT_SRGBA: // WebGL2 only
                    texture._glFormat = gl.RGBA;
                    texture._glInternalFormat = gl.SRGB8_ALPHA8;
                    texture._glPixelType = gl.UNSIGNED_BYTE;
                    break;
            }

            // Track this texture now that it is a WebGL resource
            this.textures.push(texture);
        },

        destroyTexture: function (texture) {
            if (texture._glTexture) {
                // Remove texture from device's texture cache
                var idx = this.textures.indexOf(texture);
                if (idx !== -1) {
                    this.textures.splice(idx, 1);
                }

                // Remove texture from any uniforms
                for (var uniformName in this.scope.variables) {
                    var uniform = this.scope.variables[uniformName];
                    if (uniform.value === texture) {
                        uniform.value = null;
                    }
                }

                // Update shadowed texture unit state to remove texture from any units
                for (var i = 0; i < this.textureUnits.length; i++) {
                    var textureUnit = this.textureUnits[i];
                    for (var j = 0; j < textureUnit.length; j++) {
                        if (textureUnit[j] === texture._glTexture) {
                            textureUnit[j] = null;
                        }
                    }
                }

                // Blow away WebGL texture resource
                var gl = this.gl;
                gl.deleteTexture(texture._glTexture);
                delete texture._glTexture;
                delete texture._glTarget;
                delete texture._glFormat;
                delete texture._glInternalFormat;
                delete texture._glPixelType;

                // Update texture stats
                this._vram.tex -= texture._gpuSize;
            }
        },

        setUnpackFlipY: function (flipY) {
            if (this.unpackFlipY !== flipY) {
                this.unpackFlipY = flipY;

                // Note: the WebGL spec states that UNPACK_FLIP_Y_WEBGL only affects
                // texImage2D and texSubImage2D, not compressedTexImage2D
                var gl = this.gl;
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
            }
        },

        setUnpackPremultiplyAlpha: function (premultiplyAlpha) {
            if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
                this.unpackPremultiplyAlpha = premultiplyAlpha;

                // Note: the WebGL spec states that UNPACK_PREMULTIPLY_ALPHA_WEBGL only affects
                // texImage2D and texSubImage2D, not compressedTexImage2D
                var gl = this.gl;
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
            }
        },

        uploadTexture: function (texture) {
            var gl = this.gl;

            if (!texture._needsUpload && ((texture._needsMipmapsUpload && texture._mipmapsUploaded) || !texture.pot))
                return;

            var mipLevel = 0;
            var mipObject;
            var resMult;

            var requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;

            while (texture._levels[mipLevel] || mipLevel === 0) {
                // Upload all existing mip levels. Initialize 0 mip anyway.

                if (!texture._needsUpload && mipLevel === 0) {
                    mipLevel++;
                    continue;
                } else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
                    break;
                }

                mipObject = texture._levels[mipLevel];

                if (mipLevel == 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {
                    // We have more than one mip levels we want to assign, but we need all mips to make
                    // the texture complete. Therefore first generate all mip chain from 0, then assign custom mips.
                    // (this implies the call to _completePartialMipLevels above was unsuccessful)
                    gl.generateMipmap(texture._glTarget);
                    texture._mipmapsUploaded = true;
                }

                if (texture._cubemap) {
                    // ----- CUBEMAP -----
                    var face;

                    if ((mipObject[0] instanceof HTMLCanvasElement) || (mipObject[0] instanceof HTMLImageElement) || (mipObject[0] instanceof HTMLVideoElement)) {
                        // Upload the image, canvas or video
                        for (face = 0; face < 6; face++) {
                            if (!texture._levelsUpdated[0][face])
                                continue;

                            var src = mipObject[face];
                            // Downsize images that are too large to be used as cube maps
                            if (src instanceof HTMLImageElement) {
                                if (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {
                                    src = _downsampleImage(src, this.maxCubeMapSize);
                                    if (mipLevel === 0) {
                                        texture.width = src.width;
                                        texture.height = src.height;
                                    }
                                }
                            }

                            this.setUnpackFlipY(false);
                            this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
                            gl.texImage2D(
                                gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
                                mipLevel,
                                texture._glInternalFormat,
                                texture._glFormat,
                                texture._glPixelType,
                                src
                            );
                        }
                    } else {
                        // Upload the byte array
                        resMult = 1 / Math.pow(2, mipLevel);
                        for (face = 0; face < 6; face++) {
                            if (!texture._levelsUpdated[0][face])
                                continue;

                            var texData = mipObject[face];
                            if (texture._compressed) {
                                gl.compressedTexImage2D(
                                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
                                    mipLevel,
                                    texture._glInternalFormat,
                                    Math.max(texture._width * resMult, 1),
                                    Math.max(texture._height * resMult, 1),
                                    0,
                                    texData
                                );
                            } else {
                                this.setUnpackFlipY(false);
                                this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
                                gl.texImage2D(
                                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
                                    mipLevel,
                                    texture._glInternalFormat,
                                    Math.max(texture._width * resMult, 1),
                                    Math.max(texture._height * resMult, 1),
                                    0,
                                    texture._glFormat,
                                    texture._glPixelType,
                                    texData
                                );
                            }
                        }
                    }
                } else if (texture._volume) {
                    // ----- 3D -----
                    // Image/canvas/video not supported (yet?)
                    // Upload the byte array
                    resMult = 1 / Math.pow(2, mipLevel);
                    if (texture._compressed) {
                        gl.compressedTexImage3D(gl.TEXTURE_3D,
                                                mipLevel,
                                                texture._glInternalFormat,
                                                Math.max(texture._width * resMult, 1),
                                                Math.max(texture._height * resMult, 1),
                                                Math.max(texture._depth * resMult, 1),
                                                0,
                                                mipObject);
                    } else {
                        this.setUnpackFlipY(false);
                        this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
                        gl.texImage3D(gl.TEXTURE_3D,
                                      mipLevel,
                                      texture._glInternalFormat,
                                      Math.max(texture._width * resMult, 1),
                                      Math.max(texture._height * resMult, 1),
                                      Math.max(texture._depth * resMult, 1),
                                      0,
                                      texture._glFormat,
                                      texture._glPixelType,
                                      mipObject);
                    }
                } else {
                    // ----- 2D -----
                    if ((mipObject instanceof HTMLCanvasElement) || (mipObject instanceof HTMLImageElement) || (mipObject instanceof HTMLVideoElement)) {
                        // Downsize images that are too large to be used as textures
                        if (mipObject instanceof HTMLImageElement) {
                            if (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {
                                mipObject = _downsampleImage(mipObject, this.maxTextureSize);
                                if (mipLevel === 0) {
                                    texture.width = mipObject.width;
                                    texture.height = mipObject.height;
                                }
                            }
                        }

                        // Upload the image, canvas or video
                        this.setUnpackFlipY(texture._flipY);
                        this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
                        gl.texImage2D(
                            gl.TEXTURE_2D,
                            mipLevel,
                            texture._glInternalFormat,
                            texture._glFormat,
                            texture._glPixelType,
                            mipObject
                        );
                    } else {
                        // Upload the byte array
                        resMult = 1 / Math.pow(2, mipLevel);
                        if (texture._compressed) {
                            gl.compressedTexImage2D(
                                gl.TEXTURE_2D,
                                mipLevel,
                                texture._glInternalFormat,
                                Math.max(texture._width * resMult, 1),
                                Math.max(texture._height * resMult, 1),
                                0,
                                mipObject
                            );
                        } else {
                            this.setUnpackFlipY(false);
                            this.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
                            gl.texImage2D(
                                gl.TEXTURE_2D,
                                mipLevel,
                                texture._glInternalFormat,
                                Math.max(texture._width * resMult, 1),
                                Math.max(texture._height * resMult, 1),
                                0,
                                texture._glFormat,
                                texture._glPixelType,
                                mipObject
                            );
                        }
                    }

                    if (mipLevel === 0) {
                        texture._mipmapsUploaded = false;
                    } else {
                        texture._mipmapsUploaded = true;
                    }
                }
                mipLevel++;
            }

            if (texture._needsUpload) {
                if (texture._cubemap) {
                    for (var i = 0; i < 6; i++)
                        texture._levelsUpdated[0][i] = false;
                } else {
                    texture._levelsUpdated[0] = false;
                }
            }

            if (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && texture.pot && texture._levels.length === 1) {
                gl.generateMipmap(texture._glTarget);
                texture._mipmapsUploaded = true;
            }

            if (texture._gpuSize) {
                this._vram.tex -= texture._gpuSize;
            }

            texture._gpuSize = texture.gpuSize;
            this._vram.tex += texture._gpuSize;
        },

        // Activate the specified texture unit
        activeTexture: function (textureUnit) {
            if (this.textureUnit !== textureUnit) {
                this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
                this.textureUnit = textureUnit;
            }
        },

        // If the texture is not already bound on the currently active texture
        // unit, bind it
        bindTexture: function (texture) {
            var textureTarget = texture._glTarget;
            var textureObject = texture._glTexture;
            var textureUnit = this.textureUnit;
            var slot = this.targetToSlot[textureTarget];
            if (this.textureUnits[textureUnit][slot] !== textureObject) {
                this.gl.bindTexture(textureTarget, textureObject);
                this.textureUnits[textureUnit][slot] = textureObject;
            }
        },

        // If the texture is not bound on the specified texture unit, active the
        // texture unit and bind the texture to it
        bindTextureOnUnit: function (texture, textureUnit) {
            var textureTarget = texture._glTarget;
            var textureObject = texture._glTexture;
            var slot = this.targetToSlot[textureTarget];
            if (this.textureUnits[textureUnit][slot] !== textureObject) {
                this.activeTexture(textureUnit);
                this.gl.bindTexture(textureTarget, textureObject);
                this.textureUnits[textureUnit][slot] = textureObject;
            }
        },

        setTextureParameters: function (texture) {
            var gl = this.gl;
            var flags = texture._parameterFlags;
            var target = texture._glTarget;

            if (flags & 1) {
                var filter = texture._minFilter;
                if (!texture.pot || !texture._mipmaps || (texture._compressed && texture._levels.length === 1)) {
                    if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
                        filter = FILTER_NEAREST;
                    } else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
                        filter = FILTER_LINEAR;
                    }
                }
                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
            }
            if (flags & 2) {
                gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
            }
            if (flags & 4) {
                if (this.webgl2) {
                    gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
                } else {
                    // WebGL1 doesn't support all addressing modes with NPOT textures
                    gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);
                }
            }
            if (flags & 8) {
                if (this.webgl2) {
                    gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
                } else {
                    // WebGL1 doesn't support all addressing modes with NPOT textures
                    gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);
                }
            }
            if (flags & 16) {
                if (this.webgl2) {
                    gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
                }
            }
            if (flags & 32) {
                if (this.webgl2) {
                    gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
                }
            }
            if (flags & 64) {
                if (this.webgl2) {
                    gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
                }
            }
            if (flags & 128) {
                var ext = this.extTextureFilterAnisotropic;
                if (ext) {
                    gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));
                }
            }
        },

        setTexture: function (texture, textureUnit) {
            if (!texture._glTexture)
                this.initializeTexture(texture);

            if (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPassTexture) {
                // Ensure the specified texture unit is active
                this.activeTexture(textureUnit);
                // Ensure the texture is bound on correct target of the specified texture unit
                this.bindTexture(texture);

                if (texture._parameterFlags) {
                    this.setTextureParameters(texture);
                    texture._parameterFlags = 0;
                }

                if (texture === this.grabPassTexture) {
                    this.updateGrabPass();

                } else if (texture._needsUpload || texture._needsMipmapsUpload) {
                    this.uploadTexture(texture);
                    texture._needsUpload = false;
                    texture._needsMipmapsUpload = false;
                }
            } else {
                // Ensure the texture is currently bound to the correct target on the specified texture unit.
                // If the texture is already bound to the correct target on the specified unit, there's no need
                // to actually make the specified texture unit active because the texture itself does not need
                // to be updated.
                this.bindTextureOnUnit(texture, textureUnit);
            }
        },

        setBuffers: function (numInstances) {
            var gl = this.gl;
            var attribute, element, vertexBuffer, vbOffset, bufferId, locationId;
            var attributes = this.shader.attributes;

            // Commit the vertex buffer inputs
            if (this.attributesInvalidated) {
                for (var i = 0, len = attributes.length; i < len; i++) {
                    attribute = attributes[i];

                    // Retrieve vertex element for this shader attribute
                    element = attribute.scopeId.value;

                    // Check the vertex element is valid
                    if (element !== null) {
                        // Retrieve the vertex buffer that contains this element
                        vertexBuffer = this.vertexBuffers[element.stream];
                        if (vertexBuffer) {
                            vbOffset = this.vbOffsets[element.stream] || 0;

                            // Set the active vertex buffer object
                            bufferId = vertexBuffer.bufferId;
                            if (this.boundBuffer !== bufferId) {
                                gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
                                this.boundBuffer = bufferId;
                            }

                            // Hook the vertex buffer to the shader program
                            locationId = attribute.locationId;
                            if (!this.enabledAttributes[locationId]) {
                                gl.enableVertexAttribArray(locationId);
                                this.enabledAttributes[locationId] = true;
                            }
                            gl.vertexAttribPointer(
                                locationId,
                                element.numComponents,
                                this.glType[element.dataType],
                                element.normalize,
                                element.stride,
                                element.offset + vbOffset
                            );

                            if (element.stream === 1 && numInstances > 0) {
                                if (!this.instancedAttribs[locationId]) {
                                    gl.vertexAttribDivisor(locationId, 1);
                                    this.instancedAttribs[locationId] = true;
                                }
                            } else if (this.instancedAttribs[locationId]) {
                                gl.vertexAttribDivisor(locationId, 0);
                                this.instancedAttribs[locationId] = false;
                            }
                        }
                    } else {
                        // disable the attribute (shader will get default value 0, 0, 0, 1)
                        if (this.enabledAttributes[attribute.locationId]) {
                            gl.disableVertexAttribArray(attribute.locationId);
                            this.enabledAttributes[attribute.locationId] = false;
                        }
                    }
                }

                this.attributesInvalidated = false;
            }

            // Set the active index buffer object
            bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;
            if (this.boundElementBuffer !== bufferId) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
                this.boundElementBuffer = bufferId;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#draw
         * @description Submits a graphical primitive to the hardware for immediate rendering.
         * @param {object} primitive - Primitive object describing how to submit current vertex/index buffers defined as follows:
         * @param {number} primitive.type - The type of primitive to render. Can be:
         * * {@link pc.PRIMITIVE_POINTS}
         * * {@link pc.PRIMITIVE_LINES}
         * * {@link pc.PRIMITIVE_LINELOOP}
         * * {@link pc.PRIMITIVE_LINESTRIP}
         * * {@link pc.PRIMITIVE_TRIANGLES}
         * * {@link pc.PRIMITIVE_TRISTRIP}
         * * {@link pc.PRIMITIVE_TRIFAN}
         * @param {number} primitive.base - The offset of the first index or vertex to dispatch in the draw call.
         * @param {number} primitive.count - The number of indices or vertices to dispatch in the draw call.
         * @param {boolean} [primitive.indexed] - True to interpret the primitive as indexed, thereby using the currently set index buffer and false otherwise.
         * @param {number} [numInstances=1] - The number of instances to render when using ANGLE_instanced_arrays. Defaults to 1.
         * @example
         * // Render a single, unindexed triangle
         * device.draw({
         *     type: pc.PRIMITIVE_TRIANGLES,
         *     base: 0,
         *     count: 3,
         *     indexed: false
         * });
         */
        draw: function (primitive, numInstances) {
            var gl = this.gl;

            var i, j, len; // Loop counting
            var sampler, samplerValue, texture, numTextures; // Samplers
            var uniform, scopeId, uniformVersion, programVersion; // Uniforms
            var shader = this.shader;
            var samplers = shader.samplers;
            var uniforms = shader.uniforms;

            if (numInstances > 0) {
                this.boundBuffer = null;
                this.attributesInvalidated = true;
            }

            this.setBuffers(numInstances);

            // Commit the shader program variables
            var textureUnit = 0;

            for (i = 0, len = samplers.length; i < len; i++) {
                sampler = samplers[i];
                samplerValue = sampler.scopeId.value;
                if (!samplerValue) {
                    continue; // Because unset constants shouldn't raise random errors
                }

                if (samplerValue instanceof Texture) {
                    texture = samplerValue;
                    this.setTexture(texture, textureUnit);


                    if (sampler.slot !== textureUnit) {
                        gl.uniform1i(sampler.locationId, textureUnit);
                        sampler.slot = textureUnit;
                    }
                    textureUnit++;
                } else { // Array
                    sampler.array.length = 0;
                    numTextures = samplerValue.length;
                    for (j = 0; j < numTextures; j++) {
                        texture = samplerValue[j];
                        this.setTexture(texture, textureUnit);

                        sampler.array[j] = textureUnit;
                        textureUnit++;
                    }
                    gl.uniform1iv(sampler.locationId, sampler.array);
                }
            }

            // Commit any updated uniforms
            for (i = 0, len = uniforms.length; i < len; i++) {
                uniform = uniforms[i];
                scopeId = uniform.scopeId;
                uniformVersion = uniform.version;
                programVersion = scopeId.versionObject.version;

                // Check the value is valid
                if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
                    uniformVersion.globalId = programVersion.globalId;
                    uniformVersion.revision = programVersion.revision;

                    // Call the function to commit the uniform value
                    if (scopeId.value !== null) {
                        this.commitFunction[uniform.dataType](uniform, scopeId.value);
                    }
                }
            }

            if (this.webgl2 && this.transformFeedbackBuffer) {
                // Enable TF, start writing to out buffer
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);
                gl.beginTransformFeedback(gl.POINTS);
            }

            var mode = this.glPrimitive[primitive.type];
            var count = primitive.count;

            if (primitive.indexed) {
                var indexBuffer = this.indexBuffer;
                var format = indexBuffer.glFormat;
                var offset = primitive.base * indexBuffer.bytesPerIndex;

                if (numInstances > 0) {
                    gl.drawElementsInstanced(mode, count, format, offset, numInstances);
                } else {
                    gl.drawElements(mode, count, format, offset);
                }
            } else {
                var first = primitive.base;

                if (numInstances > 0) {
                    gl.drawArraysInstanced(mode, first, count, numInstances);
                } else {
                    gl.drawArrays(mode, first, count);
                }
            }

            if (this.webgl2 && this.transformFeedbackBuffer) {
                // disable TF
                gl.endTransformFeedback();
                gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            }

        },

        /**
         * @function
         * @name pc.GraphicsDevice#clear
         * @description Clears the frame buffer of the currently set render target.
         * @param {object} options - Optional options object that controls the behavior of the clear operation defined as follows:
         * @param {number[]} options.color - The color to clear the color buffer to in the range 0.0 to 1.0 for each component.
         * @param {number} options.depth - The depth value to clear the depth buffer to in the range 0.0 to 1.0.
         * @param {number} options.flags - The buffers to clear (the types being color, depth and stencil). Can be any bitwise
         * combination of:
         * * pc.CLEARFLAG_COLOR
         * * pc.CLEARFLAG_DEPTH
         * * pc.CLEARFLAG_STENCIL
         * @example
         * // Clear color buffer to black and depth buffer to 1.0
         * device.clear();
         *
         * // Clear just the color buffer to red
         * device.clear({
         *     color: [1, 0, 0, 1],
         *     flags: pc.CLEARFLAG_COLOR
         * });
         *
         * // Clear color buffer to yellow and depth to 1.0
         * device.clear({
         *     color: [1, 1, 0, 1],
         *     depth: 1.0,
         *     flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH
         * });
         */
        clear: function (options) {
            var defaultOptions = this.defaultClearOptions;
            options = options || defaultOptions;

            var flags = (options.flags == undefined) ? defaultOptions.flags : options.flags;
            if (flags !== 0) {
                var gl = this.gl;

                // Set the clear color
                if (flags & CLEARFLAG_COLOR) {
                    var color = (options.color == undefined) ? defaultOptions.color : options.color;
                    this.setClearColor(color[0], color[1], color[2], color[3]);
                }

                if (flags & CLEARFLAG_DEPTH) {
                    // Set the clear depth
                    var depth = (options.depth == undefined) ? defaultOptions.depth : options.depth;
                    this.setClearDepth(depth);
                    if (!this.depthWrite) {
                        gl.depthMask(true);
                    }
                }

                if (flags & CLEARFLAG_STENCIL) {
                    // Set the clear stencil
                    var stencil = (options.stencil == undefined) ? defaultOptions.stencil : options.stencil;
                    this.setClearStencil(stencil);
                }

                // Clear the frame buffer
                gl.clear(this.glClearFlag[flags]);

                if (flags & CLEARFLAG_DEPTH) {
                    if (!this.depthWrite) {
                        gl.depthMask(false);
                    }
                }
            }
        },

        readPixels: function (x, y, w, h, pixels) {
            var gl = this.gl;
            gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        },

        setClearDepth: function (depth) {
            if (depth !== this.clearDepth) {
                this.gl.clearDepth(depth);
                this.clearDepth = depth;
            }
        },

        setClearColor: function (r, g, b, a) {
            if ((r !== this.clearRed) || (g !== this.clearGreen) || (b !== this.clearBlue) || (a !== this.clearAlpha)) {
                this.gl.clearColor(r, g, b, a);
                this.clearRed = r;
                this.clearGreen = g;
                this.clearBlue = b;
                this.clearAlpha = a;
            }
        },

        setClearStencil: function (value) {
            if (value !== this.clearStencil) {
                this.gl.clearStencil(value);
                this.clearStencil = value;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setRenderTarget
         * @description Sets the specified render target on the device. If null
         * is passed as a parameter, the back buffer becomes the current target
         * for all rendering operations.
         * @param {pc.RenderTarget} renderTarget - The render target to activate.
         * @example
         * // Set a render target to receive all rendering output
         * device.setRenderTarget(renderTarget);
         *
         * // Set the back buffer to receive all rendering output
         * device.setRenderTarget(null);
         */
        setRenderTarget: function (renderTarget) {
            this.renderTarget = renderTarget;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#getRenderTarget
         * @description Queries the currently set render target on the device.
         * @returns {pc.RenderTarget} The current render target.
         * @example
         * // Get the current render target
         * var renderTarget = device.getRenderTarget();
         */
        getRenderTarget: function () {
            return this.renderTarget;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#getDepthTest
         * @description Queries whether depth testing is enabled.
         * @returns {boolean} True if depth testing is enabled and false otherwise.
         * @example
         * var depthTest = device.getDepthTest();
         * console.log('Depth testing is ' + depthTest ? 'enabled' : 'disabled');
         */
        getDepthTest: function () {
            return this.depthTest;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setDepthTest
         * @description Enables or disables depth testing of fragments. Once this state
         * is set, it persists until it is changed. By default, depth testing is enabled.
         * @param {boolean} depthTest - True to enable depth testing and false otherwise.
         * @example
         * device.setDepthTest(true);
         */
        setDepthTest: function (depthTest) {
            if (this.depthTest !== depthTest) {
                var gl = this.gl;
                if (depthTest) {
                    gl.enable(gl.DEPTH_TEST);
                } else {
                    gl.disable(gl.DEPTH_TEST);
                }
                this.depthTest = depthTest;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setDepthFunc
         * @description Configures the depth test.
         * @param {number} func - A function to compare a new depth value with an existing z-buffer value and decide if to write a pixel. Can be:
         * * {@link pc.FUNC_NEVER}: don't draw
         * * {@link pc.FUNC_LESS}: draw if new depth < depth buffer
         * * {@link pc.FUNC_EQUAL}: draw if new depth == depth buffer
         * * {@link pc.FUNC_LESSEQUAL}: draw if new depth <= depth buffer
         * * {@link pc.FUNC_GREATER}: draw if new depth > depth buffer
         * * {@link pc.FUNC_NOTEQUAL}: draw if new depth != depth buffer
         * * {@link pc.FUNC_GREATEREQUAL}: draw if new depth >= depth buffer
         * * {@link pc.FUNC_ALWAYS}: always draw
         */
        setDepthFunc: function (func) {
            if (this.depthFunc === func) return;
            this.gl.depthFunc(this.glComparison[func]);
            this.depthFunc = func;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#getDepthWrite
         * @description Queries whether writes to the depth buffer are enabled.
         * @returns {boolean} True if depth writing is enabled and false otherwise.
         * @example
         * var depthWrite = device.getDepthWrite();
         * console.log('Depth writing is ' + depthWrite ? 'enabled' : 'disabled');
         */
        getDepthWrite: function () {
            return this.depthWrite;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setDepthWrite
         * @description Enables or disables writes to the depth buffer. Once this state
         * is set, it persists until it is changed. By default, depth writes are enabled.
         * @param {boolean} writeDepth - True to enable depth writing and false otherwise.
         * @example
         * device.setDepthWrite(true);
         */
        setDepthWrite: function (writeDepth) {
            if (this.depthWrite !== writeDepth) {
                this.gl.depthMask(writeDepth);
                this.depthWrite = writeDepth;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setColorWrite
         * @description Enables or disables writes to the color buffer. Once this state
         * is set, it persists until it is changed. By default, color writes are enabled
         * for all color channels.
         * @param {boolean} writeRed - True to enable writing of the red channel and false otherwise.
         * @param {boolean} writeGreen - True to enable writing of the green channel and false otherwise.
         * @param {boolean} writeBlue - True to enable writing of the blue channel and false otherwise.
         * @param {boolean} writeAlpha - True to enable writing of the alpha channel and false otherwise.
         * @example
         * // Just write alpha into the frame buffer
         * device.setColorWrite(false, false, false, true);
         */
        setColorWrite: function (writeRed, writeGreen, writeBlue, writeAlpha) {
            if ((this.writeRed !== writeRed) ||
                (this.writeGreen !== writeGreen) ||
                (this.writeBlue !== writeBlue) ||
                (this.writeAlpha !== writeAlpha)) {
                this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
                this.writeRed = writeRed;
                this.writeGreen = writeGreen;
                this.writeBlue = writeBlue;
                this.writeAlpha = writeAlpha;
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#setAlphaToCoverage
         * @description Enables or disables alpha to coverage (WebGL2 only).
         * @param {boolean} state - True to enable alpha to coverage and false to disable it.
         */
        setAlphaToCoverage: function (state) {
            if (!this.webgl2) return;
            if (this.alphaToCoverage === state) return;
            this.alphaToCoverage = state;

            if (state) {
                this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
            } else {
                this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#setTransformFeedbackBuffer
         * @description Sets the output vertex buffer. It will be written to by a shader with transform feedback varyings.
         * @param {pc.VertexBuffer} tf - The output vertex buffer.
         */
        setTransformFeedbackBuffer: function (tf) {
            if (this.transformFeedbackBuffer === tf)
                return;

            this.transformFeedbackBuffer = tf;

            if (this.webgl2) {
                var gl = this.gl;
                if (tf) {
                    if (!this.feedback) {
                        this.feedback = gl.createTransformFeedback();
                    }
                    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
                } else {
                    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
                }
            }
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#setRaster
         * @description Enables or disables rasterization. Useful with transform feedback, when you only need to process the data without drawing.
         * @param {boolean} on - True to enable rasterization and false to disable it.
         */
        setRaster: function (on) {
            if (this.raster === on) return;

            this.raster = on;

            if (this.webgl2) {
                if (on) {
                    this.gl.disable(this.gl.RASTERIZER_DISCARD);
                } else {
                    this.gl.enable(this.gl.RASTERIZER_DISCARD);
                }
            }
        },

        setDepthBias: function (on) {
            if (this.depthBiasEnabled === on) return;

            this.depthBiasEnabled = on;

            if (on) {
                this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
            } else {
                this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
            }
        },

        setDepthBiasValues: function (constBias, slopeBias) {
            this.gl.polygonOffset(slopeBias, constBias);
        },

        /**
         * @function
         * @name pc.GraphicsDevice#getBlending
         * @description Queries whether blending is enabled.
         * @returns {boolean} True if blending is enabled and false otherwise.
         */
        getBlending: function () {
            return this.blending;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setBlending
         * @description Enables or disables blending.
         * @param {boolean} blending - True to enable blending and false to disable it.
         */
        setBlending: function (blending) {
            if (this.blending !== blending) {
                var gl = this.gl;
                if (blending) {
                    gl.enable(gl.BLEND);
                } else {
                    gl.disable(gl.BLEND);
                }
                this.blending = blending;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilTest
         * @description Enables or disables stencil test.
         * @param {boolean} enable - True to enable stencil test and false to disable it.
         */
        setStencilTest: function (enable) {
            if (this.stencil !== enable) {
                var gl = this.gl;
                if (enable) {
                    gl.enable(gl.STENCIL_TEST);
                } else {
                    gl.disable(gl.STENCIL_TEST);
                }
                this.stencil = enable;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilFunc
         * @description Configures stencil test for both front and back faces.
         * @param {number} func - A comparison function that decides if the pixel should be written, based on the current stencil buffer value,
         * reference value, and mask value. Can be:
         * * {@link pc.FUNC_NEVER}: never pass
         * * {@link pc.FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
         * * {@link pc.FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
         * * {@link pc.FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
         * * {@link pc.FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
         * * {@link pc.FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
         * * {@link pc.FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
         * * {@link pc.FUNC_ALWAYS}: always pass
         * @param {number} ref - Reference value used in comparison.
         * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
         */
        setStencilFunc: function (func, ref, mask) {
            if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask ||
                this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
                var gl = this.gl;
                gl.stencilFunc(this.glComparison[func], ref, mask);
                this.stencilFuncFront = this.stencilFuncBack = func;
                this.stencilRefFront = this.stencilRefBack = ref;
                this.stencilMaskFront = this.stencilMaskBack = mask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilFuncFront
         * @description Configures stencil test for front faces.
         * @param {number} func - A comparison function that decides if the pixel should be written,
         * based on the current stencil buffer value, reference value, and mask value. Can be:
         * * {@link pc.FUNC_NEVER}: never pass
         * * {@link pc.FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
         * * {@link pc.FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
         * * {@link pc.FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
         * * {@link pc.FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
         * * {@link pc.FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
         * * {@link pc.FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
         * * {@link pc.FUNC_ALWAYS}: always pass
         * @param {number} ref - Reference value used in comparison.
         * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
         */
        setStencilFuncFront: function (func, ref, mask) {
            if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
                var gl = this.gl;
                gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
                this.stencilFuncFront = func;
                this.stencilRefFront = ref;
                this.stencilMaskFront = mask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilFuncBack
         * @description Configures stencil test for back faces.
         * @param {number} func - A comparison function that decides if the pixel should be written,
         * based on the current stencil buffer value, reference value, and mask value. Can be:
         * * {@link pc.FUNC_NEVER}: never pass
         * * {@link pc.FUNC_LESS}: pass if (ref & mask) < (stencil & mask)
         * * {@link pc.FUNC_EQUAL}: pass if (ref & mask) == (stencil & mask)
         * * {@link pc.FUNC_LESSEQUAL}: pass if (ref & mask) <= (stencil & mask)
         * * {@link pc.FUNC_GREATER}: pass if (ref & mask) > (stencil & mask)
         * * {@link pc.FUNC_NOTEQUAL}: pass if (ref & mask) != (stencil & mask)
         * * {@link pc.FUNC_GREATEREQUAL}: pass if (ref & mask) >= (stencil & mask)
         * * {@link pc.FUNC_ALWAYS}: always pass
         * @param {number} ref - Reference value used in comparison.
         * @param {number} mask - Mask applied to stencil buffer value and reference value before comparison.
         */
        setStencilFuncBack: function (func, ref, mask) {
            if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
                var gl = this.gl;
                gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
                this.stencilFuncBack = func;
                this.stencilRefBack = ref;
                this.stencilMaskBack = mask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilOperation
         * @description Configures how stencil buffer values should be modified based on the result
         * of depth/stencil tests. Works for both front and back faces.
         * @param {number} fail - Action to take if stencil test is failed.
         * @param {number} zfail - Action to take if depth test is failed.
         * @param {number} zpass - Action to take if both depth and stencil test are passed
         * All arguments can be:
         * * {@link pc.STENCILOP_KEEP}: don't change the stencil buffer value
         * * {@link pc.STENCILOP_ZERO}: set value to zero
         * * {@link pc.STENCILOP_REPLACE}: replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc})
         * * {@link pc.STENCILOP_INCREMENT}: increment the value
         * * {@link pc.STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger than a maximum representable value
         * * {@link pc.STENCILOP_DECREMENT}: decrement the value
         * * {@link pc.STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum representable value, if the current value is 0
         * * {@link pc.STENCILOP_INVERT}: invert the value bitwise
         * @param {number} writeMask - A bit mask applied to the reference value, when written.
         */
        setStencilOperation: function (fail, zfail, zpass, writeMask) {
            if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass ||
                this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
                this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
                this.stencilFailFront = this.stencilFailBack = fail;
                this.stencilZfailFront = this.stencilZfailBack = zfail;
                this.stencilZpassFront = this.stencilZpassBack = zpass;
            }
            if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
                this.gl.stencilMask(writeMask);
                this.stencilWriteMaskFront = writeMask;
                this.stencilWriteMaskBack = writeMask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilOperationFront
         * @description Configures how stencil buffer values should be modified based on the result
         * of depth/stencil tests. Works for front faces.
         * @param {number} fail - Action to take if stencil test is failed.
         * @param {number} zfail - Action to take if depth test is failed.
         * @param {number} zpass - Action to take if both depth and stencil test are passed
         * All arguments can be:
         * * {@link pc.STENCILOP_KEEP}: don't change the stencil buffer value
         * * {@link pc.STENCILOP_ZERO}: set value to zero
         * * {@link pc.STENCILOP_REPLACE}: replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc})
         * * {@link pc.STENCILOP_INCREMENT}: increment the value
         * * {@link pc.STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger than a maximum representable value
         * * {@link pc.STENCILOP_DECREMENT}: decrement the value
         * * {@link pc.STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum representable value, if the current value is 0
         * * {@link pc.STENCILOP_INVERT}: invert the value bitwise
         * @param {number} writeMask - A bit mask applied to the reference value, when written.
         */
        setStencilOperationFront: function (fail, zfail, zpass, writeMask) {
            if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
                this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
                this.stencilFailFront = fail;
                this.stencilZfailFront = zfail;
                this.stencilZpassFront = zpass;
            }
            if (this.stencilWriteMaskFront !== writeMask) {
                this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
                this.stencilWriteMaskFront = writeMask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setStencilOperationBack
         * @description Configures how stencil buffer values should be modified based on the result
         * of depth/stencil tests. Works for back faces.
         * @param {number} fail - Action to take if stencil test is failed.
         * @param {number} zfail - Action to take if depth test is failed.
         * @param {number} zpass - Action to take if both depth and stencil test are passed
         * All arguments can be:
         * * {@link pc.STENCILOP_KEEP}: don't change the stencil buffer value
         * * {@link pc.STENCILOP_ZERO}: set value to zero
         * * {@link pc.STENCILOP_REPLACE}: replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc})
         * * {@link pc.STENCILOP_INCREMENT}: increment the value
         * * {@link pc.STENCILOP_INCREMENTWRAP}: increment the value, but wrap it to zero when it's larger than a maximum representable value
         * * {@link pc.STENCILOP_DECREMENT}: decrement the value
         * * {@link pc.STENCILOP_DECREMENTWRAP}: decrement the value, but wrap it to a maximum representable value, if the current value is 0
         * * {@link pc.STENCILOP_INVERT}: invert the value bitwise
         * @param {number} writeMask - A bit mask applied to the reference value, when written.
         */
        setStencilOperationBack: function (fail, zfail, zpass, writeMask) {
            if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
                this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
                this.stencilFailBack = fail;
                this.stencilZfailBack = zfail;
                this.stencilZpassBack = zpass;
            }
            if (this.stencilWriteMaskBack !== writeMask) {
                this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
                this.stencilWriteMaskBack = writeMask;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setBlendFunction
         * @description Configures blending operations. Both source and destination
         * blend modes can take the following values:
         * * {@link pc.BLENDMODE_ZERO}
         * * {@link pc.BLENDMODE_ONE}
         * * {@link pc.BLENDMODE_SRC_COLOR}
         * * {@link pc.BLENDMODE_ONE_MINUS_SRC_COLOR}
         * * {@link pc.BLENDMODE_DST_COLOR}
         * * {@link pc.BLENDMODE_ONE_MINUS_DST_COLOR}
         * * {@link pc.BLENDMODE_SRC_ALPHA}
         * * {@link pc.BLENDMODE_SRC_ALPHA_SATURATE}
         * * {@link pc.BLENDMODE_ONE_MINUS_SRC_ALPHA}
         * * {@link pc.BLENDMODE_DST_ALPHA}
         * * {@link pc.BLENDMODE_ONE_MINUS_DST_ALPHA}
         * @param {number} blendSrc - The source blend function.
         * @param {number} blendDst - The destination blend function.
         */
        setBlendFunction: function (blendSrc, blendDst) {
            if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {
                this.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);
                this.blendSrc = blendSrc;
                this.blendDst = blendDst;
                this.separateAlphaBlend = false;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setBlendFunctionSeparate
         * @description Configures blending operations. Both source and destination
         * blend modes can take the following values:
         * * {@link pc.BLENDMODE_ZERO}
         * * {@link pc.BLENDMODE_ONE}
         * * {@link pc.BLENDMODE_SRC_COLOR}
         * * {@link pc.BLENDMODE_ONE_MINUS_SRC_COLOR}
         * * {@link pc.BLENDMODE_DST_COLOR}
         * * {@link pc.BLENDMODE_ONE_MINUS_DST_COLOR}
         * * {@link pc.BLENDMODE_SRC_ALPHA}
         * * {@link pc.BLENDMODE_SRC_ALPHA_SATURATE}
         * * {@link pc.BLENDMODE_ONE_MINUS_SRC_ALPHA}
         * * {@link pc.BLENDMODE_DST_ALPHA}
         * * {@link pc.BLENDMODE_ONE_MINUS_DST_ALPHA}
         * @param {number} blendSrc - The source blend function.
         * @param {number} blendDst - The destination blend function.
         * @param {number} blendSrcAlpha - The separate source blend function for the alpha channel.
         * @param {number} blendDstAlpha - The separate destination blend function for the alpha channel.
         */
        setBlendFunctionSeparate: function (blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {
            if (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {
                this.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst],
                                          this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);
                this.blendSrc = blendSrc;
                this.blendDst = blendDst;
                this.blendSrcAlpha = blendSrcAlpha;
                this.blendDstAlpha = blendDstAlpha;
                this.separateAlphaBlend = true;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setBlendEquation
         * @description Configures the blending equation. The default blend equation is
         * pc.BLENDEQUATION_ADD.
         * @param {number} blendEquation - The blend equation. Can be:
         * * {@link pc.BLENDEQUATION_ADD}
         * * {@link pc.BLENDEQUATION_SUBTRACT}
         * * {@link pc.BLENDEQUATION_REVERSE_SUBTRACT}
         * * {@link pc.BLENDEQUATION_MIN}
         * * {@link pc.BLENDEQUATION_MAX}
         *
         * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check device.extBlendMinmax).
         */
        setBlendEquation: function (blendEquation) {
            if (this.blendEquation !== blendEquation || this.separateAlphaEquation) {
                this.gl.blendEquation(this.glBlendEquation[blendEquation]);
                this.blendEquation = blendEquation;
                this.separateAlphaEquation = false;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setBlendEquationSeparate
         * @description Configures the blending equation. The default blend equation is
         * pc.BLENDEQUATION_ADD.
         * @param {number} blendEquation - The blend equation. Can be:
         * * {@link pc.BLENDEQUATION_ADD}
         * * {@link pc.BLENDEQUATION_SUBTRACT}
         * * {@link pc.BLENDEQUATION_REVERSE_SUBTRACT}
         * * {@link pc.BLENDEQUATION_MIN}
         * * {@link pc.BLENDEQUATION_MAX}
         *
         * Note that MIN and MAX modes require either EXT_blend_minmax or WebGL2 to work (check device.extBlendMinmax).
         * @param {number} blendAlphaEquation - A separate blend equation for the alpha channel. Accepts same values as blendEquation.
         */
        setBlendEquationSeparate: function (blendEquation, blendAlphaEquation) {
            if (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {
                this.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);
                this.blendEquation = blendEquation;
                this.blendAlphaEquation = blendAlphaEquation;
                this.separateAlphaEquation = true;
            }
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setCullMode
         * @description Controls how triangles are culled based on their face direction.
         * The default cull mode is pc.CULLFACE_BACK.
         * @param {number} cullMode - The cull mode to set. Can be:
         * * {@link pc.CULLFACE_NONE}
         * * {@link pc.CULLFACE_BACK}
         * * {@link pc.CULLFACE_FRONT}
         * * {@link pc.CULLFACE_FRONTANDBACK}
         */
        setCullMode: function (cullMode) {
            if (this.cullMode !== cullMode) {
                if (cullMode === CULLFACE_NONE) {
                    this.gl.disable(this.gl.CULL_FACE);
                } else {
                    if (this.cullMode === CULLFACE_NONE) {
                        this.gl.enable(this.gl.CULL_FACE);
                    }

                    var mode = this.glCull[cullMode];
                    if (this.cullFace !== mode) {
                        this.gl.cullFace(mode);
                        this.cullFace = mode;
                    }
                }
                this.cullMode = cullMode;
            }
        },

        getCullMode: function () {
            return this.cullMode;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setIndexBuffer
         * @description Sets the current index buffer on the graphics device. On subsequent
         * calls to pc.GraphicsDevice#draw, the specified index buffer will be used to provide
         * index data for any indexed primitives.
         * @param {pc.IndexBuffer} indexBuffer - The index buffer to assign to the device.
         */
        setIndexBuffer: function (indexBuffer) {
            // Store the index buffer
            this.indexBuffer = indexBuffer;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setVertexBuffer
         * @description Sets the current vertex buffer for a specific stream index on the graphics
         * device. On subsequent calls to pc.GraphicsDevice#draw, the specified vertex buffer will be
         * used to provide vertex data for any primitives.
         * @param {pc.VertexBuffer} vertexBuffer - The vertex buffer to assign to the device.
         * @param {number} stream - The stream index for the vertex buffer, indexed from 0 upwards.
         * @param {number} [vbOffset=0] - The byte offset into the vertex buffer data. Defaults to 0.
         */
        setVertexBuffer: function (vertexBuffer, stream, vbOffset) {
            if (this.vertexBuffers[stream] !== vertexBuffer || this.vbOffsets[stream] !== vbOffset) {
                // Store the vertex buffer for this stream index
                this.vertexBuffers[stream] = vertexBuffer;
                this.vbOffsets[stream] = vbOffset;

                // Push each vertex element in scope
                if (vertexBuffer) {
                    var vertexFormat = vertexBuffer.getFormat();
                    var i = 0;
                    var elements = vertexFormat.elements;
                    var numElements = elements.length;
                    while (i < numElements) {
                        var vertexElement = elements[i++];
                        vertexElement.stream = stream;
                        vertexElement.scopeId.setValue(vertexElement);
                    }
                }

                this.attributesInvalidated = true;
            }
        },

        // Function to disable vertex elements coming from vertex buffer and using constant default value instead (0,0,0,1)
        // this is similar to setVertexBuffer with null vertex buffer, where access to vertexFormat is replaced by providing list of element semantics
        disableVertexBufferElements: function (elementNames) {

            for (var i = 0; i < elementNames.length; i++) {
                // Resolve the ScopeId for the attribute name
                var scopeId = this.scope.resolve(elementNames[i]);
                if (scopeId.value) {
                    this.attributesInvalidated = true;
                    scopeId.setValue(null);
                }
            }
        },

        compileShaderSource: function (src, isVertexShader) {
            var gl = this.gl;

            var glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];

            if (!glShader) {

                glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);

                gl.shaderSource(glShader, src);
                gl.compileShader(glShader);


                if (isVertexShader) {
                    this.vertexShaderCache[src] = glShader;
                } else {
                    this.fragmentShaderCache[src] = glShader;
                }
            }

            return glShader;
        },

        compileAndLinkShader: function (shader) {
            var gl = this.gl;

            var definition = shader.definition;
            var glVertexShader = this.compileShaderSource(definition.vshader, true);
            var glFragmentShader = this.compileShaderSource(definition.fshader, false);

            var glProgram = gl.createProgram();

            gl.attachShader(glProgram, glVertexShader);
            gl.attachShader(glProgram, glFragmentShader);

            if (this.webgl2 && definition.useTransformFeedback) {
                // Collect all "out_" attributes and use them for output
                var attrs = definition.attributes;
                var outNames = [];
                for (var attr in attrs) {
                    if (attrs.hasOwnProperty(attr)) {
                        outNames.push("out_" + attr);
                    }
                }
                gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
            }

            gl.linkProgram(glProgram);

            // Cache the WebGL objects on the shader
            shader._glVertexShader = glVertexShader;
            shader._glFragmentShader = glFragmentShader;
            shader._glProgram = glProgram;

        },

        createShader: function (shader) {
            this.compileAndLinkShader(shader);

            this.shaders.push(shader);
        },

        destroyShader: function (shader) {
            var idx = this.shaders.indexOf(shader);
            if (idx !== -1) {
                this.shaders.splice(idx, 1);
            }

            if (shader._glProgram) {
                this.gl.deleteProgram(shader._glProgram);
                shader._glProgram = null;
                this.removeShaderFromCache(shader);
            }
        },

        _addLineNumbers: function (src) {
            var lines = src.split("\n");

            // Chrome reports shader errors on lines indexed from 1
            for (var i = 0, len = lines.length; i < len; i++) {
                lines[i] = (i + 1) + ":\t" + lines[i];
            }

            return lines.join( "\n" );
        },

        postLink: function (shader) {
            var gl = this.gl;

            var glVertexShader = shader._glVertexShader;
            var glFragmentShader = shader._glFragmentShader;
            var glProgram = shader._glProgram;

            var definition = shader.definition;


            // Check for errors
            if (!gl.getShaderParameter(glVertexShader, gl.COMPILE_STATUS)) {
                console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(definition.vshader) + "\n\n" + gl.getShaderInfoLog(glVertexShader));
                return false;
            }
            if (!gl.getShaderParameter(glFragmentShader, gl.COMPILE_STATUS)) {
                console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(definition.fshader) + "\n\n" + gl.getShaderInfoLog(glFragmentShader));
                return false;
            }
            if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                console.error("Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram));
                return false;
            }

            var i, info, location, shaderInput;

            // Query the program for each vertex buffer input (GLSL 'attribute')
            i = 0;
            var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
            while (i < numAttributes) {
                info = gl.getActiveAttrib(glProgram, i++);
                location = gl.getAttribLocation(glProgram, info.name);

                // Check attributes are correctly linked up
                if (definition.attributes[info.name] === undefined) {
                    console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition.');
                }

                shaderInput = new ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);

                shader.attributes.push(shaderInput);
            }

            // Query the program for each shader state (GLSL 'uniform')
            i = 0;
            var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
            while (i < numUniforms) {
                info = gl.getActiveUniform(glProgram, i++);
                location = gl.getUniformLocation(glProgram, info.name);

                shaderInput = new ShaderInput(this, info.name, this.pcUniformType[info.type], location);

                if (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE ||
                    (this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D))
                ) {
                    shader.samplers.push(shaderInput);
                } else {
                    shader.uniforms.push(shaderInput);
                }
            }

            shader.ready = true;


            return true;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#setShader
         * @description Sets the active shader to be used during subsequent draw calls.
         * @param {pc.Shader} shader - The shader to set to assign to the device.
         * @returns {boolean} True if the shader was successfully set, false otherwise.
         */
        setShader: function (shader) {
            if (shader !== this.shader) {
                if (!shader.ready) {
                    if (!this.postLink(shader)) {
                        return false;
                    }
                }

                this.shader = shader;

                // Set the active shader
                this.gl.useProgram(shader._glProgram);


                this.attributesInvalidated = true;
            }
            return true;
        },

        getHdrFormat: function () {
            if (this.textureHalfFloatRenderable) {
                return PIXELFORMAT_RGB16F;
            } else if (this.textureFloatRenderable) {
                return PIXELFORMAT_RGB32F;
            }
            return PIXELFORMAT_R8_G8_B8_A8;
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#getBoneLimit
         * @description Queries the maximum number of bones that can be referenced by a shader.
         * The shader generators (pc.programlib) use this number to specify the matrix array
         * size of the uniform 'matrix_pose[0]'. The value is calculated based on the number of
         * available uniform vectors available after subtracting the number taken by a typical
         * heavyweight shader. If a different number is required, it can be tuned via
         * pc.GraphicsDevice#setBoneLimit.
         * @returns {number} The maximum number of bones that can be supported by the host hardware.
         */
        getBoneLimit: function () {
            return this.boneLimit;
        },

        /**
         * @private
         * @function
         * @name pc.GraphicsDevice#setBoneLimit
         * @description Specifies the maximum number of bones that the device can support on
         * the current hardware. This function allows the default calculated value based on
         * available vector uniforms to be overridden.
         * @param {number} maxBones - The maximum number of bones supported by the host hardware.
         */
        setBoneLimit: function (maxBones) {
            this.boneLimit = maxBones;
        },

        /**
         * @function
         * @name pc.GraphicsDevice#resizeCanvas
         * @description Sets the width and height of the canvas, then fires the 'resizecanvas' event.
         * Note that the specified width and height values will be multiplied by the value of
         * {@link pc.GraphicsDevice#maxPixelRatio} to give the final resultant width and height for
         * the canvas.
         * @param {number} width - The new width of the canvas.
         * @param {number} height - The new height of the canvas.
         */
        resizeCanvas: function (width, height) {
            this._width = width;
            this._height = height;

            var ratio = Math.min(this._maxPixelRatio, window.devicePixelRatio);
            width *= ratio;
            height *= ratio;

            if (this.canvas.width === width && this.canvas.height === height)
                return;

            this.canvas.width = width;
            this.canvas.height = height;
            this.fire(EVENT_RESIZE, width, height);
        },

        setResolution: function (width, height) {
            this._width = width;
            this._height = height;
            this.canvas.width = width;
            this.canvas.height = height;
            this.fire(EVENT_RESIZE, width, height);
        },

        /**
         * @function
         * @name pc.GraphicsDevice#clearShaderCache
         * @description Frees memory from all shaders ever allocated with this device.
         */
        clearShaderCache: function () {
            var gl = this.gl;
            var shaderSrc;
            for (shaderSrc in this.fragmentShaderCache) {
                gl.deleteShader(this.fragmentShaderCache[shaderSrc]);
                delete this.fragmentShaderCache[shaderSrc];
            }
            for (shaderSrc in this.vertexShaderCache) {
                gl.deleteShader(this.vertexShaderCache[shaderSrc]);
                delete this.vertexShaderCache[shaderSrc];
            }

            this.programLib.clearCache();
        },

        removeShaderFromCache: function (shader) {
            this.programLib.removeFromCache(shader);
        },

        destroy: function () {
            var gl = this.gl;

            this.destroyGrabPass();

            if (this.webgl2 && this.feedback) {
                gl.deleteTransformFeedback(this.feedback);
            }

            this.clearShaderCache();

            this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
            this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);

            this._contextLostHandler = null;
            this._contextRestoredHandler = null;

            this.canvas = null;
            this.gl = null;
        }
    });

    /**
     * @readonly
     * @name pc.GraphicsDevice#width
     * @type {number}
     * @description Width of the back buffer in pixels.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'width', {
        get: function () {
            return this.gl.drawingBufferWidth || this.canvas.width;
        }
    });

    /**
     * @readonly
     * @name pc.GraphicsDevice#height
     * @type {number}
     * @description Height of the back buffer in pixels.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'height', {
        get: function () {
            return this.gl.drawingBufferHeight || this.canvas.height;
        }
    });

    /**
     * @name pc.GraphicsDevice#fullscreen
     * @type {boolean}
     * @description Fullscreen mode.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'fullscreen', {
        get: function () {
            return !!document.fullscreenElement;
        },
        set: function (fullscreen) {
            if (fullscreen) {
                var canvas = this.gl.canvas;
                canvas.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
    });

    /**
     * @private
     * @name pc.GraphicsDevice#enableAutoInstancing
     * @type {boolean}
     * @description Automatic instancing.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'enableAutoInstancing', {
        get: function () {
            return this._enableAutoInstancing;
        },
        set: function (value) {
            this._enableAutoInstancing = value && this.extInstancing;
        }
    });

    /**
     * @name pc.GraphicsDevice#maxPixelRatio
     * @type {number}
     * @description Maximum pixel ratio.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'maxPixelRatio', {
        get: function () {
            return this._maxPixelRatio;
        },
        set: function (ratio) {
            this._maxPixelRatio = ratio;
            this.resizeCanvas(this._width, this._height);
        }
    });

    /**
     * @readonly
     * @name pc.GraphicsDevice#textureFloatHighPrecision
     * @type {number}
     * @description Check if high precision floating-point textures are supported.
     */
    Object.defineProperty(GraphicsDevice.prototype, 'textureFloatHighPrecision', {
        get: function () {
            if (this._textureFloatHighPrecision === undefined) {
                this._textureFloatHighPrecision = testTextureFloatHighPrecision(this);
            }
            return this._textureFloatHighPrecision;
        }
    });

    var defaultOptions = {
        depth: true,
        face: 0
    };

    /**
     * @class
     * @name pc.RenderTarget
     * @classdesc A render target is a rectangular rendering surface.
     * @description Creates a new render target. A color buffer or a depth buffer must be set.
     * @param {object} options - Object for passing optional arguments.
     * @param {pc.Texture} [options.colorBuffer] - The texture that this render target will treat as a rendering surface.
     * @param {boolean} [options.depth] - If set to true, depth buffer will be created. Defaults to true. Ignored if depthBuffer is defined.
     * @param {boolean} [options.stencil] - If set to true, depth buffer will include stencil. Defaults to false. Ignored if depthBuffer is defined or depth is false.
     * @param {pc.Texture} [options.depthBuffer] - The texture that this render target will treat as a depth/stencil surface (WebGL2 only). If set, the 'depth' and 'stencil' properties are ignored.
     * Texture must have pc.PIXELFORMAT_DEPTH or PIXELFORMAT_DEPTHSTENCIL format.
     * @param {number} [options.samples] - Number of hardware anti-aliasing samples (WebGL2 only). Default is 1.
     * @param {boolean} [options.autoResolve] - If samples > 1, enables or disables automatic MSAA resolve after rendering to this RT (see pc.RenderTarget#resolve). Defaults to true;
     * Defaults to true.
     * @param {number} [options.face] - If the colorBuffer parameter is a cubemap, use this option to specify the
     * face of the cubemap to render to. Can be:
     *
     * * {@link pc.CUBEFACE_POSX}
     * * {@link pc.CUBEFACE_NEGX}
     * * {@link pc.CUBEFACE_POSY}
     * * {@link pc.CUBEFACE_NEGY}
     * * {@link pc.CUBEFACE_POSZ}
     * * {@link pc.CUBEFACE_NEGZ}
     *
     * Defaults to pc.CUBEFACE_POSX.
     * @example
     * // Create a 512x512x24-bit render target with a depth buffer
     * var colorBuffer = new pc.Texture(graphicsDevice, {
     *     width: 512,
     *     height: 512,
     *     format: pc.PIXELFORMAT_R8_G8_B8
     * });
     * var renderTarget = new pc.RenderTarget({
     *     colorBuffer: colorBuffer,
     *     depth: true
     * });
     *
     * // Set the render target on a layer
     * layer.renderTarget = renderTarget;
     */
    var RenderTarget = function (options) {
        var _arg2 = arguments[1];
        var _arg3 = arguments[2];

        if (options instanceof GraphicsDevice) {
            // old constructor
            this._colorBuffer = _arg2;
            options = _arg3;
        } else {
            // new constructor
            this._colorBuffer = options.colorBuffer;
        }

        this._glFrameBuffer = null;
        this._glDepthBuffer = null;

        // Process optional arguments
        options = (options !== undefined) ? options : defaultOptions;
        this._depthBuffer = options.depthBuffer;
        this._face = (options.face !== undefined) ? options.face : 0;

        if (this._depthBuffer) {
            var format = this._depthBuffer._format;
            if (format === PIXELFORMAT_DEPTH) {
                this._depth = true;
                this._stencil = false;
            } else if (format === PIXELFORMAT_DEPTHSTENCIL) {
                this._depth = true;
                this._stencil = true;
            } else {
                this._depth = false;
                this._stencil = false;
            }
        } else {
            this._depth = (options.depth !== undefined) ? options.depth : true;
            this._stencil = (options.stencil !== undefined) ? options.stencil : false;
        }

        this._samples = (options.samples !== undefined) ? options.samples : 1;
        this.autoResolve = (options.autoResolve !== undefined) ? options.autoResolve : true;
        this._glResolveFrameBuffer = null;
        this._glMsaaColorBuffer = null;
        this._glMsaaDepthBuffer = null;
    };

    Object.assign(RenderTarget.prototype, {
        /**
         * @function
         * @name pc.RenderTarget#destroy
         * @description Frees resources associated with this render target.
         */
        destroy: function () {
            if (!this._device) return;

            var device = this._device;
            var idx = device.targets.indexOf(this);
            if (idx !== -1) {
                device.targets.splice(idx, 1);
            }

            var gl = device.gl;
            if (this._glFrameBuffer) {
                gl.deleteFramebuffer(this._glFrameBuffer);
                this._glFrameBuffer = null;
            }

            if (this._glDepthBuffer) {
                gl.deleteRenderbuffer(this._glDepthBuffer);
                this._glDepthBuffer = null;
            }

            if (this._glResolveFrameBuffer) {
                gl.deleteFramebuffer(this._glResolveFrameBuffer);
                this._glResolveFrameBuffer = null;
            }

            if (this._glMsaaColorBuffer) {
                gl.deleteRenderbuffer(this._glMsaaColorBuffer);
                this._glMsaaColorBuffer = null;
            }

            if (this._glMsaaDepthBuffer) {
                gl.deleteRenderbuffer(this._glMsaaDepthBuffer);
                this._glMsaaDepthBuffer = null;
            }
        },

        /**
         * @function
         * @name pc.RenderTarget#resolve
         * @description If samples > 1, resolves the anti-aliased render target (WebGL2 only).
         * When you're rendering to an anti-aliased render target, pixels aren't written directly to the readable texture.
         * Instead, they're first written to a MSAA buffer, where each sample for each pixel is stored independently.
         * In order to read the results, you first need to 'resolve' the buffer - to average all samples and create a simple texture with one color per pixel.
         * This function performs this averaging and updates the colorBuffer and the depthBuffer.
         * If autoResolve is set to true, the resolve will happen after every rendering to this render target, otherwise you can do it manually,
         * during the app update or inside a pc.Command.
         * @param {boolean} color - Resolve color buffer.
         * @param {boolean} depth - Resolve depth buffer.
         */
        resolve: function (color, depth) {
            if (!this._device) return;
            if (!this._device.webgl2) return;
            var gl = this._device.gl;

            if (color === undefined) color = true;
            if (depth === undefined && this._depthBuffer) depth = true;

            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);
            gl.blitFramebuffer( 0, 0, this.width, this.height,
                                0, 0, this.width, this.height,
                                (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0),
                                gl.NEAREST);

            gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
        },

        /**
         * @function
         * @name pc.RenderTarget#copy
         * @description Copies color and/or depth contents of source render target to this one. Formats, sizes and anti-aliasing samples must match.
         * Depth buffer can only be copied on WebGL 2.0.
         * @param {pc.RenderTarget} source - Source render target to copy from.
         * @param {boolean} [color] - If true will copy the color buffer. Defaults to false.
         * @param {boolean} [depth] - If true will copy the depth buffer. Defaults to false.
         * @returns {boolean} True if the copy was successful, false otherwise.
         */
        copy: function (source, color, depth) {
            if (!this._device) {
                if (source._device) {
                    this._device = source._device;
                } else {
                    return false;
                }
            }
            return this._device.copyRenderTarget(source, this, color, depth);
        }
    });

    /**
     * @readonly
     * @name pc.RenderTarget#colorBuffer
     * @type {pc.Texture}
     * @description Color buffer set up on the render target.
     */
    Object.defineProperty(RenderTarget.prototype, 'colorBuffer', {
        get: function () {
            return this._colorBuffer;
        }
    });

    /**
     * @readonly
     * @name pc.RenderTarget#depthBuffer
     * @type {pc.Texture}
     * @description Depth buffer set up on the render target. Only available, if depthBuffer was set in constructor.
     * Not available, if depth property was used instead.
     */
    Object.defineProperty(RenderTarget.prototype, 'depthBuffer', {
        get: function () {
            return this._depthBuffer;
        }
    });

    /**
     * @readonly
     * @name pc.RenderTarget#face
     * @type {number}
     * @description If the render target is bound to a cubemap, this property
     * specifies which face of the cubemap is rendered to. Can be:
     *
     * * {@link pc.CUBEFACE_POSX}
     * * {@link pc.CUBEFACE_NEGX}
     * * {@link pc.CUBEFACE_POSY}
     * * {@link pc.CUBEFACE_NEGY}
     * * {@link pc.CUBEFACE_POSZ}
     * * {@link pc.CUBEFACE_NEGZ}
     */
    Object.defineProperty(RenderTarget.prototype, 'face', {
        get: function () {
            return this._face;
        }
    });

    /**
     * @readonly
     * @name pc.RenderTarget#width
     * @type {number}
     * @description Width of the render target in pixels.
     */
    Object.defineProperty(RenderTarget.prototype, 'width', {
        get: function () {
            return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;
        }
    });

    /**
     * @readonly
     * @name pc.RenderTarget#height
     * @type {number}
     * @description Height of the render target in pixels.
     */
    Object.defineProperty(RenderTarget.prototype, 'height', {
        get: function () {
            return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;
        }
    });

    function syncToCpu(device, targ, face) {
        var tex = targ._colorBuffer;
        if (tex.format != PIXELFORMAT_R8_G8_B8_A8) return;
        var pixels = new Uint8Array(tex.width * tex.height * 4);
        var gl = device.gl;
        device.setFramebuffer(targ._glFrameBuffer);
        gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        if (!tex._levels) tex._levels = [];
        if (!tex._levels[0]) tex._levels[0] = [];
        tex._levels[0][face] = pixels;
    }

    /**
     * @static
     * @function
     * @name pc.prefilterCubemap
     * @description Prefilter a cubemap for use by a {@link pc.StandardMaterial} as an environment map. Should only be used for cubemaps that can't be prefiltered ahead of time (in the editor).
     * @param {object} options - The options for how the cubemap is prefiltered.
     */
    function prefilterCubemap(options) {
        var device = options.device;
        var sourceCubemap = options.sourceCubemap;
        var method = options.method;
        var samples = options.samples;
        var cpuSync = options.cpuSync;

        if (cpuSync && !sourceCubemap._levels[0]) {
            console.error("ERROR: prefilter: cubemap must have _levels");
            return;
        }

        var chunks = shaderChunks;
        var sourceType = sourceCubemap.type;
        var rgbmSource = sourceType === TEXTURETYPE_RGBM;
        var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.rgbmPS +
            chunks.prefilterCubemapPS
                .replace(/\$METHOD/g, method === 0 ? "cos" : "phong")
                .replace(/\$NUMSAMPLES/g, samples)
                .replace(/\$textureCube/g, rgbmSource ? "textureCubeRGBM" : "textureCube"),
                                                 "prefilter" + method + "" + samples + "" + rgbmSource);
        var shader2 = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.outputCubemapPS, "outputCubemap");
        var constantTexSource = device.scope.resolve("source");
        var constantParams = device.scope.resolve("params");
        var params = new Vec4();
        var size = sourceCubemap.width;
        var format = sourceCubemap.format;

        var cmapsList = [[], options.filteredFixed, options.filteredRgbm, options.filteredFixedRgbm];
        var gloss = method === 0 ? [0.9, 0.85, 0.7, 0.4, 0.25, 0.15, 0.1] : [512, 128, 32, 8, 2, 1, 1]; // TODO: calc more correct values depending on mip
        var mipSize = [64, 32, 16, 8, 4, 2, 1]; // TODO: make non-static?
        var numMips = 7;                        // generate all mips down to 1x1
        var targ;
        var i, face, pass;

        var rgbFormat = format === PIXELFORMAT_R8_G8_B8;
        var isImg = false;
        var nextCubemap, cubemap;
        if (cpuSync) {
            isImg = sourceCubemap._levels[0][0] instanceof HTMLImageElement;
        }
        if ((rgbFormat || isImg) && cpuSync) {
            // WebGL can't read non-RGBA pixels
            format = PIXELFORMAT_R8_G8_B8_A8;
            nextCubemap = new Texture(device, {
                cubemap: true,
                type: sourceType,
                format: format,
                width: size,
                height: size,
                mipmaps: false
            });
            nextCubemap.name = 'prefiltered-cube';
            for (face = 0; face < 6; face++) {
                targ = new RenderTarget(device, nextCubemap, {
                    face: face,
                    depth: false
                });
                params.x = face;
                params.y = 0;
                constantTexSource.setValue(sourceCubemap);
                constantParams.setValue(params.data);

                drawQuadWithShader(device, targ, shader2);
                syncToCpu(device, targ, face);
            }
            sourceCubemap = nextCubemap;
        }

        if (size > 128) {
            // Downsample to 128 first
            var log128 = Math.round(Math.log2(128));
            var logSize = Math.round(Math.log2(size));
            var steps = logSize - log128;
            for (i = 0; i < steps; i++) {
                size = sourceCubemap.width * 0.5;
                var sampleGloss = method === 0 ? 1 : Math.pow(2, Math.round(Math.log2(gloss[0]) + (steps - i) * 2));
                nextCubemap = new Texture(device, {
                    cubemap: true,
                    type: sourceType,
                    format: format,
                    width: size,
                    height: size,
                    mipmaps: false
                });
                nextCubemap.name = 'prefiltered-cube';
                for (face = 0; face < 6; face++) {
                    targ = new RenderTarget(device, nextCubemap, {
                        face: face,
                        depth: false
                    });
                    params.x = face;
                    params.y = sampleGloss;
                    params.z = size;
                    params.w = rgbmSource ? 3 : 0;
                    constantTexSource.setValue(sourceCubemap);
                    constantParams.setValue(params.data);

                    drawQuadWithShader(device, targ, shader2);
                    if (i === steps - 1 && cpuSync) {
                        syncToCpu(device, targ, face);
                    }
                }
                sourceCubemap = nextCubemap;
            }
        }
        options.sourceCubemap = sourceCubemap;

        var sourceCubemapRgbm = null;
        if (!rgbmSource && options.filteredFixedRgbm) {
            nextCubemap = new Texture(device, {
                cubemap: true,
                type: TEXTURETYPE_RGBM,
                format: PIXELFORMAT_R8_G8_B8_A8,
                width: size,
                height: size,
                mipmaps: false
            });
            nextCubemap.name = 'prefiltered-cube';
            for (face = 0; face < 6; face++) {
                targ = new RenderTarget(device, nextCubemap, {
                    face: face,
                    depth: false
                });
                params.x = face;
                params.w = 2;
                constantTexSource.setValue(sourceCubemap);
                constantParams.setValue(params.data);

                drawQuadWithShader(device, targ, shader2);
                syncToCpu(device, targ, face);
            }
            sourceCubemapRgbm = nextCubemap;
        }

        var unblurredGloss = method === 0 ? 1 : 2048;
        var startPass = method === 0 ? 0 : -1; // do prepass for unblurred downsampled textures when using importance sampling
        cmapsList[startPass] = [];

        // Initialize textures
        for (i = 0; i < numMips; i++) {
            for (pass = startPass; pass < cmapsList.length; pass++) {
                if (cmapsList[pass] != null) {
                    cmapsList[pass][i] = new Texture(device, {
                        cubemap: true,
                        type: pass < 2 ? sourceType : TEXTURETYPE_RGBM,
                        format: pass < 2 ? format : PIXELFORMAT_R8_G8_B8_A8,
                        fixCubemapSeams: pass === 1 || pass === 3,
                        width: mipSize[i],
                        height: mipSize[i],
                        mipmaps: false
                    });
                    cmapsList[pass][i].name = 'prefiltered-cube';
                }
            }
        }

        // Filter
        // [Prepass]: just downsample
        // Pass 0: just filter
        // Pass 1: filter + edge fixup
        // Pass 2: filter + encode to RGBM
        // Pass 3: filter + edge fixup + encode to RGBM
        for (pass = startPass; pass < cmapsList.length; pass++) {
            if (cmapsList[pass] != null) {
                if (pass > 1 && rgbmSource) {
                    // already RGBM
                    cmapsList[pass] = cmapsList[pass - 2];
                    continue;
                }
                for (i = 0; i < numMips; i++) {
                    for (face = 0; face < 6; face++) {
                        targ = new RenderTarget(device, cmapsList[pass][i], { // TODO: less excessive allocations
                            face: face,
                            depth: false
                        });
                        params.x = face;
                        params.y = pass < 0 ? unblurredGloss : gloss[i];
                        params.z = mipSize[i];
                        params.w = rgbmSource ? 3 : pass;
                        constantTexSource.setValue(i === 0 ? sourceCubemap :
                            method === 0 ? cmapsList[0][i - 1] : cmapsList[-1][i - 1]);
                        constantParams.setValue(params.data);

                        drawQuadWithShader(device, targ, shader);
                        if (cpuSync) syncToCpu(device, targ, face);
                    }
                }
            }
        }

        options.filtered = cmapsList[0];

        var mips;
        if (cpuSync && options.singleFilteredFixed) {
            mips = [sourceCubemap].concat(options.filteredFixed);
            cubemap = new Texture(device, {
                cubemap: true,
                type: sourceType,
                fixCubemapSeams: true,
                format: format,
                width: 128,
                height: 128,
                addressU: ADDRESS_CLAMP_TO_EDGE,
                addressV: ADDRESS_CLAMP_TO_EDGE
            });
            cubemap.name = 'prefiltered-cube';
            for (i = 0; i < mips.length; i++)
                cubemap._levels[i] = mips[i]._levels[0];

            cubemap.upload();
            cubemap._prefilteredMips = true;
            options.singleFilteredFixed = cubemap;
        }

        if (cpuSync && options.singleFilteredFixedRgbm && options.filteredFixedRgbm) {
            mips = [sourceCubemapRgbm].concat(options.filteredFixedRgbm);
            cubemap = new Texture(device, {
                cubemap: true,
                type: TEXTURETYPE_RGBM,
                fixCubemapSeams: true,
                format: PIXELFORMAT_R8_G8_B8_A8,
                width: 128,
                height: 128,
                addressU: ADDRESS_CLAMP_TO_EDGE,
                addressV: ADDRESS_CLAMP_TO_EDGE
            });
            cubemap.name = 'prefiltered-cube';
            for (i = 0; i < mips.length; i++) {
                cubemap._levels[i] = mips[i]._levels[0];
            }
            cubemap.upload();
            cubemap._prefilteredMips = true;
            options.singleFilteredFixedRgbm = cubemap;
        }
    }

    // https://seblagarde.wordpress.com/2012/06/10/amd-cubemapgen-for-physically-based-rendering/
    function areaElement(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
    }
    function texelCoordSolidAngle(u, v, size) {
        // Scale up to [-1, 1] range (inclusive), offset by 0.5 to point to texel center.
        var _u = (2.0 * (u + 0.5) / size ) - 1.0;
        var _v = (2.0 * (v + 0.5) / size ) - 1.0;

        // fixSeams
        _u *= 1.0 - 1.0 / size;
        _v *= 1.0 - 1.0 / size;

        var invResolution = 1.0 / size;

        // U and V are the -1..1 texture coordinate on the current face.
        // Get projected area for this texel
        var x0 = _u - invResolution;
        var y0 = _v - invResolution;
        var x1 = _u + invResolution;
        var y1 = _v + invResolution;
        var solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);

        // fixSeams cut
        if ((u === 0 && v === 0) || (u === size - 1 && v === 0) || (u === 0 && v === size - 1) || (u === size - 1 && v === size - 1)) {
            solidAngle /= 3;
        } else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {
            solidAngle *= 0.5;
        }

        return solidAngle;
    }

    function shFromCubemap(source, dontFlipX) {
        var face;
        var cubeSize = source.width;
        var x, y;

        if (source.format != PIXELFORMAT_R8_G8_B8_A8) {
            console.error("ERROR: SH: cubemap must be RGBA8");
            return;
        }
        if (!source._levels[0]) {
            console.error("ERROR: SH: cubemap must be synced to CPU");
            return;
        }
        if (!source._levels[0][0].length) {
            // Cubemap is not composed of arrays
            if (source._levels[0][0] instanceof HTMLImageElement) {
                // Cubemap is made of imgs - convert to arrays
                var device = Application.getApplication().graphicsDevice;
                var gl = device.gl;
                var chunks = shaderChunks;
                var shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, chunks.fullscreenQuadPS, "fsQuadSimple");
                var constantTexSource = device.scope.resolve("source");
                for (face = 0; face < 6; face++) {
                    var img = source._levels[0][face];

                    var tex = new Texture(device, {
                        cubemap: false,
                        type: TEXTURETYPE_DEFAULT,
                        format: source.format,
                        width: cubeSize,
                        height: cubeSize,
                        mipmaps: false
                    });
                    tex.name = 'prefiltered-cube';
                    tex._levels[0] = img;
                    tex.upload();

                    var tex2 = new Texture(device, {
                        cubemap: false,
                        type: TEXTURETYPE_DEFAULT,
                        format: source.format,
                        width: cubeSize,
                        height: cubeSize,
                        mipmaps: false
                    });
                    tex2.name = 'prefiltered-cube';

                    var targ = new RenderTarget(device, tex2, {
                        depth: false
                    });
                    constantTexSource.setValue(tex);
                    drawQuadWithShader(device, targ, shader);

                    var pixels = new Uint8Array(cubeSize * cubeSize * 4);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);
                    gl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

                    source._levels[0][face] = pixels;
                }
            } else {
                console.error("ERROR: SH: cubemap must be composed of arrays or images");
                return;
            }
        }

        var dirs = [];
        for (y = 0; y < cubeSize; y++) {
            for (x = 0; x < cubeSize; x++) {
                var u = (x / (cubeSize - 1)) * 2 - 1;
                var v = (y / (cubeSize - 1)) * 2 - 1;
                dirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();
            }
        }

        var sh = new Float32Array(9 * 3);
        var coef1 = 0;
        var coef2 = 1 * 3;
        var coef3 = 2 * 3;
        var coef4 = 3 * 3;
        var coef5 = 4 * 3;
        var coef6 = 5 * 3;
        var coef7 = 6 * 3;
        var coef8 = 7 * 3;
        var coef9 = 8 * 3;

        var nx = 0;
        var px = 1;
        var ny = 2;
        var py = 3;
        var nz = 4;
        var pz = 5;

        var addr, c, a, value, weight, dir, dx, dy, dz;
        var weight1, weight2, weight3, weight4, weight5;

        var accum = 0;
        for (face = 0; face < 6; face++) {
            for (y = 0; y < cubeSize; y++) {
                for (x = 0; x < cubeSize; x++) {

                    addr = y * cubeSize + x;
                    weight = texelCoordSolidAngle(x, y, cubeSize);

                    // http://home.comcast.net/~tom_forsyth/blog.wiki.html#[[Spherical%20Harmonics%20in%20Actual%20Games%20notes]]
                    weight1 = weight * 4 / 17;
                    weight2 = weight * 8 / 17;
                    weight3 = weight * 15 / 17;
                    weight4 = weight * 5 / 68;
                    weight5 = weight * 15 / 68;

                    dir = dirs[addr];
                    if (face == nx) {
                        dx = dir.z;
                        dy = -dir.y;
                        dz = -dir.x;
                    } else if (face == px) {
                        dx = -dir.z;
                        dy = -dir.y;
                        dz = dir.x;
                    } else if (face == ny) {
                        dx = dir.x;
                        dy = dir.z;
                        dz = dir.y;
                    } else if (face == py) {
                        dx = dir.x;
                        dy = -dir.z;
                        dz = -dir.y;
                    } else if (face == nz) {
                        dx = dir.x;
                        dy = -dir.y;
                        dz = dir.z;
                    } else if (face == pz) {
                        dx = -dir.x;
                        dy = -dir.y;
                        dz = -dir.z;
                    }

                    if (!dontFlipX) dx = -dx; // flip original cubemap x instead of doing it at runtime

                    a = source._levels[0][face][addr * 4 + 3] / 255.0;

                    for (c = 0; c < 3; c++) {
                        value =  source._levels[0][face][addr * 4 + c] / 255.0;
                        if (source.type === TEXTURETYPE_RGBM) {
                            value *= a * 8.0;
                            value *= value;
                        } else {
                            value = Math.pow(value, 2.2);
                        }

                        sh[coef1 + c] += value * weight1;
                        sh[coef2 + c] += value * weight2 * dx;
                        sh[coef3 + c] += value * weight2 * dy;
                        sh[coef4 + c] += value * weight2 * dz;

                        sh[coef5 + c] += value * weight3 * dx * dz;
                        sh[coef6 + c] += value * weight3 * dz * dy;
                        sh[coef7 + c] += value * weight3 * dy * dx;

                        sh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);
                        sh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);

                        accum += weight;
                    }
                }
            }
        }

        for (c = 0; c < sh.length; c++) {
            sh[c] *= 4 * Math.PI / accum;
        }

        return sh;
    }

    // Primitive for drawFullscreenQuad
    var primitive = {
        type: PRIMITIVE_TRISTRIP,
        base: 0,
        count: 4,
        indexed: false
    };

    /**
     * @class
     * @name pc.PostEffect
     * @classdesc Base class for all post effects. Post effects take a a render target as input
     * apply effects to it and then render the result to an output render target or the screen
     * if no output is specified.
     * @description Creates new PostEffect.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device of the application.
     * @property {pc.GraphicsDevice} device The graphics device of the application. [read only].
     * @property {pc.VertexBuffer} vertexBuffer The vertex buffer for the fullscreen quad. Used when calling {@link pc.drawFullscreenQuad}. [read only].
     * @property {pc.Shader|null} shader The shader definition for the fullscreen quad. Needs to be set by the custom post effect (default is null). Used when calling {@link pc.drawFullscreenQuad}.
     * @property {boolean} needsDepthBuffer The property that should to be set to `true` (by the custom post effect) if a depth map is necessary (default is false).
     */
    function PostEffect(graphicsDevice) {
        this.device = graphicsDevice;
        this.shader = null;
        this.depthMap = null;
        this.vertexBuffer = createFullscreenQuad(graphicsDevice);
        this.needsDepthBuffer = false;
    }

    Object.assign(PostEffect.prototype, {
        /**
         * @function
         * @name pc.PostEffect#render
         * @description Render the post effect using the specified inputTarget
         * to the specified outputTarget.
         * @param {pc.RenderTarget} inputTarget - The input render target.
         * @param {pc.RenderTarget} outputTarget - The output render target. If null then this will be the screen.
         * @param {pc.Vec4} rect - (Optional) The rect of the current camera. If not specified then it will default to [0,0,1,1].
         */
        render: function (inputTarget, outputTarget, rect) {
        }
    });

    function createFullscreenQuad(device) {
        // Create the vertex format
        var vertexFormat = new VertexFormat(device, [
            { semantic: SEMANTIC_POSITION, components: 2, type: TYPE_FLOAT32 }
        ]);

        // Create a vertex buffer
        var vertexBuffer = new VertexBuffer(device, vertexFormat, 4);

        // Fill the vertex buffer
        var iterator = new VertexIterator(vertexBuffer);
        iterator.element[SEMANTIC_POSITION].set(-1.0, -1.0);
        iterator.next();
        iterator.element[SEMANTIC_POSITION].set(1.0, -1.0);
        iterator.next();
        iterator.element[SEMANTIC_POSITION].set(-1.0, 1.0);
        iterator.next();
        iterator.element[SEMANTIC_POSITION].set(1.0, 1.0);
        iterator.end();

        return vertexBuffer;
    }

    /**
     * @static
     * @function
     * @name pc.drawFullscreenQuad
     * @description Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post effects based on {@link pc.PostEffect}.
     * @param {pc.GraphicsDevice} device - The graphics device of the application.
     * @param {pc.RenderTarget} target - The output render target.
     * @param {pc.VertexBuffer} vertexBuffer - The vertex buffer for the rectangle mesh. When calling from a custom post effect, pass the field {@link pc.PostEffect#vertexBuffer}.
     * @param {pc.Shader} shader - The shader to be used for drawing the rectangle. When calling from a custom post effect, pass the field {@link pc.PostEffect#shader}.
     * @param {pc.Vec4} [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z, rect.w) of the rectangle. Default is [0, 0, 1, 1].
     */
    function drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {
        var oldRt = device.getRenderTarget();
        device.setRenderTarget(target);
        device.updateBegin();

        var w = (target !== null) ? target.width : device.width;
        var h = (target !== null) ? target.height : device.height;
        var x = 0;
        var y = 0;

        if (rect) {
            x = rect.x * w;
            y = rect.y * h;
            w *= rect.z;
            h *= rect.w;
        }

        var oldVx = device.vx;
        var oldVy = device.vy;
        var oldVw = device.vw;
        var oldVh = device.vh;
        device.setViewport(x, y, w, h);
        var oldSx = device.sx;
        var oldSy = device.sy;
        var oldSw = device.sw;
        var oldSh = device.sh;
        device.setScissor(x, y, w, h);

        var oldBlending = device.getBlending();
        var oldDepthTest = device.getDepthTest();
        var oldDepthWrite = device.getDepthWrite();
        var oldCullMode = device.getCullMode();
        var oldWR = device.writeRed;
        var oldWG = device.writeGreen;
        var oldWB = device.writeBlue;
        var oldWA = device.writeAlpha;
        device.setBlending(false);
        device.setDepthTest(false);
        device.setDepthWrite(false);
        device.setCullMode(CULLFACE_NONE);
        device.setColorWrite(true, true, true, true);

        device.setVertexBuffer(vertexBuffer, 0);
        device.setShader(shader);

        device.draw(primitive);

        device.setBlending(oldBlending);
        device.setDepthTest(oldDepthTest);
        device.setDepthWrite(oldDepthWrite);
        device.setCullMode(oldCullMode);
        device.setColorWrite(oldWR, oldWG, oldWB, oldWA);

        device.updateEnd();

        device.setRenderTarget(oldRt);
        device.updateBegin();

        device.setViewport(oldVx, oldVy, oldVw, oldVh);
        device.setScissor(oldSx, oldSy, oldSw, oldSh);
    }

    /* eslint-disable jsdoc/check-examples */
    /**
     * @class
     * @name pc.TransformFeedback
     * @classdesc Transform feedback helper object.
     * @description This object allows you to configure and use the transform feedback feature (WebGL2
     * only). How to use:
     *
     * 1. First, check that you're on WebGL2, by looking at the `app.graphicsDevice.webgl2`` value.
     * 2. Define the outputs in your vertex shader. The syntax is `out vec3 out_vertex_position`,
     * note that there must be out_ in the name. You can then simply assign values to these outputs
     * in VS. The order and size of shader outputs must match the output buffer layout.
     * 3. Create the shader using `pc.TransformFeedback.createShader(device, vsCode, yourShaderName)`.
     * 4. Create/acquire the input vertex buffer. Can be any pc.VertexBuffer, either manually created,
     * or from a pc.Mesh.
     * 5. Create the pc.TransformFeedback object: `var tf = new pc.TransformFeedback(inputBuffer)`.
     * This object will internally create an output buffer.
     * 6. Run the shader: `tf.process(shader)`. Shader will take the input buffer, process it and
     * write to the output buffer, then the input/output buffers will be automatically swapped, so
     * you'll immediately see the result.
     * @param {pc.VertexBuffer} inputBuffer - The input vertex buffer.
     * @param {number} [usage] - The optional usage type of the output vertex buffer. Can be:
     *
     * * {@link pc.BUFFER_STATIC}
     * * {@link pc.BUFFER_DYNAMIC}
     * * {@link pc.BUFFER_STREAM}
     * * {@link pc.BUFFER_GPUDYNAMIC}
     *
     * Defaults to pc.BUFFER_GPUDYNAMIC (which is recommended for continuous update).
     * @example
     * // *** shader asset ***
     * attribute vec3 vertex_position;
     * attribute vec3 vertex_normal;
     * attribute vec2 vertex_texCoord0;
     * attribute vec4 vertex_tangent;
     * out vec3 out_vertex_position;
     * out vec3 out_vertex_normal;
     * out vec2 out_vertex_texCoord0;
     * out vec4 out_vertex_tangent;
     * void main(void) {
     *     // read position and normal, write new position (push away)
     *     out_vertex_position = vertex_position + vertex_normal * 0.01;
     *     // pass other attributes unchanged
     *     out_vertex_normal = vertex_normal;
     *     out_vertex_texCoord0 = vertex_texCoord0;
     *     out_vertex_tangent = vertex_tangent;
     * }
     * @example
     * // *** script asset ***
     * var TransformExample = pc.createScript('transformExample');
     *
     * // attribute that references shader asset and material
     * TransformExample.attributes.add('shaderCode', { type: 'asset', assetType: 'shader' });
     * TransformExample.attributes.add('material', { type: 'asset', assetType: 'material' });
     *
     * TransformExample.prototype.initialize = function() {
     *     var device = this.app.graphicsDevice;
     *     var mesh = pc.createTorus(device, { tubeRadius: 0.01, ringRadius: 3 });
     *     var node = new pc.GraphNode();
     *     var meshInstance = new pc.MeshInstance(node, mesh, this.material.resource);
     *     var model = new pc.Model();
     *     model.graph = node;
     *     model.meshInstances = [ meshInstance ];
     *     this.app.scene.addModel(model);
     *
     *     // if webgl2 is not supported, TF is not available
     *     if (!device.webgl2) return;
     *     var inputBuffer = mesh.vertexBuffer;
     *     this.tf = new pc.TransformFeedback(inputBuffer);
     *     this.shader = pc.TransformFeedback.createShader(device, this.shaderCode.resource, "tfMoveUp");
     * };
     *
     * TransformExample.prototype.update = function(dt) {
     *     if (!this.app.graphicsDevice.webgl2) return;
     *     this.tf.process(this.shader);
     * };
     */
    /* eslint-enable jsdoc/check-examples */
    function TransformFeedback(inputBuffer, usage) {
        usage = usage || BUFFER_GPUDYNAMIC;
        this.device = inputBuffer.device;
        var gl = this.device.gl;

        this._inputBuffer = inputBuffer;
        if (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {
            // have to recreate input buffer with other usage
            gl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);
            gl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);
        }

        this._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);
    }

    /**
     * @function
     * @name pc.TransformFeedback#createShader
     * @description Creates a transform feedback ready vertex shader from code.
     * @param {pc.GraphicsDevice} graphicsDevice - The graphics device used by the renderer.
     * @param {string} vsCode - Vertex shader code. Should contain output variables starting with "out_".
     * @param {string} name - Unique name for caching the shader.
     * @returns {pc.Shader} A shader to use in the process() function.
     */
    TransformFeedback.createShader = function (graphicsDevice, vsCode, name) {
        return shaderChunks.createShaderFromCode(graphicsDevice, vsCode, null, name, true);
    };

    Object.assign(TransformFeedback.prototype, {
        /**
         * @function
         * @name pc.TransformFeedback#destroy
         * @description Destroys the transform feedback helper object.
         */
        destroy: function () {
            this._outputBuffer.destroy();
        },

        /**
         * @function
         * @name pc.TransformFeedback#process
         * @description Runs the specified shader on the input buffer, writes results into the new buffer, then optionally swaps input/output.
         * @param {pc.Shader} shader - A vertex shader to run. Should be created with pc.TransformFeedback.createShader.
         * @param {boolean} [swap] - Swap input/output buffer data. Useful for continuous buffer processing. Default is true.
         */
        process: function (shader, swap) {
            if (swap === undefined) swap = true;

            var device = this.device;
            device.setRenderTarget(null);
            device.updateBegin();
            device.setVertexBuffer(this._inputBuffer, 0);
            device.setRaster(false);
            device.setTransformFeedbackBuffer(this._outputBuffer);
            device.setShader(shader);
            device.draw({
                type: PRIMITIVE_POINTS,
                base: 0,
                count: this._inputBuffer.numVertices,
                indexed: false
            });
            device.setTransformFeedbackBuffer(null);
            device.setRaster(true);
            device.updateEnd();

            // swap buffers
            if (swap) {
                var tmp = this._inputBuffer.bufferId;
                this._inputBuffer.bufferId = this._outputBuffer.bufferId;
                this._outputBuffer.bufferId = tmp;
            }
        }
    });

    /**
     * @readonly
     * @name pc.TransformFeedback#inputBuffer
     * @type {pc.VertexBuffer}
     * @description The current input buffer.
     */
    Object.defineProperty(TransformFeedback.prototype, 'inputBuffer', {
        get: function () {
            return this._inputBuffer;
        }
    });

    /**
     * @readonly
     * @name pc.TransformFeedback#outputBuffer
     * @type {pc.VertexBuffer}
     * @description The current output buffer.
     */
    Object.defineProperty(TransformFeedback.prototype, 'outputBuffer', {
        get: function () {
            return this._outputBuffer;
        }
    });

    /**
     * @private
     * @class
     * @name pc.DepthMaterial
     * @classdesc A Depth material is for rendering linear depth values to a render target.
     */
    function DepthMaterial() {
        Material.call(this);
    }
    DepthMaterial.prototype = Object.create(Material.prototype);
    DepthMaterial.prototype.constructor = DepthMaterial;

    Object.assign(DepthMaterial.prototype, {
        /**
         * @private
         * @function
         * @name pc.DepthMaterial#clone
         * @description Duplicates a Depth material.
         * @returns {pc.DepthMaterial} A cloned Depth material.
         */
        clone: function () {
            var clone = new DepthMaterial();

            Material.prototype._cloneInternal.call(this, clone);

            return clone;
        },

        updateShader: function (device) {
            var options = {
                skin: !!this.meshInstances[0].skinInstance
            };
            var library = device.getProgramLibrary();
            this.shader = library.getProgram('depth', options);
        }
    });

    /**
     * @class
     * @name pc.Picker
     * @classdesc Picker object used to select mesh instances from screen coordinates.
     * @description Create a new instance of a Picker object.
     * @param {pc.Application} app - The application managing this picker instance.
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     * @property {number} width Width of the pick buffer in pixels (read-only).
     * @property {number} height Height of the pick buffer in pixels (read-only).
     * @property {pc.RenderTarget} renderTarget The render target used by the picker internally (read-only).
     */
    function Picker(app, width, height) {
        if (app instanceof GraphicsDevice) {
            app = Application.getApplication();
        }

        this.app = app;
        this.device = app.graphicsDevice;
        var device = this.device;

        this.library = device.getProgramLibrary();

        this.pickColor = new Float32Array(4);
        this.pickColor[3] = 1;

        this.scene = null;
        this.drawCalls = [];
        this.layer = null;
        this.layerComp = null;

        this.clearOptions = {
            color: [1, 1, 1, 1],
            depth: 1,
            flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
        };

        var self = this;
        this._clearDepthOptions = {
            depth: 1.0,
            flags: CLEARFLAG_DEPTH
        };
        this.clearDepthCommand = new Command(0, 0, function (){
            device.clear(self._clearDepthOptions);
        });

        this.resize(width, height);

        this._ignoreOpacityFor = null; // meshInstance
    }

    /**
     * @function
     * @name pc.Picker#getSelection
     * @description Return the list of mesh instances selected by the specified rectangle in the
     * previously prepared pick buffer.The rectangle using top-left coordinate system.
     * @param {number} x - The left edge of the rectangle.
     * @param {number} y - The top edge of the rectangle.
     * @param {number} [width] - The width of the rectangle.
     * @param {number} [height] - The height of the rectangle.
     * @returns {pc.MeshInstance[]} An array of mesh instances that are in the selection.
     * @example
     * // Get the selection at the point (10,20)
     * var selection = picker.getSelection(10, 20);
     * @example
     * // Get all models in rectangle with corners at (10,20) and (20,40)
     * var selection = picker.getSelection(10, 20, 10, 20);
     */
    Picker.prototype.getSelection = function (x, y, width, height) {
        var device = this.device;

        if (typeof x === 'object') {

            var rect = x;
            x = rect.x;
            y = rect.y;
            width = rect.width;
            height = rect.height;
        } else {
            y = this.layer.renderTarget.height - (y + (height || 1));
        }

        width = width || 1;
        height = height || 1;

        // Cache active render target
        var prevRenderTarget = device.renderTarget;

        // Ready the device for rendering to the pick buffer
        device.setRenderTarget(this.layer.renderTarget);
        device.updateBegin();

        var pixels = new Uint8Array(4 * width * height);
        device.readPixels(x, y, width, height, pixels);

        device.updateEnd();

        // Restore render target
        device.setRenderTarget(prevRenderTarget);

        var selection = [];

        var drawCalls = this.layer.instances.visibleOpaque[0].list;

        var r, g, b, index;
        for (var i = 0; i < width * height; i++) {
            r = pixels[4 * i + 0];
            g = pixels[4 * i + 1];
            b = pixels[4 * i + 2];
            index = r << 16 | g << 8 | b;
            // White is 'no selection'
            if (index !== 0xffffff) {
                var selectedMeshInstance = drawCalls[index];
                if (selection.indexOf(selectedMeshInstance) === -1) {
                    selection.push(selectedMeshInstance);
                }
            }
        }

        return selection;
    };

    /**
     * @function
     * @name pc.Picker#prepare
     * @description Primes the pick buffer with a rendering of the specified models from the point of view
     * of the supplied camera. Once the pick buffer has been prepared, pc.Picker#getSelection can be
     * called multiple times on the same picker object. Therefore, if the models or camera do not change
     * in any way, pc.Picker#prepare does not need to be called again.
     * @param {pc.CameraComponent} camera - The camera component used to render the scene.
     * @param {pc.Scene} scene - The scene containing the pickable mesh instances.
     * @param {pc.Layer|pc.RenderTarget} [arg] - Layer or RenderTarget from which objects will be picked. If not supplied, all layers rendering to backbuffer before this layer will be used.
     */
    Picker.prototype.prepare = function (camera, scene, arg) {
        var device = this.device;
        var i, j;
        var self = this;

        if (camera instanceof Camera) {
            camera = camera._component;
        }

        this.scene = scene;
        var sourceLayer = null;
        var sourceRt = null;

        if (arg instanceof Layer) {
            sourceLayer = arg;
        } else {
            sourceRt = arg;
        }

        // Setup picker rendering once
        if (!this.layer) {
            var pickColorId = device.scope.resolve('uColor');

            this.layer = new Layer({
                name: "Picker",
                shaderPass: SHADER_PICK,
                opaqueSortMode: SORTMODE_NONE,

                onEnable: function () {
                    if (this.renderTarget) return;
                    var colorBuffer = new Texture(device, {
                        format: PIXELFORMAT_R8_G8_B8_A8,
                        width: self.width,
                        height: self.height
                    });
                    colorBuffer.name = 'pick';
                    colorBuffer.minFilter = FILTER_NEAREST;
                    colorBuffer.magFilter = FILTER_NEAREST;
                    colorBuffer.addressU = ADDRESS_CLAMP_TO_EDGE;
                    colorBuffer.addressV = ADDRESS_CLAMP_TO_EDGE;
                    this.renderTarget = new RenderTarget(device, colorBuffer, {
                        depth: true
                    });
                },

                onDisable: function () {
                    if (!this.renderTarget) return;
                    this.renderTarget._colorBuffer.destroy();
                    this.renderTarget.destroy();
                    this.renderTarget = null;
                },

                onDrawCall: function (meshInstance, index) {
                    self.pickColor[0] = ((index >> 16) & 0xff) / 255;
                    self.pickColor[1] = ((index >> 8) & 0xff) / 255;
                    self.pickColor[2] = (index & 0xff) / 255;
                    pickColorId.setValue(self.pickColor);
                    device.setBlending(false);
                }
            });

            this.layerComp = new LayerComposition();
            this.layerComp.pushOpaque(this.layer);

            this.meshInstances = this.layer.opaqueMeshInstances;
            this._instancesVersion = -1;
        }

        // Collect pickable mesh instances
        var instanceList, instanceListLength, drawCall;
        if (!sourceLayer) {
            this.layer.clearMeshInstances();
            var layers = scene.layers.layerList;
            var subLayerEnabled = scene.layers.subLayerEnabled;
            var isTransparent = scene.layers.subLayerList;
            var layer;
            var layerCamId, transparent;
            for (i = 0; i < layers.length; i++) {
                if (layers[i].overrideClear && layers[i]._clearDepthBuffer) layers[i]._pickerCleared = false;
            }
            for (i = 0; i < layers.length; i++) {
                layer = layers[i];
                if (layer.renderTarget !== sourceRt || !layer.enabled || !subLayerEnabled[i]) continue;
                layerCamId = layer.cameras.indexOf(camera);
                if (layerCamId < 0) continue;
                if (layer.overrideClear && layer._clearDepthBuffer && !layer._pickerCleared) {
                    this.meshInstances.push(this.clearDepthCommand);
                    layer._pickerCleared = true;
                }
                transparent = isTransparent[i];
                instanceList = transparent ? layer.instances.transparentMeshInstances : layer.instances.opaqueMeshInstances;
                instanceListLength = instanceList.length;
                for (j = 0; j < instanceListLength; j++) {
                    drawCall = instanceList[j];
                    if (drawCall.pick) {
                        this.meshInstances.push(drawCall);
                    }
                }
            }
        } else {
            if (this._instancesVersion !== sourceLayer._version) {
                this.layer.clearMeshInstances();
                instanceList = sourceLayer.instances.opaqueMeshInstances;
                instanceListLength = instanceList.length;
                for (j = 0; j < instanceListLength; j++) {
                    drawCall = instanceList[j];
                    if (drawCall.pick) {
                        this.meshInstances.push(drawCall);
                    }
                }
                instanceList = sourceLayer.instances.transparentMeshInstances;
                instanceListLength = instanceList.length;
                for (j = 0; j < instanceListLength; j++) {
                    drawCall = instanceList[j];
                    if (drawCall.pick) {
                        this.meshInstances.push(drawCall);
                    }
                }
                this._instancesVersion = sourceLayer._version;
            }
        }

        // Setup picker camera if changed
        if (this.layer.cameras[0] !== camera) {
            this.layer.clearCameras();
            this.layer.addCamera(camera);
        }

        // save old camera state
        this.onLayerPreRender(this.layer, sourceLayer, sourceRt);

        // Render
        this.app.renderer.renderComposition(this.layerComp);

        // restore old camera state
        this.onLayerPostRender(this.layer);
    };

    Picker.prototype.onLayerPreRender = function (layer, sourceLayer, sourceRt) {
        if (this.width !== layer.renderTarget.width || this.height !== layer.renderTarget.height) {
            layer.onDisable();
            layer.onEnable();
        }
        layer.oldClear = layer.cameras[0].camera._clearOptions;
        layer.oldAspectMode = layer.cameras[0].aspectRatioMode;
        layer.oldAspect = layer.cameras[0].aspectRatio;
        layer.cameras[0].camera._clearOptions = this.clearOptions;
        layer.cameras[0].aspectRatioMode = ASPECT_MANUAL;
        var rt = sourceRt ? sourceRt : (sourceLayer ? sourceLayer.renderTarget : null);
        layer.cameras[0].aspectRatio = layer.cameras[0].calculateAspectRatio(rt);
        this.app.renderer.updateCameraFrustum(layer.cameras[0].camera);
    };

    Picker.prototype.onLayerPostRender = function (layer) {
        layer.cameras[0].camera._clearOptions = layer.oldClear;
        layer.cameras[0].aspectRatioMode = layer.oldAspectMode;
        layer.cameras[0].aspectRatio = layer.oldAspect;
    };

    /**
     * @function
     * @name pc.Picker#resize
     * @description Sets the resolution of the pick buffer. The pick buffer resolution does not need
     * to match the resolution of the corresponding frame buffer use for general rendering of the
     * 3D scene. However, the lower the resolution of the pick buffer, the less accurate the selection
     * results returned by pc.Picker#getSelection. On the other hand, smaller pick buffers will
     * yield greater performance, so there is a trade off.
     * @param {number} width - The width of the pick buffer in pixels.
     * @param {number} height - The height of the pick buffer in pixels.
     */
    Picker.prototype.resize = function (width, height) {
        this.width = width;
        this.height = height;
    };

    Object.defineProperty(Picker.prototype, 'renderTarget', {
        get: function () {
            return this.layer.renderTarget;
        }
    });

    // Basis worker function. The function assumes pc.PIXELFORMAT_ enums are available.
    function BasisWorker() {

        // Basis compression format enums
        // Note: these must match definitions in the BASIS module
        var BASIS_FORMAT = {
            cTFETC1: 0,                         // etc1
            cTFETC2: 1,                         // etc2
            cTFBC1: 2,                          // dxt1
            cTFBC3: 3,                          // dxt5
            cTFPVRTC1_4_RGB: 8,                 // PVRTC1 rgb
            cTFPVRTC1_4_RGBA: 9,                // PVRTC1 rgba
            cTFASTC_4x4: 10,                    // ASTC
            cTFATC_RGB: 11,                     // ATC rgb
            cTFATC_RGBA_INTERPOLATED_ALPHA: 12, // ATC rgba
            // uncompressed (fallback) formats
            cTFRGBA32: 13,                      // rgba 8888
            cTFRGB565: 14,                      // rgb 565
            cTFRGBA4444: 16                     // rgba 4444
        };

        // Map GPU to basis format for textures without alpha
        var opaqueMapping = {
            astc: BASIS_FORMAT.cTFASTC_4x4,
            dxt: BASIS_FORMAT.cTFBC1,
            etc2: BASIS_FORMAT.cTFETC1,
            etc1: BASIS_FORMAT.cTFETC1,
            pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
            atc: BASIS_FORMAT.cTFATC_RGB,
            none: BASIS_FORMAT.cTFRGB565
        };

        // Map GPU to basis format for textures with alpha
        var alphaMapping = {
            astc: BASIS_FORMAT.cTFASTC_4x4,
            dxt: BASIS_FORMAT.cTFBC3,
            etc2: BASIS_FORMAT.cTFETC2,
            etc1: BASIS_FORMAT.cTFRGBA4444,
            pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
            atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
            none: BASIS_FORMAT.cTFRGBA4444
        };

        // Map basis format to engine pixel format
        var basisToEngineMapping = { };
        basisToEngineMapping[BASIS_FORMAT.cTFETC1]          = PIXELFORMAT_ETC1;
        basisToEngineMapping[BASIS_FORMAT.cTFETC2]          = PIXELFORMAT_ETC2_RGBA;
        basisToEngineMapping[BASIS_FORMAT.cTFBC1]           = PIXELFORMAT_DXT1;
        basisToEngineMapping[BASIS_FORMAT.cTFBC3]           = PIXELFORMAT_DXT5;
        basisToEngineMapping[BASIS_FORMAT.cTFPVRTC1_4_RGB]  = PIXELFORMAT_PVRTC_4BPP_RGB_1;
        basisToEngineMapping[BASIS_FORMAT.cTFPVRTC1_4_RGBA] = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
        basisToEngineMapping[BASIS_FORMAT.cTFASTC_4x4]      = PIXELFORMAT_ASTC_4x4;
        basisToEngineMapping[BASIS_FORMAT.cTFATC_RGB]       = PIXELFORMAT_ATC_RGB;
        basisToEngineMapping[BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA] = PIXELFORMAT_ATC_RGBA;
        basisToEngineMapping[BASIS_FORMAT.cTFRGBA32]        = PIXELFORMAT_R8_G8_B8_A8;
        basisToEngineMapping[BASIS_FORMAT.cTFRGB565]        = PIXELFORMAT_R5_G6_B5;
        basisToEngineMapping[BASIS_FORMAT.cTFRGBA4444]      = PIXELFORMAT_R4_G4_B4_A4;

        var hasPerformance = typeof performance !== 'undefined';

        // unswizzle two-component gggr8888 normal data into rgba8888
        var unswizzleGGGR = function (data) {
            // given R and G generate B
            var genB = function (R, G) {
                var r = R * (2.0 / 255.0) - 1.0;
                var g = G * (2.0 / 255.0) - 1.0;
                var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
                return Math.max(0, Math.min(255, Math.floor(((b + 1.0) * 0.5) * 255.0)));
            };

            for (var offset = 0; offset < data.length; offset += 4) {
                var R = data[offset + 3];
                var G = data[offset + 1];
                data[offset + 0] = R;
                data[offset + 2] = genB(R, G);
                data[offset + 3] = 255;
            }

            return data;
        };

        // pack rgba8888 data into rgb565
        var pack565 = function (data) {
            var result = new Uint16Array(data.length / 4);

            for (var offset = 0; offset < data.length; offset += 4) {
                var R = data[offset + 0];
                var G = data[offset + 1];
                var B = data[offset + 2];
                result[offset / 4] = ((R & 0xf8) << 8) |  // 5
                                     ((G & 0xfc) << 3) |  // 6
                                     ((B >> 3));          // 5
            }

            return result;
        };

        // transcode the basis super-compressed data into one of the runtime gpu native formats
        var transcode = function (basis, url, format, data, options) {
            var funcStart = hasPerformance ? performance.now() : 0;
            var basisFile = new basis.BasisFile(new Uint8Array(data));

            var width = basisFile.getImageWidth(0, 0);
            var height = basisFile.getImageHeight(0, 0);
            var images = basisFile.getNumImages();
            var levels = basisFile.getNumLevels(0);
            var hasAlpha = !!basisFile.getHasAlpha();

            if (!width || !height || !images || !levels) {
                basisFile.close();
                basisFile.delete();
                throw new Error('Invalid image dimensions url=' + url + ' width=' + width + ' height=' + height + ' images=' + images + ' levels=' + levels);
            }

            // select format based on supported formats
            var basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];

            // PVR does not support non-square or non-pot textures. In these cases we
            // transcode to an uncompressed format.
            if ((basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGB ||
                 basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGBA)) {
                // if not power-of-two or not square
                if (((width & (width - 1)) !== 0) || (width !== height)) {
                    basisFormat = (basisFormat === BASIS_FORMAT.cTFPVRTC1_4_RGB) ?
                        BASIS_FORMAT.cTFRGB565 : BASIS_FORMAT.cTFRGBA32;
                }
            }

            if (options && options.unswizzleGGGR) {
                // in order unswizzle we need gggr8888
                basisFormat = BASIS_FORMAT.cTFRGBA32;
            }

            if (!basisFile.startTranscoding()) {
                basisFile.close();
                basisFile.delete();
                throw new Error('Failed to start transcoding url=' + url);
            }

            var i;

            var levelData = [];
            for (var mip = 0; mip < levels; ++mip) {
                var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
                var dst = new Uint8Array(dstSize);

                if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 1, 0)) {
                    basisFile.close();
                    basisFile.delete();
                    throw new Error('Failed to transcode image url=' + url);
                }

                if (basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444) {
                    // 16 bit formats require Uint16 typed array
                    var dst16 = new Uint16Array(dstSize / 2);
                    for (i = 0; i < dstSize / 2; ++i) {
                        dst16[i] = dst[i * 2] + dst[i * 2 + 1] * 256;
                    }
                    dst = dst16;
                }

                levelData.push(dst);
            }

            basisFile.close();
            basisFile.delete();

            // handle unswizzle option
            if (options && options.unswizzleGGGR) {
                basisFormat = BASIS_FORMAT.cTFRGB565;
                for (i = 0; i < levelData.length; ++i) {
                    levelData[i] = pack565(unswizzleGGGR(levelData[i]));
                }
            }

            return {
                format: basisToEngineMapping[basisFormat],
                width: (width + 3) & ~3,
                height: (height + 3) & ~3,
                levels: levelData,
                cubemap: false,
                mipmaps: true,
                transcodeTime: hasPerformance ? (performance.now() - funcStart) : 0,
                url: url
            };
        };

        var basis = null;
        var queue = [];

        // download and transcode the file given the basis module and
        // file url
        var workerTranscode = function (url, format, data, options) {
            try {
                // texture data has been provided
                var result = transcode(basis, url, format, data, options);
                result.levels = result.levels.map(function (v) {
                    return v.buffer;
                });
                self.postMessage( { url: url, data: result }, result.levels);
            } catch (err) {
                self.postMessage( { url: url.toString(), err: err.toString() } );
            }
        };

        // Initialize the web worker's BASIS interface.
        // basisModule is the optional wasm binary.
        var workerInit = function (basisModule) {
            var instantiateWasmFunc = function (imports, successCallback) {
                WebAssembly.instantiate(basisModule, imports)
                    .then( function (result) {
                        successCallback(result);
                    });
                return {};
            };

            self.BASIS(basisModule ? { instantiateWasm: instantiateWasmFunc } : null).then( function (instance) {
                basis = instance;
                basis.initializeBasis();
                for (var i = 0; i < queue.length; ++i) {
                    workerTranscode(queue[i].url, queue[i].format, queue[i].data, queue[i].options);
                }
                queue = [];
            } );
        };

        // handle incoming worker requests
        self.onmessage = function (message) {
            var data = message.data;
            switch (data.type) {
                case 'init':
                    workerInit(data.module);
                    break;
                case 'transcode':
                    if (basis) {
                        workerTranscode(data.url, data.format, data.data, data.options);
                    } else {
                        queue.push(data);
                    }
                    break;
            }
        };
    }

    // check for wasm module support
    var wasmSupported = (function () {
        try {
            if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
                var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
                if (module instanceof WebAssembly.Module)
                    return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
            }
        } catch (e) { }
        return false;
    })();

    // select the most desirable gpu texture compression format given the device's capabilities
    function chooseTargetFormat(device) {
        if (device.extCompressedTextureASTC) {
            return 'astc';
        } else if (device.extCompressedTextureS3TC) {
            return 'dxt';
        } else if (device.extCompressedTextureETC) {
            return 'etc2';
        } else if (device.extCompressedTextureETC1) {
            return 'etc1';
        } else if (device.extCompressedTexturePVRTC) {
            return 'pvr';
        } else if (device.extCompressedTextureATC) {
            return 'atc';
        }
        return 'none';
    }

    // global state
    var downloadInitiated = false;
    var worker = null;
    var callbacks = { };
    var format = null;
    var transcodeQueue = [];

    function basisTargetFormat() {
        if (!format) {
            format = chooseTargetFormat(Application.getApplication().graphicsDevice);
        }
        return format;
    }

    function handleWorkerResponse(message) {
        var url = message.data.url;
        var err = message.data.err;
        var data = message.data.data;
        var callback = callbacks[url];

        if (!callback) {
            console.error('internal logical error encountered in basis transcoder');
            return;
        }

        var i;
        if (err) {
            for (i = 0; i < callback.length; ++i) {
                (callback[i])(err);
            }
            return;
        }

        // (re)create typed array from the returned array buffers
        if (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {
            // handle 16 bit formats
            data.levels = data.levels.map(function (v) {
                return new Uint16Array(v);
            });
        } else {
            // all other
            data.levels = data.levels.map(function (v) {
                return new Uint8Array(v);
            });
        }

        for (i = 0; i < callback.length; ++i) {
            (callback[i])(null, data);
        }

        delete callbacks[url];
    }

    // post a transcode job to the web worker
    function transcode(url, data, callback, options) {
        if (!callbacks.hasOwnProperty(url)) {
            // store url and kick off worker job
            callbacks[url] = [callback];
            worker.postMessage({ type: 'transcode', url: url, format: basisTargetFormat(), data: data, options: options }, [data]);
        } else {
            // the basis worker is already busy processing this url, store callback
            // (this shouldn't really happen since the asset system only requests
            // a resource once)
            callbacks[url].push(callback);
        }
    }

    // initialize the basis worker given the basis module script (glue or fallback)
    // and the optional accompanying wasm binary.
    function basisInitialize(basisCode, basisModule, callback) {
        var code = [
            "/* basis.js */",
            basisCode,
            "/* mappings */",
            "var PIXELFORMAT_ETC1 = " + PIXELFORMAT_ETC1 + ";",
            "var PIXELFORMAT_ETC2_RGBA = " + PIXELFORMAT_ETC2_RGBA + ";",
            "var PIXELFORMAT_DXT1 = " + PIXELFORMAT_DXT1 + ";",
            "var PIXELFORMAT_DXT5 = " + PIXELFORMAT_DXT5 + ";",
            "var PIXELFORMAT_PVRTC_4BPP_RGB_1 = " + PIXELFORMAT_PVRTC_4BPP_RGB_1 + ";",
            "var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = " + PIXELFORMAT_PVRTC_4BPP_RGBA_1 + ";",
            "var PIXELFORMAT_ASTC_4x4 = " + PIXELFORMAT_ASTC_4x4 + ";",
            "var PIXELFORMAT_ATC_RGB = " + PIXELFORMAT_ATC_RGB + ";",
            "var PIXELFORMAT_ATC_RGBA = " + PIXELFORMAT_ATC_RGBA + ";",
            "var PIXELFORMAT_R8_G8_B8_A8 = " + PIXELFORMAT_R8_G8_B8_A8 + ";",
            "var PIXELFORMAT_R5_G6_B5 = " + PIXELFORMAT_R5_G6_B5 + ";",
            "var PIXELFORMAT_R4_G4_B4_A4 = " + PIXELFORMAT_R4_G4_B4_A4 + ";",
            "",
            "/* worker */",
            '(' + BasisWorker.toString() + ')()\n\n'
        ].join('\n');
        var blob = new Blob([code], { type: 'application/javascript' });
        var url = URL.createObjectURL(blob);
        worker = new Worker(url);
        worker.addEventListener('message', handleWorkerResponse);
        worker.postMessage({ type: 'init', module: basisModule });
        if (callback) {
            callback();
        }
        // module is initialized, initiate queued jobs
        for (var i = 0; i < transcodeQueue.length; ++i) {
            var entry = transcodeQueue[i];
            transcode(entry.url, entry.data, entry.callback, entry.options);
        }
    }

    // download the module files and initialize the basis worker
    function basisDownload(glueUrl, wasmUrl, fallbackUrl, callback) {
        if (downloadInitiated) {
            console.warn('basis module is being downloaded more than once');
        }
        downloadInitiated = true;
        if (wasmSupported) {
            var glueCode = null;
            var compiledModule = null;

            var downloadCompleted = function () {
                if (glueCode && compiledModule) {
                    basisInitialize(glueCode, compiledModule, callback);
                }
            };

            // perform the fallback http download if compileStreaming isn't
            // available or fails
            var performHttpDownload = function () {
                http.get(
                    wasmUrl,
                    { cache: true, responseType: "arraybuffer", retry: false },
                    function (err, result) {
                        if (result) {
                            WebAssembly.compile(result)
                                .then(function (result) {
                                    compiledModule = result;
                                    downloadCompleted();
                                });
                        }
                    });
            };

            // download and compile wasm module
            if (WebAssembly.compileStreaming) {
                WebAssembly.compileStreaming(fetch(wasmUrl))
                    .then(function (result) {
                        compiledModule = result;
                        downloadCompleted();
                    })
                    .catch(function (reason) {
                        console.error(reason);
                        console.warn('compileStreaming() failed for ' + wasmUrl + ', falling back to arraybuffer download...');
                        // failed to stream download, attempt arraybuffer download
                        performHttpDownload();
                    });
            } else {
                performHttpDownload();
            }

            // download glue script
            http.get(
                glueUrl,
                { cache: true, responseType: "text", retry: false },
                function (err, result) {
                    glueCode = result;
                    downloadCompleted();
                });
        } else {
            // download fallback script
            http.get(
                fallbackUrl,
                { cache: true, responseType: "text", retry: false },
                function (err, result) {
                    if (result) {
                        basisInitialize(result, null, callback);
                    }
                });
        }
    }

    // search for wasm module in the global config and initialize basis
    function basisDownloadFromConfig(callback) {
        var modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];
        var wasmModule = modules.find(function (m) {
            return m.moduleName === 'BASIS';
        });
        if (wasmModule) {
            var urlBase = window.ASSET_PREFIX ? window.ASSET_PREFIX : "";
            basisDownload(urlBase + wasmModule.glueUrl,
                          urlBase + wasmModule.wasmUrl,
                          urlBase + wasmModule.fallbackUrl,
                          callback);
        }
    }

    // render thread worker manager
    // options supports the following members:
    //   unswizzleGGGR - convert the two-component GGGR normal data to RGB
    //                   and pack into 565 format. this is used to overcome
    //                   quality issues on apple devices.
    function basisTranscode(url, data, callback, options) {
        if (!worker) {
            // store transcode job if no worker exists
            transcodeQueue.push({ url: url, data: data, callback: callback, options: options });
            // if the basis module download has not yet been initiated, do so now
            if (!downloadInitiated) {
                basisDownloadFromConfig();
            }
        } else {
            transcode(url, data, callback, options);
        }
    }

    /**
     * @interface
     * @name pc.ResourceHandler
     * @description Interface for ResourceHandlers used by {@link pc.ResourceLoader}.
     */
    function ResourceHandler() {}

    Object.assign(ResourceHandler.prototype, {

        /**
         * @function
         * @name pc.ResourceHandler#load
         * @description Load a resource from a remote URL. When loaded (or failed),
         * use the callback to return an the raw resource data (or error).
         * @param {string|object} url - Either the URL of the resource to load or a structure containing the
         * load and original URL.
         * @param {string} [url.load] - The URL to be used for loading the resource.
         * @param {string} [url.original] - The original URL to be used for identifying the resource
         * format. This is necessary when loading, for example from blob.
         * @param {pc.callbacks.ResourceHandler} callback - The callback used when the resource is loaded or an error occurs.
         * @param {pc.Asset} [asset] - Optional asset that is passed by ResourceLoader.
         */
        load: function (url, callback, asset) {
            throw new Error('not implemented');
        },

        /**
         * @function
         * @name pc.ResourceHandler#open
         * @description Convert raw resource data into a resource instance. E.g. Take 3D model format JSON and return a pc.Model.
         * @param {string} url - The URL of the resource to open.
         * @param {*} data - The raw resource data passed by callback from {@link pc.ResourceHandler#load}.
         * @param {pc.Asset} [asset] - Optional asset that is passed by ResourceLoader.
         * @returns {*} The parsed resource data.
         */
        /* eslint-disable jsdoc/require-returns-check */
        open: function (url, data, asset) {
            throw new Error('not implemented');
        },
        /* eslint-enable jsdoc/require-returns-check */

        /**
         * @function
         * @name pc.ResourceHandler#[patch]
         * @description Optional function to perform any operations on a resource, that requires a dependency on its asset data
         * or any other asset data.
         * @param {pc.Asset} asset - The asset to patch.
         * @param {pc.AssetRegistry} assets - The asset registry.
         */
        patch: function (asset, assets) {
            // optional function
        }
    });

    var ACTION_MOUSE = 'mouse';
    var ACTION_KEYBOARD = 'keyboard';
    var ACTION_GAMEPAD = 'gamepad';

    var AXIS_MOUSE_X = 'mousex';
    var AXIS_MOUSE_Y = 'mousey';
    var AXIS_PAD_L_X = 'padlx';
    var AXIS_PAD_L_Y = 'padly';
    var AXIS_PAD_R_X = 'padrx';
    var AXIS_PAD_R_Y = 'padry';
    var AXIS_KEY = 'key';

    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_KEYDOWN
     * @description Name of event fired when a key is pressed.
     */
    var EVENT_KEYDOWN = 'keydown';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_KEYUP
     * @description Name of event fired when a key is released.
     */
    var EVENT_KEYUP = 'keyup';

    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_MOUSEDOWN
     * @description Name of event fired when a mouse button is pressed.
     */
    var EVENT_MOUSEDOWN = "mousedown";
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_MOUSEMOVE
     * @description Name of event fired when the mouse is moved.
     */
    var EVENT_MOUSEMOVE = "mousemove";
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_MOUSEUP
     * @description Name of event fired when a mouse button is released.
     */
    var EVENT_MOUSEUP = "mouseup";
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_MOUSEWHEEL
     * @description Name of event fired when the mouse wheel is rotated.
     */
    var EVENT_MOUSEWHEEL = "mousewheel";

    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_TOUCHSTART
     * @description Name of event fired when a new touch occurs. For example, a finger is placed on the device.
     */
    var EVENT_TOUCHSTART = 'touchstart';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_TOUCHEND
     * @description Name of event fired when touch ends. For example, a finger is lifted off the device.
     */
    var EVENT_TOUCHEND = 'touchend';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_TOUCHMOVE
     * @description Name of event fired when a touch moves.
     */
    var EVENT_TOUCHMOVE = 'touchmove';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_TOUCHCANCEL
     * @description Name of event fired when a touch point is interrupted in some way.
     * The exact reasons for cancelling a touch can vary from device to device.
     * For example, a modal alert pops up during the interaction; the touch point leaves the document area,
     * or there are more touch points than the device supports, in which case the earliest touch point is canceled.
     */
    var EVENT_TOUCHCANCEL = 'touchcancel';

    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_SELECT
     * @description Name of event fired when a new xr select occurs. For example, primary trigger was pressed.
     */
    var EVENT_SELECT = 'select';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_SELECTSTART
     * @description Name of event fired when a new xr select starts. For example, primary trigger is now pressed.
     */
    var EVENT_SELECTSTART = 'selectstart';
    /**
     * @constant
     * @type {string}
     * @name pc.EVENT_SELECTEND
     * @description Name of event fired when xr select ends. For example, a primary trigger is now released.
     */
    var EVENT_SELECTEND = 'selectend';

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_BACKSPACE
     */
    var KEY_BACKSPACE = 8;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_TAB
     */
    var KEY_TAB = 9;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_RETURN
     */
    var KEY_RETURN = 13;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_ENTER
     */
    var KEY_ENTER = 13;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SHIFT
     */
    var KEY_SHIFT = 16;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_CONTROL
     */
    var KEY_CONTROL = 17;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_ALT
     */
    var KEY_ALT = 18;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_PAUSE
     */
    var KEY_PAUSE = 19;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_CAPS_LOCK
     */
    var KEY_CAPS_LOCK = 20;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_ESCAPE
     */
    var KEY_ESCAPE = 27;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SPACE
     */
    var KEY_SPACE = 32;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_PAGE_UP
     */
    var KEY_PAGE_UP = 33;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_PAGE_DOWN
     */
    var KEY_PAGE_DOWN = 34;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_END
     */
    var KEY_END = 35;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_HOME
     */
    var KEY_HOME = 36;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_LEFT
     */
    var KEY_LEFT = 37;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_UP
     */
    var KEY_UP = 38;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_RIGHT
     */
    var KEY_RIGHT = 39;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_DOWN
     */
    var KEY_DOWN = 40;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_PRINT_SCREEN
     */
    var KEY_PRINT_SCREEN = 44;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_INSERT
     */
    var KEY_INSERT = 45;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_DELETE
     */
    var KEY_DELETE = 46;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_0
     */
    var KEY_0 = 48;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_1
     */
    var KEY_1 = 49;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_2
     */
    var KEY_2 = 50;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_3
     */
    var KEY_3 = 51;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_4
     */
    var KEY_4 = 52;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_5
     */
    var KEY_5 = 53;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_6
     */
    var KEY_6 = 54;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_7
     */
    var KEY_7 = 55;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_8
     */
    var KEY_8 = 56;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_9
     */
    var KEY_9 = 57;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SEMICOLON
     */
    var KEY_SEMICOLON = 59;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_EQUAL
     */
    var KEY_EQUAL = 61;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_A
     */
    var KEY_A = 65;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_B
     */
    var KEY_B = 66;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_C
     */
    var KEY_C = 67;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_D
     */
    var KEY_D = 68;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_E
     */
    var KEY_E = 69;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F
     */
    var KEY_F = 70;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_G
     */
    var KEY_G = 71;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_H
     */
    var KEY_H = 72;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_I
     */
    var KEY_I = 73;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_J
     */
    var KEY_J = 74;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_K
     */
    var KEY_K = 75;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_L
     */
    var KEY_L = 76;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_M
     */
    var KEY_M = 77;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_N
     */
    var KEY_N = 78;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_O
     */
    var KEY_O = 79;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_P
     */
    var KEY_P = 80;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_Q
     */
    var KEY_Q = 81;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_R
     */
    var KEY_R = 82;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_S
     */
    var KEY_S = 83;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_T
     */
    var KEY_T = 84;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_U
     */
    var KEY_U = 85;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_V
     */
    var KEY_V = 86;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_W
     */
    var KEY_W = 87;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_X
     */
    var KEY_X = 88;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_Y
     */
    var KEY_Y = 89;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_Z
     */
    var KEY_Z = 90;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_WINDOWS
     */
    var KEY_WINDOWS = 91;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_CONTEXT_MENU
     */
    var KEY_CONTEXT_MENU = 93;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_0
     */
    var KEY_NUMPAD_0 = 96;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_1
     */
    var KEY_NUMPAD_1 = 97;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_2
     */
    var KEY_NUMPAD_2 = 98;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_3
     */
    var KEY_NUMPAD_3 = 99;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_4
     */
    var KEY_NUMPAD_4 = 100;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_5
     */
    var KEY_NUMPAD_5 = 101;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_6
     */
    var KEY_NUMPAD_6 = 102;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_7
     */
    var KEY_NUMPAD_7 = 103;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_8
     */
    var KEY_NUMPAD_8 = 104;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_NUMPAD_9
     */
    var KEY_NUMPAD_9 = 105;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_MULTIPLY
     */
    var KEY_MULTIPLY = 106;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_ADD
     */
    var KEY_ADD = 107;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SEPARATOR
     */
    var KEY_SEPARATOR = 108;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SUBTRACT
     */
    var KEY_SUBTRACT = 109;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_DECIMAL
     */
    var KEY_DECIMAL = 110;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_DIVIDE
     */
    var KEY_DIVIDE = 111;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F1
     */
    var KEY_F1 = 112;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F2
     */
    var KEY_F2 = 113;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F3
     */
    var KEY_F3 = 114;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F4
     */
    var KEY_F4 = 115;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F5
     */
    var KEY_F5 = 116;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F6
     */
    var KEY_F6 = 117;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F7
     */
    var KEY_F7 = 118;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F8
     */
    var KEY_F8 = 119;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F9
     */
    var KEY_F9 = 120;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F10
     */
    var KEY_F10 = 121;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F11
     */
    var KEY_F11 = 122;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_F12
     */
    var KEY_F12 = 123;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_COMMA
     */
    var KEY_COMMA = 188;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_PERIOD
     */
    var KEY_PERIOD = 190;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_SLASH
     */
    var KEY_SLASH = 191;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_OPEN_BRACKET
     */
    var KEY_OPEN_BRACKET = 219;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_BACK_SLASH
     */
    var KEY_BACK_SLASH = 220;
    /**
     * @constant
     * @type {number}
     * @name pc.KEY_CLOSE_BRACKET
     */
    var KEY_CLOSE_BRACKET = 221;

    /**
     * @constant
     * @type {number}
     * @name pc.KEY_META
     */
    var KEY_META = 224;

    /**
     * @constant
     * @type {number}
     * @name pc.MOUSEBUTTON_NONE
     * @description No mouse buttons pressed.
     */
    var MOUSEBUTTON_NONE = -1;
    /**
     * @constant
     * @type {number}
     * @name pc.MOUSEBUTTON_LEFT
     * @description The left mouse button.
     */
    var MOUSEBUTTON_LEFT = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.MOUSEBUTTON_MIDDLE
     * @description The middle mouse button.
     */
    var MOUSEBUTTON_MIDDLE = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.MOUSEBUTTON_RIGHT
     * @description The right mouse button.
     */
    var MOUSEBUTTON_RIGHT = 2;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_1
     * @description Index for pad 1.
     */
    var PAD_1 = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_2
     * @description Index for pad 2.
     */
    var PAD_2 = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_3
     * @description Index for pad 3.
     */
    var PAD_3 = 2;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_4
     * @description Index for pad 4.
     */
    var PAD_4 = 3;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_FACE_1
     * @description The first face button, from bottom going clockwise.
     */
    var PAD_FACE_1 = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_FACE_2
     * @description The second face button, from bottom going clockwise.
     */
    var PAD_FACE_2 = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_FACE_3
     * @description The third face button, from bottom going clockwise.
     */
    var PAD_FACE_3 = 2;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_FACE_4
     * @description The fourth face button, from bottom going clockwise.
     */
    var PAD_FACE_4 = 3;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_L_SHOULDER_1
     * @description The first shoulder button on the left.
     */
    var PAD_L_SHOULDER_1 = 4;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_R_SHOULDER_1
     * @description The first shoulder button on the right.
     */
    var PAD_R_SHOULDER_1 = 5;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_L_SHOULDER_2
     * @description The second shoulder button on the left.
     */
    var PAD_L_SHOULDER_2 = 6;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_R_SHOULDER_2
     * @description The second shoulder button on the right.
     */
    var PAD_R_SHOULDER_2 = 7;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_SELECT
     * @description The select button.
     */
    var PAD_SELECT = 8;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_START
     * @description The start button.
     */
    var PAD_START = 9;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_L_STICK_BUTTON
     * @description The button when depressing the left analogue stick.
     */
    var PAD_L_STICK_BUTTON = 10;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_R_STICK_BUTTON
     * @description The button when depressing the right analogue stick.
     */
    var PAD_R_STICK_BUTTON = 11;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_UP
     * @description Direction pad up.
     */
    var PAD_UP = 12;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_DOWN
     * @description Direction pad down.
     */
    var PAD_DOWN = 13;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_LEFT
     * @description Direction pad left.
     */
    var PAD_LEFT = 14;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_RIGHT
     * @description Direction pad right.
     */
    var PAD_RIGHT = 15;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_VENDOR
     * @description Vendor specific button.
     */
    var PAD_VENDOR = 16;

    /**
     * @constant
     * @type {number}
     * @name pc.PAD_L_STICK_X
     * @description Horizontal axis on the left analogue stick.
     */
    var PAD_L_STICK_X = 0;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_L_STICK_Y
     * @description Vertical axis on the left analogue stick.
     */
    var PAD_L_STICK_Y = 1;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_R_STICK_X
     * @description Horizontal axis on the right analogue stick.
     */
    var PAD_R_STICK_X = 2;
    /**
     * @constant
     * @type {number}
     * @name pc.PAD_R_STICK_Y
     * @description Vertical axis on the right analogue stick.
     */
    var PAD_R_STICK_Y = 3;

    /**
     * @class
     * @name pc.KeyboardEvent
     * @classdesc The KeyboardEvent is passed into all event callbacks from the {@link pc.Keyboard}. It corresponds to a key press or release.
     * @description Create a new KeyboardEvent.
     * @param {pc.Keyboard} keyboard - The keyboard object which is firing the event.
     * @param {KeyboardEvent} event - The original browser event that was fired.
     * @property {number} key The keyCode of the key that has changed. See the pc.KEY_* constants.
     * @property {Element} element The element that fired the keyboard event.
     * @property {KeyboardEvent} event The original browser event which was fired.
     * @example
     * var onKeyDown = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key pressed
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keydown", onKeyDown, this);
     */
    function KeyboardEvent(keyboard, event) {
        if (event) {
            this.key = event.keyCode;
            this.element = event.target;
            this.event = event;
        } else {
            this.key = null;
            this.element = null;
            this.event = null;
        }
    }

    // internal global keyboard events
    var _keyboardEvent = new KeyboardEvent();

    function makeKeyboardEvent(event) {
        _keyboardEvent.key = event.keyCode;
        _keyboardEvent.element = event.target;
        _keyboardEvent.event = event;
        return _keyboardEvent;
    }

    /**
     * @private
     * @function
     * @name pc.toKeyCode
     * @description Convert a string or keycode to a keycode.
     * @param {string|number} s - Either a character code or the key character.
     * @returns {number} The character code.
     */
    function toKeyCode(s){
        if (typeof s === "string") {
            return s.toUpperCase().charCodeAt(0);
        }
        return s;
    }

    var _keyCodeToKeyIdentifier = {
        '9': 'Tab',
        '13': 'Enter',
        '16': 'Shift',
        '17': 'Control',
        '18': 'Alt',
        '27': 'Escape',

        '37': 'Left',
        '38': 'Up',
        '39': 'Right',
        '40': 'Down',

        '46': 'Delete',

        '91': 'Win'
    };

    /**
     * @event
     * @name pc.Keyboard#keydown
     * @description Event fired when a key is pressed.
     * @param {pc.KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
     * @example
     * var onKeyDown = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key pressed
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keydown", onKeyDown, this);
     */

    /**
     * @event
     * @name pc.Keyboard#keyup
     * @description Event fired when a key is released.
     * @param {pc.KeyboardEvent} event - The Keyboard event object. Note, this event is only valid for the current callback.
     * @example
     * var onKeyUp = function (e) {
     *     if (e.key === pc.KEY_SPACE) {
     *         // space key released
     *     }
     *     e.event.preventDefault(); // Use original browser event to prevent browser action.
     * };
     * app.keyboard.on("keyup", onKeyUp, this);
     */

    /**
     * @class
     * @name pc.Keyboard
     * @augments pc.EventHandler
     * @classdesc A Keyboard device bound to an Element. Allows you to detect the state of the key presses.
     * Note, Keyboard object must be attached to an Element before it can detect any key presses.
     * @description Create a new Keyboard object.
     * @param {Element|Window} [element] - Element to attach Keyboard to. Note that elements like &lt;div&gt; can't
     * accept focus by default. To use keyboard events on an element like this it must have a value of 'tabindex' e.g. tabindex="0". For more details: <a href="http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html">http://www.w3.org/WAI/GL/WCAG20/WD-WCAG20-TECHS/SCR29.html</a>.
     * @param {object} [options] - Optional options object.
     * @param {boolean} [options.preventDefault] - Call preventDefault() in key event handlers. This stops the default action of the event occurring. e.g. Ctrl+T will not open a new browser tab
     * @param {boolean} [options.stopPropagation] - Call stopPropagation() in key event handlers. This stops the event bubbling up the DOM so no parent handlers will be notified of the event
     * @example
     * var keyboard = new pc.Keyboard(window); // attach keyboard listeners to the window
     */
    function Keyboard(element, options) {
        EventHandler.call(this);

        options = options || {};
        this._element = null;

        this._keyDownHandler = this._handleKeyDown.bind(this);
        this._keyUpHandler = this._handleKeyUp.bind(this);
        this._keyPressHandler = this._handleKeyPress.bind(this);

        this._keymap = {};
        this._lastmap = {};

        if (element) {
            this.attach(element);
        }

        this.preventDefault = options.preventDefault || false;
        this.stopPropagation = options.stopPropagation || false;
    }
    Keyboard.prototype = Object.create(EventHandler.prototype);
    Keyboard.prototype.constructor = Keyboard;

    /**
     * @function
     * @name pc.Keyboard#attach
     * @description Attach the keyboard event handlers to an Element.
     * @param {Element} element - The element to listen for keyboard events on.
     */
    Keyboard.prototype.attach = function (element) {
        if (this._element) {
            // remove previous attached element
            this.detach();
        }
        this._element = element;
        this._element.addEventListener("keydown", this._keyDownHandler, false);
        this._element.addEventListener("keypress", this._keyPressHandler, false);
        this._element.addEventListener("keyup", this._keyUpHandler, false);
    };

    /**
     * @function
     * @name pc.Keyboard#detach
     * @description Detach the keyboard event handlers from the element it is attached to.
     */
    Keyboard.prototype.detach = function () {
        this._element.removeEventListener("keydown", this._keyDownHandler);
        this._element.removeEventListener("keypress", this._keyPressHandler);
        this._element.removeEventListener("keyup", this._keyUpHandler);
        this._element = null;
    };

    /**
     * @private
     * @function
     * @name pc.Keyboard#toKeyIdentifier
     * @description Convert a key code into a key identifier.
     * @param {number} keyCode - The key code.
     * @returns {string} The key identifier.
     */
    Keyboard.prototype.toKeyIdentifier = function (keyCode){
        keyCode = toKeyCode(keyCode);
        var count;
        var hex;
        var length;
        var id = _keyCodeToKeyIdentifier[keyCode.toString()];

        if (id) {
            return id;
        }

        // Convert to hex and add leading 0's
        hex = keyCode.toString(16).toUpperCase();
        length = hex.length;
        for (count = 0; count < (4 - length); count++) {
            hex = '0' + hex;
        }

        return 'U+' + hex;
    };

    Keyboard.prototype._handleKeyDown = function (event) {
        var code = event.keyCode || event.charCode;

        // Google Chrome auto-filling of login forms could raise a malformed event
        if (code === undefined) return;

        var id = this.toKeyIdentifier(code);

        this._keymap[id] = true;

        // Patch on the keyIdentifier property in non-webkit browsers
        // event.keyIdentifier = event.keyIdentifier || id;

        this.fire("keydown", makeKeyboardEvent(event));

        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    };

    Keyboard.prototype._handleKeyUp = function (event){
        var code = event.keyCode || event.charCode;

        // Google Chrome auto-filling of login forms could raise a malformed event
        if (code === undefined) return;

        var id = this.toKeyIdentifier(code);

        delete this._keymap[id];

        // Patch on the keyIdentifier property in non-webkit browsers
        // event.keyIdentifier = event.keyIdentifier || id;

        this.fire("keyup", makeKeyboardEvent(event));

        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    };

    Keyboard.prototype._handleKeyPress = function (event){
        this.fire("keypress", makeKeyboardEvent(event));

        if (this.preventDefault) {
            event.preventDefault();
        }
        if (this.stopPropagation) {
            event.stopPropagation();
        }
    };

    /**
     * @private
     * @function
     * @name pc.Keyboard#update
     * @description Called once per frame to update internal state.
     */
    Keyboard.prototype.update = function () {
        var prop;

        // clear all keys
        for (prop in this._lastmap) {
            delete this._lastmap[prop];
        }

        for (prop in this._keymap) {
            if (this._keymap.hasOwnProperty(prop)) {
                this._lastmap[prop] = this._keymap[prop];
            }
        }
    };

    /**
     * @function
     * @name pc.Keyboard#isPressed
     * @description Return true if the key is currently down.
     * @param {number} key - The keyCode of the key to test. See the pc.KEY_* constants.
     * @returns {boolean} True if the key was pressed, false if not.
     */
    Keyboard.prototype.isPressed = function (key) {
        var keyCode = toKeyCode(key);
        var id = this.toKeyIdentifier(keyCode);

        return !!(this._keymap[id]);
    };

    /**
     * @function
     * @name pc.Keyboard#wasPressed
     * @description Returns true if the key was pressed since the last update.
     * @param {number} key - The keyCode of the key to test. See the pc.KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    Keyboard.prototype.wasPressed = function (key) {
        var keyCode = toKeyCode(key);
        var id = this.toKeyIdentifier(keyCode);

        return (!!(this._keymap[id]) && !!!(this._lastmap[id]));
    };

    /**
     * @function
     * @name pc.Keyboard#wasReleased
     * @description Returns true if the key was released since the last update.
     * @param {number} key - The keyCode of the key to test. See the pc.KEY_* constants.
     * @returns {boolean} True if the key was pressed.
     */
    Keyboard.prototype.wasReleased = function (key) {
        var keyCode = toKeyCode(key);
        var id = this.toKeyIdentifier(keyCode);

        return (!!!(this._keymap[id]) && !!(this._lastmap[id]));
    };

    /**
     * @class
     * @name pc.MouseEvent
     * @classdesc MouseEvent object that is passed to events 'mousemove', 'mouseup', 'mousedown' and 'mousewheel'.
     * @description Create an new MouseEvent.
     * @param {pc.Mouse} mouse - The Mouse device that is firing this event.
     * @param {MouseEvent} event - The original browser event that fired.
     * @property {number} x The x co-ordinate of the mouse pointer relative to the element pc.Mouse is attached to.
     * @property {number} y The y co-ordinate of the mouse pointer relative to the element pc.Mouse is attached to.
     * @property {number} dx The change in x co-ordinate since the last mouse event.
     * @property {number} dy The change in y co-ordinate since the last mouse event.
     * @property {number} button The mouse button associated with this event. Can be:
     *
     * * {@link pc.MOUSEBUTTON_LEFT}
     * * {@link pc.MOUSEBUTTON_MIDDLE}
     * * {@link pc.MOUSEBUTTON_RIGHT}
     *
     * @property {number} wheelDelta A value representing the amount the mouse wheel has moved, only
     * valid for {@link mousewheel} events.
     * @property {Element} element The element that the mouse was fired from.
     * @property {boolean} ctrlKey True if the ctrl key was pressed when this event was fired.
     * @property {boolean} shiftKey True if the shift key was pressed when this event was fired.
     * @property {boolean} altKey True if the alt key was pressed when this event was fired.
     * @property {boolean} metaKey True if the meta key was pressed when this event was fired.
     * @property {MouseEvent} event The original browser event.
     */
    function MouseEvent(mouse, event) {
        var coords = {
            x: 0,
            y: 0
        };

        if (event) {
            if (event instanceof MouseEvent) {
                throw Error("Expected MouseEvent");
            }
            coords = mouse._getTargetCoords(event);
        } else {
            event = { };
        }

        if (coords) {
            this.x = coords.x;
            this.y = coords.y;
        } else if (Mouse.isPointerLocked()) {
            this.x = 0;
            this.y = 0;
        } else {
            return;
        }

        // deltaY is in a different range across different browsers. The only thing
        // that is consistent is the sign of the value so snap to -1/+1.
        this.wheelDelta = 0;
        if (event.type === 'wheel') {
            if (event.deltaY > 0) {
                this.wheelDelta = 1;
            } else if (event.deltaY < 0) {
                this.wheelDelta = -1;
            }
        }

        // Get the movement delta in this event
        if (Mouse.isPointerLocked()) {
            this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
            this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
        } else {
            this.dx = this.x - mouse._lastX;
            this.dy = this.y - mouse._lastY;
        }

        if (event.type === 'mousedown' || event.type === 'mouseup') {
            this.button = event.button;
        } else {
            this.button = MOUSEBUTTON_NONE;
        }
        this.buttons = mouse._buttons.slice(0);
        this.element = event.target;

        this.ctrlKey = event.ctrlKey || false;
        this.altKey = event.altKey || false;
        this.shiftKey = event.shiftKey || false;
        this.metaKey = event.metaKey || false;

        this.event = event;
    }

    // Events Documentation
    /**
     * @event
     * @name pc.Mouse#mousemove
     * @description Fired when the mouse is moved.
     * @param {pc.MouseEvent} event - The MouseEvent object.
     */

    /**
     * @event
     * @name pc.Mouse#mousedown
     * @description Fired when a mouse button is pressed.
     * @param {pc.MouseEvent} event - The MouseEvent object.
     */

    /**
     * @event
     * @name pc.Mouse#mouseup
     * @description Fired when a mouse button is released.
     * @param {pc.MouseEvent} event - The MouseEvent object.
     */

    /**
     * @event
     * @name pc.Mouse#mousewheel
     * @description Fired when a mouse wheel is moved.
     * @param {pc.MouseEvent} event - The MouseEvent object.
     */

    /**
     * @class
     * @name pc.Mouse
     * @augments pc.EventHandler
     * @classdesc A Mouse Device, bound to a DOM Element.
     * @description Create a new Mouse device.
     * @param {Element} [element] - The Element that the mouse events are attached to.
     */
    function Mouse(element) {
        EventHandler.call(this);

        // Clear the mouse state
        this._lastX      = 0;
        this._lastY      = 0;
        this._buttons      = [false, false, false];
        this._lastbuttons  = [false, false, false];


        // Setup event handlers so they are bound to the correct 'this'
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._contextMenuHandler = function (event) {
            event.preventDefault();
        };

        this._target = null;
        this._attached = false;

        this.attach(element);
    }
    Mouse.prototype = Object.create(EventHandler.prototype);
    Mouse.prototype.constructor = Mouse;

    /**
     * @static
     * @function
     * @name pc.Mouse.isPointerLocked
     * @description Check if the mouse pointer has been locked, using {@link pc.Mouse#enabledPointerLock}.
     * @returns {boolean} True if locked.
     */
    Mouse.isPointerLocked = function () {
        return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
    };

    Object.assign(Mouse.prototype, {
        /**
         * @function
         * @name pc.Mouse#attach
         * @description Attach mouse events to an Element.
         * @param {Element} element - The DOM element to attach the mouse to.
         */
        attach: function (element) {
            this._target = element;

            if (this._attached) return;
            this._attached = true;

            var opts = platform.passiveEvents ? { passive: false } : false;
            window.addEventListener("mouseup", this._upHandler, opts);
            window.addEventListener("mousedown", this._downHandler, opts);
            window.addEventListener("mousemove", this._moveHandler, opts);
            window.addEventListener("wheel", this._wheelHandler, opts);
        },

        /**
         * @function
         * @name pc.Mouse#detach
         * @description Remove mouse events from the element that it is attached to.
         */
        detach: function () {
            if (!this._attached) return;
            this._attached = false;
            this._target = null;

            var opts = platform.passiveEvents ? { passive: false } : false;
            window.removeEventListener("mouseup", this._upHandler, opts);
            window.removeEventListener("mousedown", this._downHandler, opts);
            window.removeEventListener("mousemove", this._moveHandler, opts);
            window.removeEventListener("wheel", this._wheelHandler, opts);
        },

        /**
         * @function
         * @name pc.Mouse#disableContextMenu
         * @description Disable the context menu usually activated with right-click.
         */
        disableContextMenu: function () {
            if (!this._target) return;
            this._target.addEventListener("contextmenu", this._contextMenuHandler);
        },

        /**
         * @function
         * @name pc.Mouse#enableContextMenu
         * @description Enable the context menu usually activated with right-click. This option is active by default.
         */
        enableContextMenu: function () {
            if (!this._target) return;
            this._target.removeEventListener("contextmenu", this._contextMenuHandler);
        },

        /**
         * @function
         * @name pc.Mouse#enablePointerLock
         * @description Request that the browser hides the mouse cursor and locks the mouse to the element.
         * Allowing raw access to mouse movement input without risking the mouse exiting the element.
         * Notes:
         *
         * * In some browsers this will only work when the browser is running in fullscreen mode. See {@link pc.Application#enableFullscreen}
         * * Enabling pointer lock can only be initiated by a user action e.g. in the event handler for a mouse or keyboard input.
         *
         * @param {pc.callbacks.LockMouse} [success] - Function called if the request for mouse lock is successful.
         * @param {pc.callbacks.LockMouse} [error] - Function called if the request for mouse lock is unsuccessful.
         */
        enablePointerLock: function (success, error) {
            if (!document.body.requestPointerLock) {
                if (error)
                    error();

                return;
            }

            var s = function () {
                success();
                document.removeEventListener('pointerlockchange', s);
            };
            var e = function () {
                error();
                document.removeEventListener('pointerlockerror', e);
            };

            if (success) {
                document.addEventListener('pointerlockchange', s, false);
            }

            if (error) {
                document.addEventListener('pointerlockerror', e, false);
            }

            document.body.requestPointerLock();
        },

        /**
         * @function
         * @name pc.Mouse#disablePointerLock
         * @description Return control of the mouse cursor to the user.
         * @param {pc.callbacks.LockMouse} [success] - Function called when the mouse lock is disabled.
         */
        disablePointerLock: function (success) {
            if (!document.exitPointerLock) {
                return;
            }

            var s = function () {
                success();
                document.removeEventListener('pointerlockchange', s);
            };
            if (success) {
                document.addEventListener('pointerlockchange', s, false);
            }
            document.exitPointerLock();
        },

        /**
         * @function
         * @name pc.Mouse#update
         * @description Update method, should be called once per frame.
         */
        update: function () {
            // Copy current button state
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2];
        },

        /**
         * @function
         * @name pc.Mouse#isPressed
         * @description Returns true if the mouse button is currently pressed.
         * @param {number} button - The mouse button to test. Can be:
         *
         * * {@link pc.MOUSEBUTTON_LEFT}
         * * {@link pc.MOUSEBUTTON_MIDDLE}
         * * {@link pc.MOUSEBUTTON_RIGHT}
         *
         * @returns {boolean} True if the mouse button is current pressed.
         */
        isPressed: function (button) {
            return this._buttons[button];
        },

        /**
         * @function
         * @name pc.Mouse#wasPressed
         * @description Returns true if the mouse button was pressed this frame (since the last call to update).
         * @param {number} button - The mouse button to test. Can be:
         *
         * * {@link pc.MOUSEBUTTON_LEFT}
         * * {@link pc.MOUSEBUTTON_MIDDLE}
         * * {@link pc.MOUSEBUTTON_RIGHT}
         *
         * @returns {boolean} True if the mouse button was pressed since the last update.
         */
        wasPressed: function (button) {
            return (this._buttons[button] && !this._lastbuttons[button]);
        },

        /**
         * @function
         * @name pc.Mouse#wasReleased
         * @description Returns true if the mouse button was released this frame (since the last call to update).
         * @param {number} button - The mouse button to test. Can be:
         *
         * * {@link pc.MOUSEBUTTON_LEFT}
         * * {@link pc.MOUSEBUTTON_MIDDLE}
         * * {@link pc.MOUSEBUTTON_RIGHT}
         *
         * @returns {boolean} True if the mouse button was released since the last update.
         */
        wasReleased: function (button) {
            return (!this._buttons[button] && this._lastbuttons[button]);
        },

        _handleUp: function (event) {
            // disable released button
            this._buttons[event.button] = false;

            var e = new MouseEvent(this, event);
            if (!e.event) return;

            // send 'mouseup' event
            this.fire(EVENT_MOUSEUP, e);
        },

        _handleDown: function (event) {
            // Store which button has affected
            this._buttons[event.button] = true;

            var e = new MouseEvent(this, event);
            if (!e.event) return;

            this.fire(EVENT_MOUSEDOWN, e);
        },

        _handleMove: function (event) {
            var e = new MouseEvent(this, event);
            if (!e.event) return;

            this.fire(EVENT_MOUSEMOVE, e);

            // Store the last offset position to calculate deltas
            this._lastX = e.x;
            this._lastY = e.y;
        },

        _handleWheel: function (event) {
            var e = new MouseEvent(this, event);
            if (!e.event) return;

            this.fire(EVENT_MOUSEWHEEL, e);
        },

        _getTargetCoords: function (event) {
            var rect = this._target.getBoundingClientRect();
            var left = Math.floor(rect.left);
            var top = Math.floor(rect.top);

            // mouse is outside of canvas
            if (event.clientX < left ||
                event.clientX >= left + this._target.clientWidth ||
                event.clientY < top ||
                event.clientY >= top + this._target.clientHeight) {

                return null;
            }

            return {
                x: event.clientX - left,
                y: event.clientY - top
            };
        }
    });

    /**
     * @class
     * @name pc.Controller
     * @classdesc A general input handler which handles both mouse and keyboard input assigned to named actions.
     * This allows you to define input handlers separately to defining keyboard/mouse configurations.
     * @description Create a new instance of a Controller.
     * @param {Element} [element] - Element to attach Controller to.
     * @param {object} [options] - Optional arguments.
     * @param {pc.Keyboard} [options.keyboard] - A Keyboard object to use.
     * @param {pc.Mouse} [options.mouse] - A Mouse object to use.
     * @param {pc.GamePads} [options.gamepads] - A Gamepads object to use.
     * @example
     * var c = new pc.Controller(document);
     *
     * // Register the "fire" action and assign it to both the Enter key and the Spacebar.
     * c.registerKeys("fire", [pc.KEY_ENTER, pc.KEY_SPACE]);
     */
    function Controller(element, options) {
        options = options || {};
        this._keyboard = options.keyboard || null;
        this._mouse = options.mouse || null;
        this._gamepads = options.gamepads || null;

        this._element = null;

        this._actions = {};
        this._axes = {};
        this._axesValues = {};

        if (element) {
            this.attach(element);
        }
    }

    /**
     * @function
     * @name pc.Controller#attach
     * @description Attach Controller to a Element, this is required before you can monitor for key/mouse inputs.
     * @param {Element} element - The element to attach mouse and keyboard event handler too.
     */
    Controller.prototype.attach = function (element) {
        this._element = element;
        if (this._keyboard) {
            this._keyboard.attach(element);
        }

        if (this._mouse) {
            this._mouse.attach(element);
        }
    };

    /**
     * @function
     * @name pc.Controller#detach
     * @description Detach Controller from an Element, this should be done before the Controller is destroyed.
     */
    Controller.prototype.detach = function () {
        if (this._keyboard) {
            this._keyboard.detach();
        }
        if (this._mouse) {
            this._mouse.detach();
        }
        this._element = null;
    };

    /**
     * @function
     * @name pc.Controller#disableContextMenu
     * @description Disable the context menu usually activated with the right mouse button.
     */
    Controller.prototype.disableContextMenu = function () {
        if (!this._mouse) {
            this._enableMouse();
        }

        this._mouse.disableContextMenu();
    };

    /**
     * @function
     * @name pc.Controller#enableContextMenu
     * @description Enable the context menu usually activated with the right mouse button. This is enabled by default.
     */
    Controller.prototype.enableContextMenu = function () {
        if (!this._mouse) {
            this._enableMouse();
        }

        this._mouse.enableContextMenu();
    };

    /**
     * @function
     * @name pc.Controller#update
     * @description Update the Keyboard and Mouse handlers.
     * @param {object} dt - The time since the last frame.
     */
    Controller.prototype.update = function (dt) {
        if (this._keyboard) {
            this._keyboard.update(dt);
        }

        if (this._mouse) {
            this._mouse.update(dt);
        }

        if (this._gamepads) {
            this._gamepads.update(dt);
        }

        // clear axes values
        this._axesValues = {};
        for (var key in this._axes) {
            this._axesValues[key] = [];
        }
    };

    /**
     * @function
     * @name pc.Controller#registerKeys
     * @description Create or update a action which is enabled when the supplied keys are pressed.
     * @param {string} action - The name of the action.
     * @param {number[]} keys - A list of keycodes.
     */
    Controller.prototype.registerKeys = function (action, keys) {
        if (!this._keyboard) {
            this._enableKeyboard();
        }
        if (this._actions[action]) {
            throw new Error("Action: " + action + " already registered");
        }

        if (keys === undefined) {
            throw new Error("Invalid button");
        }

        // convert to an array
        if (!keys.length) {
            keys = [keys];
        }

        if (this._actions[action]) {
            this._actions[action].push({
                type: ACTION_KEYBOARD,
                keys: keys
            });
        } else {
            this._actions[action] = [{
                type: ACTION_KEYBOARD,
                keys: keys
            }];
        }
    };

    /**
     * @function
     * @name pc.Controller#registerMouse
     * @description Create or update an action which is enabled when the supplied mouse button is pressed.
     * @param {string} action - The name of the action.
     * @param {number} button - The mouse button.
     */
    Controller.prototype.registerMouse = function (action, button) {
        if (!this._mouse) {
            this._enableMouse();
        }

        if (button === undefined) {
            throw new Error('Invalid button');
        }

        // Mouse actions are stored as negative numbers to prevent clashing with keycodes.
        if (this._actions[action]) {
            this._actions[action].push({
                type: ACTION_MOUSE,
                button: button
            });
        } else {
            this._actions[action] = [{
                type: ACTION_MOUSE,
                button: -button
            }];
        }
    };

    /**
     * @function
     * @name pc.Controller#registerPadButton
     * @description Create or update an action which is enabled when the gamepad button is pressed.
     * @param {string} action - The name of the action.
     * @param {number} pad - The index of the pad to register (use pc.PAD_1, etc).
     * @param {number} button - The pad button.
     */
    Controller.prototype.registerPadButton = function (action, pad, button) {
        if (button === undefined) {
            throw new Error('Invalid button');
        }
        // Mouse actions are stored as negative numbers to prevent clashing with keycodes.
        if (this._actions[action]) {
            this._actions[action].push({
                type: ACTION_GAMEPAD,
                button: button,
                pad: pad
            });
        } else {
            this._actions[action] = [{
                type: ACTION_GAMEPAD,
                button: button,
                pad: pad
            }];
        }
    };

    /**
     * @function
     * @name pc.Controller#registerAxis
     * @param {object} [options] - Optional options object.
     * @param {object} [options.pad] - The index of the game pad to register for (use pc.PAD_1, etc).
     */
    Controller.prototype.registerAxis = function (options) {
        var name = options.name;
        if (!this._axes[name]) {
            this._axes[name] = [];
        }
        var i = this._axes[name].push(name);

        //
        options = options || {};
        options.pad = options.pad || PAD_1;

        var bind = function (controller, source, value, key) {
            switch (source) {
                case 'mousex':
                    controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
                        controller._axesValues[name][i] = e.dx / 10;
                    });
                    break;
                case 'mousey':
                    controller._mouse.on(EVENT_MOUSEMOVE, function (e) {
                        controller._axesValues[name][i] = e.dy / 10;
                    });
                    break;
                case 'key':
                    controller._axes[name].push(function () {
                        return controller._keyboard.isPressed(key) ? value : 0;
                    });
                    break;
                case 'padrx':
                    controller._axes[name].push(function () {
                        return controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);
                    });
                    break;
                case 'padry':
                    controller._axes[name].push(function () {
                        return controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);
                    });
                    break;
                case 'padlx':
                    controller._axes[name].push(function () {
                        return controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);
                    });
                    break;
                case 'padly':
                    controller._axes[name].push(function () {
                        return controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);
                    });
                    break;
                default:
                    throw new Error('Unknown axis');
            }
        };

        bind(this, options.positive, 1, options.positiveKey);
        if (options.negativeKey || options.negative !== options.positive) {
            bind(this, options.negative, -1, options.negativeKey);
        }

    };

    /**
     * @function
     * @name pc.Controller#isPressed
     * @description Returns true if the current action is enabled.
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action is enabled.
     */
    Controller.prototype.isPressed = function (actionName) {
        if (!this._actions[actionName]) {
            return false;
        }

        var action;
        var index = 0;
        var length = this._actions[actionName].length;

        for (index = 0; index < length; ++index) {
            action = this._actions[actionName][index];
            switch (action.type) {
                case ACTION_KEYBOARD:
                    if (this._keyboard) {
                        var i, len = action.keys.length;
                        for (i = 0; i < len; i++) {
                            if (this._keyboard.isPressed(action.keys[i])) {
                                return true;
                            }
                        }
                    }
                    break;
                case ACTION_MOUSE:
                    if (this._mouse && this._mouse.isPressed(action.button)) {
                        return true;
                    }
                    break;
                case ACTION_GAMEPAD:
                    if (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    };

    /**
     * @function
     * @name pc.Controller#wasPressed
     * @description Returns true if the action was enabled this since the last update.
     * @param {string} actionName - The name of the action.
     * @returns {boolean} True if the action was enabled this since the last update.
     */
    Controller.prototype.wasPressed = function (actionName) {
        if (!this._actions[actionName]) {
            return false;
        }

        var index = 0;
        var length = this._actions[actionName].length;

        for (index = 0; index < length; ++index) {
            var action = this._actions[actionName][index];
            switch (action.type) {
                case ACTION_KEYBOARD:
                    if (this._keyboard) {
                        var i, len = action.keys.length;
                        for (i = 0; i < len; i++) {
                            if (this._keyboard.wasPressed(action.keys[i])) {
                                return true;
                            }
                        }
                    }
                    break;
                case ACTION_MOUSE:
                    if (this._mouse && this._mouse.wasPressed(action.button)) {
                        return true;
                    }
                    break;
                case ACTION_GAMEPAD:
                    if (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    };

    Controller.prototype.getAxis = function (name) {
        var value = 0;

        if (this._axes[name]) {
            var i, len = this._axes[name].length;
            for (i = 0; i < len; i++) {
                if (type(this._axes[name][i]) === 'function') {
                    var v = this._axes[name][i]();
                    if (Math.abs(v) > Math.abs(value)) {
                        value = v;
                    }
                } else if (this._axesValues[name]) {
                    if (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {
                        value = this._axesValues[name][i];
                    }
                }
            }
        }

        return value;
    };

    Controller.prototype._enableMouse = function () {
        this._mouse = new Mouse();
        if (!this._element) {
            throw new Error("Controller must be attached to an Element");
        }
        this._mouse.attach(this._element);
    };

    Controller.prototype._enableKeyboard = function () {
        this._keyboard = new Keyboard();
        if (!this._element) {
            throw new Error("Controller must be attached to an Element");
        }
        this._keyboard.attach(this._element);
    };

    var targetX, targetY;
    var vecA$1 = new Vec3();
    var vecB$1 = new Vec3();

    var rayA = new Ray();
    var rayB = new Ray();
    var rayC = new Ray();

    rayA.end = new Vec3();
    rayB.end = new Vec3();
    rayC.end = new Vec3();

    var _pq = new Vec3();
    var _pa = new Vec3();
    var _pb = new Vec3();
    var _pc = new Vec3();
    var _pd = new Vec3();
    var _m = new Vec3();
    var _sct = new Vec3();
    var _accumulatedScale = new Vec2();
    var _paddingTop = new Vec3();
    var _paddingBottom = new Vec3();
    var _paddingLeft = new Vec3();
    var _paddingRight = new Vec3();
    var _cornerBottomLeft = new Vec3();
    var _cornerBottomRight = new Vec3();
    var _cornerTopRight = new Vec3();
    var _cornerTopLeft = new Vec3();

    var ZERO_VEC4 = new Vec4();

    // pi x p2 * p3
    function scalarTriple(p1, p2, p3) {
        return _sct.cross(p1, p2).dot(p3);
    }

    // Given line pq and ccw corners of a quad, return whether the line
    // intersects it. (from Real-Time Collision Detection book)
    function intersectLineQuad(p, q, corners) {
        _pq.sub2(q, p);
        _pa.sub2(corners[0], p);
        _pb.sub2(corners[1], p);
        _pc.sub2(corners[2], p);

        // Determine which triangle to test against by testing against diagonal first
        _m.cross(_pc, _pq);
        var v = _pa.dot(_m);
        if (v >= 0) {
            // Test intersection against triangle abc
            if (-_pb.dot(_m) < 0)
                return false;

            if (scalarTriple(_pq, _pb, _pa) < 0)
                return false;
        } else {
            // Test intersection against triangle dac
            _pd.sub2(corners[3], p);
            if (_pd.dot(_m) < 0)
                return false;

            if (scalarTriple(_pq, _pa, _pd) < 0)
                return false;
        }

        // The algorithm above doesn't work if all the corners are the same
        // So do that test here by checking if the diagonals are 0 (since these are rectangles we're checking against)
        if (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return false;
        if (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return false;

        return true;
    }

    /**
     * @class
     * @name pc.ElementInputEvent
     * @classdesc Represents an input event fired on a {@link pc.ElementComponent}. When an event is raised
     * on an ElementComponent it bubbles up to its parent ElementComponents unless we call stopPropagation().
     * @description Create an instance of a pc.ElementInputEvent.
     * @param {MouseEvent|TouchEvent} event - The MouseEvent or TouchEvent that was originally raised.
     * @param {pc.ElementComponent} element - The ElementComponent that this event was originally raised on.
     * @param {pc.CameraComponent} camera - The CameraComponent that this event was originally raised via.
     * @property {MouseEvent|TouchEvent} event The MouseEvent or TouchEvent that was originally raised.
     * @property {pc.ElementComponent} element The ElementComponent that this event was originally raised on.
     * @property {pc.CameraComponent} camera The CameraComponent that this event was originally raised via.
     */
    function ElementInputEvent(event, element, camera) {
        this.event = event;
        this.element = element;
        this.camera = camera;
        this._stopPropagation = false;
    }

    Object.assign(ElementInputEvent.prototype, {
        /**
         * @function
         * @name pc.ElementInputEvent#stopPropagation
         * @description Stop propagation of the event to parent {@link pc.ElementComponent}s. This also stops propagation of the event to other event listeners of the original DOM Event.
         */
        stopPropagation: function () {
            this._stopPropagation = true;
            if (this.event) {
                this.event.stopImmediatePropagation();
                this.event.stopPropagation();
            }
        }
    });

    /**
     * @class
     * @name pc.ElementMouseEvent
     * @augments pc.ElementInputEvent
     * @classdesc Represents a Mouse event fired on a {@link pc.ElementComponent}.
     * @description Create an instance of a pc.ElementMouseEvent.
     * @param {MouseEvent} event - The MouseEvent that was originally raised.
     * @param {pc.ElementComponent} element - The ElementComponent that this event was originally raised on.
     * @param {pc.CameraComponent} camera - The CameraComponent that this event was originally raised via.
     * @param {number} x - The x coordinate.
     * @param {number} y - The y coordinate.
     * @param {number} lastX - The last x coordinate.
     * @param {number} lastY - The last y coordinate.
     * @property {boolean} ctrlKey Whether the ctrl key was pressed.
     * @property {boolean} altKey Whether the alt key was pressed.
     * @property {boolean} shiftKey Whether the shift key was pressed.
     * @property {boolean} metaKey Whether the meta key was pressed.
     * @property {number} button The mouse button.
     * @property {number} dx The amount of horizontal movement of the cursor.
     * @property {number} dy The amount of vertical movement of the cursor.
     * @property {number} wheelDelta The amount of the wheel movement.
     */
    function ElementMouseEvent(event, element, camera, x, y, lastX, lastY) {
        ElementInputEvent.call(this, event, element, camera);

        this.x = x;
        this.y = y;

        this.ctrlKey = event.ctrlKey || false;
        this.altKey = event.altKey || false;
        this.shiftKey = event.shiftKey || false;
        this.metaKey = event.metaKey || false;

        this.button = event.button;

        if (Mouse.isPointerLocked()) {
            this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
            this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
        } else {
            this.dx = x - lastX;
            this.dy = y - lastY;
        }

        // deltaY is in a different range across different browsers. The only thing
        // that is consistent is the sign of the value so snap to -1/+1.
        this.wheelDelta = 0;
        if (event.type === 'wheel') {
            if (event.deltaY > 0) {
                this.wheelDelta = 1;
            } else if (event.deltaY < 0) {
                this.wheelDelta = -1;
            }
        }
    }
    ElementMouseEvent.prototype = Object.create(ElementInputEvent.prototype);
    ElementMouseEvent.prototype.constructor = ElementMouseEvent;

    /**
     * @class
     * @name pc.ElementTouchEvent
     * @augments pc.ElementInputEvent
     * @classdesc Represents a TouchEvent fired on a {@link pc.ElementComponent}.
     * @description Create an instance of a pc.ElementTouchEvent.
     * @param {TouchEvent} event - The TouchEvent that was originally raised.
     * @param {pc.ElementComponent} element - The ElementComponent that this event was originally raised on.
     * @param {pc.CameraComponent} camera - The CameraComponent that this event was originally raised via.
     * @param {number} x - The x coordinate of the touch that triggered the event.
     * @param {number} y - The y coordinate of the touch that triggered the event.
     * @param {Touch} touch - The touch object that triggered the event.
     * @property {Touch[]} touches The Touch objects representing all current points of contact with the surface, regardless of target or changed status.
     * @property {Touch[]} changedTouches The Touch objects representing individual points of contact whose states changed between the previous touch event and this one.
     * @property {Touch} touch The touch object that triggered the event.
     */
    function ElementTouchEvent(event, element, camera, x, y, touch) {
        ElementInputEvent.call(this, event, element, camera);

        this.touches = event.touches;
        this.changedTouches = event.changedTouches;
        this.x = x;
        this.y = y;
        this.touch = touch;
    }
    ElementTouchEvent.prototype = Object.create(ElementInputEvent.prototype);
    ElementTouchEvent.prototype.constructor = ElementTouchEvent;

    /**
     * @class
     * @name pc.ElementSelectEvent
     * @augments pc.ElementInputEvent
     * @classdesc Represents a XRInputSourceEvent fired on a {@link pc.ElementComponent}.
     * @description Create an instance of a pc.ElementSelectEvent.
     * @param {object} event - The XRInputSourceEvent that was originally raised.
     * @param {pc.ElementComponent} element - The ElementComponent that this event was originally raised on.
     * @param {pc.CameraComponent} camera - The CameraComponent that this event was originally raised via.
     * @param {pc.XrInputSource} inputSource - The XR input source that this event was originally raised from.
     * @property {pc.XrInputSource} inputSource The XR input source that this event was originally raised from.
     */
    function ElementSelectEvent(event, element, camera, inputSource) {
        ElementInputEvent.call(this, event, element, camera);
        this.inputSource = inputSource;
    }
    ElementSelectEvent.prototype = Object.create(ElementInputEvent.prototype);
    ElementSelectEvent.prototype.constructor = ElementSelectEvent;

    /**
     * @class
     * @name pc.ElementInput
     * @classdesc Handles mouse and touch events for {@link pc.ElementComponent}s. When input events
     * occur on an ElementComponent this fires the appropriate events on the ElementComponent.
     * @description Create a new pc.ElementInput instance.
     * @param {Element} domElement - The DOM element.
     * @param {object} [options] - Optional arguments.
     * @param {boolean} [options.useMouse] - Whether to allow mouse input. Defaults to true.
     * @param {boolean} [options.useTouch] - Whether to allow touch input. Defaults to true.
     * @param {boolean} [options.useXr] - Whether to allow XR input sources. Defaults to true.
     */
    function ElementInput(domElement, options) {
        this._app = null;
        this._attached = false;
        this._target = null;

        // force disable all element input events
        this._enabled = true;

        this._lastX = 0;
        this._lastY = 0;

        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._touchstartHandler = this._handleTouchStart.bind(this);
        this._touchendHandler = this._handleTouchEnd.bind(this);
        this._touchcancelHandler = this._touchendHandler;
        this._touchmoveHandler = this._handleTouchMove.bind(this);
        this._sortHandler = this._sortElements.bind(this);

        this._elements = [];
        this._hoveredElement = null;
        this._pressedElement = null;
        this._touchedElements = {};
        this._touchesForWhichTouchLeaveHasFired = {};
        this._selectedElements = {};
        this._selectedPressedElements = {};

        this._useMouse = !options || options.useMouse !== false;
        this._useTouch = !options || options.useTouch !== false;
        this._useXr = !options || options.useXr !== false;
        this._selectEventsAttached = false;

        if (platform.touch)
            this._clickedEntities = {};

        this.attach(domElement);
    }

    Object.assign(ElementInput.prototype, {
        /**
         * @function
         * @name pc.ElementInput#attach
         * @description Attach mouse and touch events to a DOM element.
         * @param {Element} domElement - The DOM element.
         */
        attach: function (domElement) {
            if (this._attached) {
                this._attached = false;
                this.detach();
            }

            this._target = domElement;
            this._attached = true;

            var opts = platform.passiveEvents ? { passive: true } : false;
            if (this._useMouse) {
                window.addEventListener('mouseup', this._upHandler, opts);
                window.addEventListener('mousedown', this._downHandler, opts);
                window.addEventListener('mousemove', this._moveHandler, opts);
                window.addEventListener('wheel', this._wheelHandler, opts);
            }

            if (this._useTouch && platform.touch) {
                this._target.addEventListener('touchstart', this._touchstartHandler, opts);
                // Passive is not used for the touchend event because some components need to be
                // able to call preventDefault(). See notes in button/component.js for more details.
                this._target.addEventListener('touchend', this._touchendHandler, false);
                this._target.addEventListener('touchmove', this._touchmoveHandler, false);
                this._target.addEventListener('touchcancel', this._touchcancelHandler, false);
            }

            this.attachSelectEvents();
        },

        attachSelectEvents: function () {
            if (! this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {
                if (! this._clickedEntities)
                    this._clickedEntities = {};

                this._selectEventsAttached = true;
                this.app.xr.on('start', this._onXrStart, this);
            }
        },

        /**
         * @function
         * @name pc.ElementInput#detach
         * @description Remove mouse and touch events from the DOM element that it is attached to.
         */
        detach: function () {
            if (!this._attached) return;
            this._attached = false;

            var opts = platform.passiveEvents ? { passive: true } : false;
            if (this._useMouse) {
                window.removeEventListener('mouseup', this._upHandler, opts);
                window.removeEventListener('mousedown', this._downHandler, opts);
                window.removeEventListener('mousemove', this._moveHandler, opts);
                window.removeEventListener('wheel', this._wheelHandler, opts);
            }

            if (this._useTouch) {
                this._target.removeEventListener('touchstart', this._touchstartHandler, opts);
                this._target.removeEventListener('touchend', this._touchendHandler, false);
                this._target.removeEventListener('touchmove', this._touchmoveHandler, false);
                this._target.removeEventListener('touchcancel', this._touchcancelHandler, false);
            }

            if (this._selectEventsAttached) {
                this._selectEventsAttached = false;
                this.app.xr.off('start', this._onXrStart, this);
                this.app.xr.off('end', this._onXrEnd, this);
                this.app.xr.off('update', this._onXrUpdate, this);
                this.app.xr.input.off('selectstart', this._onSelectStart, this);
                this.app.xr.input.off('selectend', this._onSelectEnd, this);
                this.app.xr.input.off('remove', this._onXrInputRemove, this);
            }

            this._target = null;
        },

        /**
         * @function
         * @name pc.ElementInput#addElement
         * @description Add a {@link pc.ElementComponent} to the internal list of ElementComponents that are being checked for input.
         * @param {pc.ElementComponent} element - The ElementComponent.
         */
        addElement: function (element) {
            if (this._elements.indexOf(element) === -1)
                this._elements.push(element);
        },

        /**
         * @function
         * @name pc.ElementInput#removeElement
         * @description Remove a {@link pc.ElementComponent} from the internal list of ElementComponents that are being checked for input.
         * @param {pc.ElementComponent} element - The ElementComponent.
         */
        removeElement: function (element) {
            var idx = this._elements.indexOf(element);
            if (idx !== -1)
                this._elements.splice(idx, 1);
        },

        _handleUp: function (event) {
            if (!this._enabled) return;

            if (Mouse.isPointerLocked())
                return;

            this._calcMouseCoords(event);
            if (targetX === null)
                return;

            this._onElementMouseEvent('mouseup', event);
        },

        _handleDown: function (event) {
            if (!this._enabled) return;

            if (Mouse.isPointerLocked())
                return;

            this._calcMouseCoords(event);
            if (targetX === null)
                return;

            this._onElementMouseEvent('mousedown', event);
        },

        _handleMove: function (event) {
            if (!this._enabled) return;

            this._calcMouseCoords(event);
            if (targetX === null)
                return;

            this._onElementMouseEvent('mousemove', event);

            this._lastX = targetX;
            this._lastY = targetY;
        },

        _handleWheel: function (event) {
            if (!this._enabled) return;

            this._calcMouseCoords(event);
            if (targetX === null)
                return;

            this._onElementMouseEvent('mousewheel', event);
        },

        _determineTouchedElements: function (event) {
            var touchedElements = {};
            var cameras = this.app.systems.camera.cameras;
            var i, j, len;

            // check cameras from last to front
            // so that elements that are drawn above others
            // receive events first
            for (i = cameras.length - 1; i >= 0; i--) {
                var camera = cameras[i];

                var done = 0;
                for (j = 0, len = event.changedTouches.length; j < len; j++) {
                    if (touchedElements[event.changedTouches[j].identifier]) {
                        done++;
                        continue;
                    }

                    var coords = this._calcTouchCoords(event.changedTouches[j]);

                    var element = this._getTargetElement(camera, coords.x, coords.y);
                    if (element) {
                        done++;
                        touchedElements[event.changedTouches[j].identifier] = {
                            element: element,
                            camera: camera,
                            x: coords.x,
                            y: coords.y
                        };
                    }
                }

                if (done === len) {
                    break;
                }
            }

            return touchedElements;
        },

        _handleTouchStart: function (event) {
            if (!this._enabled) return;

            var newTouchedElements = this._determineTouchedElements(event);

            for (var i = 0, len = event.changedTouches.length; i < len; i++) {
                var touch = event.changedTouches[i];
                var newTouchInfo = newTouchedElements[touch.identifier];
                var oldTouchInfo = this._touchedElements[touch.identifier];

                if (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {
                    this._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));
                    this._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;
                }
            }

            for (var touchId in newTouchedElements) {
                this._touchedElements[touchId] = newTouchedElements[touchId];
            }
        },

        _handleTouchEnd: function (event) {
            if (!this._enabled) return;

            var cameras = this.app.systems.camera.cameras;

            // clear clicked entities first then store each clicked entity
            // in _clickedEntities so that we don't fire another click
            // on it in this handler or in the mouseup handler which is
            // fired later
            for (var key in this._clickedEntities) {
                delete this._clickedEntities[key];
            }

            for (var i = 0, len = event.changedTouches.length; i < len; i++) {
                var touch = event.changedTouches[i];
                var touchInfo = this._touchedElements[touch.identifier];
                if (!touchInfo)
                    continue;

                var element = touchInfo.element;
                var camera = touchInfo.camera;
                var x = touchInfo.x;
                var y = touchInfo.y;

                delete this._touchedElements[touch.identifier];
                delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];

                this._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));

                // check if touch was released over previously touch
                // element in order to fire click event
                if (event.touches.length === 0) {
                    var coords = this._calcTouchCoords(touch);

                    for (var c = cameras.length - 1; c >= 0; c--) {
                        var hovered = this._getTargetElement(cameras[c], coords.x, coords.y);
                        if (hovered === element) {

                            if (!this._clickedEntities[element.entity.getGuid()]) {
                                this._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));
                                this._clickedEntities[element.entity.getGuid()] = true;
                            }

                        }
                    }
                }
            }
        },

        _handleTouchMove: function (event) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            event.preventDefault();

            if (!this._enabled) return;

            var newTouchedElements = this._determineTouchedElements(event);

            for (var i = 0, len = event.changedTouches.length; i < len; i++) {
                var touch = event.changedTouches[i];
                var newTouchInfo = newTouchedElements[touch.identifier];
                var oldTouchInfo = this._touchedElements[touch.identifier];

                if (oldTouchInfo) {
                    var coords = this._calcTouchCoords(touch);

                    // Fire touchleave if we've left the previously touched element
                    if ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {
                        this._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));

                        // Flag that touchleave has been fired for this touch, so that we don't
                        // re-fire it on the next touchmove. This is required because touchmove
                        // events keep on firing for the same element until the touch ends, even
                        // if the touch position moves away from the element. Touchleave, on the
                        // other hand, should fire once when the touch position moves away from
                        // the element and then not re-fire again within the same touch session.
                        this._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;
                    }

                    this._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));
                }
            }
        },

        _onElementMouseEvent: function (eventType, event) {
            var element;

            var hovered = this._hoveredElement;
            this._hoveredElement = null;

            var cameras = this.app.systems.camera.cameras;
            var camera;

            // check cameras from last to front
            // so that elements that are drawn above others
            // receive events first
            for (var i = cameras.length - 1; i >= 0; i--) {
                camera = cameras[i];

                element = this._getTargetElement(camera, targetX, targetY);
                if (element)
                    break;
            }

            // fire mouse event
            if (element) {
                this._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));

                this._hoveredElement = element;

                if (eventType === 'mousedown') {
                    this._pressedElement = element;
                }
            }

            if (hovered !== this._hoveredElement) {
                // mouseleave event
                if (hovered) {
                    this._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));
                }

                // mouseenter event
                if (this._hoveredElement) {
                    this._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
                }
            }

            if (eventType === 'mouseup' && this._pressedElement) {
                // click event
                if (this._pressedElement === this._hoveredElement) {
                    this._pressedElement = null;

                    // fire click event if it hasn't been fired already by the touchup handler
                    if (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {
                        this._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));
                    }
                } else {
                    this._pressedElement = null;
                }
            }
        },

        _onXrStart: function () {
            this.app.xr.on('end', this._onXrEnd, this);
            this.app.xr.on('update', this._onXrUpdate, this);
            this.app.xr.input.on('selectstart', this._onSelectStart, this);
            this.app.xr.input.on('selectend', this._onSelectEnd, this);
            this.app.xr.input.on('remove', this._onXrInputRemove, this);
        },

        _onXrEnd: function () {
            this.app.xr.off('update', this._onXrUpdate, this);
            this.app.xr.input.off('selectstart', this._onSelectStart, this);
            this.app.xr.input.off('selectend', this._onSelectEnd, this);
            this.app.xr.input.off('remove', this._onXrInputRemove, this);
        },

        _onXrUpdate: function () {
            if (!this._enabled) return;

            var inputSources = this.app.xr.input.inputSources;
            for (var i = 0; i < inputSources.length; i++) {
                this._onElementSelectEvent('selectmove', inputSources[i], null);
            }
        },

        _onXrInputRemove: function (inputSource) {
            var hovered = this._selectedElements[inputSource.id];
            if (hovered) {
                inputSource._elementEntity = null;
                this._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));
            }

            delete this._selectedElements[inputSource.id];
            delete this._selectedPressedElements[inputSource.id];
        },

        _onSelectStart: function (inputSource, event) {
            if (! this._enabled) return;
            this._onElementSelectEvent('selectstart', inputSource, event);
        },

        _onSelectEnd: function (inputSource, event) {
            if (! this._enabled) return;
            this._onElementSelectEvent('selectend', inputSource, event);
        },

        _onElementSelectEvent: function (eventType, inputSource, event) {
            var element;

            var hoveredBefore = this._selectedElements[inputSource.id];
            var hoveredNow;

            var cameras = this.app.systems.camera.cameras;
            var camera;

            if (inputSource.elementInput) {
                rayC.set(inputSource.getOrigin(), inputSource.getDirection());

                for (var i = cameras.length - 1; i >= 0; i--) {
                    camera = cameras[i];

                    element = this._getTargetElementByRay(rayC, camera);
                    if (element)
                        break;
                }
            }

            inputSource._elementEntity = element || null;

            if (element) {
                this._selectedElements[inputSource.id] = element;
                hoveredNow = element;
            } else {
                delete this._selectedElements[inputSource.id];
            }

            if (hoveredBefore !== hoveredNow) {
                if (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
                if (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
            }

            if (eventType === 'selectstart') {
                this._selectedPressedElements[inputSource.id] = hoveredNow;
                if (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));
            }

            var pressed = this._selectedPressedElements[inputSource.id];
            if (! inputSource.elementInput && pressed) {
                delete this._selectedPressedElements[inputSource.id];
                if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));
            }

            if (eventType === 'selectend' && inputSource.elementInput) {
                delete this._selectedPressedElements[inputSource.id];

                if (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));

                if (pressed && pressed === hoveredBefore) {
                    this._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));
                }
            }
        },

        _fireEvent: function (name, evt) {
            var element = evt.element;
            while (true) {
                element.fire(name, evt);
                if (evt._stopPropagation)
                    break;

                if (!element.entity.parent)
                    break;

                element = element.entity.parent.element;
                if (!element)
                    break;
            }

        },

        _calcMouseCoords: function (event) {
            var rect = this._target.getBoundingClientRect();
            var left = Math.floor(rect.left);
            var top = Math.floor(rect.top);

            // mouse is outside of canvas
            if (event.clientX < left ||
                event.clientX >= left + this._target.clientWidth ||
                event.clientY < top ||
                event.clientY >= top + this._target.clientHeight) {

                targetX = null;
                targetY = null;
            } else {
                // calculate coords and scale them to the graphicsDevice size
                targetX = (event.clientX - left);
                targetY = (event.clientY - top);
            }
        },

        _calcTouchCoords: function (touch) {
            var totalOffsetX = 0;
            var totalOffsetY = 0;
            var target = touch.target;
            while (!(target instanceof HTMLElement)) {
                target = target.parentNode;
            }
            var currentElement = target;

            do {
                totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
                totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
                currentElement = currentElement.offsetParent;
            } while (currentElement);

            // calculate coords and scale them to the graphicsDevice size
            return {
                x: (touch.pageX - totalOffsetX),
                y: (touch.pageY - totalOffsetY)
            };
        },

        _sortElements: function (a, b) {
            var layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);
            if (layerOrder !== 0) return layerOrder;

            if (a.screen && !b.screen)
                return -1;
            if (!a.screen && b.screen)
                return 1;
            if (!a.screen && !b.screen)
                return 0;

            if (a.screen.screen.screenSpace && !b.screen.screen.screenSpace)
                return -1;
            if (b.screen.screen.screenSpace && !a.screen.screen.screenSpace)
                return 1;
            return b.drawOrder - a.drawOrder;
        },

        _getTargetElement: function (camera, x, y) {
            var result = null;

            // sort elements
            this._elements.sort(this._sortHandler);

            var rayScreen, ray3d;

            for (var i = 0, len = this._elements.length; i < len; i++) {
                var element = this._elements[i];
                var screen = false;
                var ray;

                // cache rays
                if (element.screen && element.screen.screen.screenSpace) {
                    // 2D screen
                    if (rayScreen === undefined) {
                        rayScreen = rayA;
                        if (this._calculateRayScreen(x, y, camera, rayScreen) === false) {
                            rayScreen = null;
                        }
                    }
                    ray = rayScreen;
                    screen = true;
                } else {
                    // 3d
                    if (ray3d === undefined) {
                        ray3d = rayB;
                        if (this._calculateRay3d(x, y, camera, ray3d) === false) {
                            ray3d = null;
                        }
                    }
                    ray = ray3d;
                }

                if (ray && this._checkElement(ray, element, screen)) {
                    result = element;
                    break;
                }
            }

            return result;
        },

        _getTargetElementByRay: function (ray, camera) {
            var result = null;

            rayA.origin.copy(ray.origin);
            rayA.direction.copy(ray.direction);
            rayA.end.copy(rayA.direction).scale(camera.farClip * 2).add(rayA.origin);

            // sort elements
            this._elements.sort(this._sortHandler);

            for (var i = 0, len = this._elements.length; i < len; i++) {
                var element = this._elements[i];

                if (! element.screen || ! element.screen.screen.screenSpace) {
                    if (this._checkElement(rayA, element, false)) {
                        result = element;
                        break;
                    }
                }
            }

            return result;
        },

        // In most cases the corners used for hit testing will just be the element's
        // screen corners. However, in cases where the element has additional hit
        // padding specified, we need to expand the screenCorners to incorporate the
        // padding.
        _buildHitCorners: function (element, screenOrWorldCorners, scaleX, scaleY) {
            var hitCorners = screenOrWorldCorners;
            var button = element.entity && element.entity.button;

            if (button) {
                var hitPadding = element.entity.button.hitPadding || ZERO_VEC4;

                _paddingTop.copy(element.entity.up);
                _paddingBottom.copy(_paddingTop).scale(-1);
                _paddingRight.copy(element.entity.right);
                _paddingLeft.copy(_paddingRight).scale(-1);

                _paddingTop.scale(hitPadding.w * scaleY);
                _paddingBottom.scale(hitPadding.y * scaleY);
                _paddingRight.scale(hitPadding.z * scaleX);
                _paddingLeft.scale(hitPadding.x * scaleX);

                _cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);
                _cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);
                _cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);
                _cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);

                hitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];
            }

            return hitCorners;
        },

        _calculateScaleToScreen: function (element) {
            var current = element.entity;
            var screenScale = element.screen.screen.scale;

            _accumulatedScale.set(screenScale, screenScale);

            while (current && !current.screen) {
                _accumulatedScale.mul(current.getLocalScale());
                current = current.parent;
            }

            return _accumulatedScale;
        },

        _calculateRayScreen: function (x, y, camera, ray) {
            var sw = this.app.graphicsDevice.width;
            var sh = this.app.graphicsDevice.height;

            var cameraWidth = camera.rect.z * sw;
            var cameraHeight = camera.rect.w * sh;
            var cameraLeft = camera.rect.x * sw;
            var cameraRight = cameraLeft + cameraWidth;
            // camera bottom (origin is bottom left of window)
            var cameraBottom = (1 - camera.rect.y) * sh;
            var cameraTop = cameraBottom - cameraHeight;

            var _x = x * sw / this._target.clientWidth;
            var _y = y * sh / this._target.clientHeight;

            if (_x >= cameraLeft && _x <= cameraRight &&
                _y <= cameraBottom && _y >= cameraTop) {

                // limit window coords to camera rect coords
                _x = sw * (_x - cameraLeft) / cameraWidth;
                _y = sh * (_y - cameraTop) / cameraHeight;

                // reverse _y
                _y = sh - _y;

                ray.origin.set(_x, _y, 1);
                ray.direction.set(0, 0, -1);
                ray.end.copy(ray.direction).scale(2).add(ray.origin);

                return true;
            }
            return false;
        },

        _calculateRay3d: function (x, y, camera, ray) {
            var sw = this._target.clientWidth;
            var sh = this._target.clientHeight;

            var cameraWidth = camera.rect.z * sw;
            var cameraHeight = camera.rect.w * sh;
            var cameraLeft = camera.rect.x * sw;
            var cameraRight = cameraLeft + cameraWidth;
            // camera bottom - origin is bottom left of window
            var cameraBottom = (1 - camera.rect.y) * sh;
            var cameraTop = cameraBottom - cameraHeight;

            var _x = x;
            var _y = y;

            // check window coords are within camera rect
            if (x >= cameraLeft && x <= cameraRight &&
                y <= cameraBottom && _y >= cameraTop) {

                // limit window coords to camera rect coords
                _x = sw * (_x - cameraLeft) / cameraWidth;
                _y = sh * (_y - (cameraTop)) / cameraHeight;

                // 3D screen
                camera.screenToWorld(_x, _y, camera.nearClip, vecA$1);
                camera.screenToWorld(_x, _y, camera.farClip, vecB$1);

                ray.origin.copy(vecA$1);
                ray.direction.set(0, 0, -1);
                ray.end.copy(vecB$1);

                return true;
            }
            return false;
        },

        _checkElement: function (ray, element, screen) {
            // ensure click is contained by any mask first
            if (element.maskedBy) {
                var result = this._checkElement(ray, element.maskedBy.element, screen);
                if (!result) return false;
            }

            var scale;

            if (screen) {
                scale = this._calculateScaleToScreen(element);
            } else {
                scale = element.entity.getWorldTransform().getScale();
            }

            var corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y);

            if (intersectLineQuad(ray.origin, ray.end, corners))
                return true;

            return false;
        }
    });

    Object.defineProperty(ElementInput.prototype, 'enabled', {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            this._enabled = value;
        }
    });

    Object.defineProperty(ElementInput.prototype, 'app', {
        get: function () {
            return this._app || Application.getApplication();
        },
        set: function (value) {
            this._app = value;
        }
    });

    /**
     * @class
     * @name pc.GamePads
     * @classdesc Input handler for accessing GamePad input.
     */
    function GamePads() {
        this.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;

        this.current = [];
        this.previous = [];

        this.deadZone = 0.25;
    }

    var MAPS = {
        DEFAULT: {
            buttons: [
                // Face buttons
                'PAD_FACE_1',
                'PAD_FACE_2',
                'PAD_FACE_3',
                'PAD_FACE_4',

                // Shoulder buttons
                'PAD_L_SHOULDER_1',
                'PAD_R_SHOULDER_1',
                'PAD_L_SHOULDER_2',
                'PAD_R_SHOULDER_2',

                // Other buttons
                'PAD_SELECT',
                'PAD_START',
                'PAD_L_STICK_BUTTON',
                'PAD_R_STICK_BUTTON',

                // D Pad
                'PAD_UP',
                'PAD_DOWN',
                'PAD_LEFT',
                'PAD_RIGHT',

                 // Vendor specific button
                'PAD_VENDOR'
            ],

            axes: [
                // Analogue Sticks
                'PAD_L_STICK_X',
                'PAD_L_STICK_Y',
                'PAD_R_STICK_X',
                'PAD_R_STICK_Y'
            ]
        },

        PS3: {
            buttons: [
                // X, O, TRI, SQ
                'PAD_FACE_1',
                'PAD_FACE_2',
                'PAD_FACE_4',
                'PAD_FACE_3',

                // Shoulder buttons
                'PAD_L_SHOULDER_1',
                'PAD_R_SHOULDER_1',
                'PAD_L_SHOULDER_2',
                'PAD_R_SHOULDER_2',

                // Other buttons
                'PAD_SELECT',
                'PAD_START',
                'PAD_L_STICK_BUTTON',
                'PAD_R_STICK_BUTTON',

                // D Pad
                'PAD_UP',
                'PAD_DOWN',
                'PAD_LEFT',
                'PAD_RIGHT',

                'PAD_VENDOR'
            ],

            axes: [
                // Analogue Sticks
                'PAD_L_STICK_X',
                'PAD_L_STICK_Y',
                'PAD_R_STICK_X',
                'PAD_R_STICK_Y'
            ]
        }
    };

    var PRODUCT_CODES = {
        'Product: 0268': 'PS3'
    };

    Object.assign(GamePads.prototype, {
        /**
         * @function
         * @name pc.GamePads#update
         * @description Update the current and previous state of the gamepads. This must be called every frame for wasPressed()
         * to work.
         */
        update: function () {
            var i, j, l;
            var buttons, buttonsLen;

            // move current buttons status into previous array
            for (i = 0, l = this.current.length; i < l; i++) {
                buttons = this.current[i].pad.buttons;
                buttonsLen = buttons.length;
                for (j = 0; j < buttonsLen; j++) {
                    if (this.previous[i] === undefined) {
                        this.previous[i] = [];
                    }
                    this.previous[i][j] = buttons[j].pressed;
                }
            }

            // update current
            var pads = this.poll();
            for (i = 0, l = pads.length; i < l; i++) {
                this.current[i] = pads[i];
            }
        },

        /**
         * @function
         * @name pc.GamePads#poll
         * @description Poll for the latest data from the gamepad API.
         * @returns {object[]} An array of gamepads and mappings for the model of gamepad that is attached.
         * @example
         * var gamepads = new pc.GamePads();
         * var pads = gamepads.poll();
         */
        poll: function () {
            var pads = [];
            if (this.gamepadsSupported) {
                var padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();
                var i, len = padDevices.length;
                for (i = 0; i < len; i++) {
                    if (padDevices[i]) {
                        pads.push({
                            map: this.getMap(padDevices[i]),
                            pad: padDevices[i]
                        });
                    }
                }
            }
            return pads;
        },

        getMap: function (pad) {
            for (var code in PRODUCT_CODES) {
                if (pad.id.indexOf(code) >= 0) {
                    return MAPS[PRODUCT_CODES[code]];
                }
            }

            return MAPS.DEFAULT;
        },

        /**
         * @function
         * @name pc.GamePads#isPressed
         * @description Returns true if the button on the pad requested is pressed.
         * @param {number} index - The index of the pad to check, use constants pc.PAD_1, pc.PAD_2, etc.
         * @param {number} button - The button to test, use constants pc.PAD_FACE_1, etc.
         * @returns {boolean} True if the button is pressed.
         */
        isPressed: function (index, button) {
            if (!this.current[index]) {
                return false;
            }

            var key = this.current[index].map.buttons[button];
            return this.current[index].pad.buttons[pc[key]].pressed;
        },

        /**
         * @function
         * @name pc.GamePads#wasPressed
         * @description Returns true if the button was pressed since the last frame.
         * @param {number} index - The index of the pad to check, use constants pc.PAD_1, pc.PAD_2, etc.
         * @param {number} button - The button to test, use constants pc.PAD_FACE_1, etc.
         * @returns {boolean} True if the button was pressed since the last frame.
         */
        wasPressed: function (index, button) {
            if (!this.current[index]) {
                return false;
            }

            var key = this.current[index].map.buttons[button];
            var i = pc[key];
            return this.current[index].pad.buttons[i].pressed && !this.previous[index][i];
        },

        /**
         * @function
         * @name pc.GamePads#getAxis
         * @description Get the value of one of the analogue axes of the pad.
         * @param {number} index - The index of the pad to check, use constants pc.PAD_1, pc.PAD_2, etc.
         * @param {number} axes - The axes to get the value of, use constants pc.PAD_L_STICK_X, etc.
         * @returns {number} The value of the axis between -1 and 1.
         */
        getAxis: function (index, axes) {
            if (!this.current[index]) {
                return false;
            }

            var key = this.current[index].map.axes[axes];
            var value = this.current[index].pad.axes[pc[key]];

            if (Math.abs(value) < this.deadZone) {
                value = 0;
            }
            return value;
        }
    });

    /**
     * @class
     * @name pc.Touch
     * @classdesc A instance of a single point touch on a {@link pc.TouchDevice}.
     * @description Create a new Touch object from the browser Touch.
     * @param {Touch} touch - The browser Touch object.
     * @property {number} id The identifier of the touch.
     * @property {number} x The x co-ordinate relative to the element that the TouchDevice is attached to.
     * @property {number} y The y co-ordinate relative to the element that the TouchDevice is attached to.
     * @property {Element} target The target element of the touch event.
     * @property {Touch} touch The original browser Touch object.
     */
    function Touch(touch) {
        var coords = getTouchTargetCoords(touch);

        this.id = touch.identifier;

        this.x = coords.x;
        this.y = coords.y;

        this.target = touch.target;

        this.touch = touch;
    }

    /**
     * @class
     * @name pc.TouchEvent
     * @classdesc A Event corresponding to touchstart, touchend, touchmove or touchcancel. TouchEvent wraps the standard
     * browser event and provides lists of {@link pc.Touch} objects.
     * @description Create a new TouchEvent from an existing browser event.
     * @param {pc.TouchDevice} device - The source device of the touch events.
     * @param {TouchEvent} event - The original browser TouchEvent.
     * @property {Element} element The target Element that the event was fired from.
     * @property {pc.Touch[]} touches A list of all touches currently in contact with the device.
     * @property {pc.Touch[]} changedTouches A list of touches that have changed since the last event.
     * @property {TouchEvent} event - The original browser TouchEvent.
     */
    function TouchEvent(device, event) {
        this.element = event.target;
        this.event = event;

        this.touches = [];
        this.changedTouches = [];

        if (event) {
            var i, l = event.touches.length;
            for (i = 0; i < l; i++) {
                this.touches.push(new Touch(event.touches[i]));
            }

            l = event.changedTouches.length;
            for (i = 0; i < l; i++) {
                this.changedTouches.push(new Touch(event.changedTouches[i]));
            }
        }
    }

    Object.assign(TouchEvent.prototype, {
        /**
         * @function
         * @name pc.TouchEvent#getTouchById
         * @description Get an event from one of the touch lists by the id. It is useful to access
         * touches by their id so that you can be sure you are referencing the same touch.
         * @param {number} id - The identifier of the touch.
         * @param {pc.Touch[]} list - An array of touches to search.
         * @returns {pc.Touch} The {@link pc.Touch} object or null.
         */
        getTouchById: function (id, list) {
            var i, l = list.length;
            for (i = 0; i < l; i++) {
                if (list[i].id === id) {
                    return list[i];
                }
            }

            return null;
        }
    });

    /**
     * @class
     * @name pc.TouchDevice
     * @augments pc.EventHandler
     * @classdesc Attach a TouchDevice to an element and it will receive and fire events when the element is touched.
     * See also {@link pc.Touch} and {@link pc.TouchEvent}.
     * @description Create a new touch device and attach it to an element.
     * @param {Element} element - The element to attach listen for events on.
     */
    function TouchDevice(element) {
        EventHandler.call(this);

        this._element = null;

        this._startHandler = this._handleTouchStart.bind(this);
        this._endHandler = this._handleTouchEnd.bind(this);
        this._moveHandler = this._handleTouchMove.bind(this);
        this._cancelHandler = this._handleTouchCancel.bind(this);

        this.attach(element);
    }
    TouchDevice.prototype = Object.create(EventHandler.prototype);
    TouchDevice.prototype.constructor = TouchDevice;

    Object.assign(TouchDevice.prototype, {
        /**
         * @function
         * @name pc.TouchDevice#attach
         * @description Attach a device to an element in the DOM.
         * If the device is already attached to an element this method will detach it first.
         * @param {Element} element - The element to attach to.
         */
        attach: function (element) {
            if (this._element) {
                this.detach();
            }

            this._element = element;

            this._element.addEventListener('touchstart', this._startHandler, false);
            this._element.addEventListener('touchend', this._endHandler, false);
            this._element.addEventListener('touchmove', this._moveHandler, false);
            this._element.addEventListener('touchcancel', this._cancelHandler, false);
        },

        /**
         * @function
         * @name pc.TouchDevice#detach
         * @description Detach a device from the element it is attached to.
         */
        detach: function () {
            if (this._element) {
                this._element.removeEventListener('touchstart', this._startHandler, false);
                this._element.removeEventListener('touchend', this._endHandler, false);
                this._element.removeEventListener('touchmove', this._moveHandler, false);
                this._element.removeEventListener('touchcancel', this._cancelHandler, false);
            }
            this._element = null;
        },

        _handleTouchStart: function (e) {
            this.fire('touchstart', new TouchEvent(this, e));
        },

        _handleTouchEnd: function (e) {
            this.fire('touchend', new TouchEvent(this, e));
        },

        _handleTouchMove: function (e) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            e.preventDefault();
            this.fire('touchmove', new TouchEvent(this, e));
        },

        _handleTouchCancel: function (e) {
            this.fire('touchcancel', new TouchEvent(this, e));
        }
    });

    /**
     * @function
     * @name pc.getTouchTargetCoords
     * @description Similiar to {@link pc.getTargetCoords} for the MouseEvents.
     * This function takes a browser Touch object and returns the co-ordinates of the
     * touch relative to the target element.
     * @param {Touch} touch - The browser Touch object.
     * @returns {object} The co-ordinates of the touch relative to the touch.target element. In the format {x, y}.
     */
    function getTouchTargetCoords(touch) {
        var totalOffsetX = 0;
        var totalOffsetY = 0;
        var target = touch.target;
        while (!(target instanceof HTMLElement)) {
            target = target.parentNode;
        }
        var currentElement = target;

        do {
            totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
            totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
            currentElement = currentElement.offsetParent;
        } while (currentElement);

        return {
            x: touch.pageX - totalOffsetX,
            y: touch.pageY - totalOffsetY
        };
    }

    var MAX_TEXTURE_SIZE = 4096;
    var DEFAULT_TEXTURE_SIZE = 512;

    /**
     * @private
     * @class
     * @name pc.CanvasFont
     * @augments pc.EventHandler
     * @classdesc Represents the resource of a canvas font asset.
     * @param {pc.Application} app - The application.
     * @param {object} options - The font options.
     * @param {string} [options.fontName] - The name of the font, use in the same manner as a CSS font.
     * @param {string} [options.fontWeight] - The weight of the font, e.g. 'normal', 'bold', defaults to "normal".
     * @param {number} [options.fontSize] - The size the font will be rendered into to the texture atlas at, defaults to 32.
     * @param {pc.Color} [options.color] - The color the font will be rendered into the texture atlas as, defaults to white.
     * @param {number} [options.width] - The width of each texture atlas, defaults to 512.
     * @param {number} [options.height] - The height of each texture atlas, defaults to 512.
     * @param {number} [options.padding] - Amount of glyph padding added to each glyph in the atlas.
     */
    function CanvasFont(app, options) {
        EventHandler.call(this);

        this.type = "bitmap";

        this.app = app;

        this.intensity = 0;

        options = options || {};
        this.fontWeight = options.fontWeight || 'normal';
        this.fontSize = parseInt(options.fontSize, 10);
        this.glyphSize = this.fontSize;
        this.fontName = options.fontName || 'Arial';
        this.color = options.color || new Color(1, 1, 1);
        this.padding = options.padding || 0;

        var w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : (options.width || DEFAULT_TEXTURE_SIZE);
        var h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : (options.height || DEFAULT_TEXTURE_SIZE);

        // Create a canvas to do the text rendering
        var canvas = document.createElement('canvas');
        canvas.height = h;
        canvas.width = w;

        var texture = new Texture(this.app.graphicsDevice, {
            format: PIXELFORMAT_R8_G8_B8_A8,
            autoMipmap: true
        });

        texture.name = 'font';
        texture.setSource(canvas);
        texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
        texture.magFilter = FILTER_LINEAR;
        texture.addressU = ADDRESS_CLAMP_TO_EDGE;
        texture.addressV = ADDRESS_CLAMP_TO_EDGE;

        this.textures = [texture];

        this.chars = "";
        this.data = {};
    }
    CanvasFont.prototype = Object.create(EventHandler.prototype);
    CanvasFont.prototype.constructor = CanvasFont;

    /**
     * @private
     * @function
     * @name pc.CanvasFont#createTextures
     * @description Render the necessary textures for all characters in a string to be used for the canvas font.
     * @param {string} text - The list of characters to render into the texture atlas.
     */
    CanvasFont.prototype.createTextures = function (text) {
        var _chars = this._normalizeCharsSet(text);

        // different length so definitely update
        if (_chars.length !== this.chars.length) {
            this._renderAtlas(_chars);
            return;
        }

        // compare sorted characters for difference
        for (var i = 0; i < _chars.length; i++) {
            if (_chars[i] !== this.chars[i]) {
                this._renderAtlas(_chars);
                return;
            }
        }
    };

    /**
     * @private
     * @function
     * @name pc.CanvasFont#updateTextures
     * @description Update the list of characters to include in the atlas to include those provided and re-render the texture atlas
     * to include all the characters that have been supplied so far.
     * @param {string} text - The list of characters to add to the texture atlas.
     */
    CanvasFont.prototype.updateTextures = function (text) {
        var _chars = this._normalizeCharsSet(text);
        var newCharsSet = [];

        for (var i = 0; i < _chars.length; i++) {
            var char = _chars[i];
            if (!this.data.chars[char]) {
                newCharsSet.push(char);
            }
        }

        if (newCharsSet.length > 0) {
            this._renderAtlas(this.chars.concat(newCharsSet));
        }
    };

    /**
     * @private
     * @function
     * @name pc.CanvasFont#destroy
     * @description Tears down all resources used by the font.
     */
    CanvasFont.prototype.destroy = function () {
        // call texture.destroy on any created textures
        for (var i = 0; i < this.textures.length; i++) {
            this.textures[i].destroy();
        }
        // null instance variables to make it obvious this font is no longer valid
        this.chars = null;
        this.color = null;
        this.data = null;
        this.fontName = null;
        this.fontSize = null;
        this.glyphSize = null;
        this.intensity = null;
        this.textures = null;
        this.type = null;
        this.fontWeight = null;
    };

    CanvasFont.prototype._getAndClearContext = function (canvas, clearColor) {
        var w = canvas.width;
        var h = canvas.height;

        var ctx = canvas.getContext('2d', {
            alpha: true
        });

        ctx.clearRect(0, 0, w, h);  // clear to black first to remove everything as clear color is transparent
        ctx.fillStyle = clearColor;
        ctx.fillRect(0, 0, w, h);   // clear to color

        return ctx;
    };

    CanvasFont.prototype._colorToRgbString = function (color, alpha) {
        var str;
        var r = Math.round(255 * color.r);
        var g = Math.round(255 * color.g);
        var b = Math.round(255 * color.b);

        if (alpha) {
            str = "rgba(" + r + ", " + g + ", " + b + ", " + color.a + ")";
        } else {
            str = "rgb(" + r + ", " + g + ", " + b + ")";
        }

        return str;
    };

    CanvasFont.prototype.renderCharacter = function (context, char, x, y, color) {
        context.fillStyle = color;
        context.fillText(char, x, y);
    };

    CanvasFont.prototype._renderAtlas = function (charsArray) {
        this.chars = charsArray;

        var numTextures = 1;

        var canvas = this.textures[numTextures - 1].getSource();
        var w = canvas.width;
        var h = canvas.height;

        // fill color
        var color = this._colorToRgbString(this.color, false);

        // generate a "transparent" color for the background
        // browsers seem to optimize away all color data if alpha=0
        // so setting alpha to min value and hope this isn't noticable
        var a = this.color.a;
        this.color.a = 1 / 255;
        var transparent = this._colorToRgbString(this.color, true);
        this.color.a = a;

        var TEXT_ALIGN = 'center';
        var TEXT_BASELINE = 'alphabetic';

        var ctx = this._getAndClearContext(canvas, transparent);

        ctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;
        ctx.textAlign = TEXT_ALIGN;
        ctx.textBaseline = TEXT_BASELINE;

        this.data = this._createJson(this.chars, this.fontName, w, h);

        var symbols = string.getSymbols(this.chars.join(''));
        var prevNumTextures = this.textures.length;

        var maxHeight = 0;
        var maxDescent = 0;
        var metrics = {};
        var i, ch;
        for (i = 0; i < symbols.length; i++) {
            ch = symbols[i];
            metrics[ch] = this._getTextMetrics(ch);
            maxHeight = Math.max(maxHeight, metrics[ch].height);
            maxDescent = Math.max(maxDescent, metrics[ch].descent);
        }

        this.glyphSize = Math.max(this.glyphSize, maxHeight);

        var sx = this.glyphSize + this.padding * 2;
        var sy = this.glyphSize + this.padding * 2;
        var _xOffset = this.glyphSize / 2 + this.padding;
        var _yOffset = sy - maxDescent - this.padding;
        var _x = 0;
        var _y = 0;

        for (i = 0; i < symbols.length; i++) {
            ch = symbols[i];
            var code = string.getCodePoint(symbols[i]);

            var fs = this.fontSize;
            ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
            ctx.textAlign = TEXT_ALIGN;
            ctx.textBaseline = TEXT_BASELINE;

            var width = ctx.measureText(ch).width;

            if (width > fs) {
                fs = this.fontSize * this.fontSize / width;
                ctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;
                width = this.fontSize;
            }

            this.renderCharacter(ctx, ch, _x + _xOffset, _y + _yOffset, color);

            var xoffset = this.padding + (this.glyphSize - width) / 2;
            var yoffset = -this.padding + metrics[ch].descent - maxDescent;
            var xadvance = width;

            this._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);

            _x += sx;
            if (_x + sx > w) {
                // Wrap to the next row of this canvas if the right edge of the next glyph would overflow
                _x = 0;
                _y += sy;
                if (_y + sy > h) {
                    // We ran out of space on this texture!
                    // Copy the canvas into the texture and upload it
                    this.textures[numTextures - 1].upload();
                    // Create a new texture (if needed) and continue on
                    numTextures++;
                    _y = 0;
                    if (numTextures > prevNumTextures) {
                        canvas = document.createElement('canvas');
                        canvas.height = h;
                        canvas.width = w;

                        ctx = this._getAndClearContext(canvas, transparent);

                        var texture = new Texture(this.app.graphicsDevice, {
                            format: PIXELFORMAT_R8_G8_B8_A8,
                            autoMipmap: true
                        });
                        texture.name = 'font-atlas';
                        texture.setSource(canvas);
                        texture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;
                        texture.magFilter = FILTER_LINEAR;
                        texture.addressU = ADDRESS_CLAMP_TO_EDGE;
                        texture.addressV = ADDRESS_CLAMP_TO_EDGE;
                        this.textures.push(texture);
                    } else {
                        canvas = this.textures[numTextures - 1].getSource();
                        ctx = this._getAndClearContext(canvas, transparent);
                    }
                }
            }
        }
        // Copy any remaining characters in the canvas into the last texture and upload it
        this.textures[numTextures - 1].upload();

        // Cleanup any remaining (unused) textures
        if (numTextures < prevNumTextures) {
            for (i = numTextures; i < prevNumTextures; i++) {
                this.textures[i].destroy();
            }
            this.textures.splice(numTextures);
        }

        // alert text-elements that the font has been re-rendered
        this.fire("render");
    };

    CanvasFont.prototype._createJson = function (chars, fontName, width, height) {
        var base = {
            "version": 3,
            "intensity": this.intensity,
            "info": {
                "face": fontName,
                "width": width,
                "height": height,
                "maps": [{
                    "width": width,
                    "height": height
                }]
            },
            "chars": {}
        };

        return base;
    };

    CanvasFont.prototype._addChar = function (json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {
        if (json.info.maps.length < mapNum + 1) {
            json.info.maps.push({ "width": mapW, "height": mapH });
        }

        var scale = this.fontSize / 32;

        json.chars[char] = {
            "id": charCode,
            "letter": char,
            "x": x,
            "y": y,
            "width": w,
            "height": h,
            "xadvance": xadvance / scale,
            "xoffset": xoffset / scale,
            "yoffset": (yoffset + this.padding) / scale,
            "scale": scale,
            "range": 1,
            "map": mapNum,
            "bounds": [0, 0, w / scale, h / scale]
        };
    };


    // take a unicode string and produce
    // the set of characters used to create that string
    // e.g. "abcabcabc" -> ['a', 'b', 'c']
    CanvasFont.prototype._normalizeCharsSet = function (text) {
        // normalize unicode if needed
        var unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();
        if (unicodeConverterFunc) {
            text = unicodeConverterFunc(text);
        }
        // strip duplicates
        var set = {};
        var symbols = string.getSymbols(text);
        var i;
        for (i = 0; i < symbols.length; i++) {
            var ch = symbols[i];
            if (set[ch]) continue;
            set[ch] = ch;
        }
        var chars = Object.keys(set);
        // sort
        return chars.sort();
    };

    // Calculate some metrics that aren't available via the
    // browser API, notably character height and descent size
    CanvasFont.prototype._getTextMetrics = function (text) {
        var textSpan = document.createElement('span');
        textSpan.id = 'content-span';
        textSpan.innerHTML = text;

        var block = document.createElement("div");
        block.id = 'content-block';
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(textSpan);
        div.appendChild(block);
        div.style.font = this.fontName;
        div.style.fontSize = this.fontSize + 'px';

        var body = document.body;
        body.appendChild(div);

        var ascent = -1;
        var descent = -1;
        var height = -1;

        try {
            block.style['vertical-align'] = 'baseline';
            ascent = block.offsetTop - textSpan.offsetTop;
            block.style['vertical-align'] = 'bottom';
            height = block.offsetTop - textSpan.offsetTop;
            descent = height - ascent;
        } finally {
            document.body.removeChild(div);
        }

        return {
            ascent: ascent,
            descent: descent,
            height: height
        };
    };

    /**
     * @private
     * @class
     * @name pc.ComponentData
     * @classdesc Base class for Component data storage.
     */
    function ComponentData() {}

    // CORE

    var log = {
        write: function (text) {
            console.log(text);
        },

        open: function () {
            log.write("Powered by PlayCanvas " + version + " " + revision);
        },

        info: function (text) {
            console.info("INFO:    " + text);
        },

        debug: function (text) {
            console.debug("DEBUG:   " + text);
        },

        error: function (text) {
            console.error("ERROR:   " + text);
        },

        warning: function (text) {
            console.warn("WARNING: " + text);
        },

        alert: function (text) {
            log.write("ALERT:   " + text);
            alert(text); // eslint-disable-line no-alert
        },

        assert: function (condition, text) {
            if (condition === false) {
                log.write("ASSERT:  " + text);
            }
        }
    };

    string.endsWith = function (s, subs) {
        return s.endsWith(subs);
    };

    string.format = function (s) {
        var i = 0,
            regexp,
            args = pc.makeArray(arguments);

        // drop first argument
        args.shift();

        for (i = 0; i < args.length; i++) {
            regexp = new RegExp('\\{' + i + '\\}', 'gi');
            s = s.replace(regexp, args[i]);
        }
        return s;
    };

    string.startsWith = function (s, subs) {
        return s.startsWith(subs);
    };

    var time = {
        now: now,
        Timer: Timer
    };

    Object.defineProperty(Color.prototype, "data", {
        get: function () {
            if (!this._data) {
                this._data = new Float32Array(4);
            }
            this._data[0] = this.r;
            this._data[1] = this.g;
            this._data[2] = this.b;
            this._data[3] = this.a;
            return this._data;
        }
    });

    Object.defineProperty(Color.prototype, "data3", {
        get: function () {
            if (!this._data3) {
                this._data3 = new Float32Array(3);
            }
            this._data3[0] = this.r;
            this._data3[1] = this.g;
            this._data3[2] = this.b;
            return this._data3;
        }
    });

    function inherits(Self, Super) {
        var Temp = function () {};
        var Func = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            Super.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            Self.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            // this.constructor = Self;
        };
        Func._super = Super.prototype;
        Temp.prototype = Super.prototype;
        Func.prototype = new Temp();

        return Func;
    }

    math.INV_LOG2 = Math.LOG2E;

    math.intToBytes = math.intToBytes32;
    math.bytesToInt = math.bytesToInt32;

    Object.defineProperty(Vec2.prototype, "data", {
        get: function () {
            if (!this._data) {
                this._data = new Float32Array(2);
            }
            this._data[0] = this.x;
            this._data[1] = this.y;
            return this._data;
        }
    });

    Object.defineProperty(Vec3.prototype, "data", {
        get: function () {
            if (!this._data) {
                this._data = new Float32Array(3);
            }
            this._data[0] = this.x;
            this._data[1] = this.y;
            this._data[2] = this.z;
            return this._data;
        }
    });

    Object.defineProperty(Vec4.prototype, "data", {
        get: function () {
            if (!this._data) {
                this._data = new Float32Array(4);
            }
            this._data[0] = this.x;
            this._data[1] = this.y;
            this._data[2] = this.z;
            this._data[3] = this.w;
            return this._data;
        }
    });

    var shape = {
        Aabb: BoundingBox,
        Sphere: BoundingSphere,
        Plane: Plane
    };

    BoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;

    var ELEMENTTYPE_INT8 = TYPE_INT8;
    var ELEMENTTYPE_UINT8 = TYPE_UINT8;
    var ELEMENTTYPE_INT16 = TYPE_INT16;
    var ELEMENTTYPE_UINT16 = TYPE_UINT16;
    var ELEMENTTYPE_INT32 = TYPE_INT32;
    var ELEMENTTYPE_UINT32 = TYPE_UINT32;
    var ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;

    function UnsupportedBrowserError(message) {
        this.name = "UnsupportedBrowserError";
        this.message = (message || "");
    }
    UnsupportedBrowserError.prototype = Error.prototype;

    function ContextCreationError(message) {
        this.name = "ContextCreationError";
        this.message = (message || "");
    }
    ContextCreationError.prototype = Error.prototype;

    var gfx = {
        drawQuadWithShader: drawQuadWithShader,
        programlib: programlib,
        shaderChunks: shaderChunks,
        ContextCreationError: ContextCreationError,
        Device: GraphicsDevice,
        IndexBuffer: IndexBuffer,
        ProgramLibrary: ProgramLibrary,
        RenderTarget: RenderTarget,
        ScopeId: ScopeId,
        Shader: Shader,
        ShaderInput: ShaderInput,
        Texture: Texture,
        UnsupportedBrowserError: UnsupportedBrowserError,
        VertexBuffer: VertexBuffer,
        VertexFormat: VertexFormat,
        VertexIterator: VertexIterator
    };

    var posteffect = {
        createFullscreenQuad: createFullscreenQuad,
        drawFullscreenQuad: drawFullscreenQuad,
        PostEffect: PostEffect,
        PostEffectQueue: PostEffectQueue
    };

    Object.defineProperty(shaderChunks, "transformSkinnedVS", {
        get: function () {
            return "#define SKIN\n" + shaderChunks.transformVS;
        }
    });

    Object.defineProperties(Texture.prototype, {
        rgbm: {
            get: function () {
                return this.type === TEXTURETYPE_RGBM;
            },
            set: function (rgbm) {
                this.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
            }
        },

        swizzleGGGR: {
            get: function () {
                return this.type === TEXTURETYPE_SWIZZLEGGGR;
            },
            set: function (swizzleGGGR) {
                this.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;
            }
        }
    });

    var PhongMaterial = StandardMaterial;

    var scene = {
        partitionSkin: partitionSkin,
        procedural: {
            calculateTangents: calculateTangents,
            createMesh: createMesh,
            createTorus: createTorus,
            createCylinder: createCylinder,
            createCapsule: createCapsule,
            createCone: createCone,
            createSphere: createSphere,
            createPlane: createPlane,
            createBox: createBox
        },
        BasicMaterial: BasicMaterial,
        Command: Command,
        DepthMaterial: DepthMaterial,
        ForwardRenderer: ForwardRenderer,
        GraphNode: GraphNode,
        Material: Material,
        Mesh: Mesh,
        MeshInstance: MeshInstance,
        Model: Model,
        ParticleEmitter: ParticleEmitter,
        PhongMaterial: StandardMaterial,
        Picker: Picker,
        Projection: {
            ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
            PERSPECTIVE: PROJECTION_PERSPECTIVE
        },
        Scene: Scene,
        Skin: Skin,
        SkinInstance: SkinInstance
    };

    GraphNode.prototype._dirtify = function (local) {
        if (local)
            this._dirtifyLocal();
        else
            this._dirtifyWorld();
    };

    GraphNode.prototype.addLabel = function (label) {

        this._labels[label] = true;
    };

    GraphNode.prototype.getLabels = function () {

        return Object.keys(this._labels);
    };

    GraphNode.prototype.hasLabel = function (label) {

        return !!this._labels[label];
    };

    GraphNode.prototype.removeLabel = function (label) {

        delete this._labels[label];
    };

    GraphNode.prototype.findByLabel = function (label, results) {

        var i, length = this._children.length;
        results = results || [];

        if (this.hasLabel(label)) {
            results.push(this);
        }

        for (i = 0; i < length; ++i) {
            results = this._children[i].findByLabel(label, results);
        }

        return results;
    };

    GraphNode.prototype.getChildren = function () {

        return this.children;
    };

    GraphNode.prototype.getName = function () {

        return this.name;
    };

    GraphNode.prototype.getPath = function () {

        return this.path;
    };

    GraphNode.prototype.getRoot = function () {

        return this.root;
    };

    GraphNode.prototype.getParent = function () {

        return this.parent;
    };

    GraphNode.prototype.setName = function (name) {

        this.name = name;
    };

    Material.prototype.getName = function () {
        return this.name;
    };

    Material.prototype.setName = function (name) {
        this.name = name;
    };

    Material.prototype.getShader = function () {
        return this.shader;
    };

    Material.prototype.setShader = function (shader) {
        this.shader = shader;
    };

    var anim = {
        Animation: Animation,
        Key: Key,
        Node: Node,
        Skeleton: Skeleton
    };

    var audio = {
        AudioManager: SoundManager,
        Channel: Channel,
        Channel3d: Channel3d,
        Listener: Listener,
        Sound: Sound
    };

    SoundManager.prototype.getListener = function () {
        return this.listener;
    };

    SoundManager.prototype.getVolume = function () {
        return this.volume;
    };

    SoundManager.prototype.setVolume = function (volume) {
        this.volume = volume;
    };

    var asset = {
        ASSET_ANIMATION: 'animation',
        ASSET_AUDIO: 'audio',
        ASSET_IMAGE: 'image',
        ASSET_JSON: 'json',
        ASSET_MODEL: 'model',
        ASSET_MATERIAL: 'material',
        ASSET_TEXT: 'text',
        ASSET_TEXTURE: 'texture',
        ASSET_CUBEMAP: 'cubemap',
        ASSET_SCRIPT: 'script'
    };

    AssetRegistry.prototype.getAssetById = function (id) {
        return this.get(id);
    };

    Object.defineProperty(XrInputSource.prototype, 'ray', {
        get: function () {
            return this._rayLocal;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'position', {
        get: function () {
            return this._localPosition;
        }
    });

    Object.defineProperty(XrInputSource.prototype, 'rotation', {
        get: function () {
            return this._localRotation;
        }
    });

    var input = {
        getTouchTargetCoords: getTouchTargetCoords,
        Controller: Controller,
        GamePads: GamePads,
        Keyboard: Keyboard,
        KeyboardEvent: KeyboardEvent,
        Mouse: Mouse,
        MouseEvent: MouseEvent,
        Touch: Touch,
        TouchDevice: TouchDevice,
        TouchEvent: TouchEvent
    };

    Object.defineProperty(ElementInput.prototype, 'wheel', {
        get: function () {
            return this.wheelDelta * -2;
        }
    });

    Object.defineProperty(MouseEvent.prototype, 'wheel', {
        get: function () {
            return this.wheelDelta * -2;
        }
    });

    var RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;
    var RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;
    var RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;
    var RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
    var RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
    var RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
    var RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
    var RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
    var RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
    var RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
    var RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;

    var fw = {
        Application: Application,
        Component: Component,
        ComponentData: ComponentData,
        ComponentSystem: ComponentSystem,
        Entity: Entity,
        FillMode: {
            NONE: FILLMODE_NONE,
            FILL_WINDOW: FILLMODE_FILL_WINDOW,
            KEEP_ASPECT: FILLMODE_KEEP_ASPECT
        },
        ResolutionMode: {
            AUTO: RESOLUTION_AUTO,
            FIXED: RESOLUTION_FIXED
        }
    };

    Application.prototype.isFullscreen = function () {

        return !!document.fullscreenElement;
    };

    Application.prototype.enableFullscreen = function (element, success, error) {

        element = element || this.graphicsDevice.canvas;

        // success callback
        var s = function () {
            success();
            document.removeEventListener('fullscreenchange', s);
        };

        // error callback
        var e = function () {
            error();
            document.removeEventListener('fullscreenerror', e);
        };

        if (success) {
            document.addEventListener('fullscreenchange', s, false);
        }

        if (error) {
            document.addEventListener('fullscreenerror', e, false);
        }

        if (element.requestFullscreen) {
            element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else {
            error();
        }
    };

    Application.prototype.disableFullscreen = function (success) {

        // success callback
        var s = function () {
            success();
            document.removeEventListener('fullscreenchange', s);
        };

        if (success) {
            document.addEventListener('fullscreenchange', s, false);
        }

        document.exitFullscreen();
    };

    Object.defineProperty(LightComponent.prototype, "enable", {
        get: function () {
            return this.enabled;
        },
        set: function (value) {
            this.enabled = value;
        }
    });

    Object.defineProperty(RigidBodyComponent.prototype, "bodyType", {
        get: function () {
            return this.type;
        },
        set: function (type) {
            this.type = type;
        }
    });

    RigidBodyComponent.prototype.syncBodyToEntity = function () {
        this._updateDynamic();
    };

    RigidBodyComponentSystem.prototype.setGravity = function () {

        if (arguments.length === 1) {
            this.gravity.copy(arguments[0]);
        } else {
            this.gravity.set(arguments[0], arguments[1], arguments[2]);
        }
    };

    exports.ABSOLUTE_URL = ABSOLUTE_URL;
    exports.ACTION_GAMEPAD = ACTION_GAMEPAD;
    exports.ACTION_KEYBOARD = ACTION_KEYBOARD;
    exports.ACTION_MOUSE = ACTION_MOUSE;
    exports.ADDRESS_CLAMP_TO_EDGE = ADDRESS_CLAMP_TO_EDGE;
    exports.ADDRESS_MIRRORED_REPEAT = ADDRESS_MIRRORED_REPEAT;
    exports.ADDRESS_REPEAT = ADDRESS_REPEAT;
    exports.ANIM_EQUAL_TO = ANIM_EQUAL_TO;
    exports.ANIM_GREATER_THAN = ANIM_GREATER_THAN;
    exports.ANIM_GREATER_THAN_EQUAL_TO = ANIM_GREATER_THAN_EQUAL_TO;
    exports.ANIM_INTERRUPTION_NEXT = ANIM_INTERRUPTION_NEXT;
    exports.ANIM_INTERRUPTION_NEXT_PREV = ANIM_INTERRUPTION_NEXT_PREV;
    exports.ANIM_INTERRUPTION_NONE = ANIM_INTERRUPTION_NONE;
    exports.ANIM_INTERRUPTION_PREV = ANIM_INTERRUPTION_PREV;
    exports.ANIM_INTERRUPTION_PREV_NEXT = ANIM_INTERRUPTION_PREV_NEXT;
    exports.ANIM_LESS_THAN = ANIM_LESS_THAN;
    exports.ANIM_LESS_THAN_EQUAL_TO = ANIM_LESS_THAN_EQUAL_TO;
    exports.ANIM_NOT_EQUAL_TO = ANIM_NOT_EQUAL_TO;
    exports.ANIM_PARAMETER_BOOLEAN = ANIM_PARAMETER_BOOLEAN;
    exports.ANIM_PARAMETER_FLOAT = ANIM_PARAMETER_FLOAT;
    exports.ANIM_PARAMETER_INTEGER = ANIM_PARAMETER_INTEGER;
    exports.ANIM_PARAMETER_TRIGGER = ANIM_PARAMETER_TRIGGER;
    exports.ANIM_STATE_END = ANIM_STATE_END;
    exports.ANIM_STATE_START = ANIM_STATE_START;
    exports.ASPECT_AUTO = ASPECT_AUTO;
    exports.ASPECT_MANUAL = ASPECT_MANUAL;
    exports.ASSET_ANIMATION = ASSET_ANIMATION;
    exports.ASSET_AUDIO = ASSET_AUDIO;
    exports.ASSET_CONTAINER = ASSET_CONTAINER;
    exports.ASSET_CSS = ASSET_CSS;
    exports.ASSET_CUBEMAP = ASSET_CUBEMAP;
    exports.ASSET_HTML = ASSET_HTML;
    exports.ASSET_IMAGE = ASSET_IMAGE;
    exports.ASSET_JSON = ASSET_JSON;
    exports.ASSET_MATERIAL = ASSET_MATERIAL;
    exports.ASSET_MODEL = ASSET_MODEL;
    exports.ASSET_SCRIPT = ASSET_SCRIPT;
    exports.ASSET_SHADER = ASSET_SHADER;
    exports.ASSET_TEXT = ASSET_TEXT;
    exports.ASSET_TEXTURE = ASSET_TEXTURE;
    exports.AXIS_KEY = AXIS_KEY;
    exports.AXIS_MOUSE_X = AXIS_MOUSE_X;
    exports.AXIS_MOUSE_Y = AXIS_MOUSE_Y;
    exports.AXIS_PAD_L_X = AXIS_PAD_L_X;
    exports.AXIS_PAD_L_Y = AXIS_PAD_L_Y;
    exports.AXIS_PAD_R_X = AXIS_PAD_R_X;
    exports.AXIS_PAD_R_Y = AXIS_PAD_R_Y;
    exports.AnimBinder = AnimBinder;
    exports.AnimClip = AnimClip;
    exports.AnimClipHandler = AnimClipHandler;
    exports.AnimComponent = AnimComponent;
    exports.AnimComponentLayer = AnimComponentLayer;
    exports.AnimComponentSystem = AnimComponentSystem;
    exports.AnimController = AnimController;
    exports.AnimCurve = AnimCurve;
    exports.AnimData = AnimData;
    exports.AnimEvaluator = AnimEvaluator;
    exports.AnimPropertyLocator = AnimPropertyLocator;
    exports.AnimSnapshot = AnimSnapshot;
    exports.AnimStateGraph = AnimStateGraph;
    exports.AnimStateGraphHandler = AnimStateGraphHandler;
    exports.AnimTarget = AnimTarget;
    exports.AnimTrack = AnimTrack;
    exports.Animation = Animation;
    exports.AnimationComponent = AnimationComponent;
    exports.AnimationComponentSystem = AnimationComponentSystem;
    exports.AnimationHandler = AnimationHandler;
    exports.Application = Application;
    exports.Asset = Asset;
    exports.AssetListLoader = AssetListLoader;
    exports.AssetReference = AssetReference;
    exports.AssetRegistry = AssetRegistry;
    exports.AudioHandler = AudioHandler;
    exports.AudioListenerComponent = AudioListenerComponent;
    exports.AudioListenerComponentSystem = AudioListenerComponentSystem;
    exports.AudioSourceComponent = AudioSourceComponent;
    exports.AudioSourceComponentSystem = AudioSourceComponentSystem;
    exports.BAKE_COLOR = BAKE_COLOR;
    exports.BAKE_COLORDIR = BAKE_COLORDIR;
    exports.BLENDEQUATION_ADD = BLENDEQUATION_ADD;
    exports.BLENDEQUATION_MAX = BLENDEQUATION_MAX;
    exports.BLENDEQUATION_MIN = BLENDEQUATION_MIN;
    exports.BLENDEQUATION_REVERSE_SUBTRACT = BLENDEQUATION_REVERSE_SUBTRACT;
    exports.BLENDEQUATION_SUBTRACT = BLENDEQUATION_SUBTRACT;
    exports.BLENDMODE_DST_ALPHA = BLENDMODE_DST_ALPHA;
    exports.BLENDMODE_DST_COLOR = BLENDMODE_DST_COLOR;
    exports.BLENDMODE_ONE = BLENDMODE_ONE;
    exports.BLENDMODE_ONE_MINUS_DST_ALPHA = BLENDMODE_ONE_MINUS_DST_ALPHA;
    exports.BLENDMODE_ONE_MINUS_DST_COLOR = BLENDMODE_ONE_MINUS_DST_COLOR;
    exports.BLENDMODE_ONE_MINUS_SRC_ALPHA = BLENDMODE_ONE_MINUS_SRC_ALPHA;
    exports.BLENDMODE_ONE_MINUS_SRC_COLOR = BLENDMODE_ONE_MINUS_SRC_COLOR;
    exports.BLENDMODE_SRC_ALPHA = BLENDMODE_SRC_ALPHA;
    exports.BLENDMODE_SRC_ALPHA_SATURATE = BLENDMODE_SRC_ALPHA_SATURATE;
    exports.BLENDMODE_SRC_COLOR = BLENDMODE_SRC_COLOR;
    exports.BLENDMODE_ZERO = BLENDMODE_ZERO;
    exports.BLEND_ADDITIVE = BLEND_ADDITIVE;
    exports.BLEND_ADDITIVEALPHA = BLEND_ADDITIVEALPHA;
    exports.BLEND_MAX = BLEND_MAX;
    exports.BLEND_MIN = BLEND_MIN;
    exports.BLEND_MULTIPLICATIVE = BLEND_MULTIPLICATIVE;
    exports.BLEND_MULTIPLICATIVE2X = BLEND_MULTIPLICATIVE2X;
    exports.BLEND_NONE = BLEND_NONE;
    exports.BLEND_NORMAL = BLEND_NORMAL;
    exports.BLEND_PREMULTIPLIED = BLEND_PREMULTIPLIED;
    exports.BLEND_SCREEN = BLEND_SCREEN;
    exports.BLEND_SUBTRACTIVE = BLEND_SUBTRACTIVE;
    exports.BLUR_BOX = BLUR_BOX;
    exports.BLUR_GAUSSIAN = BLUR_GAUSSIAN;
    exports.BODYFLAG_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;
    exports.BODYFLAG_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;
    exports.BODYFLAG_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;
    exports.BODYGROUP_DEFAULT = BODYGROUP_DEFAULT;
    exports.BODYGROUP_DYNAMIC = BODYGROUP_DYNAMIC;
    exports.BODYGROUP_ENGINE_1 = BODYGROUP_ENGINE_1;
    exports.BODYGROUP_ENGINE_2 = BODYGROUP_ENGINE_2;
    exports.BODYGROUP_ENGINE_3 = BODYGROUP_ENGINE_3;
    exports.BODYGROUP_KINEMATIC = BODYGROUP_KINEMATIC;
    exports.BODYGROUP_NONE = BODYGROUP_NONE;
    exports.BODYGROUP_STATIC = BODYGROUP_STATIC;
    exports.BODYGROUP_TRIGGER = BODYGROUP_TRIGGER;
    exports.BODYGROUP_USER_1 = BODYGROUP_USER_1;
    exports.BODYGROUP_USER_2 = BODYGROUP_USER_2;
    exports.BODYGROUP_USER_3 = BODYGROUP_USER_3;
    exports.BODYGROUP_USER_4 = BODYGROUP_USER_4;
    exports.BODYGROUP_USER_5 = BODYGROUP_USER_5;
    exports.BODYGROUP_USER_6 = BODYGROUP_USER_6;
    exports.BODYGROUP_USER_7 = BODYGROUP_USER_7;
    exports.BODYGROUP_USER_8 = BODYGROUP_USER_8;
    exports.BODYMASK_ALL = BODYMASK_ALL;
    exports.BODYMASK_NONE = BODYMASK_NONE;
    exports.BODYMASK_NOT_STATIC = BODYMASK_NOT_STATIC;
    exports.BODYMASK_NOT_STATIC_KINEMATIC = BODYMASK_NOT_STATIC_KINEMATIC;
    exports.BODYMASK_STATIC = BODYMASK_STATIC;
    exports.BODYSTATE_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;
    exports.BODYSTATE_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;
    exports.BODYSTATE_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;
    exports.BODYSTATE_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;
    exports.BODYSTATE_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;
    exports.BODYTYPE_DYNAMIC = BODYTYPE_DYNAMIC;
    exports.BODYTYPE_KINEMATIC = BODYTYPE_KINEMATIC;
    exports.BODYTYPE_STATIC = BODYTYPE_STATIC;
    exports.BUFFER_DYNAMIC = BUFFER_DYNAMIC;
    exports.BUFFER_GPUDYNAMIC = BUFFER_GPUDYNAMIC;
    exports.BUFFER_STATIC = BUFFER_STATIC;
    exports.BUFFER_STREAM = BUFFER_STREAM;
    exports.BUTTON_TRANSITION_MODE_SPRITE_CHANGE = BUTTON_TRANSITION_MODE_SPRITE_CHANGE;
    exports.BUTTON_TRANSITION_MODE_TINT = BUTTON_TRANSITION_MODE_TINT;
    exports.BasicMaterial = BasicMaterial;
    exports.BasisParser = BasisParser;
    exports.Batch = Batch;
    exports.BatchGroup = BatchGroup;
    exports.BatchManager = BatchManager;
    exports.BinaryHandler = BinaryHandler;
    exports.BoundingBox = BoundingBox;
    exports.BoundingSphere = BoundingSphere;
    exports.Bundle = Bundle;
    exports.BundleHandler = BundleHandler;
    exports.BundleRegistry = BundleRegistry;
    exports.ButtonComponent = ButtonComponent;
    exports.ButtonComponentSystem = ButtonComponentSystem;
    exports.CLEARFLAG_COLOR = CLEARFLAG_COLOR;
    exports.CLEARFLAG_DEPTH = CLEARFLAG_DEPTH;
    exports.CLEARFLAG_STENCIL = CLEARFLAG_STENCIL;
    exports.COMPUPDATED_BLEND = COMPUPDATED_BLEND;
    exports.COMPUPDATED_CAMERAS = COMPUPDATED_CAMERAS;
    exports.COMPUPDATED_INSTANCES = COMPUPDATED_INSTANCES;
    exports.COMPUPDATED_LIGHTS = COMPUPDATED_LIGHTS;
    exports.CUBEFACE_NEGX = CUBEFACE_NEGX;
    exports.CUBEFACE_NEGY = CUBEFACE_NEGY;
    exports.CUBEFACE_NEGZ = CUBEFACE_NEGZ;
    exports.CUBEFACE_POSX = CUBEFACE_POSX;
    exports.CUBEFACE_POSY = CUBEFACE_POSY;
    exports.CUBEFACE_POSZ = CUBEFACE_POSZ;
    exports.CUBEPROJ_BOX = CUBEPROJ_BOX;
    exports.CUBEPROJ_NONE = CUBEPROJ_NONE;
    exports.CULLFACE_BACK = CULLFACE_BACK;
    exports.CULLFACE_FRONT = CULLFACE_FRONT;
    exports.CULLFACE_FRONTANDBACK = CULLFACE_FRONTANDBACK;
    exports.CULLFACE_NONE = CULLFACE_NONE;
    exports.CURVE_CARDINAL = CURVE_CARDINAL;
    exports.CURVE_CATMULL = CURVE_CATMULL;
    exports.CURVE_LINEAR = CURVE_LINEAR;
    exports.CURVE_SMOOTHSTEP = CURVE_SMOOTHSTEP;
    exports.CURVE_SPLINE = CURVE_SPLINE;
    exports.CURVE_STEP = CURVE_STEP;
    exports.Camera = Camera;
    exports.CameraComponent = CameraComponent;
    exports.CameraComponentSystem = CameraComponentSystem;
    exports.CanvasFont = CanvasFont;
    exports.CollisionComponent = CollisionComponent;
    exports.CollisionComponentSystem = CollisionComponentSystem;
    exports.Color = Color;
    exports.Command = Command;
    exports.Component = Component;
    exports.ComponentData = ComponentData;
    exports.ComponentSystem = ComponentSystem;
    exports.ComponentSystemRegistry = ComponentSystemRegistry;
    exports.ContactPoint = ContactPoint;
    exports.ContactResult = ContactResult;
    exports.ContainerHandler = ContainerHandler;
    exports.ContainerResource = ContainerResource;
    exports.ContextCreationError = ContextCreationError;
    exports.Controller = Controller;
    exports.CssHandler = CssHandler;
    exports.CubemapHandler = CubemapHandler;
    exports.Curve = Curve;
    exports.CurveSet = CurveSet;
    exports.DETAILMODE_ADD = DETAILMODE_ADD;
    exports.DETAILMODE_MAX = DETAILMODE_MAX;
    exports.DETAILMODE_MIN = DETAILMODE_MIN;
    exports.DETAILMODE_MUL = DETAILMODE_MUL;
    exports.DETAILMODE_OVERLAY = DETAILMODE_OVERLAY;
    exports.DETAILMODE_SCREEN = DETAILMODE_SCREEN;
    exports.DISTANCE_EXPONENTIAL = DISTANCE_EXPONENTIAL;
    exports.DISTANCE_INVERSE = DISTANCE_INVERSE;
    exports.DISTANCE_LINEAR = DISTANCE_LINEAR;
    exports.DefaultAnimBinder = DefaultAnimBinder;
    exports.DepthMaterial = DepthMaterial;
    exports.ELEMENTTYPE_FLOAT32 = ELEMENTTYPE_FLOAT32;
    exports.ELEMENTTYPE_GROUP = ELEMENTTYPE_GROUP;
    exports.ELEMENTTYPE_IMAGE = ELEMENTTYPE_IMAGE;
    exports.ELEMENTTYPE_INT16 = ELEMENTTYPE_INT16;
    exports.ELEMENTTYPE_INT32 = ELEMENTTYPE_INT32;
    exports.ELEMENTTYPE_INT8 = ELEMENTTYPE_INT8;
    exports.ELEMENTTYPE_TEXT = ELEMENTTYPE_TEXT;
    exports.ELEMENTTYPE_UINT16 = ELEMENTTYPE_UINT16;
    exports.ELEMENTTYPE_UINT32 = ELEMENTTYPE_UINT32;
    exports.ELEMENTTYPE_UINT8 = ELEMENTTYPE_UINT8;
    exports.EMITTERSHAPE_BOX = EMITTERSHAPE_BOX;
    exports.EMITTERSHAPE_SPHERE = EMITTERSHAPE_SPHERE;
    exports.EVENT_KEYDOWN = EVENT_KEYDOWN;
    exports.EVENT_KEYUP = EVENT_KEYUP;
    exports.EVENT_MOUSEDOWN = EVENT_MOUSEDOWN;
    exports.EVENT_MOUSEMOVE = EVENT_MOUSEMOVE;
    exports.EVENT_MOUSEUP = EVENT_MOUSEUP;
    exports.EVENT_MOUSEWHEEL = EVENT_MOUSEWHEEL;
    exports.EVENT_SELECT = EVENT_SELECT;
    exports.EVENT_SELECTEND = EVENT_SELECTEND;
    exports.EVENT_SELECTSTART = EVENT_SELECTSTART;
    exports.EVENT_TOUCHCANCEL = EVENT_TOUCHCANCEL;
    exports.EVENT_TOUCHEND = EVENT_TOUCHEND;
    exports.EVENT_TOUCHMOVE = EVENT_TOUCHMOVE;
    exports.EVENT_TOUCHSTART = EVENT_TOUCHSTART;
    exports.ElementComponent = ElementComponent;
    exports.ElementComponentSystem = ElementComponentSystem;
    exports.ElementDragHelper = ElementDragHelper;
    exports.ElementInput = ElementInput;
    exports.ElementInputEvent = ElementInputEvent;
    exports.ElementMouseEvent = ElementMouseEvent;
    exports.ElementSelectEvent = ElementSelectEvent;
    exports.ElementTouchEvent = ElementTouchEvent;
    exports.Entity = Entity;
    exports.EntityReference = EntityReference;
    exports.EventHandler = EventHandler;
    exports.FILLMODE_FILL_WINDOW = FILLMODE_FILL_WINDOW;
    exports.FILLMODE_KEEP_ASPECT = FILLMODE_KEEP_ASPECT;
    exports.FILLMODE_NONE = FILLMODE_NONE;
    exports.FILTER_LINEAR = FILTER_LINEAR;
    exports.FILTER_LINEAR_MIPMAP_LINEAR = FILTER_LINEAR_MIPMAP_LINEAR;
    exports.FILTER_LINEAR_MIPMAP_NEAREST = FILTER_LINEAR_MIPMAP_NEAREST;
    exports.FILTER_NEAREST = FILTER_NEAREST;
    exports.FILTER_NEAREST_MIPMAP_LINEAR = FILTER_NEAREST_MIPMAP_LINEAR;
    exports.FILTER_NEAREST_MIPMAP_NEAREST = FILTER_NEAREST_MIPMAP_NEAREST;
    exports.FITTING_BOTH = FITTING_BOTH;
    exports.FITTING_NONE = FITTING_NONE;
    exports.FITTING_SHRINK = FITTING_SHRINK;
    exports.FITTING_STRETCH = FITTING_STRETCH;
    exports.FOG_EXP = FOG_EXP;
    exports.FOG_EXP2 = FOG_EXP2;
    exports.FOG_LINEAR = FOG_LINEAR;
    exports.FOG_NONE = FOG_NONE;
    exports.FONT_BITMAP = FONT_BITMAP;
    exports.FONT_MSDF = FONT_MSDF;
    exports.FRESNEL_NONE = FRESNEL_NONE;
    exports.FRESNEL_SCHLICK = FRESNEL_SCHLICK;
    exports.FUNC_ALWAYS = FUNC_ALWAYS;
    exports.FUNC_EQUAL = FUNC_EQUAL;
    exports.FUNC_GREATER = FUNC_GREATER;
    exports.FUNC_GREATEREQUAL = FUNC_GREATEREQUAL;
    exports.FUNC_LESS = FUNC_LESS;
    exports.FUNC_LESSEQUAL = FUNC_LESSEQUAL;
    exports.FUNC_NEVER = FUNC_NEVER;
    exports.FUNC_NOTEQUAL = FUNC_NOTEQUAL;
    exports.FolderHandler = FolderHandler;
    exports.Font = Font;
    exports.FontHandler = FontHandler;
    exports.ForwardRenderer = ForwardRenderer;
    exports.Frustum = Frustum;
    exports.GAMMA_NONE = GAMMA_NONE;
    exports.GAMMA_SRGB = GAMMA_SRGB;
    exports.GAMMA_SRGBFAST = GAMMA_SRGBFAST;
    exports.GAMMA_SRGBHDR = GAMMA_SRGBHDR;
    exports.GamePads = GamePads;
    exports.GraphNode = GraphNode;
    exports.GraphicsDevice = GraphicsDevice;
    exports.HierarchyHandler = HierarchyHandler;
    exports.HtmlHandler = HtmlHandler;
    exports.Http = Http;
    exports.I18n = I18n;
    exports.INDEXFORMAT_UINT16 = INDEXFORMAT_UINT16;
    exports.INDEXFORMAT_UINT32 = INDEXFORMAT_UINT32;
    exports.INDEXFORMAT_UINT8 = INDEXFORMAT_UINT8;
    exports.INTERPOLATION_CUBIC = INTERPOLATION_CUBIC;
    exports.INTERPOLATION_LINEAR = INTERPOLATION_LINEAR;
    exports.INTERPOLATION_STEP = INTERPOLATION_STEP;
    exports.ImageElement = ImageElement;
    exports.ImgParser = ImgParser;
    exports.IndexBuffer = IndexBuffer;
    exports.IndexedList = IndexedList;
    exports.JsonHandler = JsonHandler;
    exports.JsonStandardMaterialParser = JsonStandardMaterialParser;
    exports.KEY_0 = KEY_0;
    exports.KEY_1 = KEY_1;
    exports.KEY_2 = KEY_2;
    exports.KEY_3 = KEY_3;
    exports.KEY_4 = KEY_4;
    exports.KEY_5 = KEY_5;
    exports.KEY_6 = KEY_6;
    exports.KEY_7 = KEY_7;
    exports.KEY_8 = KEY_8;
    exports.KEY_9 = KEY_9;
    exports.KEY_A = KEY_A;
    exports.KEY_ADD = KEY_ADD;
    exports.KEY_ALT = KEY_ALT;
    exports.KEY_B = KEY_B;
    exports.KEY_BACKSPACE = KEY_BACKSPACE;
    exports.KEY_BACK_SLASH = KEY_BACK_SLASH;
    exports.KEY_C = KEY_C;
    exports.KEY_CAPS_LOCK = KEY_CAPS_LOCK;
    exports.KEY_CLOSE_BRACKET = KEY_CLOSE_BRACKET;
    exports.KEY_COMMA = KEY_COMMA;
    exports.KEY_CONTEXT_MENU = KEY_CONTEXT_MENU;
    exports.KEY_CONTROL = KEY_CONTROL;
    exports.KEY_D = KEY_D;
    exports.KEY_DECIMAL = KEY_DECIMAL;
    exports.KEY_DELETE = KEY_DELETE;
    exports.KEY_DIVIDE = KEY_DIVIDE;
    exports.KEY_DOWN = KEY_DOWN;
    exports.KEY_E = KEY_E;
    exports.KEY_END = KEY_END;
    exports.KEY_ENTER = KEY_ENTER;
    exports.KEY_EQUAL = KEY_EQUAL;
    exports.KEY_ESCAPE = KEY_ESCAPE;
    exports.KEY_F = KEY_F;
    exports.KEY_F1 = KEY_F1;
    exports.KEY_F10 = KEY_F10;
    exports.KEY_F11 = KEY_F11;
    exports.KEY_F12 = KEY_F12;
    exports.KEY_F2 = KEY_F2;
    exports.KEY_F3 = KEY_F3;
    exports.KEY_F4 = KEY_F4;
    exports.KEY_F5 = KEY_F5;
    exports.KEY_F6 = KEY_F6;
    exports.KEY_F7 = KEY_F7;
    exports.KEY_F8 = KEY_F8;
    exports.KEY_F9 = KEY_F9;
    exports.KEY_G = KEY_G;
    exports.KEY_H = KEY_H;
    exports.KEY_HOME = KEY_HOME;
    exports.KEY_I = KEY_I;
    exports.KEY_INSERT = KEY_INSERT;
    exports.KEY_J = KEY_J;
    exports.KEY_K = KEY_K;
    exports.KEY_L = KEY_L;
    exports.KEY_LEFT = KEY_LEFT;
    exports.KEY_M = KEY_M;
    exports.KEY_META = KEY_META;
    exports.KEY_MULTIPLY = KEY_MULTIPLY;
    exports.KEY_N = KEY_N;
    exports.KEY_NUMPAD_0 = KEY_NUMPAD_0;
    exports.KEY_NUMPAD_1 = KEY_NUMPAD_1;
    exports.KEY_NUMPAD_2 = KEY_NUMPAD_2;
    exports.KEY_NUMPAD_3 = KEY_NUMPAD_3;
    exports.KEY_NUMPAD_4 = KEY_NUMPAD_4;
    exports.KEY_NUMPAD_5 = KEY_NUMPAD_5;
    exports.KEY_NUMPAD_6 = KEY_NUMPAD_6;
    exports.KEY_NUMPAD_7 = KEY_NUMPAD_7;
    exports.KEY_NUMPAD_8 = KEY_NUMPAD_8;
    exports.KEY_NUMPAD_9 = KEY_NUMPAD_9;
    exports.KEY_O = KEY_O;
    exports.KEY_OPEN_BRACKET = KEY_OPEN_BRACKET;
    exports.KEY_P = KEY_P;
    exports.KEY_PAGE_DOWN = KEY_PAGE_DOWN;
    exports.KEY_PAGE_UP = KEY_PAGE_UP;
    exports.KEY_PAUSE = KEY_PAUSE;
    exports.KEY_PERIOD = KEY_PERIOD;
    exports.KEY_PRINT_SCREEN = KEY_PRINT_SCREEN;
    exports.KEY_Q = KEY_Q;
    exports.KEY_R = KEY_R;
    exports.KEY_RETURN = KEY_RETURN;
    exports.KEY_RIGHT = KEY_RIGHT;
    exports.KEY_S = KEY_S;
    exports.KEY_SEMICOLON = KEY_SEMICOLON;
    exports.KEY_SEPARATOR = KEY_SEPARATOR;
    exports.KEY_SHIFT = KEY_SHIFT;
    exports.KEY_SLASH = KEY_SLASH;
    exports.KEY_SPACE = KEY_SPACE;
    exports.KEY_SUBTRACT = KEY_SUBTRACT;
    exports.KEY_T = KEY_T;
    exports.KEY_TAB = KEY_TAB;
    exports.KEY_U = KEY_U;
    exports.KEY_UP = KEY_UP;
    exports.KEY_V = KEY_V;
    exports.KEY_W = KEY_W;
    exports.KEY_WINDOWS = KEY_WINDOWS;
    exports.KEY_X = KEY_X;
    exports.KEY_Y = KEY_Y;
    exports.KEY_Z = KEY_Z;
    exports.Key = Key;
    exports.Keyboard = Keyboard;
    exports.KeyboardEvent = KeyboardEvent;
    exports.KtxParser = KtxParser;
    exports.LAYERID_DEPTH = LAYERID_DEPTH;
    exports.LAYERID_IMMEDIATE = LAYERID_IMMEDIATE;
    exports.LAYERID_SKYBOX = LAYERID_SKYBOX;
    exports.LAYERID_UI = LAYERID_UI;
    exports.LAYERID_WORLD = LAYERID_WORLD;
    exports.LAYER_FX = LAYER_FX;
    exports.LAYER_GIZMO = LAYER_GIZMO;
    exports.LAYER_HUD = LAYER_HUD;
    exports.LAYER_WORLD = LAYER_WORLD;
    exports.LIGHTFALLOFF_INVERSESQUARED = LIGHTFALLOFF_INVERSESQUARED;
    exports.LIGHTFALLOFF_LINEAR = LIGHTFALLOFF_LINEAR;
    exports.LIGHTTYPE_DIRECTIONAL = LIGHTTYPE_DIRECTIONAL;
    exports.LIGHTTYPE_POINT = LIGHTTYPE_POINT;
    exports.LIGHTTYPE_SPOT = LIGHTTYPE_SPOT;
    exports.LINEBATCH_GIZMO = LINEBATCH_GIZMO;
    exports.LINEBATCH_OVERLAY = LINEBATCH_OVERLAY;
    exports.LINEBATCH_WORLD = LINEBATCH_WORLD;
    exports.Layer = Layer;
    exports.LayerComposition = LayerComposition;
    exports.LayoutCalculator = LayoutCalculator;
    exports.LayoutChildComponent = LayoutChildComponent;
    exports.LayoutChildComponentSystem = LayoutChildComponentSystem;
    exports.LayoutGroupComponent = LayoutGroupComponent;
    exports.LayoutGroupComponentSystem = LayoutGroupComponentSystem;
    exports.LegacyDdsParser = LegacyDdsParser;
    exports.Light = Light;
    exports.LightComponent = LightComponent;
    exports.LightComponentSystem = LightComponentSystem;
    exports.Lightmapper = Lightmapper;
    exports.LocalizedAsset = LocalizedAsset;
    exports.MASK_BAKED = MASK_BAKED;
    exports.MASK_DYNAMIC = MASK_DYNAMIC;
    exports.MASK_LIGHTMAP = MASK_LIGHTMAP;
    exports.MOUSEBUTTON_LEFT = MOUSEBUTTON_LEFT;
    exports.MOUSEBUTTON_MIDDLE = MOUSEBUTTON_MIDDLE;
    exports.MOUSEBUTTON_NONE = MOUSEBUTTON_NONE;
    exports.MOUSEBUTTON_RIGHT = MOUSEBUTTON_RIGHT;
    exports.Mat3 = Mat3;
    exports.Mat4 = Mat4;
    exports.Material = Material;
    exports.MaterialHandler = MaterialHandler;
    exports.Mesh = Mesh;
    exports.MeshInstance = MeshInstance;
    exports.Model = Model;
    exports.ModelComponent = ModelComponent;
    exports.ModelComponentSystem = ModelComponentSystem;
    exports.ModelHandler = ModelHandler;
    exports.Morph = Morph;
    exports.MorphInstance = MorphInstance;
    exports.MorphTarget = MorphTarget;
    exports.Mouse = Mouse;
    exports.MouseEvent = MouseEvent;
    exports.Node = Node;
    exports.ORIENTATION_HORIZONTAL = ORIENTATION_HORIZONTAL;
    exports.ORIENTATION_VERTICAL = ORIENTATION_VERTICAL;
    exports.OrientedBox = OrientedBox;
    exports.PAD_1 = PAD_1;
    exports.PAD_2 = PAD_2;
    exports.PAD_3 = PAD_3;
    exports.PAD_4 = PAD_4;
    exports.PAD_DOWN = PAD_DOWN;
    exports.PAD_FACE_1 = PAD_FACE_1;
    exports.PAD_FACE_2 = PAD_FACE_2;
    exports.PAD_FACE_3 = PAD_FACE_3;
    exports.PAD_FACE_4 = PAD_FACE_4;
    exports.PAD_LEFT = PAD_LEFT;
    exports.PAD_L_SHOULDER_1 = PAD_L_SHOULDER_1;
    exports.PAD_L_SHOULDER_2 = PAD_L_SHOULDER_2;
    exports.PAD_L_STICK_BUTTON = PAD_L_STICK_BUTTON;
    exports.PAD_L_STICK_X = PAD_L_STICK_X;
    exports.PAD_L_STICK_Y = PAD_L_STICK_Y;
    exports.PAD_RIGHT = PAD_RIGHT;
    exports.PAD_R_SHOULDER_1 = PAD_R_SHOULDER_1;
    exports.PAD_R_SHOULDER_2 = PAD_R_SHOULDER_2;
    exports.PAD_R_STICK_BUTTON = PAD_R_STICK_BUTTON;
    exports.PAD_R_STICK_X = PAD_R_STICK_X;
    exports.PAD_R_STICK_Y = PAD_R_STICK_Y;
    exports.PAD_SELECT = PAD_SELECT;
    exports.PAD_START = PAD_START;
    exports.PAD_UP = PAD_UP;
    exports.PAD_VENDOR = PAD_VENDOR;
    exports.PARTICLEMODE_CPU = PARTICLEMODE_CPU;
    exports.PARTICLEMODE_GPU = PARTICLEMODE_GPU;
    exports.PARTICLEORIENTATION_EMITTER = PARTICLEORIENTATION_EMITTER;
    exports.PARTICLEORIENTATION_SCREEN = PARTICLEORIENTATION_SCREEN;
    exports.PARTICLEORIENTATION_WORLD = PARTICLEORIENTATION_WORLD;
    exports.PARTICLESORT_DISTANCE = PARTICLESORT_DISTANCE;
    exports.PARTICLESORT_NEWER_FIRST = PARTICLESORT_NEWER_FIRST;
    exports.PARTICLESORT_NONE = PARTICLESORT_NONE;
    exports.PARTICLESORT_OLDER_FIRST = PARTICLESORT_OLDER_FIRST;
    exports.PIXELFORMAT_111110F = PIXELFORMAT_111110F;
    exports.PIXELFORMAT_A8 = PIXELFORMAT_A8;
    exports.PIXELFORMAT_ASTC_4x4 = PIXELFORMAT_ASTC_4x4;
    exports.PIXELFORMAT_ATC_RGB = PIXELFORMAT_ATC_RGB;
    exports.PIXELFORMAT_ATC_RGBA = PIXELFORMAT_ATC_RGBA;
    exports.PIXELFORMAT_DEPTH = PIXELFORMAT_DEPTH;
    exports.PIXELFORMAT_DEPTHSTENCIL = PIXELFORMAT_DEPTHSTENCIL;
    exports.PIXELFORMAT_DXT1 = PIXELFORMAT_DXT1;
    exports.PIXELFORMAT_DXT3 = PIXELFORMAT_DXT3;
    exports.PIXELFORMAT_DXT5 = PIXELFORMAT_DXT5;
    exports.PIXELFORMAT_ETC1 = PIXELFORMAT_ETC1;
    exports.PIXELFORMAT_ETC2_RGB = PIXELFORMAT_ETC2_RGB;
    exports.PIXELFORMAT_ETC2_RGBA = PIXELFORMAT_ETC2_RGBA;
    exports.PIXELFORMAT_L8 = PIXELFORMAT_L8;
    exports.PIXELFORMAT_L8_A8 = PIXELFORMAT_L8_A8;
    exports.PIXELFORMAT_PVRTC_2BPP_RGBA_1 = PIXELFORMAT_PVRTC_2BPP_RGBA_1;
    exports.PIXELFORMAT_PVRTC_2BPP_RGB_1 = PIXELFORMAT_PVRTC_2BPP_RGB_1;
    exports.PIXELFORMAT_PVRTC_4BPP_RGBA_1 = PIXELFORMAT_PVRTC_4BPP_RGBA_1;
    exports.PIXELFORMAT_PVRTC_4BPP_RGB_1 = PIXELFORMAT_PVRTC_4BPP_RGB_1;
    exports.PIXELFORMAT_R32F = PIXELFORMAT_R32F;
    exports.PIXELFORMAT_R4_G4_B4_A4 = PIXELFORMAT_R4_G4_B4_A4;
    exports.PIXELFORMAT_R5_G5_B5_A1 = PIXELFORMAT_R5_G5_B5_A1;
    exports.PIXELFORMAT_R5_G6_B5 = PIXELFORMAT_R5_G6_B5;
    exports.PIXELFORMAT_R8_G8_B8 = PIXELFORMAT_R8_G8_B8;
    exports.PIXELFORMAT_R8_G8_B8_A8 = PIXELFORMAT_R8_G8_B8_A8;
    exports.PIXELFORMAT_RGB16F = PIXELFORMAT_RGB16F;
    exports.PIXELFORMAT_RGB32F = PIXELFORMAT_RGB32F;
    exports.PIXELFORMAT_RGBA16F = PIXELFORMAT_RGBA16F;
    exports.PIXELFORMAT_RGBA32F = PIXELFORMAT_RGBA32F;
    exports.PIXELFORMAT_SRGB = PIXELFORMAT_SRGB;
    exports.PIXELFORMAT_SRGBA = PIXELFORMAT_SRGBA;
    exports.PRIMITIVE_LINELOOP = PRIMITIVE_LINELOOP;
    exports.PRIMITIVE_LINES = PRIMITIVE_LINES;
    exports.PRIMITIVE_LINESTRIP = PRIMITIVE_LINESTRIP;
    exports.PRIMITIVE_POINTS = PRIMITIVE_POINTS;
    exports.PRIMITIVE_TRIANGLES = PRIMITIVE_TRIANGLES;
    exports.PRIMITIVE_TRIFAN = PRIMITIVE_TRIFAN;
    exports.PRIMITIVE_TRISTRIP = PRIMITIVE_TRISTRIP;
    exports.PROJECTION_ORTHOGRAPHIC = PROJECTION_ORTHOGRAPHIC;
    exports.PROJECTION_PERSPECTIVE = PROJECTION_PERSPECTIVE;
    exports.ParticleEmitter = ParticleEmitter;
    exports.ParticleSystemComponent = ParticleSystemComponent;
    exports.ParticleSystemComponentSystem = ParticleSystemComponentSystem;
    exports.PhongMaterial = PhongMaterial;
    exports.Picker = Picker;
    exports.Plane = Plane;
    exports.PostEffect = PostEffect;
    exports.PostEffectQueue = PostEffectQueue;
    exports.ProgramLibrary = ProgramLibrary;
    exports.Quat = Quat;
    exports.RENDERSTYLE_POINTS = RENDERSTYLE_POINTS;
    exports.RENDERSTYLE_SOLID = RENDERSTYLE_SOLID;
    exports.RENDERSTYLE_WIREFRAME = RENDERSTYLE_WIREFRAME;
    exports.RESOLUTION_AUTO = RESOLUTION_AUTO;
    exports.RESOLUTION_FIXED = RESOLUTION_FIXED;
    exports.RIGIDBODY_ACTIVE_TAG = RIGIDBODY_ACTIVE_TAG;
    exports.RIGIDBODY_CF_KINEMATIC_OBJECT = RIGIDBODY_CF_KINEMATIC_OBJECT;
    exports.RIGIDBODY_CF_NORESPONSE_OBJECT = RIGIDBODY_CF_NORESPONSE_OBJECT;
    exports.RIGIDBODY_CF_STATIC_OBJECT = RIGIDBODY_CF_STATIC_OBJECT;
    exports.RIGIDBODY_DISABLE_DEACTIVATION = RIGIDBODY_DISABLE_DEACTIVATION;
    exports.RIGIDBODY_DISABLE_SIMULATION = RIGIDBODY_DISABLE_SIMULATION;
    exports.RIGIDBODY_ISLAND_SLEEPING = RIGIDBODY_ISLAND_SLEEPING;
    exports.RIGIDBODY_TYPE_DYNAMIC = RIGIDBODY_TYPE_DYNAMIC;
    exports.RIGIDBODY_TYPE_KINEMATIC = RIGIDBODY_TYPE_KINEMATIC;
    exports.RIGIDBODY_TYPE_STATIC = RIGIDBODY_TYPE_STATIC;
    exports.RIGIDBODY_WANTS_DEACTIVATION = RIGIDBODY_WANTS_DEACTIVATION;
    exports.Ray = Ray;
    exports.RaycastResult = RaycastResult;
    exports.RenderTarget = RenderTarget;
    exports.ResourceHandler = ResourceHandler;
    exports.ResourceLoader = ResourceLoader;
    exports.RigidBodyComponent = RigidBodyComponent;
    exports.RigidBodyComponentSystem = RigidBodyComponentSystem;
    exports.SCALEMODE_BLEND = SCALEMODE_BLEND;
    exports.SCALEMODE_NONE = SCALEMODE_NONE;
    exports.SCROLLBAR_VISIBILITY_SHOW_ALWAYS = SCROLLBAR_VISIBILITY_SHOW_ALWAYS;
    exports.SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED;
    exports.SCROLL_MODE_BOUNCE = SCROLL_MODE_BOUNCE;
    exports.SCROLL_MODE_CLAMP = SCROLL_MODE_CLAMP;
    exports.SCROLL_MODE_INFINITE = SCROLL_MODE_INFINITE;
    exports.SEMANTIC_ATTR = SEMANTIC_ATTR;
    exports.SEMANTIC_ATTR0 = SEMANTIC_ATTR0;
    exports.SEMANTIC_ATTR1 = SEMANTIC_ATTR1;
    exports.SEMANTIC_ATTR10 = SEMANTIC_ATTR10;
    exports.SEMANTIC_ATTR11 = SEMANTIC_ATTR11;
    exports.SEMANTIC_ATTR12 = SEMANTIC_ATTR12;
    exports.SEMANTIC_ATTR13 = SEMANTIC_ATTR13;
    exports.SEMANTIC_ATTR14 = SEMANTIC_ATTR14;
    exports.SEMANTIC_ATTR15 = SEMANTIC_ATTR15;
    exports.SEMANTIC_ATTR2 = SEMANTIC_ATTR2;
    exports.SEMANTIC_ATTR3 = SEMANTIC_ATTR3;
    exports.SEMANTIC_ATTR4 = SEMANTIC_ATTR4;
    exports.SEMANTIC_ATTR5 = SEMANTIC_ATTR5;
    exports.SEMANTIC_ATTR6 = SEMANTIC_ATTR6;
    exports.SEMANTIC_ATTR7 = SEMANTIC_ATTR7;
    exports.SEMANTIC_ATTR8 = SEMANTIC_ATTR8;
    exports.SEMANTIC_ATTR9 = SEMANTIC_ATTR9;
    exports.SEMANTIC_BLENDINDICES = SEMANTIC_BLENDINDICES;
    exports.SEMANTIC_BLENDWEIGHT = SEMANTIC_BLENDWEIGHT;
    exports.SEMANTIC_COLOR = SEMANTIC_COLOR;
    exports.SEMANTIC_NORMAL = SEMANTIC_NORMAL;
    exports.SEMANTIC_POSITION = SEMANTIC_POSITION;
    exports.SEMANTIC_TANGENT = SEMANTIC_TANGENT;
    exports.SEMANTIC_TEXCOORD = SEMANTIC_TEXCOORD;
    exports.SEMANTIC_TEXCOORD0 = SEMANTIC_TEXCOORD0;
    exports.SEMANTIC_TEXCOORD1 = SEMANTIC_TEXCOORD1;
    exports.SEMANTIC_TEXCOORD2 = SEMANTIC_TEXCOORD2;
    exports.SEMANTIC_TEXCOORD3 = SEMANTIC_TEXCOORD3;
    exports.SEMANTIC_TEXCOORD4 = SEMANTIC_TEXCOORD4;
    exports.SEMANTIC_TEXCOORD5 = SEMANTIC_TEXCOORD5;
    exports.SEMANTIC_TEXCOORD6 = SEMANTIC_TEXCOORD6;
    exports.SEMANTIC_TEXCOORD7 = SEMANTIC_TEXCOORD7;
    exports.SHADERDEF_DIRLM = SHADERDEF_DIRLM;
    exports.SHADERDEF_INSTANCING = SHADERDEF_INSTANCING;
    exports.SHADERDEF_LM = SHADERDEF_LM;
    exports.SHADERDEF_MORPH_NORMAL = SHADERDEF_MORPH_NORMAL;
    exports.SHADERDEF_MORPH_POSITION = SHADERDEF_MORPH_POSITION;
    exports.SHADERDEF_NOSHADOW = SHADERDEF_NOSHADOW;
    exports.SHADERDEF_SCREENSPACE = SHADERDEF_SCREENSPACE;
    exports.SHADERDEF_SKIN = SHADERDEF_SKIN;
    exports.SHADERDEF_TANGENTS = SHADERDEF_TANGENTS;
    exports.SHADERDEF_UV0 = SHADERDEF_UV0;
    exports.SHADERDEF_UV1 = SHADERDEF_UV1;
    exports.SHADERDEF_VCOLOR = SHADERDEF_VCOLOR;
    exports.SHADERTAG_MATERIAL = SHADERTAG_MATERIAL;
    exports.SHADER_DEPTH = SHADER_DEPTH;
    exports.SHADER_FORWARD = SHADER_FORWARD;
    exports.SHADER_FORWARDHDR = SHADER_FORWARDHDR;
    exports.SHADER_PICK = SHADER_PICK;
    exports.SHADER_SHADOW = SHADER_SHADOW;
    exports.SHADOWUPDATE_NONE = SHADOWUPDATE_NONE;
    exports.SHADOWUPDATE_REALTIME = SHADOWUPDATE_REALTIME;
    exports.SHADOWUPDATE_THISFRAME = SHADOWUPDATE_THISFRAME;
    exports.SHADOW_DEPTH = SHADOW_DEPTH;
    exports.SHADOW_PCF3 = SHADOW_PCF3;
    exports.SHADOW_PCF5 = SHADOW_PCF5;
    exports.SHADOW_VSM16 = SHADOW_VSM16;
    exports.SHADOW_VSM32 = SHADOW_VSM32;
    exports.SHADOW_VSM8 = SHADOW_VSM8;
    exports.SORTKEY_DEPTH = SORTKEY_DEPTH;
    exports.SORTKEY_FORWARD = SORTKEY_FORWARD;
    exports.SORTMODE_BACK2FRONT = SORTMODE_BACK2FRONT;
    exports.SORTMODE_CUSTOM = SORTMODE_CUSTOM;
    exports.SORTMODE_FRONT2BACK = SORTMODE_FRONT2BACK;
    exports.SORTMODE_MANUAL = SORTMODE_MANUAL;
    exports.SORTMODE_MATERIALMESH = SORTMODE_MATERIALMESH;
    exports.SORTMODE_NONE = SORTMODE_NONE;
    exports.SPECOCC_AO = SPECOCC_AO;
    exports.SPECOCC_GLOSSDEPENDENT = SPECOCC_GLOSSDEPENDENT;
    exports.SPECOCC_NONE = SPECOCC_NONE;
    exports.SPECULAR_BLINN = SPECULAR_BLINN;
    exports.SPECULAR_PHONG = SPECULAR_PHONG;
    exports.SPRITETYPE_ANIMATED = SPRITETYPE_ANIMATED;
    exports.SPRITETYPE_SIMPLE = SPRITETYPE_SIMPLE;
    exports.SPRITE_RENDERMODE_SIMPLE = SPRITE_RENDERMODE_SIMPLE;
    exports.SPRITE_RENDERMODE_SLICED = SPRITE_RENDERMODE_SLICED;
    exports.SPRITE_RENDERMODE_TILED = SPRITE_RENDERMODE_TILED;
    exports.STENCILOP_DECREMENT = STENCILOP_DECREMENT;
    exports.STENCILOP_DECREMENTWRAP = STENCILOP_DECREMENTWRAP;
    exports.STENCILOP_INCREMENT = STENCILOP_INCREMENT;
    exports.STENCILOP_INCREMENTWRAP = STENCILOP_INCREMENTWRAP;
    exports.STENCILOP_INVERT = STENCILOP_INVERT;
    exports.STENCILOP_KEEP = STENCILOP_KEEP;
    exports.STENCILOP_REPLACE = STENCILOP_REPLACE;
    exports.STENCILOP_ZERO = STENCILOP_ZERO;
    exports.Scene = Scene;
    exports.SceneHandler = SceneHandler;
    exports.SceneRegistry = SceneRegistry;
    exports.SceneRegistryItem = SceneRegistryItem;
    exports.SceneSettingsHandler = SceneSettingsHandler;
    exports.ScopeId = ScopeId;
    exports.ScopeSpace = ScopeSpace;
    exports.ScreenComponent = ScreenComponent;
    exports.ScreenComponentSystem = ScreenComponentSystem;
    exports.ScriptAttributes = ScriptAttributes;
    exports.ScriptComponent = ScriptComponent;
    exports.ScriptComponentSystem = ScriptComponentSystem;
    exports.ScriptHandler = ScriptHandler;
    exports.ScriptLegacyComponent = ScriptLegacyComponent;
    exports.ScriptLegacyComponentSystem = ScriptLegacyComponentSystem;
    exports.ScriptRegistry = ScriptRegistry;
    exports.ScriptType = ScriptType;
    exports.ScrollViewComponent = ScrollViewComponent;
    exports.ScrollViewComponentSystem = ScrollViewComponentSystem;
    exports.ScrollbarComponent = ScrollbarComponent;
    exports.ScrollbarComponentSystem = ScrollbarComponentSystem;
    exports.Shader = Shader;
    exports.ShaderHandler = ShaderHandler;
    exports.SingleContactResult = SingleContactResult;
    exports.Skeleton = Skeleton;
    exports.Skin = Skin;
    exports.SkinInstance = SkinInstance;
    exports.SortedLoopArray = SortedLoopArray;
    exports.Sound = Sound;
    exports.SoundComponent = SoundComponent;
    exports.SoundComponentSystem = SoundComponentSystem;
    exports.SoundManager = SoundManager;
    exports.SoundSlot = SoundSlot;
    exports.Sprite = Sprite;
    exports.SpriteAnimationClip = SpriteAnimationClip;
    exports.SpriteComponent = SpriteComponent;
    exports.SpriteComponentSystem = SpriteComponentSystem;
    exports.SpriteHandler = SpriteHandler;
    exports.StandardMaterial = StandardMaterial;
    exports.StencilParameters = StencilParameters;
    exports.TEXHINT_ASSET = TEXHINT_ASSET;
    exports.TEXHINT_LIGHTMAP = TEXHINT_LIGHTMAP;
    exports.TEXHINT_NONE = TEXHINT_NONE;
    exports.TEXHINT_SHADOWMAP = TEXHINT_SHADOWMAP;
    exports.TEXTURELOCK_READ = TEXTURELOCK_READ;
    exports.TEXTURELOCK_WRITE = TEXTURELOCK_WRITE;
    exports.TEXTURETYPE_DEFAULT = TEXTURETYPE_DEFAULT;
    exports.TEXTURETYPE_RGBE = TEXTURETYPE_RGBE;
    exports.TEXTURETYPE_RGBM = TEXTURETYPE_RGBM;
    exports.TEXTURETYPE_SWIZZLEGGGR = TEXTURETYPE_SWIZZLEGGGR;
    exports.TONEMAP_ACES = TONEMAP_ACES;
    exports.TONEMAP_ACES2 = TONEMAP_ACES2;
    exports.TONEMAP_FILMIC = TONEMAP_FILMIC;
    exports.TONEMAP_HEJL = TONEMAP_HEJL;
    exports.TONEMAP_LINEAR = TONEMAP_LINEAR;
    exports.TYPE_FLOAT32 = TYPE_FLOAT32;
    exports.TYPE_INT16 = TYPE_INT16;
    exports.TYPE_INT32 = TYPE_INT32;
    exports.TYPE_INT8 = TYPE_INT8;
    exports.TYPE_UINT16 = TYPE_UINT16;
    exports.TYPE_UINT32 = TYPE_UINT32;
    exports.TYPE_UINT8 = TYPE_UINT8;
    exports.Tags = Tags;
    exports.Template = Template;
    exports.TemplateHandler = TemplateHandler;
    exports.TemplateUtils = TemplateUtils;
    exports.TextElement = TextElement;
    exports.TextHandler = TextHandler;
    exports.Texture = Texture;
    exports.TextureAtlas = TextureAtlas;
    exports.TextureAtlasHandler = TextureAtlasHandler;
    exports.TextureHandler = TextureHandler;
    exports.TextureParser = TextureParser;
    exports.Timer = Timer;
    exports.Touch = Touch;
    exports.TouchDevice = TouchDevice;
    exports.TouchEvent = TouchEvent;
    exports.TransformFeedback = TransformFeedback;
    exports.UNIFORMTYPE_BOOL = UNIFORMTYPE_BOOL;
    exports.UNIFORMTYPE_BVEC2 = UNIFORMTYPE_BVEC2;
    exports.UNIFORMTYPE_BVEC3 = UNIFORMTYPE_BVEC3;
    exports.UNIFORMTYPE_BVEC4 = UNIFORMTYPE_BVEC4;
    exports.UNIFORMTYPE_FLOAT = UNIFORMTYPE_FLOAT;
    exports.UNIFORMTYPE_FLOATARRAY = UNIFORMTYPE_FLOATARRAY;
    exports.UNIFORMTYPE_INT = UNIFORMTYPE_INT;
    exports.UNIFORMTYPE_IVEC2 = UNIFORMTYPE_IVEC2;
    exports.UNIFORMTYPE_IVEC3 = UNIFORMTYPE_IVEC3;
    exports.UNIFORMTYPE_IVEC4 = UNIFORMTYPE_IVEC4;
    exports.UNIFORMTYPE_MAT2 = UNIFORMTYPE_MAT2;
    exports.UNIFORMTYPE_MAT3 = UNIFORMTYPE_MAT3;
    exports.UNIFORMTYPE_MAT4 = UNIFORMTYPE_MAT4;
    exports.UNIFORMTYPE_TEXTURE2D = UNIFORMTYPE_TEXTURE2D;
    exports.UNIFORMTYPE_TEXTURE2D_SHADOW = UNIFORMTYPE_TEXTURE2D_SHADOW;
    exports.UNIFORMTYPE_TEXTURE3D = UNIFORMTYPE_TEXTURE3D;
    exports.UNIFORMTYPE_TEXTURECUBE = UNIFORMTYPE_TEXTURECUBE;
    exports.UNIFORMTYPE_TEXTURECUBE_SHADOW = UNIFORMTYPE_TEXTURECUBE_SHADOW;
    exports.UNIFORMTYPE_VEC2 = UNIFORMTYPE_VEC2;
    exports.UNIFORMTYPE_VEC3 = UNIFORMTYPE_VEC3;
    exports.UNIFORMTYPE_VEC4 = UNIFORMTYPE_VEC4;
    exports.URI = URI;
    exports.UnsupportedBrowserError = UnsupportedBrowserError;
    exports.VIEW_CENTER = VIEW_CENTER;
    exports.VIEW_LEFT = VIEW_LEFT;
    exports.VIEW_RIGHT = VIEW_RIGHT;
    exports.Vec2 = Vec2;
    exports.Vec3 = Vec3;
    exports.Vec4 = Vec4;
    exports.VertexBuffer = VertexBuffer;
    exports.VertexFormat = VertexFormat;
    exports.VertexIterator = VertexIterator;
    exports.VrDisplay = VrDisplay;
    exports.VrManager = VrManager;
    exports.XRHAND_LEFT = XRHAND_LEFT;
    exports.XRHAND_NONE = XRHAND_NONE;
    exports.XRHAND_RIGHT = XRHAND_RIGHT;
    exports.XRSPACE_BOUNDEDFLOOR = XRSPACE_BOUNDEDFLOOR;
    exports.XRSPACE_LOCAL = XRSPACE_LOCAL;
    exports.XRSPACE_LOCALFLOOR = XRSPACE_LOCALFLOOR;
    exports.XRSPACE_UNBOUNDED = XRSPACE_UNBOUNDED;
    exports.XRSPACE_VIEWER = XRSPACE_VIEWER;
    exports.XRTARGETRAY_GAZE = XRTARGETRAY_GAZE;
    exports.XRTARGETRAY_POINTER = XRTARGETRAY_POINTER;
    exports.XRTARGETRAY_SCREEN = XRTARGETRAY_SCREEN;
    exports.XRTRACKABLE_MESH = XRTRACKABLE_MESH;
    exports.XRTRACKABLE_PLANE = XRTRACKABLE_PLANE;
    exports.XRTRACKABLE_POINT = XRTRACKABLE_POINT;
    exports.XRTYPE_AR = XRTYPE_AR;
    exports.XRTYPE_INLINE = XRTYPE_INLINE;
    exports.XRTYPE_VR = XRTYPE_VR;
    exports.XrHitTest = XrHitTest;
    exports.XrHitTestSource = XrHitTestSource;
    exports.XrInput = XrInput;
    exports.XrInputSource = XrInputSource;
    exports.XrLightEstimation = XrLightEstimation;
    exports.XrManager = XrManager;
    exports.ZoneComponent = ZoneComponent;
    exports.ZoneComponentSystem = ZoneComponentSystem;
    exports.anim = anim;
    exports.apps = apps;
    exports.asset = asset;
    exports.audio = audio;
    exports.basisDownload = basisDownload;
    exports.basisDownloadFromConfig = basisDownloadFromConfig;
    exports.basisInitialize = basisInitialize;
    exports.basisTargetFormat = basisTargetFormat;
    exports.basisTranscode = basisTranscode;
    exports.calculateNormals = calculateNormals;
    exports.calculateTangents = calculateTangents;
    exports.common = common;
    exports.config = config;
    exports.createBox = createBox;
    exports.createCapsule = createCapsule;
    exports.createCone = createCone;
    exports.createCylinder = createCylinder;
    exports.createMesh = createMesh;
    exports.createPlane = createPlane;
    exports.createScript = createScript;
    exports.createSphere = createSphere;
    exports.createStyle = createStyle;
    exports.createTorus = createTorus;
    exports.createURI = createURI;
    exports.data = data;
    exports.debug = debug;
    exports.drawFullscreenQuad = drawFullscreenQuad;
    exports.drawQuadWithShader = drawQuadWithShader;
    exports.drawTexture = drawTexture;
    exports.events = events;
    exports.extend = extend;
    exports.fw = fw;
    exports.getTouchTargetCoords = getTouchTargetCoords;
    exports.gfx = gfx;
    exports.guid = guid;
    exports.http = http;
    exports.inherits = inherits;
    exports.input = input;
    exports.isDefined = isDefined;
    exports.log = log;
    exports.makeArray = makeArray;
    exports.math = math;
    exports.now = now;
    exports.path = path;
    exports.platform = platform;
    exports.posteffect = posteffect;
    exports.prefilterCubemap = prefilterCubemap;
    exports.programlib = programlib;
    exports.registerScript = registerScript;
    exports.revision = revision;
    exports.scene = scene;
    exports.script = script;
    exports.shaderChunks = shaderChunks;
    exports.shape = shape;
    exports.string = string;
    exports.time = time;
    exports.type = type;
    exports.typedArrayIndexFormats = typedArrayIndexFormats;
    exports.typedArrayIndexFormatsByteSize = typedArrayIndexFormatsByteSize;
    exports.typedArrayToType = typedArrayToType;
    exports.typedArrayTypes = typedArrayTypes;
    exports.typedArrayTypesByteSize = typedArrayTypesByteSize;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
